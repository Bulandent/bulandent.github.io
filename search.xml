<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「建议收藏」送你一份精心总结的3万字ES6实用指南（全）</title>
      <link href="/2020/11/17/es6/"/>
      <url>/2020/11/17/es6/</url>
      
        <content type="html"><![CDATA[<p>写本篇文章目的是为了夯实基础，基于阮一峰老师的著作 <a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a> 以及 <a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">tc39-finished-proposals</a> 这两个知识线路总结提炼出来的重点和要点，涉及到从 <code>ES2015</code> 到 <code>ES2021</code> 的几乎所有知识，基本上都是按照一个知识点配上一段代码的形式来展示，所以篇幅较长，也正是因为篇幅过长，所以就没把 <code>Stage 2</code> 和 <code>Stage 3</code> 阶段的提案写到这里，后续 <code>ES2021</code> 更新了我再同步更新。</p><blockquote><p>有 5 个提案已经列入 Expected Publication Year in 2021 所以本篇中暂且把他们归为 ES2021。</p></blockquote><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es6.png"></p><a id="more"></a><h2 id="ES6前言"><a href="#ES6前言" class="headerlink" title="ES6前言"></a>ES6前言</h2><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><p>能写好 <code>JS</code> 固然是重要的，但是作为一个前端，我们也要了解自己所使用语言的发展历程，这里强烈推荐看 <a href="https://cn.history.js.org/index.html">《JavaScript 20年》</a>，本书详细记载和解读了自 1995 年语言诞生到 2015 年 <code>ES6</code> 规范制定为止，共计 20 年的 <code>JavaScript</code> 语言演化历程。</p><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><p>2011 年，发布了 <code>ECMAScript 5.1</code> 版，而 2015 年 6 月发布了 <code>ES6</code> 的第一个版本又叫 <code>ES2015</code>。<code>ES6</code> 其实是一个泛指，指代 5.1 版本以后的下一代标准。<code>TC39</code> 规定将于每年的 6 月发布一次正式版本，版本号以当年的年份为准，比如当前已经发布了 <code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>、<code>ES2019</code>、<code>ES2020</code> 等版本。</p><h3 id="提案发布流程"><a href="#提案发布流程" class="headerlink" title="提案发布流程"></a>提案发布流程</h3><p>任何人都可以向 <code>TC39</code> 提案，要求修改语言标准。一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 <code>TC39</code> 委员会批准。</p><ul><li><code>Stage 0</code> - <code>Strawperson</code>（展示阶段）</li><li><code>Stage 1</code> - <code>Proposal</code>（征求意见阶段）</li><li><code>Stage 2</code> - <code>Draft</code>（草案阶段）</li><li><code>Stage 3</code> - <code>Candidate</code>（候选人阶段）</li><li><code>Stage 4</code> - <code>Finished</code>（定案阶段）</li></ul><p>一个提案只要能进入 <code>Stage 2</code>，就差不多肯定会包括在以后的正式标准里面。<code>ECMAScript</code> 当前的所有提案，可以在这里查看 <a href="https://github.com/tc39/ecma262">ecma262</a>。关于提案流程可以在这里 <a href="https://tc39.es/process-document/">TC39_Process</a> 看到更加详细的信息。</p><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2015.png"></p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><code>const</code>：声明一个常量，<code>let</code>：声明一个变量；<code>const/let</code> 声明的常量/变量都只能作用于代码块（块级作用域或函数作用域）里；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><code>const/let</code> 不存在变量提升，所以在代码块里必须先声明然后才可以使用，这叫暂时性死区；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br></pre></td></tr></table></figure><p><code>const/let</code> 不允许在同一个作用域内，重复声明；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span>  <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const</code> 声明时必须初始化，且后期不能被修改，但如果初始化的是一个对象，那么不能修改的是该对象的内存地址；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">person.name = <span class="string">&#x27;bubuzou&#x27;</span>  </span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br><span class="line">person = <span class="string">&#x27;&#x27;</span>  <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p><code>const/let</code> 在全局作用域中声明的常量/变量不会挂到顶层对象（浏览器中是 window ）的属性中；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)  <span class="comment">// &#x27;布兰&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p><strong>解构类型</strong>：</p><ul><li><p>字符串解构</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c = <span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;12&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)  <span class="comment">// &#x27;1&#x27; &#x27;2&#x27; &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数值解构</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toFixed</span>: tf&#125; = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log( tf.call(<span class="built_in">Math</span>.PI, <span class="number">2</span>) )  <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure></li><li><p>布尔值解构</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: ts&#125; = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log( ts.call(<span class="literal">false</span>) )  <span class="comment">// &#x27;false&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数组解构：等号右侧的数据具有 <code>Iterator</code> 接口可以进行数组形式的解构赋值；</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构不成功的变量值为 undefined</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)  <span class="comment">// 1, 2, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以设置默认值</span></span><br><span class="line"><span class="keyword">let</span> [x, y, z = <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z)  <span class="comment">// 1, 2, null</span></span><br></pre></td></tr></table></figure><blockquote><p>什么样的数据具有 <code>Iterator</code> 接口呢？如果一个对象能够通过 [Symbol.iterator] 访问，且能够返回一个符合迭代器协议的对象，那么该对象就是可迭代的。目前内置的可迭代对象有：String、Array、TypeArray、Map、Set、arguments 和 NodeList 等。</p></blockquote></li><li><p>对象解构：与数组按照索引位置进行解构不同，对象解构是按照属性名进行解构赋值，如果在当前对象属性匹配不成功则会去对象的原型属性上查找：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认写法</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name, <span class="attr">age</span>: age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改名且设置默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name1, <span class="attr">age</span>: age1 = <span class="number">12</span> &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name1, age1)  <span class="comment">// &#x27;布兰&#x27; 12</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数解构：其实就是运用上面的对象解构和数组解构规则；</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([x, y])</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;)  <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;)        <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;)            <span class="comment">// [0, 0]</span></span><br><span class="line">move()              <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>解构要点</strong>：</p><ul><li>只要等号两边的模式相同（同是对象或同是数组），则左边的变量会被赋予对应的值；</li><li>解构不成功的变量值为 <code>undefined</code>；</li><li>默认值生效的前提是当等号右边对应的值全等于 undefined 的时候；</li><li>只要等号右边的值不是对象或者数组，则会进行自动装箱将其转成对象；</li><li><code>null</code> 和 <code>undefined</code> 都无法转成对象，所以无法解构。</li></ul><p><strong>解构应用</strong>：</p><ul><li><p>交换变量的值；</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"><span class="built_in">console</span>.log(x, y)  <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure></li><li><p>通过函数返回对象属性</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">        age: <span class="number">12</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = getParams()</span><br></pre></td></tr></table></figure></li><li><p>通过定义函数参数来声明变量</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">init(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;name, age&#125; = person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简洁用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">&#123;name, age&#125;</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定函数参数默认值</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPerson</span>(<span class="params">&#123;name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, age)</span><br><span class="line">&#125;</span><br><span class="line">initPerson()  <span class="comment">// &#x27;布兰&#x27; 12</span></span><br><span class="line">initPerson(&#123;<span class="attr">age</span>: <span class="number">20</span>&#125;)  <span class="comment">// &#x27;布兰&#x27; 20</span></span><br></pre></td></tr></table></figure></li><li><p>提取 <code>JSON</code> 数据</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> responseData = &#123;</span><br><span class="line">    code: <span class="number">1000</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    message: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; code, data = &#123;&#125; &#125; = responseData</span><br></pre></td></tr></table></figure></li><li><p>遍历 Map 结构</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">map.set(<span class="string">&#x27;xiamen&#x27;</span>, <span class="string">&#x27;厦门&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输入模块的指定方法和属性</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile, writeFile &#125; = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li><p>可以使用 <code>Unicode</code> 编码来表示一个字符：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下写法都可以用来表示字符 z</span></span><br><span class="line"><span class="string">&#x27;\z&#x27;</span>      <span class="comment">// 转义</span></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span>    <span class="comment">// 十进制表示法</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span>    <span class="comment">// 十六进制表示法</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span>  <span class="comment">// Unicode 普通表示法</span></span><br><span class="line"><span class="string">&#x27;\u&#123;7A&#125;&#x27;</span>  <span class="comment">// Unicode 大括号表示法</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.52unicode.com/">www.52unicode.com</a> 这个网站可以查询到常见符号的 Unicode 编码。</p></blockquote></li><li><p>可以使用 <code>for...of</code> <strong>正确遍历</strong>字符串：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;😀🤣😜😍🤗🤔&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> emoji <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(emoji) <span class="comment">// 😀🤣😜😍🤗🤔</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, l = str.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[i])  <span class="comment">// 不能正确输出表情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模板字符串使用两个反引号标识（``），可以用来定义多行字符串，或者使用它在字符串中插入变量：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;hero&#x27;</span></span><br><span class="line"><span class="keyword">let</span> tips = <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, </span></span><br><span class="line"><span class="string">    welcome to my world.`</span></span><br><span class="line">alert( tips )</span><br></pre></td></tr></table></figure></li><li><p>标签模板：在函数名后面接一个模板字符串相当于给函数传入了参数进行调用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> tips = parse<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, are you <span class="subst">$&#123;age&#125;</span> years old this year?`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">stringArr, ...variable</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于传递如下参数进行调用 parse 函数</span></span><br><span class="line">parse([<span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;, are you &quot;</span>, <span class="string">&quot; years old this year?&quot;</span>], name, age)</span><br></pre></td></tr></table></figure></li><li><p><code>String.fromCodePoint()</code> 用于从 <code>Unicode</code> 码点返回对应字符，可以支持 <code>0xFFFF</code> 的码点：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x1f600</span>)   <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f600</span>)  <span class="comment">// &quot;😀&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>String.raw()</code> 返回把字符串所有变量替换且对斜杠进行转义的结果：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>  <span class="comment">// &quot;Hi\n5!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>codePointAt()</code> 返回字符的十进制码点，对于 <code>Unicode</code> 大于 <code>0xFFFF</code> 的字符，会被认为是2个字符，十进制码点转成十六进制可以使用 <code>toString(16)</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emoji = <span class="string">&#x27;🤣&#x27;</span></span><br><span class="line">emoji.length  <span class="comment">// 2</span></span><br><span class="line">emoji.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>)  <span class="comment">// &#x27;d83d&#x27;</span></span><br><span class="line">emoji.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>)  <span class="comment">// &#x27;de00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0xd83d</span>, <span class="number">0xde00</span>) === <span class="string">&#x27;🤣&#x27;</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>normalize()</code> 方法会按照指定的一种 <code>Unicode</code> 正规形式将当前字符串正规化。（如果该值不是字符串，则首先将其转换为一个字符串）：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;\u00F1&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;\u006E\u0303&#x27;</span></span><br><span class="line"></span><br><span class="line">str1  <span class="comment">//  ñ</span></span><br><span class="line">str2  <span class="comment">//  ñ</span></span><br><span class="line">str1 === str2  <span class="comment">// false</span></span><br><span class="line">str1.length === str2.length  <span class="comment">// false</span></span><br><span class="line">str1.normalize() === str2.normalize()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>字符串是否包含子串：</p><ul><li><p>includes()：返回布尔值，表示是否找到了参数字符串。</p></li><li><p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</p></li><li><p>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line"></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>)        <span class="comment">// true</span></span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>)        <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line"></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>)   <span class="comment">// false</span></span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，使用第二个参数 <code>n</code> 时，<code>endsWith</code> 的行为与其他两个方法有所不同。它针对前 <code>n</code> 个字符，而其他两个方法针对从第 <code>n</code> 个位置直到字符串结束。</p></li></ul></li><li><p><code>repeat(n)</code> 将当前字符串重复 <code>n</code> 次后，返回一个新字符串：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">2</span>)         <span class="comment">// &#x27;xx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">1.9</span>)       <span class="comment">// &#x27;x&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="literal">NaN</span>)       <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="literal">undefined</span>) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="string">&#x27;2a&#x27;</span>)      <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">-0.6</span>)      <span class="comment">// &#x27;&#x27;，解释：0 ~ 1 之间的小数相当于 0</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">-2</span>)        <span class="comment">// RangeError</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="literal">Infinity</span>)  <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li><p>二进制（0b）和八进制（0o）表示法：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> b = num.toString(<span class="number">2</span>)  <span class="comment">// 二进制的100：1100100</span></span><br><span class="line"><span class="keyword">let</span> o = num.toString(<span class="number">8</span>)  <span class="comment">// 八进制的100：144</span></span><br><span class="line"><span class="number">0b1100100</span> === <span class="number">100</span>        <span class="comment">// true</span></span><br><span class="line"><span class="number">0o144</span> === <span class="number">100</span>            <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isFinite()</code> 判断一个数是否是有限的数，入参如果不是数值一律返回 <code>false</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">-2.9</span>)      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>)       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;&#x27;</span>)        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">false</span>)     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isNaN()</code> 判断一个数值是否为 <code>NaN</code>，如果入参不是 <code>NaN</code> 那结果都是 <code>false</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>)       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;a&#x27;</span>/<span class="number">0</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;NaN&#x27;</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>数值转化：<code>Number.parseInt()</code> 和 <code>Number.parseFloat()</code>，非严格转化，从左到右解析字符串，遇到非数字就停止解析，并且把解析的数字返回：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12a&#x27;</span>)  <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;a12&#x27;</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xA&#x27;</span>)  <span class="comment">// 10，0x开头的将会被当成十六进制数</span></span><br></pre></td></tr></table></figure><p>  <code>parseInt()</code> 默认是用十进制去解析字符串的，其实他是支持传入第二个参数的，表示要以多少进制的 基数去解析第一个参数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1010&#x27;</span>, <span class="number">2</span>)  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>)  <span class="comment">// 255</span></span><br></pre></td></tr></table></figure><p>  参考：<a href="https://juejin.im/post/6855129005121765390#heading-13">parseInt</a></p></li><li><p><code>Number.isInteger()</code> 判断一个数值是否为整数，入参为非数值则一定返回 <code>false</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>)   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger()     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">&#x27;15&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">3.0000000000000002</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>如果对数据精度的要求较高，不建议使用 Number.isInteger() 判断一个数值是否为整数。</p></blockquote></li><li><p><code>Number.EPSILON</code> 表示一个可接受的最小误差范围，通常用于浮点数运算：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>) &lt; <span class="built_in">Number</span>.EPSILON  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isSafeInteger()</code> 用来判断一个数是否在最大安全整数（<code>Number.MAX_SAFE_INTEGER</code>）和最小安全整数（<code>Number.MIN_SAFE_INTEGER</code>）之间：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">2</span> ** <span class="number">53</span> <span class="number">-1</span>        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span>  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span>)         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">&#x27;2&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>Math.trunc()</code>：返回数值整数部分</p></li><li><p><code>Math.sign()</code>：返回数值类型(正数 1、负数 -1、零 0)</p></li><li><p><code>Math.cbrt()</code>：返回数值立方根</p></li><li><p><code>Math.clz32()</code>：返回数值的 32 位无符号整数形式</p></li><li><p><code>Math.imul()</code>：返回两个数值相乘</p></li><li><p><code>Math.fround()</code>：返回数值的 32 位单精度浮点数形式</p></li><li><p><code>Math.hypot()</code>：返回所有数值平方和的平方根</p></li><li><p><code>Math.expm1()</code>：返回 <code>e^n - 1</code></p></li><li><p><code>Math.log1p()</code>：返回 1 + n 的自然对数(<code>Math.log(1 + n)</code>)</p></li><li><p><code>Math.log10()</code>：返回以 10 为底的 n 的对数</p></li><li><p><code>Math.log2()</code>：返回以 2 为底的n的对数</p></li><li><p><code>Math.sinh()</code>：返回 n 的双曲正弦</p></li><li><p><code>Math.cosh()</code>：返回 n 的双曲余弦</p></li><li><p><code>Math.tanh()</code>：返回 n 的双曲正切</p></li><li><p><code>Math.asinh()</code>：返回 n 的反双曲正弦</p></li><li><p><code>Math.acosh()</code>：返回 n 的反双曲余弦</p></li><li><p><code>Math.atanh()</code>：返回 n 的反双曲正切</p></li></ul><h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li><p>数组扩展运算符（…）将数组展开成用逗号分隔的参数序列，只能展开一层数组：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：函数传参</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>]  <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：浅克隆</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> clone = [...a]</span><br><span class="line">a === clone  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用四：数组解构</span></span><br><span class="line"><span class="keyword">const</span> [x, ...y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x  <span class="comment">// 1</span></span><br><span class="line">y  <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.from()</code> 可以将类数组对象（ <code>NodeList</code>，<code>arguments</code>）和可迭代对象转成数组：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：字符串转数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;foo&#x27;</span>)  <span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并去重</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(merge))  <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：arguments 转数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>  如果 <code>Array.from()</code> 带第二个参数 <code>mapFn</code>，将对生成的新数组执行一次 <code>map</code> 操作：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x )    <span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> ++i)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.of()</code> 将一组参数转成数组：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayOf</span>(<span class="params">...params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].slice.call(params)</span><br><span class="line">&#125;</span><br><span class="line">arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.copyWithin()</code> 在当前数组内部，将制定位置的成员复制到其他位置（会覆盖原来位置的成员），最后返回一个新数组。接收 3 个参数，参数为负数表示右边开始计算：</p><ul><li><p><code>target</code>（必选）：替换位置的索引；</p></li><li><p><code>start</code>（可选）：从该位置开始读取数据，默认为 0；</p></li><li><p><code>end</code>（可选）：从该位置结束读取数据（不包括该位置的数据），默认为原数组长度；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-1</span>)         <span class="comment">// [1, 2, 3, 4, 1]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>)          <span class="comment">// [1, 1, 2, 3, 4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)    <span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-3</span>, <span class="number">-1</span>)  <span class="comment">// [3, 4, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查找第一个出现的子成员：<code>find()</code> 和 <code>findIndex()</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出第一个偶数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>].find(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>)       <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出第一个偶数的索引位置</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>].findIndex(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>fill()</code> 使用给定的值来填充数组，有 3 个参数：</p><ul><li><p><code>value</code>：填充值；</p></li><li><p><code>start</code>（可选），开始索引，默认为 0；</p></li><li><p><code>end</code>（可选）：结束索引，默认为数组长度，不包括该索引位置的值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化空数组</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">1</span>)  <span class="comment">// [1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].fill(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)  <span class="comment">// [1, 2, &#x27;a&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过 <code>keys()</code>（键名）、<code>entries()</code>（键值）和 <code>values()</code>（键值对） 获取数组迭代器对象，可以被 <code>for...of</code> 迭代，</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)  <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)  <span class="comment">// [0, &#x27;a&#x27;] [0, &#x27;b&#x27;] [0, &#x27;c&#x27;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组空位，是指数组没有值，比如：<code>[,,]</code>，而像这种 <code>[undefined]</code> 是不包含空位的。由于 <code>ES6</code> 之前的一些 <code>API</code> 对空位的处理规则很不一致，所以实际操作的时候应该尽量避免空位的出现，而为了改变这个现状，<code>ES6</code> 的 <code>API</code> 会默认将空位处理成 <code>undefined</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="number">1</span>, , <span class="number">3</span>].values()]  <span class="comment">// [1, undefined, 3]</span></span><br><span class="line">[<span class="number">1</span>, , <span class="number">3</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x === <span class="literal">undefined</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li><p>对象属性简写：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name,</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性名表达式：在用对象字面量定义对象的时候，允许通过属性名表达式来定义对象属性：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;name&#x27;</span>, </span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [name]: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    [<span class="string">&#x27;get&#x27;</span>+ name]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法的 <code>name</code> 属性，存在好几种情况，这里仅列出常见的几种：</p><p>  情况一：普通对象方法的 <code>name</code> 属性直接返回方法名，函数声明亦是如此，函数表达式返回变量名：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    hi()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.hi.name  <span class="comment">// &#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure><p>  情况二：构造函数的 <code>name</code> 为 <code>anonymous</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name  <span class="comment">// &#x27;anonymous&#x27;</span></span><br></pre></td></tr></table></figure><p>  情况三：绑定函数的 <code>name</code> 将会在函数名前加上 <code>bound</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">foo.bind(&#123;&#125;).name  <span class="comment">// &#x27;bound foo&#x27;</span></span><br></pre></td></tr></table></figure><p>  情况四：如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则 <code>name</code> 属性不是在该方法上面，而是该方法的属性的描述对象的 <code>get</code> 和 <code>set</code> 属性上面：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line">    <span class="keyword">get</span> <span class="title">foo</span>()&#123;&#125;, </span><br><span class="line">    <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">x</span>)&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line">o.foo.name  <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">&quot;foo&quot;</span>) </span><br><span class="line">descriptor.get.name  <span class="comment">// &quot;get foo&quot; </span></span><br><span class="line">descriptor.set.name  <span class="comment">// &quot;set foo&quot;</span></span><br></pre></td></tr></table></figure><p>  参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name">function_name</a></p></li><li><p>属性的可枚举性</p><p>  对象的每个属性都有一个描述对象（<code>Descriptor</code>），用来控制该属性的行为。可以通过 <code>Object.getOwnPropertyDescriptor()</code> 来获取对象某个属性的描述：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     value: &quot;布兰&quot;,</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>  这里的 <code>enumerable</code> 就是对象某个属性的可枚举属性，如果某个属性的 <code>enumerable</code> 值为 <code>false</code> 则表示该属性不能被枚举，所以该属性会被如下 4 种操作忽略：</p><ul><li><p><code>for...in</code> ：只遍历对象自身的和继承的可枚举的属性；</p></li><li><p><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名；</p></li><li><p><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性；</p></li><li><p><code>Object.assign()</code>： 只拷贝对象自身的可枚举的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">person  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作都将忽略 person 对象的 age 属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)         <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(person)        <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(person)     <span class="comment">// &#x27;&#123;&quot;name&quot;: &quot;布兰&quot;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, person)  <span class="comment">// &#123; name: &#x27;布兰&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p><code>Reflect.ownKeys(obj)</code>： 返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 <code>Symbol</code> 或字符串，也不管是否可枚举：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(person)  <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>super</code> 关键字，指向对象的原型对象，只能用于对象的方法中，其他地方将报错：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, &#123;<span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>&#125;)</span><br><span class="line">person.getName()  <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下几种 super 的使用将报错</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    foo: <span class="built_in">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    foo: <span class="function">() =&gt;</span> <span class="built_in">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.is()</code> 用来判断两个值是否相等，表现基本和 <code>===</code> 一样，除了以下两种情况：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>            <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>          <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.assign()</code> 用于对象的合并，将源对象（<code>source</code>）的所有可枚举属性，复制到目标对象（<code>target</code>），如果有同名属性，则后面的会直接替换前面的：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> source1 = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">d</span>: &#123;<span class="attr">e</span>: <span class="number">1</span>, <span class="attr">f</span>: <span class="number">2</span>&#125; &#125;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: &#123;<span class="attr">g</span>: <span class="number">3</span>&#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2)</span><br><span class="line">target  <span class="comment">// &#123; a: 3, b: 3, c: 4, d: &#123;g: 3&#125; &#125;</span></span><br></pre></td></tr></table></figure><p>  <code>Object.assign()</code> 实行的是浅拷贝，如果源对象某个属性是对象，那么拷贝的是这个对象的引用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line">target.a.b = <span class="number">3</span></span><br><span class="line">source.a.b  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>__proto__</code> 属性是用来读取和设置当前对象的原型，而由于其下划线更多的是表面其是一个内部属性，所以建议不在正式场合使用它，而是用下面的 <code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p></li><li><p><code>Object.setPrototypeOf()</code> 用于设置对象原型，<code>Object.getPrototypeOf()</code> 用于读取对象原型：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, &#123;<span class="attr">name</span>: <span class="string">&#x27;动物&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person)  <span class="comment">// &#123;name: &#x27;动物&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li><p><code>RegExp</code> 构造函数，允许首参为正则表达式，第二个参数为修饰符，如果有第二个参数，则修饰符以第二个为准：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xYz\d+/gi</span>, i)</span><br><span class="line">reg.flags  <span class="comment">// &#x27;i&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>正则方法调用变更：字符串对象的 <code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code> 内部调用转为调用 <code>RegExp</code> 实例对应的 <code>RegExp.prototype[Symbol.方法]</code>；</p></li><li><p><code>u</code> 修饰符：含义为 <code>Unicode</code> 模式，用来正确处理大于 <code>\uFFFF</code> 的 <code>Unicode</code> 字符。也就是说，如果待匹配的字符串中可能包含有大于 <code>\uFFFF</code> 的字符，就必须加上 <code>u</code> 修饰符，才能正确处理。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上 u 修饰符才能让 . 字符正确识别大于 \uFFFF 的字符</span></span><br><span class="line">/^.$/.test(<span class="string">&#x27;🤣&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(<span class="string">&#x27;🤣&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大括号 Unicode 字符表示法必须加上 u 修饰符</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">&#x27;a&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有 u 修饰符，量词才能正确匹配大于 \uFFFF 的字符 </span></span><br><span class="line">/🤣&#123;<span class="number">2</span>&#125;/.test(<span class="string">&#x27;🤣🤣&#x27;</span>)  <span class="comment">// false</span></span><br><span class="line">/🤣&#123;<span class="number">2</span>&#125;/u.test(<span class="string">&#x27;🤣🤣&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  <code>RegExp.prototype.unicode</code> 属性表示正则是否设置了 <code>u</code> 修饰符：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/🤣/.unicode   <span class="comment">// false</span></span><br><span class="line">/🤣/u.unicode  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>y</code> 修饰符，与 <code>g</code> 修饰符类似也是全局匹配；不同的是 <code>g</code> 是剩余字符中匹配即可，而 <code>y</code> 则是必须在剩余的第一个字符开始匹配才行，所以 <code>y</code> 修饰符也叫黏连修饰符：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span></span><br><span class="line"><span class="keyword">let</span> r1 = <span class="regexp">/a+/g</span></span><br><span class="line"><span class="keyword">let</span> r2 = <span class="regexp">/a+/y</span></span><br><span class="line"></span><br><span class="line">r1.exec(s)  <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line">r2.exec(s)  <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s)  <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">r2.exec(s)  <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>  <code>RegExp.prototype.sticky</code> 属性表示是否设置了 <code>y</code> 修饰符：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/abc/y.sticky  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>RegExp.prototype.flags</code> 属性会返回当前正则的所有修饰符：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/abc🤣/iuy.flags  <span class="comment">// &#x27;iuy&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li><p>函数参数默认值。参数不能有同名的，函数体内不能用 <code>let</code> 和 <code>const</code> 声明同参数名的变量：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params">name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>  使用参数默认值的时候，参数不能有同名的：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, x, y</span>) </span>&#123;&#125;      <span class="comment">// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, x, y = <span class="number">1</span></span>) </span>&#123;&#125;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>  函数体内不能用 <code>let</code> 和 <code>const</code> 声明同参数名的变量：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  函数的 <code>length</code> 属性会返回没有指定默认值的参数个数，且如果设置默认值的参数不是尾参数，则 <code>length</code> 不再计入后面的参数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>)</span>&#123;&#125;).length      <span class="comment">// 2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">1</span></span>)</span>&#123;&#125;).length  <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>)</span>&#123;&#125;).length  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p>剩余（<code>rest</code>） 参数（…变量名）的形式，用于获取函数的剩余参数，注意 <code>rest</code> 参数必须放在最后一个位置，可以很好的代替 <code>arguments</code> 对象：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> y) &#123;</span><br><span class="line">        coonsole.log(val)  <span class="comment">// 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>严格模式：只要函数参数使用了默认值、解构赋值或者扩展运算符，那么函数体内就不能显示的设定为严格模式，因为严格模式的作用范围包含了函数参数，而函数执行的顺序是先执行参数，然后再执行函数体，执行到函数体里的 <code>use strict</code> 的时候，那么此时因为函数参数已经执行完成了，那函数参数还要不要受到严格模式的限制呢？这就出现矛盾了。规避限制的办法有两个：设置全局的严格模式或者在函数体外在包一个立即执行函数并且声明严格模式：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二</span></span><br><span class="line"><span class="keyword">let</span> f = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li><p>箭头函数语法比函数表达式更简洁，并且没有自己的 <code>this</code>、<code>arguments</code>，不能用作构造函数和用作生成器。</p><p>  几种箭头函数写法：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f1 = <span class="function">() =&gt;</span> &#123;&#125;               <span class="comment">// 没有参数</span></span><br><span class="line"><span class="keyword">let</span> f2 = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;&#125;              <span class="comment">// 1个参数</span></span><br><span class="line"><span class="keyword">let</span> f3 = <span class="function"><span class="params">x</span> =&gt;</span> &#123;&#125;                <span class="comment">// 1个参数可以省略圆括号</span></span><br><span class="line"><span class="keyword">let</span> f4 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;&#125;           <span class="comment">// 2个参数以上必须加上圆括号</span></span><br><span class="line"><span class="keyword">let</span> f5 = <span class="function">(<span class="params">x = <span class="number">1</span>, y = <span class="number">2</span></span>) =&gt;</span> &#123;&#125;   <span class="comment">// 支持参数默认值</span></span><br><span class="line"><span class="keyword">let</span> f6 = <span class="function">(<span class="params">x, ...y</span>) =&gt;</span> &#123;&#125;        <span class="comment">// 支持 rest 参数</span></span><br><span class="line"><span class="keyword">let</span> f7 = (&#123;x = <span class="number">1</span>, y = <span class="number">2</span>&#125; = &#123;&#125;)  <span class="comment">// 支持参数解构</span></span><br></pre></td></tr></table></figure><p>  箭头函数没有自己的 <code>this</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">0</span></span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age++</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()  <span class="comment">// 1 秒后 Person &#123;age: 1&#125;</span></span><br></pre></td></tr></table></figure><p>  通过 <code>call/apply</code> 调用箭头函数的时候将不会绑定第一个参数的作用域：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> adder = &#123;</span><br><span class="line">    base: <span class="number">1</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.base</span><br><span class="line">        <span class="keyword">return</span> f(a)</span><br><span class="line">    &#125;, </span><br><span class="line">    addThruCall: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.base</span><br><span class="line">        <span class="keyword">let</span> b = &#123;</span><br><span class="line">            base: <span class="number">2</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> f.call(b, a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">adder.add(<span class="number">1</span>)          <span class="comment">// 输出 2</span></span><br><span class="line">adder.addThruCall(<span class="number">1</span>)  <span class="comment">// 仍然输出 2</span></span><br></pre></td></tr></table></figure><p>  箭头函数没有自己的 <code>arguments</code> 对象，不过可以使用 <code>rest</code> 参数代替：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> log = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)  <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数代替写法</span></span><br><span class="line"><span class="keyword">let</span> restLog = <span class="function">(<span class="params">...arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr)  <span class="comment">// [2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line">restLog(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>  箭头函数不能用作构造器，和 <code>new</code> 一起用会抛出错误：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure><p>  箭头函数返回对象字面量，需要用圆括号包起来：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func2 = <span class="function">() =&gt;</span> (&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>  参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow_functions</a></p></li><li><p>尾调用和尾递归 </p><p>  首先得知道什么是尾调用：函数的最后一步调用另外一个函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都不是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = g(x)</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = g(x)</span><br><span class="line">    <span class="keyword">return</span> g(x) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    g(x)</span><br><span class="line">    <span class="comment">// 因为最后一步是 return: undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  尾调用有啥用？我们知道函数的相互调用是会生成“调用帧”的，而“调用帧”里存了各种信息比如函数的内部变量和调用函数的位置等，所有的“调用帧”组成了一个“调用栈”。如果在函数的最后一步操作调用了另外一个函数，因为外层函数里调用位置、内部变量等信息都不会再用到了，所有就无需保留外层函数的“调用帧”了，只要直接用内层函数的“调用帧”取代外层函数的“调用帧”即可：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> g(m + n)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>  这样一来就很明显的减少了调用栈中的帧数，内存占用就少了，所以这就是尾调用的优化作用。尾递归也是如此，递归如果次数多那就需要保留非常多的“调用帧”，所以经常会出现栈溢出错误，而使用了尾递归优化后就不会发生栈溢出的错误了：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规递归的斐波那契函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fibonacci(<span class="number">100</span>) <span class="comment">// 超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归优化后的斐波那契函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span>(<span class="params">n, ac1 = <span class="number">1</span>, ac2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> ac2&#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci2(n - <span class="number">1</span>, ac2, ac1 + ac2)</span><br><span class="line">&#125;s</span><br><span class="line">Fibonacci2(<span class="number">100</span>)  <span class="comment">// 573147844013817200000</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul><li><p><code>Symbol</code> 是一个新的原始类型，用来表示一个独一无二的值，可以通过 <code>Symbol()</code> 函数来创建一个 <code>Symbol</code> 类型的值，为了加以区分，可以传入一个字符串作为其描述：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) </span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol</code> 类型无法通过数学运算符进行隐式类型转换，但是可以通过 <code>String()</code> 显示转成字符串或者通过 <code>Boolean()</code> 显示转成布尔值：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">String</span>(s)     <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line">s.toString()  <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line"><span class="built_in">Boolean</span>(s)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>引入 <code>Symbol</code> 最大的初衷其实就是为了让它作为对象的属性名而使用，这样就可以有效避免属性名的冲突了：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [foo]: <span class="string">&#x27;foo1&#x27;</span>,</span><br><span class="line">    foo: <span class="string">&#x27;foo2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[foo]  <span class="comment">// &#x27;foo1&#x27;</span></span><br><span class="line">obj.foo   <span class="comment">// &#x27;foo2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol</code> 属性的不可枚举性，不会被 <code>for...in</code>、<code>for...of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 等枚举：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(person)  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(person)  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(person)  <span class="comment">// &#x27;&#123;&quot;name&quot;:&quot;布兰&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>  但是可以通过 <code>Object.getOwnPropertySymbols()</code> 获取到对象的所有 <code>Symbol</code> 属性名，返回一个数组：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(person)  <span class="comment">// [Symbol(age)]</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>静态方法</strong>：</p><ul><li><p><code>Symbol.for()</code> 按照描述去全局查找 <code>Symbol</code>，找不到则在全局登记一个：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  <code>Symbol.for()</code> 的这个全局登记特性，可以用在不同的 <code>iframe</code> 或 <code>service worker</code> 中取到同一个值。</p></li><li><p><code>Symbol.keyFor()</code> 根据已经在全局登记的 <code>Symbol</code> 查找其描述：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s)  <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong><code>Symbol</code> 的内置值</strong>：</p><ul><li><code>Symbol.hasInstance</code>：指向一个内部方法，当其他对象使用 <code>instanceof</code> 运算符判断是否为此对象的实例时会调用此方法；</li><li><code>Symbol.isConcatSpreadable</code>：指向一个布尔，定义对象用于 <code>Array.prototype.concat()</code> 时是否可展开；</li><li><code>Symbol.species</code>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数；</li><li><code>Symbol.match</code>：指向一个函数，当实例对象被 <code>String.prototype.match()</code> 调用时会重新定义match()的行为；</li><li><code>Symbol.replace</code>：指向一个函数，当实例对象被 <code>String.prototype.replace()</code> 调用时会重新定义 <code>replace()</code> 的行为；</li><li><code>Symbol.search</code>：指向一个函数，当实例对象被 <code>String.prototype.search()</code> 调用时会重新定义 <code>search()</code> 的行为；s</li><li><code>Symbol.split</code>：指向一个函数，当实例对象被 <code>String.prototype.split()</code> 调用时会重新定义 <code>split()</code> 的行为；</li><li><code>Symbol.iterator</code>：指向一个默认遍历器方法，当实例对象执行<code> for...of</code> 时会调用指定的默认遍历器；</li><li><code>Symbol.toPrimitive</code>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值；</li><li><code>Symbol.toStringTag</code>：指向一个函数，当实例对象被 <code>Object.prototype.toString()</code> 调用时其返回值会出现在 <code>toString()</code> 返回的字符串之中表示对象的类型；</li><li><code>Symbol.unscopables</code>：指向一个对象，指定使用 <code>with</code> 时哪些属性会被 <code>with</code> 环境排除；</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><p><code>Set</code> 是一种新的数据结构，类似数组，但是它没有键只有值，且值都是唯一的。可以通过构造函数生成一个新实例，接收一个数组或者可迭代数据结构作为参数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;abc&#x27;</span>)      <span class="comment">// Set &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Set</code> 判断两个值是不是相等用的是 <a href="https://tc39.es/ecma262/#sec-samevaluezero">sameValueZero</a> 算法，类似于 <code>===</code>，唯一的区别是，在 <code>Set</code> 里 <code>NaN</code> 之间被认为是相等的：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>相同对象的不同实例也被 <code>Set</code> 认为是不相等的：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>Set</code> 是有顺序的，将按照插入的顺序进行迭代，可以使用 <code>for...of</code> 迭代：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>)</span><br><span class="line">set.add(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>Set</code> 实例属性和方法</strong>：</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是 <code>Set</code> 函数；</li><li><code>Set.prototype.size</code>：返回 <code>Set</code> 实例的成员总数；</li><li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身；</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功；</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为Set的成员；</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值；</li><li><code>Set.prototype.keys()</code>：返回键名的遍历器；</li><li><code>Set.prototype.values()</code>：返回键值的遍历器；</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器；</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>)     <span class="comment">// Set &#123;1, 3, 5&#125;</span></span><br><span class="line">set.size       <span class="comment">// 3</span></span><br><span class="line">set.delete(<span class="number">1</span>)  <span class="comment">// true，1 已被删除</span></span><br><span class="line">set.has(<span class="number">1</span>)     <span class="comment">// false</span></span><br><span class="line">set.keys()     <span class="comment">// SetIterator &#123;3, 5&#125;</span></span><br><span class="line">set.clear()</span><br><span class="line">set.size       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><strong><code>Set</code> 应用场景</strong>：</p><ul><li><p>数组去重：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>])]         <span class="comment">// [1, 3, 6]</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>]))  <span class="comment">// [1, 3, 6]</span></span><br></pre></td></tr></table></figure></li><li><p>字符串去重：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;abcbacd&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>)  <span class="comment">// &#x27;abcd&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>求两个集合的交集/并集/差集：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b])  <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)))  <span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)))  <span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>遍历修改集合成员的值：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>))     <span class="comment">// Set &#123;2, 3, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, <span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>))  <span class="comment">// Set &#123;2, 4, 6&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><ul><li><p><code>WeakSet</code> 对象允许将弱保持对象存储在一个集合中：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">ws.add(foo)  <span class="comment">// WeakSet &#123;&#123;&#125;&#125;</span></span><br><span class="line">ws.has(foo)  <span class="comment">// true</span></span><br><span class="line">ws.delete(foo)  <span class="comment">// WeakSet &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>和 <code>Set</code> 的区别</strong>：</p><ul><li><code>WeakSet</code> 只能是对象的集合，而不能是任何类型的任意值；</li><li><code>WeakSet</code> 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 <code>WeakSet</code> 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 <code>WeakSet</code> 中没有存储当前对象的列表。正因为这样，<code>WeakSet</code> 是不可枚举的，也就没有 <code>size</code> 属性，没有 <code>clear</code> 和遍历的方法。</li></ul><p><strong>实例方法</strong>：</p><ul><li><code>WeakSet.prototype.add(value)</code>：添加一个新元素 <code>value</code>；</li><li><code>WeakSet.prototype.delete(value)</code>：从该 <code>WeakSet</code> 对象中删除 <code>value</code> 这个元素；</li><li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值,  表示给定的值 <code>value</code> 是否存在于这个 <code>WeakSet</code> 中；</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><p><code>Map</code> 是一种类似于 <code>Object</code> 的这种键值对的数据结构，区别是对象的键只能是字符串或者 <code>Symbol</code>，而 <code>Map</code> 的键可以是任何类型（原始类型、对象或者函数），可以通过 <code>Map</code> 构造函数创建一个实例，入参是具有 <code>Iterator</code> 接口且每个成员都是一个双元素数组 <code>[key, value]</code> 的数据结构：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map1.set(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;布兰&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>, <span class="number">12</span>]]</span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(arr)</span><br></pre></td></tr></table></figure></li><li><p><code>Map</code> 中的键和 <code>Set</code> 里的值一样也必须是唯一的，遵循 <a href="https://tc39.es/ecma262/#sec-samevaluezero">sameValueZero</a> 算法，对于同一个键后面插入的会覆盖前面的，</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span>&#125;</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo1&#x27;</span>)</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo2&#x27;</span>)</span><br><span class="line">map.get(foo)  <span class="comment">// &#x27;foo2&#x27; </span></span><br></pre></td></tr></table></figure></li><li><p>对于键名同为 <code>NaN</code> 以及相同对象而不同实例的处理同 <code>Set</code> 的值一样：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(a, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(b, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">map.size    <span class="comment">// 1</span></span><br><span class="line">map.get(a)  <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> d = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">map.set(c, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">map.set(d, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">map.size    <span class="comment">// 3</span></span><br><span class="line">map.get(c)  <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>实例属性和方法</strong>：</p><ul><li><code>Map.prototype.size</code>：返回 <code>Map</code> 对象的键值对数量；</li><li><code>Map.prototype.set(key, value)</code>：设置 <code>Map</code> 对象中键的值。返回该 <code>Map</code> 对象；</li><li><code>Map.prototype.get(key)</code>： 返回键对应的值，如果不存在，则返回 <code>undefined</code>；</li><li><code>Map.prototype.has(key)</code>：返回一个布尔值，表示 <code>Map</code> 实例是否包含键对应的值；</li><li><code>Map.prototype.delete(key)</code>： 如果 <code>Map</code> 对象中存在该元素，则移除它并返回 <code>true</code>；</li><li><code>Map.prototype.clear()</code>： 移除 <code>Map</code> 对象的所有键/值对；</li><li><code>Map.prototype.keys()</code>：返回一个新的 <code>Iterator</code> 对象， 它按插入顺序包含了 <code>Map</code> 对象中每个元素的键；</li><li><code>Map.prototype.values()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map</code> 对象中每个元素的值；</li><li><code>Map.prototype.entries()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map</code> 对象中每个元素的 <code>[key, value]</code> 数组；</li><li><code>Map.prototype.forEach(callbackFn[, thisArg])</code>：按插入顺序遍历 <code>Map</code>；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(&#123;<span class="attr">a</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125; &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125; &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><ul><li><p>类似于 <code>Map</code> 的结构，但是键必须是对象的弱引用，注意弱引用的是键名而不是键值，因而 <code>WeakMap</code> 是不能被迭代的；</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>&#125;</span><br><span class="line">wm.set(foo, <span class="string">&#x27;a&#x27;</span>)  <span class="comment">// Weak</span></span><br><span class="line">wm.get(foo)       <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">wm.has(foo)       <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  虽然 <code>wm</code> 的键对 <code>foo</code> 对象有引用，但是丝毫不会阻止 <code>foo</code> 对象被 <code>GC</code> 回收。当引用对象 <code>foo</code> 被垃圾回收之后，<code>wm</code> 的 <code>foo</code> 键值对也会自动移除，所以不用手动删除引用。</p></li></ul><p><strong>实例方法</strong>：</p><ul><li><code>WeakMap.prototype.delete(key)</code>：移除 <code>key</code> 的关联对象；</li><li><code>WeakMap.prototype.get(key)</code>：返回key关联对象, 或者 undefined(没有key关联对象时)；</li><li><code>WeakMap.prototype.has(key)</code>：根据是否有 <code>key</code> 关联对象返回一个 <code>Boolean</code> 值；</li><li><code>WeakMap.prototype.set(key, value)</code>：在 <code>WeakMap</code> 中设置一组 <code>key</code> 关联对象，返回这个 <code>WeakMap</code> 对象；</li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul><li><p><code>Proxy</code> 用来定义基本操作的的自定义行为，可以理解为当对目标对象 <code>target</code> 进行某个操作之前会先进行拦截（执行 <code>handler</code> 里定义的方法），必须要对 <code>Proxy</code> 实例进行操作才能触发拦截，对目标对象操作是不会拦截的，可以通过如下方式定义一个代理实例</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>&#125;, &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;target.name&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">instance.name  <span class="comment">// &#x27;hello, 布兰&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>如果 <code>handle</code> 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;)</span><br><span class="line">proxy.name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">target.name  <span class="comment">// &#x27;布兰&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>目标对象被 <code>Proxy</code> 代理的时候，内部的 <code>this</code> 会指向代理的实例：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span> === proxy)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">target.m()  <span class="comment">// false</span></span><br><span class="line">proxy.m()   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>静态方法</strong>：</p><ul><li><p><code>Proxy.revocable()</code> 用以定义一个可撤销的 <code>Proxy</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler)</span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">123</span></span><br><span class="line">proxy.foo  <span class="comment">// 123</span></span><br><span class="line">revoke()</span><br><span class="line">proxy.foo  <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></li></ul><p><strong><code>handle</code> 对象的方法</strong>：</p><ul><li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li><li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如 <code>proxy.foo = v或proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li><code>has(target, propKey)</code>：拦截 <code>propKey in proxy</code> 的操作，返回一个布尔值。<br><code>deleteProperty(target, propKey)</code>：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li><li><code>ownKeys(target)</code>：拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code> 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys()</code> 的返回结果仅包括目标对象自身的可遍历属性。</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li><code>defineProperty(target, propKey, propDesc)</code>：拦截 <code>Object.defineProperty(proxy, propKey, propDesc)</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li><code>preventExtensions(target)</code>：拦截 <code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li><code>getPrototypeOf(target)</code>：拦截 <code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li><code>isExtensible(target)</code>：拦截 <code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li><code>setPrototypeOf(target, proto)</code>：拦截 <code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li><code>apply(target, object, args)</code>：拦截 <code>Proxy</code> 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li><code>construct(target, args)</code>：拦截 <code>Proxy</code> 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code>。</li></ul><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul><li><p><code>Reflect</code> 是一个内置的对象，它提供拦截 <code>JavaScript</code> 操作的方法。这些方法与 <code>proxy handlers</code> 的方法相同。<code>Reflect</code> 不是一个函数对象，因此它是不可构造的。</p></li><li><p>设计的目的：</p><ul><li>将 <code>Object</code> 属于语言内部的方法放到 <code>Reflect</code> 上；</li><li>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理；</li><li>让 <code>Object</code> 操作变成函数行为；</li><li><code>Proxy handles</code> 与 <code>Reflect</code> 方法一一对应，前者用于定义自定义行为，而后者用于恢复默认行为；</li></ul></li></ul><p><strong>静态方法</strong>：    </p><ul><li><code>Reflect.apply(target, thisArgument, argumentsList)</code> 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 <code>Function.prototype.apply()</code> 功能类似；</li><li><code>Reflect.construct(target, argumentsList[, newTarget])</code> 对构造函数进行 <code>new</code> 操作，相当于执行 <code>new target(...args)</code>；</li><li><code>Reflect.defineProperty(target, propertyKey, attributes)</code> 和 <code>Object.defineProperty()</code> 类似。如果设置成功就会返回 <code>true</code>；</li><li><code>Reflect.deleteProperty(target, propertyKey)</code> 作为函数的 <code>delete</code> 操作符，相当于执行 <code>delete target[name]</code>；</li><li><code>Reflect.get(target, propertyKey[, receiver])</code> 获取对象身上某个属性的值，类似于 <code>target[name]</code>；</li><li><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code> 类似于 <code>Object.getOwnPropertyDescriptor()</code>。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 <code>undefined</code>；</li><li><code>Reflect.getPrototypeOf(target)</code> 类似于 <code>Object.getPrototypeOf()</code>；</li><li><code>Reflect.has(target, propertyKey)</code> 判断一个对象是否存在某个属性，和 <code>in</code> 运算符 的功能完全相同；</li><li><code>Reflect.isExtensible(target)</code> 类似于 <code>Object.isExtensible()</code>；</li><li><code>Reflect.ownKeys(target)</code> 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <code>Object.keys()</code>, 但不会受 <code>enumerable</code> 影响)；</li><li><code>Reflect.preventExtensions(target)</code> 类似于 <code>Object.preventExtensions()</code>。返回一个 <code>Boolean</code>；</li><li><code>Reflect.set(target, propertyKey, value[, receiver])</code> 将值分配给属性的函数。返回一个 <code>Boolean</code>，如果更新成功，则返回 <code>true</code>；</li><li><code>Reflect.setPrototypeOf(target, prototype)</code> 设置对象原型的函数. 返回一个 <code>Boolean</code>， 如果更新成功，则返回 <code>true</code>；</li></ul><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul><li><p>可以用 <code>class</code> 关键字来定义一个类，类是对一类具有共同特征的事物的抽象，就比如可以把小狗定义为一个类，小狗有名字会叫也会跳；类是特殊的函数，就像函数定义的时候有函数声明和函数表达式一样，类的定义也有类声明和类表达式，不过类声明不同于函数声明，它是无法提升的；类也有 <code>name</code> 属性</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    bark() &#123;&#125;</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.name  <span class="comment">// &#x27;Dog&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类表达式：可以命名（类的 name 属性取类名），也可以不命名（类的 name 属性取变量名）</span></span><br><span class="line"><span class="keyword">let</span> Animal2 = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// xxx</span></span><br><span class="line">&#125;</span><br><span class="line">Animal2.name  <span class="comment">// &#x27;Animal2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>JS</code> 中的类建立在原型的基础上（通过函数来模拟类，其实类就是构造函数的语法糖），和 <code>ES5</code> 中构造函数类似，但是也有区别，比如类的内部方法是不可被迭代的：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">    bark() &#123;&#125;</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(Dog.prototype)  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Dog2.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">    bark() &#123;&#125;,</span><br><span class="line">    jump() &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(Dog2.prototype)  <span class="comment">// [&#x27;constructor&#x27;, &#x27;bark&#x27;, &#x27;jump&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>基于原型给类添加新方法：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(Dog.prototype, &#123;</span><br><span class="line">    wag() &#123;&#125;  <span class="comment">// 摇尾巴</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，<code>getter</code>和 <code>setter</code> 都在严格模式下执行。</p></li><li><p>类内部的 <code>this</code> 默认指向类实例，所以如果直接调用原型方法或者静态方法会导致 <code>this</code> 指向运行时的环境，而类内部是严格模式，所以此时的 <code>this</code> 会是 <code>undefined</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    bark() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is bark.`</span> )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> jump() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is jump.`</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;大黄&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> &#123; bark &#125; = dog</span><br><span class="line"><span class="keyword">let</span> &#123; jump &#125; = Dog</span><br><span class="line">bark()  <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line">jump()  <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>方法和关键字</strong>：</p><ul><li><p><code>constructor</code> 方法是类的默认方法，通过 <code>new</code> 关键字生成实例的时候，会自动调用；一个类必须有<code>constructor</code> 方法，如果没有显示定义，则会自动添加一个空的；<code>constructor</code> 默认会返回实例对象：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">- 通过 `</span>get<span class="string">` 和 `</span>set<span class="string">` 关键字拦截某个属性的读写操作：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>js</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">        <span class="keyword">get</span> <span class="title">age</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>用 <code>static</code> 关键字给类定义静态方法，静态方法不会存在类的原型上，所以不能通过类实例调用，只能通过类名来调用，静态方法和原型方法可以同名：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    bark() &#123;&#125;</span><br><span class="line">    jump() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;原型方法&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> jump() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;静态方法&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Dog.prototype)  <span class="comment">// [&#x27;constructor&#x27;, &#x27;bark&#x27;, &#x27;jump&#x27;]</span></span><br><span class="line">Dog.jump()  <span class="comment">// &#x27;静态方法&#x27;</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.jump()  <span class="comment">// &#x27;原型方法&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>公有字段和私有字段：</p><p>  静态公有字段和静态方法一样只能通过类名调用；私有属性和私有方法只能在类的内部调用，外部调用将报错：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    age = <span class="number">12</span>                   <span class="comment">// 公有字段</span></span><br><span class="line">    <span class="keyword">static</span> sex = <span class="string">&#x27;male&#x27;</span>        <span class="comment">// 静态公有字段</span></span><br><span class="line">    #secret = &#x27;我是人类的好朋友&#x27;  // 私有字段</span><br><span class="line">    #getSecret() &#123;              // 私有方法</span><br><span class="line">        return this.#secret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.sex  <span class="comment">// &#x27;male&#x27;</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.#getSecret()  // SyntaxError</span><br></pre></td></tr></table></figure><blockquote><p>公共和私有字段声明是 JavaScript 标准委员会 TC39 提出的实验性功能（第 3 阶段）。浏览器中的支持是有限的，但是可以通过 Babel 等系统构建后使用此功能。</p></blockquote></li><li><p><code>new.target</code> 属性允许你检测函数、构造方法或者类是否是通过 <code>new</code> 运算符被调用的。在通过 <code>new</code> 运算符被初始化的函数或构造方法中，<code>new.target</code> 返回一个指向构造方法或函数的引用。在普通的函数调用中，<code>new.target</code> 的值是 <code>undefined</code>，子类继承父类的时候会返回子类：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>.target) <span class="keyword">return</span> <span class="string">&#x27;new target is undefined&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fn is called by new&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()  <span class="comment">// &#x27;Dog&#x27;</span></span><br><span class="line">fn()                 <span class="comment">// &#x27;new target is undefined&#x27;</span></span><br><span class="line"><span class="keyword">new</span> fn()             <span class="comment">// &#x27;fn is called by new&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>类的继承</strong>：</p><ul><li><p>类可以通过 <code>extends</code> 关键字实现继承，如果子类显示的定义了 <code>constructor</code> 则必须在内部调用 <code>super()</code> 方法，内部的 <code>this</code> 指向当前子类：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is running.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="built_in">super</span>(name)  <span class="comment">// 必须调用</span></span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    bark() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is barking.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;大黄&#x27;</span>)</span><br><span class="line">dog.run()  <span class="comment">// &#x27;大黄 is running.&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <code>super()</code> 调用父类的构造函数或者通过 <code>super</code> 调用父类的原型方法；另外也可以在子类的静态方法里通过 <code>super</code> 调用父类的静态方法：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 基于上面的代码改造</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">            <span class="built_in">super</span>(name)  <span class="comment">// 调用父类构造函数</span></span><br><span class="line">            <span class="built_in">this</span>.name = name</span><br><span class="line">        &#125;</span><br><span class="line">        bark() &#123;</span><br><span class="line">            <span class="built_in">super</span>.run()  <span class="comment">// 调用父类原型方法</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is barking.`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">    dog.bark()s</span><br><span class="line">    <span class="comment">// &#x27;大黄 is running.&#x27;</span></span><br><span class="line">    <span class="comment">// &#x27;大黄 is barking.&#x27;</span></span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">- 子类的 `</span>__proto__<span class="string">` 属性，表示构造函数的继承，总是指向父类；子类 `</span>prototype<span class="string">` 属性的 `</span>__proto__<span class="string">` 属性，表示方法的继承，总是指向父类的prototype属性：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>js</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    Dog.__proto__ === Animal  <span class="comment">// true</span></span><br><span class="line">    Dog.prototype.__proto__ === Animal.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  子类原型的原型指向父类的原型：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.__proto__.__proto__  === animal.__proto__  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>extends</code> 还可以实现继承原生的构造函数，如下这些构造函数都可以被继承：</p><ul><li><p><code>String()</code></p></li><li><p><code>Number()</code></p></li><li><p><code>Boolean()</code></p></li><li><p><code>Array()</code></p></li><li><p><code>Object()</code></p></li><li><p><code>Function()</code></p></li><li><p><code>Date()</code></p></li><li><p><code>RegExp()</code></p></li><li><p><code>Error()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> <span class="keyword">extends</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    welcome() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`hello <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ms = <span class="keyword">new</span> MyString(<span class="string">&#x27;布兰&#x27;</span>)</span><br><span class="line">ms.welcome()      <span class="comment">// &#x27;hello 布兰&#x27;</span></span><br><span class="line">ms.length         <span class="comment">// 2</span></span><br><span class="line">ms.indexOf(<span class="string">&#x27;兰&#x27;</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul><li><p>浏览器传统加载模块方式：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步加载</span></span><br><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defer异步加载：顺序执行，文档解析完成后执行；</span></span><br><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span> defer&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async异步加载：乱序加载，下载完就执行。</span></span><br><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>浏览器现在可以按照模块（加上 <code>type=&quot;module&quot;</code>）来加载脚本，默认将按照 <code>defer</code> 的方式异步加载；<code>ES6</code> 的模块加载依赖于 <code>import</code> 和 <code>export</code> 这 2 个命令；模块内部自动采用严格模式：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块加载</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;test.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>export</code> 用于输出模块的对外接口，一个模块内只能允许一个 <code>export default</code> 存在，以下是几种输出模块接口的写法：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="comment">// 写法一：单独导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：按需导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三：重命名后导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> name1, age <span class="keyword">as</span> age1 &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法四：默认导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name</span><br></pre></td></tr></table></figure></li><li><p><code>import</code> 用于输入其他模块的接口：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按需导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入后重命名</span></span><br><span class="line"><span class="keyword">import</span> &#123; name1 <span class="keyword">as</span> name, age1 <span class="keyword">as</span> age &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导入</span></span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> person <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合导入</span></span><br><span class="line"><span class="keyword">import</span> _, &#123; each &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br></pre></td></tr></table></figure><p>  <code>import</code> 导入的细节：</p><ul><li>导入的变量名必须与导出模块的名字一致，可以使用 <code>as</code> 进行重命名；</li><li>导入的变量都是只读的，不能改写；</li><li><code>import</code> 命令具有提升效果，会提升到整个模块的头部，首先执行；</li><li><code>import</code> 是编译时导入，所以不能将其写到代码块（比如 <code>if</code> 判断块里）或者函数内部；</li><li><code>import</code> 会执行所加载的模块的代码，如果重复导入同一个模块则只会执行一次模块；</li></ul></li><li><p><code>import</code> 和 <code>export</code> 的复合写法：<code>export</code> 和 <code>import</code> 语句可以结合在一起写成一行，相当于是在当前模块直接转发外部模块的接口，复合写法也支持用 <code>as</code> 重命名。以下例子中需要在 <code>hub.js</code> 模块中转发 <code>person.js</code> 的接口：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"><span class="comment">// 按需转发接口（中转模块：hub.js）</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; name, age &#125;</span><br><span class="line"><span class="comment">// 转发默认接口（中转模块：hub.js）</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> person</span><br></pre></td></tr></table></figure></li><li><p><code>ES6</code> 模块和 <code>CommonJS</code> 模块的差异：</p><ul><li><code>CommonJS</code> 模块输出的是一个值的拷贝（一旦输出一个值，模块内部的变化就影响不到这个值），<code>ES6</code> 模块输出的是值的引用（是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值）；</li><li><code>CommonJS</code> 模块是运行时加载，<code>ES6</code> 模块是编译时输出接口；</li><li><code>CommonJS</code> 模块的 <code>require()</code> 是同步加载模块，<code>ES6</code> 模块的 <code>import</code> 命令是异步加载，有一个独立的模块依赖的解析阶段；</li></ul></li></ul><h3 id="Iterator和for…of"><a href="#Iterator和for…of" class="headerlink" title="Iterator和for…of"></a>Iterator和for…of</h3><ul><li><p><code>Iterator</code> 迭代器协议，为各种数据结构提供了一种统一按照某种顺序进行访问的机制。通常部署在一个可迭代数据结构内部或其原型上。一个对象要能够成为迭代器，它必须有一个 <code>next()</code> 方法，每次执行 <code>next()</code> 方法会返回一个对象，这个对象包含了一个 <code>done</code> 属性（是个布尔值，<code>true</code> 表示可以继续下次迭代）和一个 <code>value</code> 属性（每次迭代的值）：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> makeIterator = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next()&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; arr.length ? &#123;</span><br><span class="line">                value: arr[index++],</span><br><span class="line">                done: <span class="literal">false</span></span><br><span class="line">            &#125; : &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>iterable</code> 可迭代数据结构：内部或者原型上必须有一个 <code>Symbol.iterator</code> 属性（如果是异步的则是 <code>Symbol.asyncIterator</code>），这个属性是一个函数，执行后会生成一个迭代器：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            index: <span class="number">0</span>,</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.index &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="built_in">this</span>.index++, done: <span class="literal">false</span>&#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  内置的一些可迭代数据结构有：<code>String</code>、<code>Array</code>、<code>TypedArray</code>、<code>Map</code> 和 <code>Set</code>、<code>arguments</code>、<code>NodeList</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> si = <span class="string">&#x27;hi&#x27;</span>[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">si         <span class="comment">// StringIterator</span></span><br><span class="line">si.next()  <span class="comment">// &#123;value: &#x27;h&#x27;, done: false&#125;</span></span><br><span class="line">si.next()  <span class="comment">// &#123;value: &#x27;i&#x27;, done: false&#125;</span></span><br><span class="line">si.next()  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>for...of</code>：用于遍历可迭代数据结构：</p><ul><li><p>遍历字符串：<code>for...in</code> 获取索引，<code>for...of</code> 获取值；</p></li><li><p>遍历数组：<code>for...in</code> 获取索引，<code>for...of</code> 获取值；</p></li><li><p>遍历对象：<code>for...in</code> 获取键，<code>for...of</code> 需自行部署 <code>[Symbol.iterator]</code> 接口；</p></li><li><p>遍历 <code>Set</code>：<code>for...of</code> 获取值， <code>for (const v of set)</code>；</p></li><li><p>遍历 <code>Map</code>：<code>for...of</code> 获取键值对，<code>for (const [k, v] of map)</code>；</p></li><li><p>遍历类数组：包含 <code>length</code> 的对象、<code>arguments</code> 对象、<code>NodeList</code>对象(无 <code>Iterator</code> 接口的类数组可用 <code>Array.from()</code> 转换)；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">&#x27;abc&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">//  &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 Set</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;布兰&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">&#x27;: &#x27;</span> + value)  <span class="comment">// &#x27;name: 布兰&#x27; &#x27;age: 12&#x27;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>for...of</code> 和 <code>for...in</code> 对比</p><p>  共同点：能够通过 <code>break</code>、<code>continue</code> 和 <code>return</code> 跳出循环；<br>  不同点：</p><pre><code>  - `for...in` 的特点：只能遍历键，会遍历原型上属性，遍历无顺序，适合于对象的遍历；  - `for...of` 的特点：能够遍历值（某些数据结构能遍历键和值，比如 `Map`），不会遍历原型上的键值，遍历顺序为数据的添加顺序，适用于遍历可迭代数据结构；</code></pre></li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><code>Promise</code> 这块知识可以直接看我之前写的一篇文章：<a href="https://juejin.im/post/6886247841686093837">深入理解Promise</a> 非常完整。</p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul><li><p><code>function*</code> 会定义一个生成器函数，调用生成器函数不会立即执行，而是会返回一个 <code>Generator</code> 对象，这个对象是符合可迭代协议和迭代器协议的，换句话说这个 <code>Generator</code> 是可以被迭代的。</p></li><li><p>生成器函数内部通过 <code>yield</code> 来控制暂停，而 <code>next()</code> 将把它恢复执行，它的运行逻辑是如下这样的：</p><ul><li><p>遇到 <code>yield</code> 表达式，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值作为返回的对象的 <code>value</code> 属性值；</p></li><li><p>下一次调用 <code>next</code> 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 表达式；</p></li><li><p>如果没有再遇到新的 <code>yield</code> 表达式，就一直运行到函数结束，直到 <code>return</code> 语句为止，并将 <code>return</code> 语句后面的表达式的值，作为返回的对象的 <code>value</code> 属性值；</p></li><li><p>如果该函数没有 <code>return</code> 语句，则返回的对象的 <code>value</code> 属性值为 <code>undefined</code>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()  <span class="comment">// &#123;value: &#x27;hello&#x27;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: &#x27;world&#x27;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: &#x27;end&#x27;, done: true&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在生成器函数内部可以使用 <code>yield*</code> 表达式委托给另一个 <code>Generator</code> 或可迭代对象，比如数组、字符串等；<code>yield*</code> 表达式本身的值是当迭代器关闭时返回的值（即 <code>done</code> 为 <code>true</code> 时）：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span>* inner()</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line">g.next()</span><br><span class="line">g.next()</span><br></pre></td></tr></table></figure></li></ul><p><strong>实例方法</strong>：</p><ul><li><p><code>Generator.prototype.next()</code>：返回一个包含属性 <code>done</code> 和 <code>value</code> 的对象。该方法也可以通过接受一个参数用以向生成器传值。如果传入了参数，那么这个参数会传给上一条执行的 <code>yield</code> 语句左边的变量：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">12</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> a</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = f()</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">&#x27;c&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123;value: 12, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: &#x27;b&#x27;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Generator.prototype.throw()</code>：用来向生成器抛出异常，如果内部捕获了则会恢复生成器的执行（即执行下一条 <code>yield</code> 表达式），并且返回带有 <code>done</code> 及 <code>value</code> 两个属性的对象：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">    yiele <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line">g.throw(<span class="string">&#x27;error a&#x27;</span>)</span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;error a&#x27; </span></span><br><span class="line"><span class="comment">// &#123;value: &quot;b&quot;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;c&quot;, done: false&#125;</span></span><br></pre></td></tr></table></figure><p>  如果内部没有捕获异常，将中断内部代码的继续执行（类似 <code>throw</code> 抛出的异常，如果没有捕获，则后面的代码将不会执行），此时异常会抛到外部，可以被外部的 <code>try...catch</code> 块捕获，此时如果再执行一次 <code>next()</code>，会返回一个值为 <code>done</code> 属性为 <code>true</code> 的对象：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    g.throw(<span class="string">&#x27;error a&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;error a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Generator.prototype.return()</code>：返回给定的值并结束生成器：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()         <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">&#x27;foo&#x27;</span>)  <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.next()         <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>应用</strong>：</p><ul><li><p>将异步操作同步化，比如同时有多个请求，多个请求之间是有顺序的，只能等前面的请求完成了才请求后面的：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">yield</span> request(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">yield</span> request(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">    <span class="keyword">let</span> res3 = <span class="keyword">yield</span> request(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 模拟异步请求</span></span><br><span class="line">        it.next(url)</span><br><span class="line">    &#125;, <span class="number">300</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = main()</span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>给对象部署 <code>Iterator</code> 接口：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> key = keys[i]</span><br><span class="line">        <span class="keyword">yield</span> [key, obj[key]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;foo&#x27; 3</span></span><br><span class="line"><span class="comment">// &#x27;bar&#x27; 7</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2016.png"></p><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><p>判断一个数组是否包含某个元素，之前一般是这么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) &gt;= <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (~arr.indexOf(el)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>而现在你可以这么做了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.includes(el)) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>indexOf</code> 会返回找到元素在数组中的索引位置，判断的逻辑是是否严格相等，所以他在遇到 <code>NaN</code> 的时候不能正确返回索引，但是 <code>includes</code> 解决了这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>].indexOf(<span class="literal">NaN</span>)   <span class="comment">// -1</span></span><br><span class="line">[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>].includes(<span class="literal">NaN</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="求幂运算符（-）"><a href="#求幂运算符（-）" class="headerlink" title="求幂运算符（**）"></a>求幂运算符（**）</h3><p><code>x ** y</code> 是求 <code>x</code> 的 <code>y</code> 次幂，和 <code>Math.pow(x, y)</code> 功能一致：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x ** y</span></span><br><span class="line"><span class="keyword">let</span> squared = <span class="number">2</span> ** <span class="number">2</span>  <span class="comment">// 2 * 2 = 4</span></span><br><span class="line"><span class="keyword">let</span> cubed = <span class="number">2</span> ** <span class="number">3</span>    <span class="comment">// 2 * 2 * 2 = 8</span></span><br></pre></td></tr></table></figure><p><code>x **= y</code> 表示求 <code>x</code> 的 <code>y</code> 次幂，并且把结果赋值给 <code>x</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x **= y</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">x **= <span class="number">3</span>  <span class="comment">// x 最后等于 8</span></span><br></pre></td></tr></table></figure><h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2017.png"></p><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p>返回一个由对象自身所有可遍历属性的属性值组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">    enumrable: <span class="literal">false</span>  <span class="comment">// age 属性将不可遍历</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(person))  <span class="comment">// [&#x27;布兰&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似 str.split(&#x27;&#x27;) 效果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(<span class="string">&#x27;abc&#x27;</span>))  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>返回一个由对象自身所有可遍历属性的键值对组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(person))  <span class="comment">// [[&quot;name&quot;, &quot;布兰&quot;], [&quot;age&quot;, 12]]</span></span><br></pre></td></tr></table></figure><p>利用这个方法可以很好的将对象转成正在的 <code>Map</code> 结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(person))</span><br><span class="line"><span class="built_in">console</span>.log(map)  <span class="comment">// Map &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptor()</code> 会返回指定对象某个自身属性的的描述对象，而 <code>Object.getOwnPropertyDescriptors()</code> 则是返回指定对象自身所有属性的描述对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person))</span><br><span class="line"><span class="comment">//&#123; </span></span><br><span class="line"><span class="comment">//  name: &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;,</span></span><br><span class="line"><span class="comment">//  age: &#123;configurable: false, enumerable: false, value: 12, writable: false&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>配合 <code>Object.create()</code> 可以实现浅克隆：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="String-prototype-padStart"><a href="#String-prototype-padStart" class="headerlink" title="String.prototype.padStart()"></a>String.prototype.padStart()</h3><p><code>str.padStart(length [, padStr])</code> 会返回一个新字符串，该字符串将从 <code>str</code> 字符串的左侧开始填充某个字符串 <code>padStr</code>（非必填，如果不是字符串则会转成字符串, 传入 <code>undefined</code> 和不传这个参数效果一致）直到达到指定位数 <code>length</code> 为止：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>, <span class="number">2</span>)          <span class="comment">// &#x27;22abc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>, <span class="literal">undefined</span>)  <span class="comment">// &#x27;  abc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>, &#123;&#125;)         <span class="comment">// &#x27;[oabc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>)             <span class="comment">// &#x27;  abc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abcde&#x27;</span>.padStart(<span class="number">2</span>, <span class="string">&#x27;f&#x27;</span>)      <span class="comment">// &#x27;abcde&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-padEnd"><a href="#String-prototype-padEnd" class="headerlink" title="String.prototype.padEnd()"></a>String.prototype.padEnd()</h3><p>规则和 <code>padStart</code> 类似，但是是从字符串右侧开始填充：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padEnd(<span class="number">5</span>, <span class="number">2</span>)  <span class="comment">// &#x27;abc22&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="函数参数尾逗号"><a href="#函数参数尾逗号" class="headerlink" title="函数参数尾逗号"></a>函数参数尾逗号</h3><p>允许函数在定义和调用的时候时候最后一个参数后加上逗号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    param1, </span></span></span><br><span class="line"><span class="function"><span class="params">    param2,  </span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">init(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,)</span><br></pre></td></tr></table></figure><h3 id="Async函数"><a href="#Async函数" class="headerlink" title="Async函数"></a>Async函数</h3><ul><li><p>使用 <code>async</code> 可以声明一个 <code>async</code> 函数，结合 <code>await</code> 可以用一种很简介的方法写成基于 <code>Promise</code> 的异步行为，而不需要刻意的链式调用。<code>await</code> 表达式会暂停整个 <code>async</code> 函数的执行进程并出让其控制权，只有当其等待的基于 <code>Promise</code> 的异步操作被兑现或被拒绝之后才会恢复进程。<code>async</code> 函数有如下几种定义形式：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法</span></span><br><span class="line">lef obj = &#123;</span><br><span class="line">    <span class="keyword">async</span> foo() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">async</span> bark() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>async</code> 函数一定会返回一个 <code>Promise</code> 对象，所以它可以使用 <code>then</code> 添加处理函数。如果一个 <code>async</code> 函数的返回值看起来不是<code>Promise</code>，那么它将会被隐式地包装在一个 <code>Promise</code> 中：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>内部如果发生错误，或者显示抛出错误，那么 <code>async</code> 函数会返回一个 <code>rejected</code> 状态的 <code>Promsie</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo().catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)  <span class="comment">// Error: error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>返回的 <code>Promise</code> 对象必须等到内部所有 <code>await</code> 命令 <code>Promise</code> 对象执行完才会发生状态改变，除非遇到 <code>return</code> 语句或抛出错误；任何一个 <code>await</code> 命令返回的 <code>Promise</code> 对象变 <code>为rejected</code> 状态，整个 <code>Async</code> 函数都会中断后续执行：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a_&#x27;</span> + a)</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b_&#x27;</span> + b)  <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// 不会执行</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &#x27;a_success&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;fail&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>所以为了保证  <code>async</code> 里的异步操作都能完成，我们需要将他们放到 <code>try...catch()</code> 块里或者在 <code>await</code> 返回的 <code>Promise</code> 后跟一个 <code>catch</code> 处理函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;a fail&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;a_&#x27;</span> + a)  <span class="comment">// 不会执行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)  <span class="comment">// &#x27;a fail&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;b fail&#x27;</span>)</span><br><span class="line">        .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e)  <span class="comment">// &#x27;b fail&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b_&#x27;</span> + b)  <span class="comment">// &#x27;bundefined&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// undefined</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)  <span class="comment">// 不会执行</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>async</code> 函数里的多个异步操作之间没有依赖关系，建议将他们写到一起减少执行时间：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo()</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar()</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise</span><br></pre></td></tr></table></figure></li><li><p><code>await</code> 命令只能用在 <code>async</code> 函数之中，如果用在普通函数，就会报错。</p></li></ul><h3 id="共享内存和Atomics对象"><a href="#共享内存和Atomics对象" class="headerlink" title="共享内存和Atomics对象"></a>共享内存和Atomics对象</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/arraybuffer#SharedArrayBuffer">SharedArrayBuffer</a></li><li><a href="https://es6.ruanyifeng.com/#docs/arraybuffer#Atomics-%E5%AF%B9%E8%B1%A1">Atomics</a></li></ul><h2 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2018.png"></p><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>Promise.prototype.finally()</code> 用于给 <code>Promise</code> 对象添加 <code>onFinally</code> 函数，这个函数主要是做一些清理的工作，<strong>只有状态变化</strong>的时候才会执行该 <code>onFinally</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">888</span>)  <span class="comment">// 并不会执行  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;).finally(onFinally)</span><br></pre></td></tr></table></figure><p><code>finally()</code> 会生成一个 <code>Promise</code> 新实例，finally 一般会原样后传父 Promise，无论父级实例是什么状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = p3.finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>上面说的是一般，但是也有特殊情况，比如 <code>finally</code> 里返回了一个非 <code>fulfilled</code> 的 <code>Promise</code> 或者抛出了异常的时候，则会返回对应状态的新实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3)  <span class="comment">// Promise &#123;&lt;rejected&gt;: 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = p1.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4)  <span class="comment">// Promise &#123;&lt;rejected&gt;: Error: error&#125;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.im/post/6886247841686093837#heading-9">深入理解Promise</a></p><h3 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h3><p>想要了解异步迭代器最好的方式就是和同步迭代器进行对比。我们知道可迭代数据的内部都是有一个 <code>Symbol.iterator</code> 属性，它是一个函数，执行后会返回一个迭代器对象，这个迭代器对象有一个 <code>next()</code> 方法可以对数据进行迭代，<code>next()</code> 执行后会返回一个对象，包含了当前迭代值 <code>value</code> 和 标识是否完成迭代的 <code>done</code> 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = [<span class="number">1</span>, <span class="number">2</span>][<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: undefinde, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面这里的 <code>next()</code> 执行的是同步操作，所以这个是同步迭代器，但是如果 <code>next()</code> 里需要执行异步操作，那就需要异步迭代了，可异步迭代数据的内部有一个 <code>Symbol.asyncIterator</code> 属性，基于此我们来实现一个异步迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(iterable) &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = iterable</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">        <span class="keyword">let</span> length = <span class="built_in">this</span>.data.length,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> done = index &gt;= length</span><br><span class="line">                <span class="keyword">const</span> value = !done ? <span class="built_in">this</span>.data[index++] : <span class="literal">undefined</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    resolve(&#123;value, done&#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步迭代器的 <code>next()</code> 会进行异步的操作，通常是返回一个 <code>Promise</code>，所以需要对应的处理函数去处理结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> asyncIterator = emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">asyncIterator.next().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line">asyncIterator.next().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line">asyncIterator.next().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>另外也可以使用 <code>for await...of</code> 来迭代异步可迭代数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> asyncIterable = <span class="keyword">new</span> Emitter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> asyncIterable ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount()</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>另外还可以通过异步生成器来创建异步迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(iterable) &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = iterable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">        <span class="keyword">let</span> length = <span class="built_in">this</span>.data.length,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> (index &lt; length) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.data[index++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">const</span> asyncIterable = emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> asyncIterable ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount()</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration_protocols</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for-await...of">for-await…of</a></li></ul><h3 id="s修饰符-dotAll模式"><a href="#s修饰符-dotAll模式" class="headerlink" title="s修饰符(dotAll模式)"></a>s修饰符(dotAll模式)</h3><p>正则表达式新增了一个 <code>s</code> 修饰符，使得 <code>.</code> 可以匹配任意单个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/.test(<span class="string">&#x27;foo\nbar&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">/foo.bar/s.test(<span class="string">&#x27;foo\nbar&#x27;</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面这又被称为 <code>dotAll</code> 模式，表示点（<code>dot</code>）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/s.dotAll  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="具名组匹配"><a href="#具名组匹配" class="headerlink" title="具名组匹配"></a>具名组匹配</h3><p>正则表达式可以使用捕获组来匹配字符串，但是想要获取某个组的结果只能通过对应的索引来获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> result = re.exec(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="comment">// result[0] === &#x27;2015-01-02&#x27;</span></span><br><span class="line"><span class="comment">// result[1] === &#x27;2015&#x27;</span></span><br><span class="line"><span class="comment">// result[2] === &#x27;01&#x27;</span></span><br><span class="line"><span class="comment">// result[3] === &#x27;02&#x27;</span></span><br></pre></td></tr></table></figure><p>而现在我们可以通过给捕获组 <code>(?&lt;name&gt;...)</code> 加上名字 <code>name</code> ，通过名字来获取对应组的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> result = re.exec(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="comment">// result.groups.year === &#x27;2015&#x27;</span></span><br><span class="line"><span class="comment">// result.groups.month === &#x27;01&#x27;</span></span><br><span class="line"><span class="comment">// result.groups.day === &#x27;02&#x27;</span></span><br></pre></td></tr></table></figure><p>配合解构赋值可以写出非常精简的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;year, month, day&#125;&#125; = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>.exec(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(year, month, day)  <span class="comment">// 2015 01 02</span></span><br></pre></td></tr></table></figure><p>具名组也可以通过传递给 <code>String.prototype.replace</code> 的替换值中进行引用。如果该值为字符串，则可以使用 <code>$&lt;name&gt;</code> 获取到对应组的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">&#x27;2015-01-02&#x27;</span>.replace(re, <span class="string">&#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// result === &#x27;02/01/2015&#x27;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/tc39/proposal-regexp-named-groups">proposal-regexp-named-groups</a></p><h3 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h3><p>后行断言： <code>(?&lt;=y)x</code>，<code>x</code> 只有在 <code>y</code> 后面才能匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=\$)\d+<span class="regexp">/.exec(&#x27;I have $100.&#x27;)  /</span><span class="regexp">/ [&#x27;100&#x27;]</span></span><br></pre></td></tr></table></figure><p>后行否定断言： <code>(?&lt;!y)x</code>，<code>x</code> 只有不在 <code>y</code> 后面才能匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;!\$)\d+<span class="regexp">/.exec(&#x27;I have $100.&#x27;)  /</span><span class="regexp">/ [&#x27;00&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="Unicode属性转义"><a href="#Unicode属性转义" class="headerlink" title="Unicode属性转义"></a>Unicode属性转义</h3><p>允许正则表达式匹配符合 <code>Unicode</code> 某种属性的所有字符，<code>\p&#123;...&#125;</code> 是匹配包含，<code>\P&#123;...&#125;</code> 是匹配不包含的字符，且必须搭配 <code>/u</code> 修饰符才会生效：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\p&#123;Emoji&#125;+<span class="regexp">/u.exec(&#x27;😁😭笑死我了🤣😂不行了&#x27;)  /</span><span class="regexp">/ [&#x27;😁😭&#x27;]</span></span><br><span class="line"><span class="regexp">/</span>\P&#123;Emoji&#125;+<span class="regexp">/u.exec(&#x27;😁😭笑死我了🤣😂不行了&#x27;)  /</span><span class="regexp">/ [&#x27;笑死我了&#x27;]</span></span><br></pre></td></tr></table></figure><p>这里可以查询到更多的 <code>Unicode</code> 的属性 <a href="http://unicode.org/reports/tr18/#Full_Properties">Full_Properties</a></p><h3 id="对象扩展运算符"><a href="#对象扩展运算符" class="headerlink" title="对象扩展运算符"></a>对象扩展运算符</h3><p>对象的扩展运算符可以用到解构赋值上，且只能应用到最后一个变量上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x, ...y&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">// &#123;a: 2, b: 3&#125;</span></span><br></pre></td></tr></table></figure><p>对象扩展运算符不能解构原型上的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">obj.__proto__ = &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123;...a&#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(a.y)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>应用一：可以实现浅拷贝，但是不会拷贝原始属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(&#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;)</span><br><span class="line">person.age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝写法一</span></span><br><span class="line"><span class="keyword">let</span> &#123; ...pClone1 &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(pClone1)  <span class="comment">// &#123; age: 12 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(pClone1.name)  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝写法二</span></span><br><span class="line"><span class="keyword">let</span> pClone2 = &#123;...person&#125;</span><br><span class="line"><span class="built_in">console</span>.log(pClone2)  <span class="comment">// &#123; age: 12 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(pClone2.name)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>应用二：合并两个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123;...a, ...b&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure><p>应用三：重写对象属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>应用四：给新对象设置默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;;</span><br></pre></td></tr></table></figure><p>应用五：利用扩展运算符的解构赋值可以扩展函数参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">    <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">    <span class="keyword">return</span> baseFunction(restConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md">Object Spread Initializer</a></li><li><a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Rest.md">Object Rest Destructuring</a></li></ul><h3 id="放松对标签模板里字符串转义的限制"><a href="#放松对标签模板里字符串转义的限制" class="headerlink" title="放松对标签模板里字符串转义的限制"></a>放松对标签模板里字符串转义的限制</h3><p><a href="https://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%99%90%E5%88%B6">ECMAScript 6 入门</a></p><h2 id="ES2019"><a href="#ES2019" class="headerlink" title="ES2019"></a>ES2019</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2019.png"></p><h3 id="允许省略catch里的参数"><a href="#允许省略catch里的参数" class="headerlink" title="允许省略catch里的参数"></a>允许省略catch里的参数</h3><p>异常被捕获的时候如果不需要做操作，甚至可以省略 <code>catch(err)</code> 里的参数和圆括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON-stringify-变动"><a href="#JSON-stringify-变动" class="headerlink" title="JSON.stringify()变动"></a>JSON.stringify()变动</h3><p><code>UTF-8</code> 标准规定，<code>0xD800</code> 到 <code>0xDFFF</code> 之间的码点，不能单独使用，必须配对使用。<br>所以 <code>JSON.stringify()</code> 对单个码点进行操作，如果码点符合 <code>UTF-8</code> 标准，则会返回对应的字符，否则会返回对应的码点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;1f600&#125;&#x27;</span>)  <span class="comment">// &quot;&quot;😀&quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;D834&#125;&#x27;</span>)  <span class="comment">// &quot;&quot;\ud834&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h3><p><code>Symbol</code> 实例新增了一个描述属性 <code>description</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">symbol.description  <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h3><p>函数的 <code>toString()</code> 会原样输出函数定义时候的样子，不会省略注释和空格。</p><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.fromEntries()</code> 方法是 <code>Object.entries()</code> 的逆操作，用于将一个键值对数组转为对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> keyValueArr = <span class="built_in">Object</span>.entries(person)   <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(arr)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>常用可迭代数据结构之间的装换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 -&gt; 键值对数组</span></span><br><span class="line"><span class="keyword">let</span> keyValueArr = <span class="built_in">Object</span>.entries(person)  <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对数组 -&gt; Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(keyValueArr)  <span class="comment">// Map &#123;&quot;name&quot;: &quot;布兰&quot;, &quot;age&quot;: 12&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map -&gt; 键值对数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(map)  <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对数组 -&gt; 对象</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Array</span>.from(arr).reduce(<span class="function">(<span class="params">acc, [ key, val ]</span>) =&gt;</span> <span class="built_in">Object</span>.assign(acc, &#123; [key]: val &#125;), &#123;&#125;)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/tc39/proposal-object-from-entries">Object.fromEntries</a></p><h3 id="字符串可直接输入行分隔符和段分隔符"><a href="#字符串可直接输入行分隔符和段分隔符" class="headerlink" title="字符串可直接输入行分隔符和段分隔符"></a>字符串可直接输入行分隔符和段分隔符</h3><p><code>JavaScript</code> 规定有 5 个字符，不能在字符串里面直接使用，只能使用转义形式。</p><ul><li><code>U+005C</code>：反斜杠（reverse solidus)</li><li><code>U+000D</code>：回车（carriage return）</li><li><code>U+2028</code>：行分隔符（line separator）</li><li><code>U+2029</code>：段分隔符（paragraph separator）</li><li><code>U+000A</code>：换行符（line feed）</li></ul><p>但是由于 <code>JSON</code> 允许字符串里可以使用 <code>U+2028</code> 和 <code>U+2029</code>，所以使得 <code>JSON.parse()</code> 去解析字符串的时候可能会报错，所以 <code>ES2019</code> 允许模板字符串里可以直接这两个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;\u2028&quot;&#x27;</span>)  <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;\u2029&quot;&#x27;</span>)  <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;\u005C&quot;&#x27;</span>)  <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-trimStart"><a href="#String-prototype-trimStart" class="headerlink" title="String.prototype.trimStart"></a>String.prototype.trimStart</h3><p>消除字符串头部空格，返回一个新字符串；浏览器还额外增加了它的别名函数 <code>trimLeft()</code>： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;  hello world &#x27;</span></span><br><span class="line"><span class="keyword">let</span> newStr = str.trimStart()</span><br><span class="line"><span class="built_in">console</span>.log(newStr, newStr === str) </span><br><span class="line"><span class="comment">// &#x27;hello world &#x27;  false</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-trimEnd"><a href="#String-prototype-trimEnd" class="headerlink" title="String.prototype.trimEnd"></a>String.prototype.trimEnd</h3><p>消除字符串尾部空格，返回一个新字符串；浏览器还额外增加了它的别名函数 <code>trimRight()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;  hello world &#x27;</span></span><br><span class="line"><span class="keyword">let</span> newStr = str.trimEnd()</span><br><span class="line"><span class="built_in">console</span>.log(newStr, newStr === str) </span><br><span class="line"><span class="comment">// &#x27;  hello world&#x27;  false</span></span><br></pre></td></tr></table></figure><h3 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h3><p><code>arr.flat(depth)</code> 按照 <code>depth</code> （不传值的话默认是 1）深度拍平一个数组，并且将结果以新数组形式返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// depth 默认是 1</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.flat())  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Infinity，可展开任意深度的嵌套数组；自动跳过空数组；</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, , [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr2.flat(<span class="literal">Infinity</span>))</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>用 <code>reduce</code> 实现拍平一层数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> newStr = arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.concat(cur), [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> flattened = <span class="function"><span class="params">arr</span> =&gt;</span> [].concat(...arr)</span><br><span class="line">flattened(arr)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">flat</a></p><h3 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h3><p><code>flatMap(callback)</code> 使用映射函数 <code>callback</code> 映射每个元素，<code>callback</code> 每次的返回值组成一个数组，并且将这个数组执行类似 <code>arr.flat(1)</code> 的操作进行拍平一层后最后返回结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// 将 [[2], [4], [6], [8]] 数组拍平一层得到最终结果：[2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap">flatMap</a></p><h2 id="ES2020"><a href="#ES2020" class="headerlink" title="ES2020"></a>ES2020</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2020.png"></p><h3 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll()"></a>String.prototype.matchAll()</h3><p><code>String.prototype.matchAll()</code> 方法，可以一次性取出所有匹配。不过，它返回的是一个 <code>RegExpStringIterator</code> 迭代器同是也是一个可迭代的数据结构，所以可以通过 <code>for...of</code> 进行迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;test1test2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span></span><br><span class="line"><span class="keyword">let</span> iterable = str.matchAll(regexp)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;test1&#x27;, &#x27;e&#x27;, &#x27;st1&#x27;, &#x27;1&#x27;, index: 0, input: &#x27;test1test1&#x27;, groups: undefined]</span></span><br><span class="line"><span class="comment">// [&#x27;test2&#x27;, &#x27;e&#x27;, &#x27;st2&#x27;, &#x27;2&#x27;, index: 5, input: &#x27;test1test2&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意当使用 matchAll(regexp) 的时候，正则表达式必须加上 /g 修饰符。</p></blockquote><p>也可以将这个可迭代数据转成数组形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">[...str.matchAll(regexp)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="built_in">Array</span>.from(str.matchAll(regexp))</span><br></pre></td></tr></table></figure><h3 id="动态import"><a href="#动态import" class="headerlink" title="动态import()"></a>动态import()</h3><p>标准用法的 <code>import</code> 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。</p><p>比如按需加载一个模块可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xxx) &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./module.js&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>import()</code> 是异步导入的，结果会返回一个 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;/module.js&#x27;</span>)</span><br><span class="line">.then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Do something with the module.</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>动态 <code>import()</code> 的应用场景挺多的，比如 <code>Vue</code> 中的路由懒加载就是使用的动态导入组件。另外由于动态性不便于静态分析工具和 <code>tree-shaking</code> 工作，所以不能滥用。</p><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p><code>BigInt</code> 是一种内置对象，它提供了一种方法来表示大于 $2^{53}$ - 1 的整数。这原本是 <code>Javascript</code> 中可以用 <code>Number</code> 表示的最大数字。<code>BigInt</code> 可以表示任意大的整数。</p><p>为了区分 <code>Number</code>，定义一个 <code>BigInt</code> 需要在整数后面加上一个 <code>n</code>，或者用函数直接定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = <span class="number">10n</span></span><br><span class="line"><span class="keyword">const</span> num2 = BigInt(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><code>Number</code> 和 <code>BigInt</code> 之间能进行比较，但他们之间是宽松相等；且由于他们表示的是不同类型的数字，所以不能直接进行四则运算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10n</span> == <span class="number">10</span>         <span class="comment">// true</span></span><br><span class="line"><span class="number">10n</span> === <span class="number">10</span>        <span class="comment">// false</span></span><br><span class="line"><span class="number">10n</span> &gt; <span class="number">8</span>           <span class="comment">// true</span></span><br><span class="line"><span class="number">10</span> + <span class="built_in">Number</span>(<span class="number">10n</span>)  <span class="comment">// 20</span></span><br><span class="line"><span class="number">10</span> + <span class="number">10n</span>          <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p><code>Promise.allSettled(iterable)</code> 当所有的实例都已经 <code>settled</code>，即状态变化过了，那么将返回一个新实例，该新实例的内部值是由所有实例的值和状态组合成的数组，数组的每项是由每个实例的状态和内部值组成的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.allSettled([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">9</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="number">6</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    init()</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: undefined&#125;, </span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, reason: 6&#125;, </span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 3&#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>只要所有实例中包含一个 <code>pending</code> 状态的实例，那么 <code>Promise.allSettled()</code> 的结果为返回一个这样 <code>Promise &#123;&lt;pending&gt;&#125;</code> 的实例。</p><h3 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h3><p>在以前，从不同的 <code>JavaScript</code> 环境中获取全局对象需要不同的语句。在 <code>Web</code> 中，可以通过 <code>window</code>、<code>self</code> 或者 <code>frames</code> 取到全局对象，但是在 <code>Web Workers</code> 中，只有 <code>self</code> 可以。在 <code>Node.js</code> 中，它们都无法获取，必须使用 <code>global</code>。</p><p>而现在只需要使用 <code>globalThis</code> 即可获取到顶层对象，而不用担心环境问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line">globalThis === <span class="built_in">window</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="import-meta"><a href="#import-meta" class="headerlink" title="import.meta"></a>import.meta</h3><p><code>import.meta</code> 是一个给 <code>JavaScript</code> 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 <code>URL</code>，<code>import.meta</code> 必须在一个模块里使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有声明 type=&quot;module&quot;，就使用 import.meta 会报错</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;./js/module.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在module.js里</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">import</span>.meta)  </span><br><span class="line"><span class="comment">// &#123;url: &quot;http://localhost/3ag/js/module.js&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>如果需要在配置了 <code>Webpack</code> 的项目，比如 <code>Vue</code> 里使用 <code>import.meta</code> 需要加一个包且配置一下参数，否则项目编译阶段会报错。</p><p>包配置详情参考：<a href="https://www.npmjs.com/package/@open-wc/webpack-import-meta-loader">@open-wc/webpack-import-meta-loader</a></p><p>比如我用的是 <code>4.x</code> 版本的 <code>vue-cli</code>，那我需要在 <code>vue.config.js</code> 里配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        config.module</span><br><span class="line">            .rule(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">            .test(<span class="regexp">/\.js$/</span>)</span><br><span class="line">            .use(<span class="string">&#x27;@open-wc/webpack-import-meta-loader&#x27;</span>)</span><br><span class="line">                .loader(<span class="string">&#x27;@open-wc/webpack-import-meta-loader&#x27;</span>)</span><br><span class="line">                .end()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选链操作符（-）"><a href="#可选链操作符（-）" class="headerlink" title="可选链操作符（?.）"></a>可选链操作符（?.）</h3><p>通常我们获取一个深层对象的属性会需要写很多判断或者使用逻辑与 <code>&amp;&amp;</code> 操作符，因为对象的某个属性如果为 <code>null</code> 或者 <code>undefined</code> 就有可能报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    first: &#123;</span><br><span class="line">        second: <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> name1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.first) &#123;</span><br><span class="line">        name1 = obj.first.second</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> name2 = obj &amp;&amp; obj.first &amp;&amp; obj.first.second</span><br></pre></td></tr></table></figure><p><code>?.</code> 操作符允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。如果某个属性为 <code>null</code> 或者 <code>undefined</code> 则结果直接为 <code>undefined</code>。有了可选链操作符就可以使得表达式更加简明了，对于上面例子用可选链操作符可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name3 = obj?.first?.second</span><br></pre></td></tr></table></figure><h3 id="空值合并操作符（-）"><a href="#空值合并操作符（-）" class="headerlink" title="空值合并操作符（??）"></a>空值合并操作符（??）</h3><p>对于逻辑或 <code>||</code> 运算符，当对运算符左侧的操作数进行装换为 <code>Boolean</code> 值的时候，如果为 <code>true</code>，则取左边的操作数为结果，否则取右边的操作数为结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(name)  <span class="comment">// &#x27;布兰&#x27;</span></span><br></pre></td></tr></table></figure><p>我们都知道 <code>&#39;&#39;</code>、<code>0</code>、<code>null</code>、<code>undefined</code>、<code>false</code>、<code>NaN</code> 等转成 <code>Boolean</code> 值的时候都是 <code>false</code>，所以都会取右边的操作数。这个时候如果要给变量设置默认值，如果遇到本身值就可能是 <code>&#39;&#39;</code> 或 <code>0</code> 的情况那就会出错了，会被错误的设置为默认值了。</p><p>而 <code>??</code> 操作符就是为了解决这个问题而出现的，<code>x ?? y</code> 只有左侧的操作数为 <code>null</code> 或 <code>undefined</code> 的时候才取右侧操作数，否则取左侧操作数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span> ?? <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(num)  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="ES2021"><a href="#ES2021" class="headerlink" title="ES2021"></a>ES2021</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2021.png"></p><p>如下这几个提案已经确定了会在 2021 年发布，所以把他们归到 <code>ES2021</code> 中。</p><h3 id="String-prototype-replaceAll"><a href="#String-prototype-replaceAll" class="headerlink" title="String.prototype.replaceAll"></a>String.prototype.replaceAll</h3><p>之前需要替换一个字符串里的全部匹配字符可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = <span class="string">&#x27;q=query+string+parameters&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">const</span> withSpaces1 = queryString.replace(<span class="regexp">/\+/g</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> withSpaces2 = queryString.split(<span class="string">&#x27;+&#x27;</span>).join(<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>而现在只需要这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withSpace3 = queryString.replaceAll(<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>replaceAll 的第一个参数可以是字符串也可以是正则表达式，当是正则表达式的时候，必须加上全局修饰符 /g，否则报错。</p></blockquote><p>参考：<a href="https://github.com/tc39/proposal-string-replaceall">string-replaceall</a></p><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h3><p><code>Promsie.any()</code> 和 <code>Promise.all()</code> 一样接受一个可迭代的对象，然后依据不同的入参会返回不同的新实例：</p><ul><li><p>传一个空的可迭代对象或者可迭代对象所有 <code>Promise</code> 都是 <code>rejected</code> 状态的，则会抛出一个 <code>AggregateError</code> 类型的错误，同时返回一个 <code>rejected</code> 状态的新实例：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.any([])</span><br><span class="line"><span class="keyword">let</span> p2.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;rejected&gt;: AggregateError: All promises were rejected&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>只要可迭代对象里包含任何一个 <code>fulfilled</code> 状态的 <code>Promise</code>，则会返回第一个 <code>fulfilled</code> 的实例，并且以它的值作为新实例的值：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.any([</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line">])</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>其他情况下，都会返回一个 <code>pending</code> 状态的实例：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.any([</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">2</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">3</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;),</span><br><span class="line">])</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;pending&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="WeakRef"><a href="#WeakRef" class="headerlink" title="WeakRef"></a>WeakRef</h3><p>我们知道一个普通的引用（默认是强引用）会将与之对应的对象保存在内存中。只有当该对象没有任何的强引用时，<code>JavaScript</code> 引擎 <code>GC</code> 才会销毁该对象并且回收该对象所占的内存空间。</p><p><code>WeakRef</code> 对象允许你保留对另一个对象的弱引用，而不会阻止被弱引用的对象被 <code>GC</code> 回收。<code>WeakRef</code> 的实例方法 <code>deref()</code> 可以返回当前实例的 <code>WeakRef</code> 对象所绑定的 <code>target</code> 对象，如果该 <code>target</code> 对象已被 <code>GC</code> 回收则返回 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> wr = <span class="keyword">new</span> WeakRef(person)</span><br><span class="line"><span class="built_in">console</span>.log(wr.deref())  </span><br><span class="line"><span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>正确使用 WeakRef 对象需要仔细的考虑，最好尽量避免使用。这里面有诸多原因，比如：GC 在一个 JavaScript 引擎中的行为有可能在另一个 JavaScript 引擎中的行为大相径庭，或者甚至在同一类引擎，不同版本中 GC 的行为都有可能有较大的差距。GC 目前还是 JavaScript 引擎实现者不断改进和改进解决方案的一个难题。</p></blockquote><p>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef">WeakRef</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">内存管理</a></li></ul><h3 id="逻辑赋值符"><a href="#逻辑赋值符" class="headerlink" title="逻辑赋值符"></a>逻辑赋值符</h3><p>逻辑赋值符包含 3 个：</p><ul><li><code>x &amp;&amp;= y</code>：逻辑与赋值符，相当于 <code>x &amp;&amp; (x = y)</code></li><li><code>x ||= y</code>：逻辑或赋值符，相当于 <code>x || (x = y)</code></li><li><code>x ??= y</code>：逻辑空赋值符，相当于 <code>x ?? (x = y)</code></li></ul><p>看如下示例，加深理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line">x &amp;&amp;= <span class="number">1</span>  <span class="comment">// x: 0</span></span><br><span class="line">x ||= <span class="number">1</span>  <span class="comment">// x: 1</span></span><br><span class="line">x ??= <span class="number">2</span>  <span class="comment">// x: 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">1</span></span><br><span class="line">y &amp;&amp;= <span class="number">0</span>     <span class="comment">// y: 0</span></span><br><span class="line">y ||= <span class="literal">null</span>  <span class="comment">// y: null</span></span><br><span class="line">y ??= <span class="number">2</span>     <span class="comment">// y: 2</span></span><br></pre></td></tr></table></figure><h3 id="数值分隔符（-）"><a href="#数值分隔符（-）" class="headerlink" title="数值分隔符（_）"></a>数值分隔符（_）</h3><p>对于下面一串数字，你一眼看上去不确定它到底是多少吧？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1000000000</span></span><br></pre></td></tr></table></figure><p>那现在呢？是不是可以很清楚的看出来它是 10 亿：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1</span>_000_000_000</span><br></pre></td></tr></table></figure><p>数值分隔符（<code>_</code>）的作用就是为了让数值的可读性更强。除了能用于十进制，还可以用于二级制，十六进制甚至是 <code>BigInt</code> 类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> binarary = <span class="number">0b1010</span>_0001_1000_0101</span><br><span class="line"><span class="keyword">let</span> hex = <span class="number">0xA0</span>_B0_C0</span><br><span class="line"><span class="keyword">let</span> budget = <span class="number">1</span>_000_000_000_000n</span><br></pre></td></tr></table></figure><p>使用时必须注意 <code>_</code> 的两边必须要有类型的数值，否则会报错，以下这些都是无效的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>_</span><br><span class="line"><span class="keyword">let</span> binarary = <span class="number">0b1011</span>_</span><br><span class="line"><span class="keyword">let</span> hex = <span class="number">0</span>x_0A0B</span><br><span class="line"><span class="keyword">let</span> budget = <span class="number">1</span>_n</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://es6.ruanyifeng.com/">ECMAScript6入门</a></li><li><a href="https://juejin.im/post/6844903959283367950">1.5万字概括ES6全部特性(已更新ES2020)</a></li><li><a href="https://juejin.im/post/6844903775329583112">近一万字的ES6语法知识点补充</a></li><li><a href="https://juejin.im/post/6886247841686093837#heading-9">深入理解Promise</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for-await...of">for-await…of</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration_protocols</a></li><li><a href="https://github.com/tc39/proposal-object-from-entries">Object.fromEntries</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef">WeakRef</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">内存管理</a></li><li><a href="https://github.com/doodlewind/jshistory-cn">jshistory-cn</a></li><li><a href="https://tc39.es/ecma262/#sec-samevaluezero">sameValueZero</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Promise</title>
      <link href="/2020/10/22/promise/"/>
      <url>/2020/10/22/promise/</url>
      
        <content type="html"><![CDATA[<h2 id="从异步编程说起"><a href="#从异步编程说起" class="headerlink" title="从异步编程说起"></a>从异步编程说起</h2><p>我们都知道 <code>JavaScript</code> 的代码执行的时候是跑在单线程上的，可以理解为只能按照代码的出现顺序，从上到下一行一行的执行，但是遇到了异步的行为，比如定时器（一定时间之后才去执行），那就需要等同步代码执行完成后的一段时间里再去执行异步代码。</p><p>对于同步行为，如下面的代码，我们能够很清楚的知道每一行会发生什么，这是因为后面的指令总是等到前面的指令执行完成后才去执行，所以这里的第二行里的变量 <code>x</code> 在内存里已经是定义过的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y = x + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>但是对于异步代码，我们就不好推断到底什么时候会执行完成了。比如举一个实际的例子，我们去动态加载某个脚本，会这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = src</span><br><span class="line">    <span class="built_in">document</span>.head.append(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个脚本加载完成的时候会去执行定义在脚本里的一些函数，比如初始化函数 <code>init</code>，那么我们可以会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = src</span><br><span class="line">    <span class="built_in">document</span>.head.append(script)</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">&#x27;./js/script.js&#x27;</span>)</span><br><span class="line">init()  <span class="comment">// 定义在 ./js/script.js 里的函数</span></span><br></pre></td></tr></table></figure><p>但是实际执行后却发现，这样根本不行，因为加载脚本是需要花时间的，是一个异步的行为，浏览器执行 <code>JavaScript</code> 的时候并不会等到脚本加载完成的时候再去调用 <code>init</code> 函数。</p><p>以往，对于这种异步编程的做法通常就是通过给函数传递一个回调函数来处理，上面那个例子可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, success, fail</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = src</span><br><span class="line">    script.onload = success</span><br><span class="line">    script.onerror = fail</span><br><span class="line">    <span class="built_in">document</span>.head.append(script)</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">&#x27;./js/script.js&#x27;</span>, success, fail)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    init()  <span class="comment">// 定义在 ./js/script.js 中的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这样做能够保证在脚本加载完成的时候，再去执行脚本里的函数。但是多考虑一个问题，如果 <code>success</code> 里又需要加载别的 <code>js</code> 文件呢，那岂不是需要多层嵌套了。是的，这样的多层嵌套会使得代码层次变得更加深入，难以阅读以及后期维护成本非常高，尤其是当里面加上了很多的判断逻辑的时候情况会更加糟糕，这就是所谓的 “回调地狱”，且又因为它的代码形状很像躺着的金字塔，所以有的人也喜欢叫它 “噩运金字塔”。</p><p>而为了避免这类 “回调地狱” 问题，目前最好的做法之一就是使用 <code>Promise</code>。</p><h2 id="Promise正篇"><a href="#Promise正篇" class="headerlink" title="Promise正篇"></a>Promise正篇</h2><p>使用 <code>Promise</code> 可以很好的解决上面提到的 “回调地狱” 问题，直接来看结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.src = src;</span><br><span class="line">        script.onload = <span class="function">() =&gt;</span> resolve(script);</span><br><span class="line">        script.onerror = <span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error for <span class="subst">$&#123;src&#125;</span>`</span>));</span><br><span class="line">        <span class="built_in">document</span>.head.append(script);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">&#x27;./scripts.js&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>, res);</span><br><span class="line">    init()</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里通过使用 <code>Promise</code> 实例的 <code>then</code> 和 <code>catch</code> 函数将多层嵌套的代码改成了同步处理流程，看起来效果还是不错的，那什么是 <code>Promise</code> 呢？</p><p><code>Promise</code> 首先是一个对象，它通常用于描述现在开始执行，一段时间后才能获得结果的行为（异步行为），内部保存了该异步行为的结果。然后，它还是一个有状态的对象：</p><ul><li><code>pending</code>：待定</li><li><code>fulfilled</code>：兑现，有时候也叫解决（<code>resolved</code>）</li><li><code>rejected</code>：拒绝</li></ul><p>一个 <code>Promise</code> 只有这 3 种状态，且状态的转换过程有且仅有 2 种：</p><ul><li><code>pending</code> 到 <code>fulfilled</code></li><li><code>pending</code> 到 <code>rejected</code></li></ul><p>可以通过如下的 <code>Promise</code> 对象构造器来创建一个 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>传递给 <code>new Promise</code> 的是 <code>executor</code> 执行器。当 <code>Promise</code> 被创建的时候，<code>executor</code> 会立即同步执行。<code>executor</code> 函数里通常做了 2 件事情：初始化一个异步行为和控制状态的最终转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上代码所示，<code>setTimeout</code> 函数用来描述一个异步行为，而 <code>resolve</code> 用来改变状态。<br><code>executor</code> 函数包含 2 个参数，他们都是回调函数，用于控制 <code>Promise</code> 的状态转换：</p><ul><li><code>resolve</code>：用来将状态 <code>pending</code> 转换成 <code>fulfilled</code></li><li><code>reject</code>：用来将状态 <code>pending</code> 转换成 <code>rejected</code></li></ul><p>一个 <code>Promise</code> 的状态一旦被转换过，则无法再变更：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;第一次 resolve&#x27;</span>)</span><br><span class="line">        resolve(<span class="string">&#x27;第二次 resolve&#x27;</span>)  <span class="comment">// 将被忽略</span></span><br><span class="line">        reject(<span class="string">&#x27;第一次 reject&#x27;</span>)  <span class="comment">// 将被忽略</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">1000</span>, p)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: &quot;第一次 resolve&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到执行了 2 次 <code>resolve</code> 函数和 1 次 <code>reject</code> 函数，但是 <code>promise</code> 的最终结果是取的第一次 <code>resolve</code> 的结果，印证了上面的结论。</p><p>由 <code>new Promise</code> 构造器返回的 <code>Promise</code> 对象具有如下内部属性：</p><ul><li><code>PromiseState</code>：最初是 <code>pending</code>，<code>resolve</code> 被调用的时候变为 <code>fulfilled</code>，或者 <code>reject</code> 被调用时会变为 <code>rejected</code>；</li><li><code>PromiseResult</code>：最初是 <code>undefined</code>，<code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li></ul><p>比如上面例子中打印出来的 <code>Promise</code> 对象结果中，<code>fulfilled</code> 是其内部的 <code>PromiseState</code>，而 “第一次 resolve” 是其 <code>PromiseResult</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: &quot;第一次 resolve&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Promise实例方法"><a href="#Promise实例方法" class="headerlink" title="Promise实例方法"></a>Promise实例方法</h2><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p><code>Promise.prototype.then()</code> 将用于为 <code>Promise</code> 实例添加处理程序的函数。它接受 2 个可选的参数：</p><ul><li><code>onResolved</code>：状态由 <code>pending</code> 转换成 <code>fulfilled</code> 时执行；</li><li><code>onRejected</code>：状态由 <code>pending</code> 转换成 <code>rejected</code> 时执行。</li></ul><p>它可以写成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span> + res)  <span class="comment">// resolved3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span> + err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;).then(onResolved, onRejected)</span><br></pre></td></tr></table></figure><p>或者写成更简单的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span> + res)  <span class="comment">// resolved3</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span> + err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为状态的变化只有 2 种，所以 <code>onResolved</code> 和 <code>onRejected</code> 在执行的时候必定是互斥。</p><p>上面介绍到了 <code>then()</code> 的参数是可选的，当只有 <code>onResolved</code> 的时候可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>当参数只有 <code>onRejected</code> 的时候，需要把第一个参数设置为 <code>null</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).then(<span class="literal">null</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>如果给 <code>then()</code> 函数传递来了非函数参数，则会默认忽略。</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><code>Promise.prototype.catch()</code> 用于给 <code>Promise</code> 对象添加拒绝处理程序。只接受一个参数：<code>onRejected</code> 函数。实际上，下面这两种写法是等效的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).catch(onRejected)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).then(<span class="literal">null</span>, onRejected)</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>Promise.prototype.finally()</code> 用于给 <code>Promise</code> 对象添加 <code>onFinally</code> 函数，这个函数主要是做一些清理的工作，只有状态变化的时候才会执行该 <code>onFinally</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">888</span>)  <span class="comment">// 并不会执行  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;).finally(onFinally)</span><br></pre></td></tr></table></figure><p>因为 <code>onFinally</code> 函数是没有任何参数的，所以在其内部其实并不知道该 <code>Promise</code> 的状态是怎么样的。</p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>链式调用里涉及到的知识点很多，我们不妨先看看下面这道题，你能正确输出其打印顺序嘛？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我不给出答案，希望你能动手敲一敲代码，然后思考下为什么？容我讲完这部分知识，相信你能自己理解其中缘由。</p><p>从上面这串代码里，我们看到 <code>new Promise</code> 后面接了很多的 <code>.then()</code> 处理程序，这个其实就是 <code>Promise</code> 的链式调用，那它为什么能链式调用呢？</p><h3 id="基于onResolved生成一个新的Promise"><a href="#基于onResolved生成一个新的Promise" class="headerlink" title="基于onResolved生成一个新的Promise"></a>基于onResolved生成一个新的Promise</h3><p>因为 <code>Promise.prototype.then()</code> 会返回一个新的 <code>Promise</code>，来看下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function">() =&gt;</span> <span class="number">6</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 6&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>p1</code> 和 <code>p2</code> 的内部 <code>PromiseResult</code> 是不一样的，说明 <code>p2</code> 是一个新的 <code>Promise</code> 实例。 </p><p>新产生的 <code>Promise</code> 会基于 <code>onResolved</code> 的返回值进行构建，构建的时候其实是把返回值传递给 <code>Promise.resolve()</code> 生成的新实例，比如上面那串代码里 <code>p1.then(() =&gt; 6)</code> 这里的 <code>onResolved</code> 函数返回了一个 6 ，所以新的 <code>Promise</code> 的内部值会是 6。</p><p>如果 <code>.then()</code> 没有提供 <code>onResolved</code> 这个处理程序，则 <code>Promise.resolve()</code> 会基于上一个实例 <code>resolve</code> 后的值来初始化一个新的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>如果 <code>onResolved</code> 处理程序没有返回值，那么返回的新实例的内部值会是 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure><p>如果在 <code>onResolved</code> 处理程序里抛出异常，则会返回一个新的 <code>rejected</code> 状态的 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;rejected&gt;: 这是一个错误&#125;</span></span><br></pre></td></tr></table></figure><h3 id="基于onRejected生成一个新的Promise"><a href="#基于onRejected生成一个新的Promise" class="headerlink" title="基于onRejected生成一个新的Promise"></a>基于onRejected生成一个新的Promise</h3><p>基于 <code>onRejected</code> 的返回值也会返回一个新的 <code>Promise</code>，而且处理逻辑也是一样的，也是通过把返回值传递给 <code>Promise.resolve()</code> 产生一个新的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 `onRejected` 处理程序时，会原样向后传，不过是新实例</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function">() =&gt;</span> &#123;&#125;)  s</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;rejected&gt;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为undefined时</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;&#125;) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值有实际值的时候</span></span><br><span class="line"><span class="keyword">let</span> p4 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="number">6</span>) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当返回值是Promise时，会保留当前Promise</span></span><br><span class="line"><span class="keyword">let</span> p5 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject()) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p5)  <span class="comment">// Promise &#123;&lt;rejected&gt;: undefined&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当遇到一个错误的时候</span></span><br><span class="line"><span class="keyword">let</span> p6 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p6)  <span class="comment">// Promise &#123;&lt;rejected&gt;: error&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当返回值是一个错误时</span></span><br><span class="line"><span class="keyword">let</span> p7 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p7)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Error: error&#125; </span></span><br></pre></td></tr></table></figure><p>这里你会不会有个疑惑？实例 <code>resolve()</code> 的时候，状态由 <code>pending</code> 变成 <code>rejected</code>，从而调用 <code>onRejected</code> 进行处理，但是为什么有时候会返回一个 <code>fulfilled</code> 的新实例呢？试着想一下，如果 <code>onRejected</code> 返回了一个 <code>pending</code> 的或者 <code>rejected</code> 状态的新实例，那后续的链式调用就进行不下去了，看下面例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果 A 处理函数这里返回了一个 <code>pending</code> 状态的新实例，那么后续所有的链式操作都无法执行；或者返回的是一个 <code>rejected</code> 状态的新实例，那么后续的 B 和 C 也就无法执行了，那居然都不能执行 B 和 C 所在处理程序，那定义来干嘛呢？链式操作就毫无链式可言。又，<code>onRejected</code> 的存在的根本意义无非就是用于捕获 <code>Promise</code> 产生的错误，从而不影响程序的正常执行，所以默认情况下理应返回一个 <code>fulfilled</code> 的新实例。</p><p><code>Promise.prototype.catch()</code> 也会生成一个新的 <code>Promise</code>，其生成规则和 <code>onRejected</code> 是一样的。</p><h3 id="finally生成一个新的Promise"><a href="#finally生成一个新的Promise" class="headerlink" title="finally生成一个新的Promise"></a>finally生成一个新的Promise</h3><p>没想到吧，<code>Promise.prototype.finally()</code> 也能生成一个 <code>Promise</code>。<code>finally</code> 里的操作是和状态无关的，一般用来做后续代码的处理工作，所以 <code>finally</code> 一般会原样后传父 <code>Promise</code>，无论父级实例是什么状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = p3.finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>上面说的是一般，但是也有特殊情况，比如 <code>finally</code> 里返回了一个非 <code>fulfilled</code> 的 <code>Promise</code> 或者抛出了异常的时候，则会返回对应状态的新实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3)  <span class="comment">// Promise &#123;&lt;rejected&gt;: 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = p1.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4)  <span class="comment">// Promise &#123;&lt;rejected&gt;: Error: error&#125;</span></span><br></pre></td></tr></table></figure><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>先来看一段简单的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"><span class="comment">// 打印结果：A B D C</span></span><br></pre></td></tr></table></figure><p>上面这串代码的输出顺序是：A B D C。从上面章节介绍的知识点我们知道，<code>executor</code> 执行器会在 <code>new Promise</code> 调用的时候立即同步执行的，所以先后打印 A B 是没问题的。当执行 <code>resolve()/reject()</code> 的时候，会将 <code>Promise</code> 对应的处理程序推入微任务队列，稍等这里提到的对应的处理程序具体是指什么？</p><ul><li><code>resolve()</code> 对应 <code>.then()</code> 里的第一个入参，即 <code>onResolved</code> 函数；</li><li><code>reject()</code> 对应 <code>.then()</code> 里的第二个入参，即 <code>onRejected</code> 函数；或者 <code>Promise.prototype.catch()</code> 里的回调函数；</li></ul><p>所以当执行 <code>resolve(3)</code> 的时候（此时下面定义的这个箭头函数其实就是 <code>onResolved</code> 函数），<code>onResolved</code> 函数将被推入微任务队列，然后打印 D，此时所有同步任务执行完成，浏览器会去检查微任务队列，发现存在一个，所以最后会去调用 <code>onResolved</code> 函数，打印出 C。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onResolved = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实除了 <code>onResolved</code>、<code>onRejected</code> 以及 <code>Promise.prototype.catch()</code> 里的处理程序外，<code>Promise.prototype.finally()</code> 的处理程序 <code>onFinally</code> 也是异步执行的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment">// 打印结果：A C B</span></span><br></pre></td></tr></table></figure><p><code>Promise</code> 链式调用的基础就是因为 <code>onResolved</code>、<code>onRejected</code>、<code>catch()</code> 的处理程序以及 <code>onFinally</code> 会产生一个新的 <code>Promise</code> 实例，且又因为他们都是异步执行的，所以在链式调用的时候，对于它们执行顺序会稀里糊涂琢磨不透就是这个原因。</p><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p>那下面我们就来看点复杂的例子，先来分析下这章开篇提到的题目：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印结果：A </span></span><br></pre></td></tr></table></figure><p>为了方便分析，我们把上面的这串代码写得好看一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(executor).then(onResolvedA).then(onResolvedD)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(executor).then(onResolvedB).then(onResolvedC)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedD</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><ul><li>执行 <code>new Promise()</code>，立即同步执行 <code>executor</code> 函数，调用 <code>resolve()</code>，此时会将 <code>onResolvedA</code> 推入微任务队列 1，截止目前所有同步代码执行完成；</li><li>检查微任务队列，执行 <code>onResolvedA</code> 函数，打印 A，执行 <code>new Promise(executor)</code>，调用 <code>resolve()</code> 函数，此时将 <code>onResolvedB</code> 推入微任务队列 2；</li><li>截止目前微任务队列 1 的代码全部执行完成，即 <code>onResolvedA</code> 函数执行完成。我们知道 <code>onResolved</code> 函数会基于返回值生成一个新的 <code>Promise</code>，而 <code>onResolvedA</code> 函数没有显示的返回值，所以其返回值为 <code>undefined</code>，那么经过 <code>Promise.resolve(undefined)</code> 初始化后会生成一个这样的新实例：<code>Promise &#123;&lt;fulfilled&gt;: undefined&#125;</code>；由于这个新的实例状态已经变成 <code>fulfilled</code>，所以会立即将其处理函数 <code>onResolvedD</code> 推入微任务队列 3；</li><li>开始执行微任务队列 2 里的内容，打印 B，同上一条原理，由于 <code>onResolvedB</code> 函数的返回值为 <code>undefined</code>，所以生成了一个 <code>resolved</code> 的新实例，则会立即将 <code>onResolvedC</code> 推入微任务队列 4；</li><li>执行微任务队列 3，打印 D；</li><li>执行微任务队列 4，打印 C；</li><li>至此全部代码执行完成，最终的打印结果为：A B D C。</li></ul><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印结果：A C B D</span></span><br></pre></td></tr></table></figure><p>应该很多人会和我当初一样好奇：为什么打印结果不是 A B C D 呢？<br>这里涉及到一个知识点：如果给 <code>Promise</code> 实例添加了多个处理函数，当实例状态变化的时候，那么执行的过程就是按照添加时的顺序而执行的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(onResolvedA).finally(onFinally)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果： A B</span></span><br></pre></td></tr></table></figure><p>对于上面这串代码，其实 <code>finally()</code> 处理程序执行的时候已经不是通过 <code>new Promise()</code> 初始化的实例，而是执行完 <code>onResolvedA</code> 函数的时候生成的新实例，不信我们将上面代码中的函数 <code>onResolvedA</code> 稍微改动下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(onResolvedA).finally(onFinally)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果： A</span></span><br></pre></td></tr></table></figure><p>由于 <code>onResolvedA</code> 返回了一个这样的 <code>Promise &#123;&lt;pending&gt;&#125;</code> 新实例，这个新实例的状态没有发生变化，所以不会执行 <code>finally</code> 处理程序 <code>onFinally</code>，所以不会打印 B。这个就说明了，链式调用的时候处理程序的执行是一步一步来的，只要前面的执行完了，生成了新的实例，然后根据新实例的状态变化，才去执行后续的处理程序。</p><p>所以拿最开始那道题来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印结果：A C B D</span></span><br></pre></td></tr></table></figure><p>他的执行过程应该是这样的：</p><ul><li>执行 <code>resolve(1)</code>，将处理程序 A 推入微任务队列 1；</li><li>执行 <code>resolve(2)</code>，将处理程序 C 推入微任务队列 2；</li><li>同步任务执行完成，执行微任务队列 1 里的内容，打印 A，A 所在函数执行完成后生成了一个 <code>fulfilled</code> 的新实例，由于新实例状态变化，所以会立即执行 <code>finally()</code> 处理程序 B 推入微任务队列 3；</li><li>执行微任务队列 2 的内容，打印 C，C 所在函数执行完成后，同上条原理会将处理程序 D 推入微任务队列 4；</li><li>执行微任务队列 3 的内容，打印 B；</li><li>执行微任务队列 4 的内容，打印 D；</li><li>代码全部执行完成，最终打印：A C B D。</li></ul><p>题目就先做到这里，相信你和我一样，对 <code>Promise</code> 的执行过程应该有更深入的理解了。接下来我们将继续学习 <code>Promise</code> 的相关 <code>API</code>。</p><h2 id="Promise与错误处理"><a href="#Promise与错误处理" class="headerlink" title="Promise与错误处理"></a>Promise与错误处理</h2><p>平时我们写代码遇到错误，都习惯用 <code>try/catch</code> 块来处理，但是对于 <code>Promise</code> 产生的错误，用这个是处理不了的，看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    &#125;)  </span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// C </span></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error</span></span><br></pre></td></tr></table></figure><p>从执行结果我们可以看到，报错的信息出现在打印 C 之后，说明抛出错误这个动作是在异步任务中做的，所以 <code>catch</code> 捕获不到该错误就在情理之中了，否则就不会打印 C 了。可见，传统的 <code>try/catch</code> 语句并不能捕获 <code>Promise</code> 产生的错误，而需要使用 <code>onRejected</code> 处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)</span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// Error: error</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure><p><code>onRejected</code> 捕获了上面抛出的错误后，使得程序正常执行，最后还生成了一个 <code>fulfilled</code> 的新实例。</p><p>除了以上这种直接在 <code>executor</code> 里通过 <code>throw</code> 主动抛出一个错误外，还可以通过以下方式产出需要 <code>onRejected</code> 处理的错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    init() <span class="comment">// 被动出错，调用了不存在的函数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject())</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意，如果只是产生了一个错误，却没有抛出来是不会报错的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Error</span>())</span><br></pre></td></tr></table></figure><p><code>Promise</code> 出现了错误就需要使用 <code>onRejected</code> 处理程序处理，否则程序就会报错，执行不下去了。</p><h2 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h2><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>并非所有的 <code>Promise</code> 的初始状态都是 <code>pending</code>，可以通过 <code>Promise.resolve(value)</code> 来初始化一个状态为 <code>fulfilled</code>，值为 <code>value</code> 的 <code>Promise</code> 实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>这个操作和下面这种创建一个 <code>fulfilled</code> 的 <code>Promise</code> 在效果上是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>使用这个静态方法，理论上可以把任何一个值转换成 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve())  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>))  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125; 多余的参数将被忽略</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)))  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Error: error&#125;</span></span><br></pre></td></tr></table></figure><p>这个被转换的值甚至可以是一个 <code>Promise</code> 对象，如果是这样，<code>Promise.resolve</code> 会将其原样输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.resolve(p))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>和 <code>Promise.resolve()</code> 类似，<code>Promise.reject()</code> 会实例化一个 <code>rejected</code> 状态的 <code>Promise</code>，且会抛出一个错误，该错误只能通过拒绝处理程序捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span></span><br><span class="line">    .reject(<span class="number">3</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)  <span class="comment">// 3</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>对于初始化一个 <code>rejected</code> 状态的实例，以下两种写法都可以达到这个目的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject()</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject())</span><br></pre></td></tr></table></figure><p>与 <code>Promise.resolve()</code> 不同的是，如果给 <code>Promise.reject()</code> 传递一个 <code>Promise</code> 对象，则这个对象会成为新 <code>Promise</code> 的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.reject(p))  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><code>Promise.all(iterable)</code> 用来将多个 <code>Promise</code> 实例合成一个新实例。参数必须是一个可迭代对象，通常是数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">6</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>可迭代对象里的所有元素都会通过 <code>Promise.resolve()</code> 转成 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>所有 <code>Promise</code> 都 <code>resolve</code> 后，<code>Promise.all()</code> 才会生成一个 <code>fulfilled</code> 的新实例。且新实例的内部值是由所有 <code>Promise</code> 解决后的值组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;3&#x27;</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// [&quot;3&quot;, undefined, 6]</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: Array(3)&#125;</span></span><br></pre></td></tr></table></figure><p>所有 <code>Promise</code> 中，只要出现一个 <code>pending</code> 状态的实例，那么合成的新实例也是 <code>pending</code> 状态的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">])</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>所有 <code>Promise</code> 中，只要出现一个 <code>rejected</code> 状态的实例，那么合成的新实例也是 <code>rejected</code> 状态的，且新实例的内部值是第一个拒绝 <code>Promise</code> 的内部值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="number">9</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;rejected&gt;: 6&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><code>Promise.race(iterable)</code> 会返回一个由所有可迭代实例中第一个 <code>fulfilled</code> 或 <code>rejected</code> 的实例包装后的新实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">9</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>来将上面这串代码变动下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">9</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="number">6</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    init(),</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;rejected&gt;: 6&#125;</span></span><br></pre></td></tr></table></figure><p>想要知道 <code>Promise.race()</code> 的结果，无非是要知道到底谁才是第一个状态变化的实例，让我们来具体分析下代码执行过程：</p><ul><li>迭代第一个元素，执行同步代码 <code>resolve(9)</code>，由 <code>new Promise</code> 初始化的实例的状态已经变为了 <code>fulfilled</code>，所以第一个状态变化的实例已经出现了吗？其实并没有，因为迭代第一个元素的代码还没执行完成呢，然后会将 <code>return &#39;A&#39;</code> 所在函数的这段处理程序推入微任务队列 1；</li><li>迭代第二个元素，执行 <code>reject(6)</code>，所以由 <code>new Promise</code> 初始化的实例的状态已经变为 <code>rejected</code>，由于该实例没有处理函数，所以迭代第二个元素的代码已经全部执行完成，此时，第一个状态变化的实例已经产生；</li><li>迭代第三个元素，是一个函数，执行同步代码打印出 3，然后用 <code>Promise.resolve</code> 将函数返回值 3 转成一个 <code>Promise &#123;&lt;fulfilled&gt;: 3&#125;</code> 的新实例，这是第二个状态发生变化的实例；</li><li>此时所有迭代对象遍历完成，即同步代码执行完成，开始执行微任务队列 1 的内容，打印 <code>res</code>，其值是 9，然后处理程序返回了 ‘A’，此时根据之前提到的知识点，这里会新生成一个 <code>Promise &#123;&lt;fulfilled&gt;: &#39;A&#39;&#125;</code> 的实例，这是第三个状态发生变化的实例。此时，第一个迭代元素的代码已经全部执行完成，所以第一个迭代元素最终生成的实例是第三次状态发生变化的这个；</li><li>此时 <code>p1</code> 已经产生，它是 <code>Promise &#123;&lt;rejected&gt;: 6&#125;</code>，所以会将它的处理程序 <code>console.log(err)</code> 所在函数推入微任务队列 2；</li><li>执行微任务队列 2 的内容，打印 <code>err</code>，其值是 6；</li><li>所有微任务执行完成，开始执行 <code>setTimeout</code> 里的宏任务，打印 <code>p1</code>，至此全部代码执行完成。</li></ul><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h3><p><code>Promise.allSettled(iterable)</code> 当所有的实例都已经 <code>settled</code>，即状态变化过了，那么将返回一个新实例，该新实例的内部值是由所有实例的值和状态组合成的数组，数组的每项是由每个实例的状态和内部值组成的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.allSettled([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">9</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="number">6</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    init()</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: undefined&#125;, </span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, reason: 6&#125;, </span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 3&#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>只要所有实例中包含一个 <code>pending</code> 状态的实例，那么 <code>Promise.allSettled()</code> 的结果为返回一个这样 <code>Promise &#123;&lt;pending&gt;&#125;</code> 的实例。</p><blockquote><p>Promise.allSettled() 是 ES2020 中新增的方法，所以有一些浏览器可能还暂时不支持。</p></blockquote><p>对于不支持的浏览器，可以写 <code>polyfill</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Promise</span>.allSettled) &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises.map(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(p)</span><br><span class="line">            .then(<span class="function"><span class="params">value</span> =&gt;</span> (&#123;</span><br><span class="line">                status: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                value</span><br><span class="line">            &#125;), <span class="function"><span class="params">reason</span> =&gt;</span> (&#123;</span><br><span class="line">                status: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                reason</span><br><span class="line">            &#125;))</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详细设计一个文章页目录插件</title>
      <link href="/2020/10/14/article-catalog/"/>
      <url>/2020/10/14/article-catalog/</url>
      
        <content type="html"><![CDATA[<p>在说这个插件之前，可以先去 <a href="https://bubuzou.com/2020/09/21/vue-operate/">https://bubuzou.com/</a> 这个网站体验下这个插件的效果，好有个大概的印象。</p><p>通过阅读这篇文章，你可以收获什么？</p><ol><li>用 <code>JS</code> 直接操作 <code>DOM</code></li><li>浏览器 <code>BOM</code> 相关知识</li><li>性能优化思考</li><li>插件设计思考</li></ol><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>平时我们在用 <code>Markdown</code> 写的文章，如果放到自己的博客或者投稿到掘金等平台，其内容会被浏览器解析成 <code>HTML</code>。而 <code>Markdown</code> 里面的一级（#）、二级（##）、三级标题（###）分别对应于页面的文章标题、一级目录、二级目录。基于此，就可以很好的利用该生成的页面实现一个目录，便于更直观方便的的浏览文章内容，而这就是最初我想为博客里的文章页实现一个目录功能的理由。</p><blockquote><p>这个插件是基于 <code>Hexo</code> 生成的网页来实现的，且目前只支持一级和二级目录，因为作为一篇文章来说有两个层级已经可以很好的将一块内容划分细说得很清楚了。</p></blockquote><a id="more"></a><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/catalog.png"></p><p>首先我打算将文章的目录放置在文章内容的右侧，且是悬浮固定在那里不随浏览器的滚动而滚动。因为我们都习惯从上到下从左到右的去浏览文章，所以我希望首先映入眼帘的是文章内容而不是文章目录；另外因为我的博客的首页和文章列表页都是左侧是浏览区域而右侧是操作区域，所以把目录放到右侧能保持整站的布局统一以及操作的便利性。</p><h3 id="需要做什么"><a href="#需要做什么" class="headerlink" title="需要做什么"></a>需要做什么</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/highlight.png"></p><ol><li>首先需要根据文章内容的二级和三级标题生成目录；</li><li>然后，页面从上到下滚动过程中，需要在右侧目录里高亮当前的标题，而高亮的原则是当前标题所在的位置到浏览器可视区域顶部的距离需要小于或等于一个固定值，如上图所示；</li><li>在合适的时候滚动目录列表，使得当前高亮的子目录会出现在滚动区域内部，且尽量处于滚动区域的中间区域；</li><li>当点击某个子目录的时候需要高亮当前点击的目录，且文章内容滚动到对应目录的位置，使得点击目录对应的文章标题所在的位置距离可视区域顶部的距离刚好等于一个固定值。</li></ol><h3 id="滚动目录的机制是怎样的"><a href="#滚动目录的机制是怎样的" class="headerlink" title="滚动目录的机制是怎样的"></a>滚动目录的机制是怎样的</h3><p>对于的第三点提到在合适的时候滚动目录，那什么时候才算合适呢？目录能不能滚动，以及怎么滚动总共分为以下 5 种情况：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_top.png"></p><ol><li>当目录能在滚动区域完全显示的时候，即滚动区域高度大于所有目录子项高度总和的时候，不进行目录滚动，如上面的图 ① ；</li><li>当目录不能在滚动区域完全显示的时候，目录需要滚动。所以需要做的就是在一个划定的区域内滚动目录，超出该区域的目录子项将会自动隐藏。通过滚动目录，我们可以实现目录列表的头尾两个目录子项都能很好的在划定区域里显示出来。随着页面的滚动，目录将从头滚到尾，那么滚动的范围是从第一个子目录贴着滚动区域的顶部到最后一个子目录贴着滚动区域的底部为止；</li><li>当页面在最顶部的时候，当前高亮的子目录肯定是第一个，随着页面的向下滚动，高亮的位置也在不断下移，当高亮位置移动到在目录滚动区域的上半部分之前，这段不进行目录滚动，如上面的图 ② 到 图 ③ 的变化过程；</li><li>当第一个子目录贴着滚动区域的顶部，且高亮位置在中位往下继续滚动的时候，需要进行目录滚动，滚动的距离是当前高亮目录所在位置距离滚动区域中间位置的高度差，如上面的图 ③ 到图 ④ 的变化过程；</li><li>如果这个高度差过于大，使得滚动后最后一个子元素不能贴着滚动区域底部的时候，则不按照这个高度差进行滚动，而真实需要滚动的距离是最后一个子目录到滚动区域底部的距离，如上面的图 ④ 到图 ⑤ 的变化过程。</li></ol><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>由于文章页是由 <code>Hexo</code> 基于 <code>Markdown</code> 生成而来的，所以它有自己特定的 <code>HTML</code> 格式，它的格式大概是如下这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;7种组件通信方式随你选&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;headerlink&quot;</span> <span class="attr">title</span>=<span class="string">&quot;7种组件通信方式随你选&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    7种组件通信方式随你选</span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是部分文章内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;props-on-emit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;headerlink&quot;</span> <span class="attr">title</span>=<span class="string">&quot;props/@on+$emit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    props/@on+$emit</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是部分文章内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;$attrs和$listeners&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;headerlink&quot;</span> <span class="attr">title</span>=<span class="string">&quot;$attrs和$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    $attrs和$listeners</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是部分文章内容 --&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到所有的二级标题（H2）和三级标题（H3）都是在同一个父元素下面，且每个标题下面都包含了一个带有 <code>headerlink</code> 类名的链接，另外还有标题属性。</p><p>这个时候我们就能很容易的获取到所有的标题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arContentAnchor = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.headerlink&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面这串代码的结果会返回一个 <code>NodeList</code>，有了它我们就可以去生成目录了。</p><h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/catalog_show.png"></p><p>生成目录无非就是产生一串 <code>HTML</code>，除此之外还有哪些要做的呢？<br>首先要确定下，目录都包含了哪些部分，如上图所示这里大概是包含了 3 部分：目录条、序号和标题。那么就可以先确定好 <code>HTML</code> 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-body&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-tack1 on&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-index&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>7种组件通信方式随你选<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-dot&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>arCatalog-line</code> 表示目录条，<code>arCatalog-body</code> 是滚动区域，<code>dl</code> 是滚动列表，<code>dd</code> 是目录子项，<code>arCatalog-index</code> 是目录序号，链接里放的是子目录标题。有了 <code>HTML</code> ，接下来要做的就是把目录的样式写好，写完后样式比较多，所以就不在这里贴出来了。</p><p>生成目录到这里就完事了吗？并没有，由于浏览器可视区域是不固定的，所以我们需要计算出目录所在滚动区域的高度。</p><p>滚动高度 = n个目录子项 * 子项的实际高度</p><p>先说子项的实际高度，对于目录子项的样式上，我这里没有用内间距和外边距，而是通过 <code>line-height</code> 来控制他们之间的间隙，那么：</p><p>子项的实际高度 = 子项的行高</p><p>再说 <code>n</code> 个目录子项，那到底 <code>n</code> 是多少呢？在目录的 <code>Y</code> 轴方向上，除了有目录，还有顶部的菜单，以及为了美观还需要适当的留白，所以：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_height.png"></p><p>n = (视口高度 - （顶部菜单高度 + 留白高度））/ 子项行高</p><p>所以，最终我们可以计算出滚动高度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> DEFAULT = &#123;</span><br><span class="line">    lineHeight: <span class="number">28</span>,           <span class="comment">// 每个菜单的行高是 28</span></span><br><span class="line">    moreHeight: <span class="number">10</span>,           <span class="comment">// 菜单左侧的线比菜单多出的高度</span></span><br><span class="line">    surplusHeight: <span class="number">180</span>,       <span class="comment">// 除了菜单高度+留白高度</span></span><br><span class="line">    delay: <span class="number">200</span>,               <span class="comment">// 防抖的延迟时间</span></span><br><span class="line">    duration: <span class="number">200</span>,            <span class="comment">// 滚动的动画持续时间</span></span><br><span class="line">    toTopDistance: <span class="number">80</span>,        <span class="comment">// 距离视口顶部多少高度之内时候触发高亮</span></span><br><span class="line">    selector: <span class="string">&#x27;.headerlink&#x27;</span>,  <span class="comment">// 文章内容中标题标签的 selector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxCatalogCount 就是上面提到的 n 个目录子项中的 n</span></span><br><span class="line"><span class="keyword">let</span> maxCatalogCount = <span class="built_in">Math</span>.floor((<span class="built_in">window</span>.innerHeight - DEFAULT.surplusHeight) / DEFAULT.lineHeight)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动区域高度</span></span><br><span class="line"><span class="keyword">let</span> catalogHeight = arContentAnchor.length &gt; maxCatalogCount ? maxCatalogCount * DEFAULT.lineHeight : arContentAnchor.length * DEFAULT.lineHeight;</span><br></pre></td></tr></table></figure><p>完整的生成目录的函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成目录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateCatalog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> catalogHeight = arContentAnchor.length &gt; maxCatalogCount ? maxCatalogCount * DEFAULT.lineHeight : arContentAnchor.length * DEFAULT.lineHeight;</span><br><span class="line">    <span class="keyword">let</span> retStr = <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;arCatalog&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;arCatalog-line&quot; </span></span><br><span class="line"><span class="string">        style=&quot;height: <span class="subst">$&#123;catalogHeight + DEFAULT.moreHeight&#125;</span>px&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;arCatalog-body&quot; </span></span><br><span class="line"><span class="string">        style=&quot;max-height: <span class="subst">$&#123;catalogHeight&#125;</span>px; height: <span class="subst">$&#123;catalogHeight&#125;</span>px&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;dl style=&quot;margin-top: <span class="subst">$&#123;marginTop&#125;</span>px&quot;&gt;`</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> h2Index = <span class="number">0</span>,</span><br><span class="line">        h3Index = <span class="number">1</span>,</span><br><span class="line">        acIndex = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        tagName = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> currNode <span class="keyword">of</span> arContentAnchor) &#123;</span><br><span class="line">        tagName = currNode.parentElement.tagName</span><br><span class="line">        <span class="keyword">if</span> ( tagName === <span class="string">&#x27;H3&#x27;</span> ) &#123;</span><br><span class="line">            acIndex = <span class="string">`<span class="subst">$&#123;h2Index&#125;</span>.<span class="subst">$&#123;h3Index++&#125;</span>`</span></span><br><span class="line">            className = <span class="string">&#x27;arCatalog-tack2&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            acIndex = ++h2Index</span><br><span class="line">            h3Index = <span class="number">1</span></span><br><span class="line">            className = <span class="string">&#x27;arCatalog-tack1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        retStr += <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;dd class=&quot;<span class="subst">$&#123;className&#125;</span> <span class="subst">$&#123;index++ === lastOnIndex ? <span class="string">&#x27;on&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;span class=&quot;arCatalog-index&quot;&gt;<span class="subst">$&#123;acIndex&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">            &lt;a href=&quot;#&quot;&gt;<span class="subst">$&#123;currNode.title&#125;</span>&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;span class=&quot;arCatalog-dot&quot;&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">            &lt;/dd&gt;`</span></span><br><span class="line">    &#125;;</span><br><span class="line">    retStr += <span class="string">`&lt;/dl&gt;&lt;/div&gt;&lt;/div&gt;`</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;arAnchorBar&#x27;</span>).innerHTML = retStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置滚动监听事件"><a href="#设置滚动监听事件" class="headerlink" title="设置滚动监听事件"></a>设置滚动监听事件</h3><p>给 <code>window</code> 加上滚动事件，用于监听当滚动的时候去做一些操作，这里的操作就是设置高亮和滚动目录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setHighlight()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有目录总数超过滚动区域可容纳最大目录数的时候，目录才需要滚动</span></span><br><span class="line"><span class="keyword">if</span> (catalogLength &gt; maxCatalogCount) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        scrollCatalog()</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上这样就能监听浏览器滚动事件，从而做一些事情啦。但是这样会导致函数被频繁调用，从而存在性能问题，其实我们更希望当滚动开始到滚动结束的时候，只执行一次函数即可，那这个直接上防抖即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖：触发高频事件 n 秒后只会执行一次，如果 n 秒内事件再次触发，则会重新计时。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(fn.id)</span><br><span class="line">        fn.id = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply(_this, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们只需要把 <code>scroll</code> 监听回调里的函数对应换成如下的即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    debounce(setHighlight, DEFAULT.delay)()</span><br><span class="line">    debounce(resetStatus, DEFAULT.delay)()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (catalogLength &gt; maxCatalogCount) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        debounce(scrollCatalog, DEFAULT.delay)()</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高亮当前目录"><a href="#高亮当前目录" class="headerlink" title="高亮当前目录"></a>高亮当前目录</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bcr.png"></p><p>这部分内容开始前，我们先来复习一个 <code>API</code>，该方法会返回元素的大小及其相对于视口的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getBoundingClientRect()</span><br></pre></td></tr></table></figure><p>需求分析的时候有提到，高亮的原则是当前标题所在的位置到浏览器可视区域顶部的距离需要小于或等于一个固定值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arContentAnchor[index].getBoundingClientRect().top &lt;= DEFAULT.toTopDistance</span><br></pre></td></tr></table></figure><p>所以当遍历 <code>arContentAnchor</code> 这个列表，某项的位置小于固定值，且差值最小的时候，该项对应的目录就应该被设置为高亮：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curr = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>)</span><br><span class="line">curr.classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextOnIndex = <span class="number">0</span>,</span><br><span class="line">    currNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nextOnIndex &lt; arContentAnchor.length) &#123;</span><br><span class="line">    currNode = arContentAnchor[nextOnIndex]</span><br><span class="line">    <span class="keyword">if</span> (currNode.getBoundingClientRect().top &lt;= DEFAULT.toTopDistance) &#123;</span><br><span class="line">        nextOnIndex++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">nextOnIndex = nextOnIndex === arContentAnchor.length ? nextOnIndex - <span class="number">1</span> : nextOnIndex;</span><br><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>)</span><br><span class="line">catalogDd[nextOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure><p>到此一切都看起来很美好，但是上面这段代码存在性能问题，只要页面一滚动就会从第一个目录到最后一个目录之间进行查找，知道找到那个符合要求的为止，这样的话遍历次数太多了。</p><p>我们知道页面滚动无非就是在当前这个位置的前提下，往上滚动或者向下滚动，如果我们把 <code>nextOnIndex</code> 记为滚动前的索引，在根据滚动方向进行加加减减不就可以很好的减少遍历次数嘛？想法貌似不错，来试一下。</p><p>首先我们要判断当前滚动是向上还是向下滚动，可以根据两次滚动前后的偏移量来判断：</p><p>向上滚动 = 滚动后偏移量 &lt; 滚动前偏移量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastSH = <span class="built_in">window</span>.pageYOffset</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最近一次页面的滚动方向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollDirection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sh = <span class="built_in">window</span>.pageYOffset, ret = <span class="string">&#x27;bottom&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (sh &lt; lastSH) &#123;</span><br><span class="line">        ret = <span class="string">&#x27;top&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    lastSH = sh</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了滚动方向，我们就可以很好的写出设置高亮的优化代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curr = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> nextOnIndex = onIndex;</span><br><span class="line"><span class="keyword">if</span> (defaultDirec === <span class="string">&#x27;bottom&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextOnIndex &lt; catalogLength) &#123;</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">        <span class="keyword">if</span> ( currTop &gt; DEFAULT.toTopDistance &amp;&amp; nextOnIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nextOnIndex--</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        nextOnIndex++</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextOnIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">        <span class="keyword">if</span> ( currTop &lt;= DEFAULT.toTopDistance)&#123;</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        nextOnIndex--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">nextOnIndex = nextOnIndex === arContentAnchor.length ? nextOnIndex - <span class="number">1</span> : nextOnIndex &lt; <span class="number">0</span> ? <span class="number">0</span> : nextOnIndex </span><br><span class="line">catalogDd[nextOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure><p>优化后的遍历次数明显减少，而且遍历次数基本上是小于或等于滚动前后目录索引的差值。<br>虽然经过优化后，已经明显的减少了遍历次数，但是我还想再优化一下。纳尼？</p><p>很多文章页很长，所以有回到顶部这种功能，试想一下，如果当前页面已经滚动到最底部，这个时候来一下回到顶部，那刚刚写的优化代码会遍历几次？答案是：遍历次数将会是目录子项的总数。文章最开始提到的那个体验地址的那篇文章 <a href="https://bubuzou.com/2020/09/21/vue-operate/">34条我能告诉你的Vue之实操篇</a> 有 43 个子目录，所以需要遍历 43 次，真的不能接受结果，所以再来优化一次。</p><p>二次优化主要是处理边际问题，即滚动到头尾部的时候加上判断，最终二次优化后的高亮当前目录函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高亮当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHighlight</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    defaultDirec = getScrollDirection()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hasStopSetHighlight) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">        scrollTop,</span><br><span class="line">    &#125; = <span class="built_in">document</span>.scrollingElement;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> curr = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> onIndex = [].indexOf.call(catalogDd, curr),  <span class="comment">// 当前高亮索引</span></span><br><span class="line">        nextOnIndex = onIndex;  <span class="comment">// 滚动后高亮索引</span></span><br><span class="line">        </span><br><span class="line">    curr.classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> scrollHeight = <span class="built_in">document</span>.documentElement.scrollHeight || <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">    <span class="keyword">if</span> (arContentAnchor[catalogLength - <span class="number">1</span>].getBoundingClientRect().top &lt;= DEFAULT.toTopDistance || </span><br><span class="line">        <span class="built_in">window</span>.innerHeight + <span class="built_in">window</span>.pageYOffset === scrollHeight) &#123;  <span class="comment">// 尾部</span></span><br><span class="line">        lastOnIndex = catalogLength - <span class="number">1</span></span><br><span class="line">        catalogDd[lastOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scrollTop &lt;= firstDdTop) &#123;  <span class="comment">// 顶部</span></span><br><span class="line">        catalogDd[<span class="number">0</span>].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">        lastOnIndex = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 中间：使用缓存，直接从上一次索引（onIndex）位置开始查找</span></span><br><span class="line">        <span class="keyword">if</span> (defaultDirec === <span class="string">&#x27;bottom&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nextOnIndex &lt; catalogLength) &#123;</span><br><span class="line">                <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">                <span class="keyword">if</span> ( currTop &gt; DEFAULT.toTopDistance &amp;&amp; nextOnIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    nextOnIndex--</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                nextOnIndex++</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (nextOnIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">                <span class="keyword">if</span> ( currTop &lt;= DEFAULT.toTopDistance)&#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                nextOnIndex--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nextOnIndex = nextOnIndex === catalogLength ? nextOnIndex - <span class="number">1</span> : nextOnIndex &lt; <span class="number">0</span> ? <span class="number">0</span> : nextOnIndex </span><br><span class="line">        lastOnIndex = nextOnIndex</span><br><span class="line">        catalogDd[nextOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滚动目录"><a href="#滚动目录" class="headerlink" title="滚动目录"></a>滚动目录</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_to_bottom.png"></p><p>根据之前需求分析里的说明，我们可以知道当浏览器向下滚动的时候，会分成 3 种情况：</p><ol><li>滚动后的高亮子目录处于于滚动区域上半部分，即中位线以上，此时目录不进行滚动，如上图 ①；</li><li>滚动后的高亮子目录处于滚动区域的下半部分，即中位线以下，此时目录的滚动距离将是滚动后高亮子目录的底部位置到中位线的高度差，如上图 ②；</li><li>滚动后的高亮目录处于中位线以下且最后一个子目录需要贴着滚动区域底部，此时目录的滚动距离将是滚动列表底部到滚动区域底部的高度差，如上图 ③。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catalogBody = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog-body&#x27;</span>),</span><br><span class="line">    initBodyTop = catalogBody..getBoundingClientRect().top,</span><br><span class="line">    bodyMidBottom = initBodyTop + <span class="built_in">Math</span>.ceil((maxCatalogCount / <span class="number">2</span> )) * DEFAULT.lineHeight;  <span class="comment">// 中位线位置</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (curr.bottom + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= bodyBCR.bottom) &#123;  <span class="comment">// 上半部分</span></span><br><span class="line">    <span class="comment">// 不滚动</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.bottom - bodyMidBottom &lt; list.bottom - bodyBCR.bottom) &#123;  <span class="comment">// 中位以下</span></span><br><span class="line">    marginTop += -<span class="built_in">Math</span>.floor((curr.bottom - bodyMidBottom ) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyBCR.bottom &lt;= list.bottom) &#123;  <span class="comment">// 当剩余滚动距离</span></span><br><span class="line">    marginTop = bodyBCR.bottom - initDlBottom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，当浏览器向上滚动的时候，也能很好的得出其滚动逻辑：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_to_top.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bodyBCR.top + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= curr.top) &#123;</span><br><span class="line">    <span class="comment">// 不滚动</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyMidBottom - curr.top &lt; bodyBCR.top - list.top) &#123;</span><br><span class="line">    marginTop += <span class="built_in">Math</span>.floor((bodyMidBottom - curr.top) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.top &lt;= bodyBCR.top) &#123;</span><br><span class="line">    marginTop = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的滚动目录函数完整代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动滚动目录树，使得当前高亮目录在可视范围内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollCatalog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentCatalog = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> curr = currentCatalog.getBoundingClientRect(),</span><br><span class="line">        list = catalogDl.getBoundingClientRect();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (defaultDirec === <span class="string">&#x27;bottom&#x27;</span>) &#123;  <span class="comment">// 向下滚动</span></span><br><span class="line">        <span class="keyword">if</span> (curr.bottom + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= bodyBCR.bottom) &#123;  <span class="comment">// 上半部分</span></span><br><span class="line">            <span class="comment">// 不滚动</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.bottom - bodyMidBottom &lt; list.bottom - bodyBCR.bottom)&#123;  <span class="comment">// 中位以下</span></span><br><span class="line">            marginTop += -<span class="built_in">Math</span>.floor((curr.bottom - bodyMidBottom ) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyBCR.bottom &lt;= list.bottom) &#123;  <span class="comment">// 当剩余滚动距离</span></span><br><span class="line">            marginTop = bodyBCR.bottom - initDlBottom</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 向上滚动</span></span><br><span class="line">        <span class="keyword">if</span> (bodyBCR.top + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= curr.top) &#123;</span><br><span class="line">            <span class="comment">// 不滚动</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyMidBottom - curr.top &lt; bodyBCR.top - list.top) &#123;</span><br><span class="line">            marginTop += <span class="built_in">Math</span>.floor((bodyMidBottom - curr.top) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.top &lt;= bodyBCR.top) &#123;</span><br><span class="line">            marginTop = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catalogDl.style.marginTop = marginTop + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子目录点击事件"><a href="#子目录点击事件" class="headerlink" title="子目录点击事件"></a>子目录点击事件</h3><p>当点击子目录的时候需要做 2 件事情，第一是滚动页面到对应的目录位置，然后是高亮当前点击的目录；</p><p>滚动页面到对应的目录位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给目录子项绑定事件</span></span><br><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">    curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollTop = <span class="built_in">document</span>.body.scrollTop = currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样实现页面的滚动是没什么问题，就是体验不太好，突然从一个位置滚动到另外一个位置，显得突兀，能不能来点动画效果？类似 <code>jQuery</code> 的 <code>animate()</code> ？没问题，我们来尝试着实现一下。</p><p>用 <code>JS</code> 实现动画效果，一定离不开定时器，诸如 <code>setTimeout</code>、<code>setInterval</code> 之类，但是这次我不打算用他们，而是用 <code>HTML5</code> 中增加的 <code>requestAnimationFrame</code>，这是一个专门为浏览器实现动画而提供的 <code>API</code>。它虽然也是个定时器，但是相比于另外两个，他不需要传递时间，因为传递的回调函数里自带了参数 <code>DOMHighResTimeStamp</code>，这个参数表示回调函数被触发的时间。</p><p>除此之外，<code>requestAnimationFrame</code> 中的回调函数执行次数通常是每秒60次，即大概每 16.6 毫秒执行一次回调函数，但在大多数遵循 <code>W3C</code> 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。好了，对于 <code>requestAnimationFrame</code> 的介绍就到这里，下面我们直接来说下动画实现滚动的核心原理：</p><p>每次滚动距离 = ( 滚动距离 / 动画持续时间 ) * 每次动画执行时间距离第一次执行时间的差值 + 当前滚动距离</p><p>直接来看完整的动画实现滚动的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动到目标位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollToDest</span>(<span class="params">destScrollTop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> startTime;   </span><br><span class="line">    <span class="keyword">let</span> currScrollTop = <span class="built_in">window</span>.pageYOffset;</span><br><span class="line">    <span class="keyword">let</span> duration = <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!startTime) &#123;</span><br><span class="line">            startTime = timestamp</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> elapsed = <span class="built_in">Math</span>.round(timestamp - startTime)</span><br><span class="line">        <span class="keyword">const</span> distance = elapsed * ((<span class="built_in">Math</span>.floor(destScrollTop) - currScrollTop) / duration) + currScrollTop</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollTop = <span class="built_in">document</span>.body.scrollTop = distance</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (elapsed &lt; duration) &#123;</span><br><span class="line">            <span class="built_in">window</span>.requestAnimationFrame(step)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在有了动画函数，我们需要改写下子目录的点击事件，给滚动加上过渡效果，让人体验起来更加舒服：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>);</span><br><span class="line"></span><br><span class="line">catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">    curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">        scrollToDest(currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一件事已经做好，接下来做第二件事，高亮当前点击某个子目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给目录子项绑定事件</span></span><br><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>);</span><br><span class="line"></span><br><span class="line">catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">    curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        hasStopSetHighlight = <span class="literal">true</span></span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>).classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">        catalogDd[index].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">        lastOnIndex = index</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">        scrollToDest(currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上即可，但是由于点击了某个子目录，页面会进行滚动，而页面滚动又会触发 <code>setHighlight</code> 函数对目录进行高亮，所以我这里的做法是用了一个全局变量 <code>hasStopSetHighlight</code> 用来控制当点击子目录的时候，不进行 <code>setHighlight</code> 设置高亮操作。</p><h3 id="浏览器视口高度变了怎么办"><a href="#浏览器视口高度变了怎么办" class="headerlink" title="浏览器视口高度变了怎么办"></a>浏览器视口高度变了怎么办</h3><p>因为我们的滚动高度是根据浏览器视口高度计算出来的，如果浏览器视口高度变化了，那这个时候再去滚动页面，那肯定会出问题的。所以需要做的就是把和视口高度有关的逻辑抽离出来，统一放到一个函数里，当监听到视口高度变化的时候，再去执行这个函数。</p><p>先来写监听函数，同样用上了防抖函数处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    debounce(initCatalog, DEFAULT.delay)()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>然后去把相关逻辑抽离出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCatalog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tempHeight = <span class="built_in">window</span>.innerHeight</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (viewPortHeight !== tempHeight) &#123;</span><br><span class="line">        viewPortHeight = tempHeight</span><br><span class="line">        maxCatalogCount = <span class="built_in">Math</span>.floor((viewPortHeight - DEFAULT.surplusHeight) / DEFAULT.lineHeight)</span><br><span class="line">        </span><br><span class="line">        generateCatalog()</span><br><span class="line">        </span><br><span class="line">        catalogLength = arContentAnchor.length</span><br><span class="line">        lastSH = <span class="built_in">window</span>.pageYOffset</span><br><span class="line">        catalogBody = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog-body&#x27;</span>)</span><br><span class="line">        catalogDl = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog dl&#x27;</span>)</span><br><span class="line">        catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>)</span><br><span class="line">        bodyBCR = catalogBody.getBoundingClientRect()</span><br><span class="line">        initBodyTop = bodyBCR.top</span><br><span class="line">        initDlBottom = initDlBottom || catalogDl.getBoundingClientRect().bottom</span><br><span class="line">        firstDdTop = firstDdTop || catalogDd[<span class="number">0</span>].getBoundingClientRect().top,</span><br><span class="line">        bodyMidBottom = initBodyTop + <span class="built_in">Math</span>.ceil((maxCatalogCount / <span class="number">2</span> )) * DEFAULT.lineHeight;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给目录子项绑定事件</span></span><br><span class="line">        catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">            curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                e.preventDefault()</span><br><span class="line">                hasStopSetHighlight = <span class="literal">true</span></span><br><span class="line">                <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>).classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">                catalogDd[index].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">                lastOnIndex = index</span><br><span class="line">                <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">                scrollToDest(currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance)</span><br><span class="line">            &#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器视口高度变化后，这里有个细节需要提一下，那就是滚动目录的 <code>margin-top</code> 以及高亮位置是希望变化的，所以我们需要使用全局变量进行提前保存起来，分别用到的全局变量是 <code>marginTop</code> 和 <code>lastOnIndex</code>。</p><h3 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h3><p>上面的代码都是把不同的功能点提取到函数里进行操作，看起来比较散乱，所以我们需要看看一个完整的目录插件应该是什么样子？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * articleCatalog v2.0</span></span><br><span class="line"><span class="comment"> * Copyright(c) 2016 by bulandent</span></span><br><span class="line"><span class="comment"> * Date: 2017-5-27 16:10:41</span></span><br><span class="line"><span class="comment"> * Updated: 2020-10-10 17:40:04</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> articleCatalog = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.headerlink&#x27;</span>).length === <span class="number">0</span> || <span class="built_in">window</span>.innerWidth &lt; <span class="number">900</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> DEFAULT = &#123;</span><br><span class="line">        lineHeight: <span class="number">28</span>,           <span class="comment">// 每个菜单的行高是 28</span></span><br><span class="line">        moreHeight: <span class="number">10</span>,           <span class="comment">// 菜单左侧的线比菜单多出的高度</span></span><br><span class="line">        surplusHeight: <span class="number">180</span>,       <span class="comment">// 除了菜单高度+留白高度</span></span><br><span class="line">        delay: <span class="number">200</span>,               <span class="comment">// 防抖的延迟时间</span></span><br><span class="line">        duration: <span class="number">200</span>,            <span class="comment">// 滚动的动画持续时间</span></span><br><span class="line">        toTopDistance: <span class="number">80</span>,        <span class="comment">// 距离视口顶部多少高度之内时候触发高亮</span></span><br><span class="line">        selector: <span class="string">&#x27;.headerlink&#x27;</span>,  <span class="comment">// 文章内容中标题标签的 selector</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        DEFAULT = <span class="built_in">Object</span>.assign(DEFAULT, args)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> arContentAnchor = <span class="built_in">document</span>.querySelectorAll(DEFAULT.selector),</span><br><span class="line">            catalogLength = arContentAnchor.length,</span><br><span class="line">            maxCatalogCount = <span class="number">0</span>,          <span class="comment">// 视口内能容纳的最大目录个数</span></span><br><span class="line">            viewPortHeight = <span class="number">0</span>,           <span class="comment">// 当前视口的高度</span></span><br><span class="line">            marginTop = <span class="number">0</span>,                <span class="comment">// 菜单的初始滚动距离</span></span><br><span class="line">            defaultDirec = <span class="string">&#x27;bottom&#x27;</span>,      <span class="comment">// 默认滚动方向</span></span><br><span class="line">            lastSH = <span class="number">0</span>,                   <span class="comment">// 获取页面初始滚动距离</span></span><br><span class="line">            lastOnIndex = <span class="number">0</span>,              <span class="comment">// 上次高亮的目录索引</span></span><br><span class="line">            catalogBody = [],             <span class="comment">// .arCatalog-body</span></span><br><span class="line">            catalogDl = <span class="literal">null</span>,             <span class="comment">// .arCatalog-body dl</span></span><br><span class="line">            catalogDd = [],                 <span class="comment">// .arCatalog-body dd</span></span><br><span class="line">            initBodyTop = <span class="number">0</span>,              <span class="comment">// 目录可视区域的 top</span></span><br><span class="line">            initDlBottom = <span class="number">0</span>,             <span class="comment">// 目录 dl 的 bottom</span></span><br><span class="line">            firstDdTop = <span class="number">0</span>,               <span class="comment">// 第一个 dd 的 top</span></span><br><span class="line">            bodyMidBottom = <span class="number">0</span>,            <span class="comment">// 目录可视区域的中间位置的 dd 的 bottom</span></span><br><span class="line">            bodyBCR = <span class="literal">null</span>,                  <span class="comment">// 目录可视区域的边界值</span></span><br><span class="line">            hasStopSetHighlight = <span class="literal">false</span>;  <span class="comment">// 在点击目录子项的时候直接高亮当前目录，而不通过 scroll 事件触发 setHighlight 函数</span></span><br><span class="line">            </span><br><span class="line">        initCatalog()</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            debounce(setHighlight, DEFAULT.delay)()</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (catalogLength &gt; maxCatalogCount) &#123;</span><br><span class="line">            <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                debounce(scrollCatalog, DEFAULT.delay)()</span><br><span class="line">            &#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            debounce(initCatalog, DEFAULT.delay)()</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 此处声明初始化函数 initCatalog</span></span><br><span class="line">        <span class="comment">// 此处声明生成目录函数 generateCatalog</span></span><br><span class="line">        <span class="comment">// 此处声明设置高亮函数 setHighlight</span></span><br><span class="line">        <span class="comment">// 此处声明滚动目录函数 scrollCatalog</span></span><br><span class="line">        <span class="comment">// 此处声明动画实现滚动函数 scrollToDest</span></span><br><span class="line">        <span class="comment">// 此处声明防抖函数 debounce</span></span><br><span class="line">        <span class="comment">// 此处声明获取滚动方向函数 getScrollDirection</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resetStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (hasStopSetHighlight) &#123;</span><br><span class="line">                hasStopSetHighlight = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>然后在实际页面里使用的时候，只需要引入 <code>articleCatalog.js</code>，然后直接用调用函数即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">articleCatalog()</span><br></pre></td></tr></table></figure><p>当然调用的时候也支持传入一些参数，参数说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">articleCatalog(&#123;</span><br><span class="line">    lineHeight: 28,           &#x2F;&#x2F; 每个菜单的行高是 28</span><br><span class="line">    moreHeight: 10,           &#x2F;&#x2F; 菜单左侧的线比菜单多出的高度</span><br><span class="line">    surplusHeight: 180,       &#x2F;&#x2F; 除了菜单高度+留白高度</span><br><span class="line">    delay: 200,               &#x2F;&#x2F; 防抖的延迟时间</span><br><span class="line">    duration: 200,            &#x2F;&#x2F; 滚动的动画持续时间</span><br><span class="line">    toTopDistance: 80,        &#x2F;&#x2F; 距离视口顶部多少高度之内时候触发高亮</span><br><span class="line">    selector: &#39;.headerlink&#39;,  &#x2F;&#x2F; 文章内容中标题标签的 selector</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意传入参数也是瞎传的，需要配合该插件的样式，否则容易程问题。比如明明页面中子目录的真实行高是 <code>28px</code>，你却传入 <code>lineHeight: 24</code>，那肯定是不行的。</p><blockquote><p>使用这个插件是有前提的，那就是其文章页的 HTML 结构必须满足上面提到的那种结构才行，且只支持两级子目录。</p></blockquote><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202009/gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34条我能告诉你的Vue之实操篇</title>
      <link href="/2020/09/21/vue-operate/"/>
      <url>/2020/09/21/vue-operate/</url>
      
        <content type="html"><![CDATA[<p>这是我学习整理的关于 <code>Vue.js</code> 系列文章的第一篇，另外还有两篇分别是关于优化和原理的。希望读完这3篇文章，你能对 <code>Vue</code> 有个更深入的认识。</p><h2 id="7种组件通信方式随你选"><a href="#7种组件通信方式随你选" class="headerlink" title="7种组件通信方式随你选"></a>7种组件通信方式随你选</h2><p>组件通信是 <code>Vue</code> 的核心知识，掌握这几个知识点，面试开发一点问题都没有。</p><h3 id="props-on-emit"><a href="#props-on-emit" class="headerlink" title="props/@on+$emit"></a>props/@on+$emit</h3><p>用于实现父子组件间通信。通过 <code>props</code> 可以把父组件的消息传递给子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.vue</span></span><br><span class="line">props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来 <code>this.title</code> 就直接拿到从父组件中传过来的 <code>title</code> 的值了。注意，你不应该在子组件内部直接改变 <code>prop</code>，这里就不多赘述，<a href="https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">可以直接看官网介绍</a>。</p><p>而通过 <code>@on+$emit</code> 组合可以实现子组件给父组件传递信息：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> @<span class="attr">changeTitle</span>=<span class="string">&quot;changeTitle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;changeTitle&#x27;</span>, <span class="string">&#x27;bubuzou.com&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="attrs和-listeners"><a href="#attrs和-listeners" class="headerlink" title="$attrs和$listeners"></a>$attrs和$listeners</h3><p><code>Vue_2.4</code> 中新增的 <code>$attrs/$listeners</code> 可以进行跨级的组件通信。<br><code>$attrs</code> 包含了父级作用域中不作为 <code>prop</code> 的属性绑定（<code>class</code> 和 <code>style</code> 除外），好像听起来有些不好理解？没事，看下代码就知道是什么意思了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 index.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span> <span class="attr">class</span>=<span class="string">&quot;list-box&quot;</span> <span class="attr">title</span>=<span class="string">&quot;标题&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;描述&quot;</span> <span class="attr">:list</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件 list.vue</span></span><br><span class="line">props: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$attrs)  <span class="comment">// &#123;title: &quot;标题&quot;, desc: &quot;描述&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的父组件 <code>index.vue</code> 中我们给子组件 <code>list.vue</code> 传递了4个参数，但是在子组件内部 <code>props</code> 里只定义了一个 <code>list</code>，那么此时 <code>this.$attrs</code> 的值是什么呢？首先要去除 <code>props</code> 中已经绑定了的，然后再去除 <code>class</code> 和 <code>style</code>，最后剩下 <code>title</code> 和 <code>desc</code> 结果和打印的是一致的。<br>基于上面代码的基础上，我们在给 <code>list.vue</code> 中加一个子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 list.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">detail</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">detial</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孙子组件 detail.vue</span></span><br><span class="line"><span class="comment">// 不定义props，直接打印 $attrs</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$attrs)  <span class="comment">// &#123;title: &quot;标题&quot;, desc: &quot;描述&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子组件中我们定义了一个 <code>v-bind=&quot;$attrs&quot;</code> 可以把父级传过来的参数，去除 <code>props</code>、<code>class</code> 和 <code>style</code> 之后剩下的继续往下级传递，这样就实现了跨级的组件通信。</p><p><code>$attrs</code> 是可以进行跨级的参数传递，实现父到子的通信；同样的，通过 <code>$listeners</code> 用类似的操作方式可以进行跨级的事件传递，实现子到父的通信。<code>$listeners</code> 包含了父作用域中不含 <code>.native</code> 修饰的 <code>v-on</code> 事件监听器，通过 <code>v-on=&quot;$listeners&quot;</code> 传递到子组件内部。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 index.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span> @<span class="attr">change</span>=<span class="string">&quot;change&quot;</span> @<span class="attr">update.native</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件 list.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">detail</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">detail</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孙子组件 detail.vue</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">this</span>.$listeners.change()</span><br><span class="line">    <span class="built_in">this</span>.$listeners.update() <span class="comment">// TypeError: this.$listeners.update is not a function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="provide-inject组合拳"><a href="#provide-inject组合拳" class="headerlink" title="provide/inject组合拳"></a>provide/inject组合拳</h3><p><code>provide/inject</code> 组合以允许一个祖先组件向其所有子孙后代注入一个依赖，可以注入属性和方法，从而实现跨级父子组件通信。在开发高阶组件和组件库的时候尤其好用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件 index.vue</span></span><br><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        title: <span class="string">&#x27;bubuzou.com&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">provide() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        detail: &#123;</span><br><span class="line">            title: <span class="built_in">this</span>.title,</span><br><span class="line">            change: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log( val )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 孙子组件 detail.vue</span></span><br><span class="line">inject: [<span class="string">&#x27;detail&#x27;</span>],</span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.detail.title)  <span class="comment">// bubuzou.com</span></span><br><span class="line">    <span class="built_in">this</span>.detail.title = <span class="string">&#x27;hello world&#x27;</span>  <span class="comment">// 虽然值被改变了，但是父组件中 title 并不会重新渲染</span></span><br><span class="line">    <span class="built_in">this</span>.detail.change(<span class="string">&#x27;改变后的值&#x27;</span>)  <span class="comment">// 执行这句后将打印：改变后的值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>provide</code> 和 <code>inject</code> 的绑定对于原始类型来说并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。这也就是为什么在孙子组件中改变了 <code>title</code>，但是父组件不会重新渲染的原因。</p></blockquote><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>以上三种方式都是只能从父到子方向或者子到父方向进行组件的通信，而我就比较牛逼了😀，我还能进行兄弟组件之间的通信，甚至任意2个组件间通信。利用 <code>Vue</code> 实例实现一个 <code>EventBus</code> 进行信息的发布和订阅，可以实现在任意2个组件之间通信。有两种写法都可以初始化一个 <code>eventBus</code> 对象：</p><ol><li><p>通过导出一个 <code>Vue</code> 实例，然后再需要的地方引入：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p> 使用 <code>EventBus</code> 订阅和发布消息：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;EventBus&#125; <span class="keyword">from</span> <span class="string">&#x27;../utils/eventBus.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅处</span></span><br><span class="line">EventBus.$on(<span class="string">&#x27;update&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布处</span></span><br><span class="line">EventBus.$emit(<span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;更新信息&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>在 <code>main.js</code> 中初始化一个全局的事件总线：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$eventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p> 使用：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要订阅的地方</span></span><br><span class="line"><span class="built_in">this</span>.$eventBus.$on(<span class="string">&#x27;update&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要发布信息的地方</span></span><br><span class="line"><span class="built_in">this</span>.$eventBus.$emit(<span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;更新信息&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><p>如果想要移除事件监听，可以这样来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$eventBus.$off(<span class="string">&#x27;update&#x27;</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure><p>上面介绍了两种写法，推荐使用第二种全局定义的方式，可以避免在多处导入 <code>EventBus</code> 对象。这种组件通信方式只要订阅和发布的顺序得当，且事件名称保持唯一性，理论上可以在任何 2 个组件之间进行通信，相当的强大。但是方法虽好，可不要滥用，建议只用于简单、少量业务的项目中，如果在一个大型繁杂的项目中无休止的使用该方法，将会导致项目难以维护。</p><h3 id="Vuex进行全局的数据管理"><a href="#Vuex进行全局的数据管理" class="headerlink" title="Vuex进行全局的数据管理"></a>Vuex进行全局的数据管理</h3><p><code>Vuex</code> 是一个专门服务于 <code>Vue.js</code> 应用的状态管理工具。适用于中大型应用。<code>Vuex</code> 中有一些专有概念需要先了解下：</p><ul><li><code>State</code>：用于数据的存储，是 <code>store</code> 中的唯一数据源；</li><li><code>Getter</code>：类似于计算属性，就是对 <code>State</code> 中的数据进行二次的处理，比如筛选和对多个数据进行求值等；</li><li><code>Mutation</code>：类似事件，是改变 <code>Store</code> 中数据的唯一途径，只能进行同步操作；</li><li><code>Action</code>：类似 <code>Mutation</code>，通过提交 <code>Mutation</code> 来改变数据，而不直接操作 <code>State</code>，可以进行异步操作；</li><li><code>Module</code>：当业务复杂的时候，可以把 <code>store</code> 分成多个模块，便于维护；</li></ul><p>对于这几个概念有各种对应的 <code>map</code> 辅助函数用来简化操作，比如 <code>mapState</code>，如下三种写法其实是一个意思，都是为了从 <code>state</code> 中获取数据，并且通过计算属性返回给组件使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        count: <span class="function"><span class="params">state</span> =&gt;</span> state.count</span><br><span class="line">    &#125;),</span><br><span class="line">    ...mapState([<span class="string">&#x27;count&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>又比如 <code>mapMutations</code>， 以下两种函数的定义方式要实现的功能是一样的，都是要提交一个 <code>mutation</code> 去改变 <code>state</code> 中的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapMutations([<span class="string">&#x27;increment&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就用一个极简的例子来展示 <code>Vuex</code> 中任意2个组件间的状态管理。<br>1、 新建 <code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment(state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;,</span><br><span class="line">        decrement(state) &#123;</span><br><span class="line">            state.count--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、 创建一个带 <code>store</code> 的 <code>Vue</code> 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./utils/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>3、 任意组件 <code>A</code> 实现点击递增</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>click to increment：&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;mapState, mapMutations&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">        ...mapState([<span class="string">&#x27;count&#x27;</span>])</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">        ...mapMutations([<span class="string">&#x27;increment&#x27;</span>])</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、 任意组件 <code>B</code> 实现点击递减</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>click to decrement：&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;mapState, mapMutations&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">        ...mapState([<span class="string">&#x27;count&#x27;</span>])</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">        ...mapMutations([<span class="string">&#x27;decrement&#x27;</span>])</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上只是用最简单的 <code>vuex</code> 配置去实现组件通信，当然真实项目中的配置肯定会更复杂，比如需要对 <code>State</code> 数据进行二次筛选会用到 <code>Getter</code>，然后如果需要异步的提交那么需要使用 <code>Action</code>，再比如如果模块很多，可以将 <code>store</code> 分模块进行状态管理。对于 <code>Vuex</code> 更多复杂的操作还是建议去看<a href="https://vuex.vuejs.org/zh/">Vuex 官方文档</a>，然后多写例子。</p><h3 id="Vue-observable实现mini-vuex"><a href="#Vue-observable实现mini-vuex" class="headerlink" title="Vue.observable实现mini vuex"></a>Vue.observable实现mini vuex</h3><p>这是一个 <code>Vue2.6</code> 中新增的 <code>API</code>，用来让一个对象可以响应。我们可以利用这个特点来实现一个小型的状态管理器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = Vue.observable(&#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        state.count++</span><br><span class="line">    &#125;</span><br><span class="line">    decrement() &#123;</span><br><span class="line">        state.count--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; state &#125; <span class="keyword">from</span> <span class="string">&#x27;../store&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    computed: &#123;</span><br><span class="line">        count() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> state.count</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="keyword">import</span>  &#123; mutations &#125; <span class="keyword">from</span> <span class="string">&#x27;../store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">            mutations.increment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="refs-children-parent-root"><a href="#refs-children-parent-root" class="headerlink" title="$refs/$children/$parent/$root"></a>$refs/$children/$parent/$root</h3><p>通过给子组件定义 <code>ref</code> 属性可以使用 <code>$refs</code> 来直接操作子组件的方法和属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如子组件有一个 <code>getList</code> 方法，可以通过如下方式进行调用，实现父到子的通信：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$refs.list.getList()</span><br></pre></td></tr></table></figure><p>除了 <code>$refs</code> 外，其他3个都是自 <code>Vue</code> 实例创建后就会自动包含的属性，使用和上面的类似。</p><h2 id="6类可以掌握的修饰符"><a href="#6类可以掌握的修饰符" class="headerlink" title="6类可以掌握的修饰符"></a>6类可以掌握的修饰符</h2><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><p>表单类的修饰符都是和 <code>v-model</code> 搭配使用的，比如：<code>v-model.lazy</code>、<code>v-model-trim</code> 以及 <code>v-model.number</code> 等。</p><ul><li><p><code>.lazy</code>：对表单输入的结果进行延迟响应，通常和 <code>v-model</code> 搭配使用。正常情况下在 <code>input</code> 里输入内容会在 <code>p</code> 标签里实时的展示出来，但是加上 <code>.lazy</code> 后则需要在输入框失去焦点的时候才触发响应。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>.trim</code>：过滤输入内容的首尾空格，这个和直接拿到字符串然后通过 <code>str.trim()</code> 去除字符串首尾空格是一个意思。</p></li><li><p><code>.number</code>：如果输入的第一个字符是数字，那就只能输入数字，否则他输入的就是普通字符串。</p></li></ul><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p><code>Vue</code> 的事件修饰符是专门为 <code>v-on</code> 设计的，可以这样使用： <code>@click.stop=&quot;handleClick&quot;</code>，还能串联使用：<code>@click.stop.prevent=&quot;handleClick&quot;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;doDiv&quot;</span>&gt;</span></span><br><span class="line">    click div</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">&quot;doP&quot;</span>&gt;</span>click p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>.stop</code>：阻止事件冒泡，和原生 <code>event.stopPropagation()</code> 是一样的效果。如上代码，当点击 <code>p</code> 标签的时候，<code>div</code> 上的点击事件也会触发，加上 <code>.stop</code> 后事件就不会往父级传递，那父级的事件就不会触发了。</p></li><li><p><code>.prevent</code>：阻止默认事件，和原生的 <code>event.preventDefault()</code> 是一样的效果。比如一个带有 <code>href</code> 的链接上添加了点击事件，那么事件触发的时候也会触发链接的跳转，但是加上 <code>.prevent</code> 后就不会触发链接跳转了。</p></li><li><p><code>.capture</code>：默认的事件流是：捕获阶段-目标阶段-冒泡阶段，即事件从最具体目标元素开始触发，然后往上冒泡。而加上 <code>.capture</code> 后则是反过来，外层元素先触发事件，然后往深层传递。</p></li><li><p><code>.self</code>：只触发自身的事件，不会传递到父级，和 <code>.stop</code> 的作用有点类似。</p></li><li><p><code>.once</code>：只会触发一次该事件。</p></li><li><p><code>.passive</code>：当页面滚动的时候就会一直触发 <code>onScroll</code> 事件，这个其实是存在性能问题的，尤其是在移动端，当给他加上 <code>.passive</code> 后触发的就不会那么频繁了。</p></li><li><p><code>.native</code>：现在在组件上使用 <code>v-on</code> 只会监听自定义事件 (组件用 <code>$emit</code> 触发的事件)。如果要监听根元素的原生事件，可以使用 <code>.native</code> 修饰符，比如如下的 <code>el-input</code>，如果不加 <code>.native</code> 当回车的时候就不会触发 <code>search</code> 函数。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> @<span class="attr">keyup.enter.native</span>=<span class="string">&quot;search&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>串联使用事件修饰符的时候，需要注意其顺序，同样2个修饰符进行串联使用，顺序不同，结果大不一样。<code>@click.prevent.self</code> 会阻止所有的点击事件，而 <code>@click.self.prevent</code> 只会阻止对自身元素的点击。</p></blockquote><h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul><li><code>.left</code>：鼠标左键点击；</li><li><code>.right</code>：鼠标右键点击；</li><li><code>.middle</code>：鼠标中键点击；</li></ul><h3 id="键盘按键修饰符"><a href="#键盘按键修饰符" class="headerlink" title="键盘按键修饰符"></a>键盘按键修饰符</h3><p><code>Vue</code> 提供了一些常用的按键码：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>另外，你也可以直接将 <code>KeyboardEvent.key</code> 暴露的任意有效按键名转换为 <code>kebab-case</code> 来作为修饰符，比如可以通过如下的代码来查看具体按键的键名是什么：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup</span>=<span class="string">&quot;onKeyUp&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onKeyUp(event) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.key)  <span class="comment">// 比如键盘的方向键向下就是 ArrowDown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exact修饰符"><a href="#exact修饰符" class="headerlink" title=".exact修饰符"></a>.exact修饰符</h3><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h3><p><code>.sync</code> 修饰符常被用于子组件更新父组件数据。直接看下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:title.sync</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;update:title&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><p>子组件可以直接通过 <code>update:title</code> 的形式进行更新父组件中声明了 <code>.sync</code> 的 <code>prop</code>。<br>上面父组件中的写法其实是下面这种写法的简写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span> @<span class="attr">update:title</span>=<span class="string">&quot;title = $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用</p></blockquote><p>如果需要设置多个 <code>prop</code>，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:name.sync</span>=<span class="string">&quot;name&quot;</span> <span class="attr">:age.sync</span>=<span class="string">&quot;age&quot;</span> <span class="attr">:sex.sync</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过 <code>v-bind.sync</code> 简写成这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind.sync</span>=<span class="string">&quot;person&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person: &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">    age: <span class="number">21</span>,</span><br><span class="line">    sex: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Vue</code> 内部会自行进行解析把 <code>person</code> 对象里的每个属性都作为独立的 <code>prop</code> 传递进去，各自添加用于更新的 <code>v-on</code> 监听器。而从子组件进行更新的时候还是保持不变，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;update:name&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="6种方式编写可复用模块"><a href="#6种方式编写可复用模块" class="headerlink" title="6种方式编写可复用模块"></a>6种方式编写可复用模块</h2><p>今天需求评审了一个需求，需要实现一个详情页，这个详情页普通用户和管理员都能进去，但是展示的数据有稍有不同，但绝大部分是一样的；最主要的区别是详情对于普通用户是纯展示，而对于管理员要求能够编辑，然后管理员还有一些别的按钮权限等。需求看到这里，如果在排期的时候把用户的详情分给开发A做，而把管理员的详情分给B去做，那这样做的结果就是开发A写了一个详情页，开发B写了一个详情页，这在开发阶段、提测后的修改 <code>bug</code> 阶段以及后期迭代阶段，都需要同时维护这 2 个文件，浪费了时间浪费了人力，所以你可以从中意识到编写可复用模块的重要性。</p><p>而 <code>Vue</code> 作者尤大为了让开发者更好的编写可复用模块，提供了很多的手段，比如：组件、自定义指令、渲染函数、插件以及过滤器等。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是 <code>Vue</code> 中最精髓的地方，也是我们平时编写可复用模块最常用的手段，但是由于这块内容篇幅很多，所以不在这里展开，后续会写相关的内容进行详述。</p><h3 id="使用混入mixins"><a href="#使用混入mixins" class="headerlink" title="使用混入mixins"></a>使用混入mixins</h3><p>什么是混入呢？ 从代码结构上来看，混入其实就是半个组件，一个 <code>Vue</code> 组件可以包括 <code>template</code>、<code>script</code> 和 <code>style</code> 三部分，而混入其实就是 <code>script</code> 里面的内容。一个混入对象包含任意组件选项，比如 <code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code> 、生命周期钩子函数、甚至是 <code>mixins</code> 自己等，混入被设计出来就是旨在提高代码的灵活性、可复用性。</p><p>什么时候应该使用混入呢？当可复用逻辑只是 <code>JS</code> 代码层面的，而无 <code>template</code> 的时候就可以考虑用混入了。比如需要记录用户在页面的停留的时间，那我们就可以把这段逻辑抽出来放在 <code>mixins</code> 里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> statMixin = &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        enterPage() &#123;&#125;,</span><br><span class="line">        leavePage() &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">this</span>.enterPage()</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroyed() &#123;</span><br><span class="line">        <span class="built_in">this</span>.leavePage()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在需要统计页面停留时间的地方加上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; statMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;../common/mixins&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mixins: [statMixin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用混入的时候要注意和组件选项的合并规则，可以分为如下三类：</p><ul><li><p><code>data</code> 将进行递归合并，对于键名冲突的以组件数据为准：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// mixinA 的 data</span></span><br><span class="line">   data() &#123;</span><br><span class="line">       obj: &#123;</span><br><span class="line">           name: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// component A</span></span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">       mixins: [mixinA],</span><br><span class="line">       data()&#123;</span><br><span class="line">           obj: &#123;</span><br><span class="line">               name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">               age: <span class="number">21</span></span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;,</span><br><span class="line">       mounted() &#123;</span><br><span class="line">           <span class="built_in">console</span>.log( <span class="built_in">this</span>.obj )  <span class="comment">// &#123; name: &#x27;bubuzou&#x27;, &#x27;age&#x27;: 21 &#125;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>对于生命周期钩子函数将会合并成一个数组，混入对象的钩子将先被执行：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixin A</span></span><br><span class="line"><span class="keyword">const</span> mixinA = &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;第一个执行&#x27;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mixin B</span></span><br><span class="line"><span class="keyword">const</span> mixinB = &#123;</span><br><span class="line">    mixins: [mixinA]</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;第二个执行&#x27;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// component A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mixins: [mixinB]</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;最后一个执行&#x27;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p></li></ul><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>除了 <code>Vue</code> 内置的一些指令比如 <code>v-model</code>、<code>v-if</code> 等，<code>Vue</code> 还允许我们自定义指令。在 <code>Vue2.0</code> 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 <code>DOM</code> 元素进行底层操作，这时候就会用到自定义指令。比如我们可以通过自定义一个指令来控制按钮的权限。我们期望设计一个如下形式的指令来控制按钮权限：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-auth</span>=<span class="string">&quot;[&#x27;user&#x27;]&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过在按钮的指令里传入一组权限，如果该按钮只有 <code>admin</code> 权限才可以提交，而我们传入一个别的权限，比如 <code>user</code>，那这个按钮就不应该显示了。<br>接下来我们去注册一个全局的指令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auth.js</span></span><br><span class="line"><span class="keyword">const</span> AUTH_LIST = [<span class="string">&#x27;admin&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAuth</span>(<span class="params">auths</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AUTH_LIST.some(<span class="function"><span class="params">item</span> =&gt;</span> auths.includes(item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    Vue.directive(<span class="string">&#x27;auth&#x27;</span>, &#123;</span><br><span class="line">        inserted(el, binding) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!checkAuth(binding.value)) &#123;</span><br><span class="line">                el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; install &#125;</span><br></pre></td></tr></table></figure><p>然后我们需要在 <code>main.js</code> 里通过安装插件的方式来启用这个指令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Auth <span class="keyword">from</span> <span class="string">&#x27;./utils/auth&#x27;</span></span><br><span class="line">Vue.use(Auth)</span><br></pre></td></tr></table></figure><h3 id="使用渲染函数"><a href="#使用渲染函数" class="headerlink" title="使用渲染函数"></a>使用渲染函数</h3><p>这里将使用渲染函数实现上面介绍过的的权限按钮。<br>使用方式如下，把需要控制权限的按钮包在权限组件 <code>authority</code> 里面，如果有该权限就显示，没有就不显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authority</span> <span class="attr">:auth</span>=<span class="string">&quot;[&#x27;admin&#x27;]&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authority</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们用渲染函数去实现一个 <code>authority</code> 组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">const</span> AUTH_LIST = [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;org&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAuth</span>(<span class="params">auths</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AUTH_LIST.some(<span class="function"><span class="params">item</span> =&gt;</span> auths.includes(item))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    functional: <span class="literal">true</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        auth: &#123;</span><br><span class="line">            type: <span class="built_in">Array</span>,</span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h, context) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; props,  scopedSlots&#125; = context</span><br><span class="line">        <span class="keyword">return</span> checkAuth(props.auth) ? scopedSlots.default() : <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>全局注册这个组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Authority <span class="keyword">from</span> <span class="string">&#x27;./components/authority&#x27;</span></span><br><span class="line">Vue.component(<span class="string">&#x27;authority&#x27;</span>, Authority)</span><br></pre></td></tr></table></figure><h3 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a>使用过滤器</h3><p><code>Vue</code> 提供了自定义过滤器的功能，主要应用场景是想要将数据以某种格式展示出来，而原始数据又不符合这种格式的时候。比如有一组关于人的数据，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    name: &#x27;张茂&#x27;,</span><br><span class="line">    population: &#x27;young&#x27;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    name: &#x27;王丽&#x27;,</span><br><span class="line">    population: &#x27;middle&#x27;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    name: &#x27;郝鹏程&#x27;,</span><br><span class="line">    population: &#x27;child&#x27;,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>其中有一项是关于按照年龄划分的群体类型 <code>population</code>，而它是用 <code>code</code> 进行标识的，我们希望在展示的时候能够显示成对应的中文意思，比如 <code>young</code> 显示成青年。那我们就可以定义一个如下的局部过滤器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    filters: &#123;</span><br><span class="line">        popuFilters(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!value) &#123; <span class="keyword">return</span> <span class="string">&#x27;未知&#x27;</span> &#125;</span><br><span class="line">            <span class="keyword">let</span> index = [<span class="string">&#x27;child&#x27;</span>, <span class="string">&#x27;lad&#x27;</span>, <span class="string">&#x27;young&#x27;</span>, <span class="string">&#x27;middle&#x27;</span>, <span class="string">&#x27;wrinkly&#x27;</span>].indexOf(value)</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span> &amp;&amp; [<span class="string">&#x27;儿童&#x27;</span>, <span class="string">&#x27;少年&#x27;</span>, <span class="string">&#x27;青年&#x27;</span>, <span class="string">&#x27;中年&#x27;</span>, <span class="string">&#x27;老年&#x27;</span>][index] || <span class="string">&#x27;未知&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用过滤器的时候只要在 <code>template</code> 中这样使用即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; item.population | popuFilters &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><p>在某些情况下，我们封装的内容可能不需要使用者对其内部代码结构进行了解，其只需要熟悉我们提供出来的相应方法和 <code>api</code> 即可，这需要我们更系统性的将公用部分逻辑封装成插件，来为项目添加全局功能，比如常见的 <code>loading</code> 功能、弹框功能等。</p><p>开发 <code>Vue</code> 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象。可以通过如下4种方式来自定义插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  Vue.directive(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要在入口文件，比如 <code>main.js</code> 中注册插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyPlugin <span class="keyword">from</span> <span class="string">&#x27;./plugins/plugins.js&#x27;</span></span><br><span class="line">Vue.use(MyPlugin)</span><br></pre></td></tr></table></figure><h2 id="3种方式手写优雅代码"><a href="#3种方式手写优雅代码" class="headerlink" title="3种方式手写优雅代码"></a>3种方式手写优雅代码</h2><p>平时写项目的时候我们都是在第一时间完成需求功能的开发、提测修改 <code>bug</code> 等，然后开开心心的等待着发布生产以为没啥事情了。其实回过头来细细的看我们平时写的代码，可能会发现很多地方都是值得优化的，比如对于很多重复性很强的代码，比如对于某些写得很繁杂的地方。优雅的代码可以化机械为自动、化繁为简，看人开了如沐春风，心情大好。这里列了几个在 <code>Vue</code> 中一定会遇到的问题，然后通过优雅的方式进行解决。</p><h3 id="自动化导入模块"><a href="#自动化导入模块" class="headerlink" title="自动化导入模块"></a>自动化导入模块</h3><p>在开发一个稍微大点的项目的时候，会习惯将路由按照模块来划分，然后就可能会出现如下这种代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">// 导入了一大堆路由文件</span></span><br><span class="line"><span class="keyword">import</span> mediator <span class="keyword">from</span> <span class="string">&#x27;./mediator&#x27;</span></span><br><span class="line"><span class="keyword">import</span> judges <span class="keyword">from</span> <span class="string">&#x27;./judges&#x27;</span></span><br><span class="line"><span class="keyword">import</span> disputeMediation <span class="keyword">from</span> <span class="string">&#x27;./disputeMediation&#x27;</span></span><br><span class="line"><span class="keyword">import</span> onlineMediation <span class="keyword">from</span> <span class="string">&#x27;./onlineMediation&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useraction <span class="keyword">from</span> <span class="string">&#x27;./useraction&#x27;</span></span><br><span class="line"><span class="keyword">import</span> organcenter <span class="keyword">from</span> <span class="string">&#x27;./organcenter&#x27;</span></span><br><span class="line"><span class="keyword">import</span> admin <span class="keyword">from</span> <span class="string">&#x27;./admin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> routeList = []</span><br><span class="line">routeList.push(mediator, judges, disputeMediation, onlineMediation, useraction, organcenter, admin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes: routeList,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其实真实的远远不止这么点，就我本地项目而言就有20几个路由文件，写了一大堆的导入代码，显得很臃肿，更无奈的是每当需要新增一个路由模块，还得再次 <code>import</code> 再次 <code>push</code>，那么有没有什么办法可以解决这个问题呢？答案自然是有的。</p><p>利用 <code>webpack</code> 的 <a href="https://webpack.js.org/guides/dependency-management/#requirecontext"><code>require.context</code></a> 就可以很优雅的解决这个问题，使用语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(</span><br><span class="line">    directory,  <span class="comment">// 搜索的目录</span></span><br><span class="line">    useSubdirectories = <span class="literal">true</span>,  <span class="comment">// 是否搜索子目录</span></span><br><span class="line">    regExp = <span class="regexp">/^\.\/.*$/</span>,  <span class="comment">// 匹配的目标文件格式</span></span><br><span class="line">    mode = <span class="string">&#x27;sync&#x27;</span>  <span class="comment">// 同步还是异步</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>有了这个语法，我们就能很容易的写出下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> routeList = []</span><br><span class="line"><span class="keyword">let</span> importAll = <span class="built_in">require</span>.context(<span class="string">&#x27;@/publicResource/router&#x27;</span>, <span class="literal">false</span>, <span class="regexp">/\.js$/</span>)</span><br><span class="line">importAll.keys().map(<span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 因为 index.js 也在 @/publicResource/router 目录下，所以需要排除</span></span><br><span class="line">    <span class="keyword">if</span> (!path.includes(<span class="string">&#x27;index.js&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">//兼容处理：.default 获取 ES6 规范暴露的内容; 后者获取 commonJS 规范暴露的内容</span></span><br><span class="line">        <span class="keyword">let</span> router = importAll(path).default || importAll(path)</span><br><span class="line">        routeList(router)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes: routeList,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其实不仅仅只是用在导入路由模块这里，对于项目里任何需要导入大量本地模块的地方都可以使用这种方式来解决。</p><h3 id="模块化注册插件"><a href="#模块化注册插件" class="headerlink" title="模块化注册插件"></a>模块化注册插件</h3><p>相信写 <code>Vue</code> 的同学们都知道 <code>element-ui</code> 这个组件库，在使用这个组件库的时候大部分都是只使用某些个别的组件，所以基本上都是按需引入需要的组件，然后就有如下一堆 <code>Vue.use()</code> 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    Input,</span><br><span class="line">    Radio,</span><br><span class="line">    RadioGroup,</span><br><span class="line">    Checkbox,</span><br><span class="line">    CheckboxGroup,</span><br><span class="line">    Select</span><br><span class="line">    <span class="comment">// 还有很多组件</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Input)</span><br><span class="line">Vue.use(Radio)</span><br><span class="line">Vue.use(RadioGroup)</span><br><span class="line">Vue.use(Checkbox)</span><br><span class="line">Vue.use(CheckboxGroup)</span><br><span class="line">Vue.use(Select)</span><br></pre></td></tr></table></figure><p>这样写是没任何问题的，就是看着不够简洁舒服，那更优雅的做法是把这块逻辑抽到一个文件里，然后通过注册插件的方式来使用他们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elementComponent.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    Input,</span><br><span class="line">    Radio,</span><br><span class="line">    RadioGroup,</span><br><span class="line">    Checkbox,</span><br><span class="line">    CheckboxGroup,</span><br><span class="line">    Select</span><br><span class="line">    <span class="comment">// 还有很多组件</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = &#123;</span><br><span class="line">    Input,</span><br><span class="line">    Radio,</span><br><span class="line">    RadioGroup,</span><br><span class="line">    Checkbox,</span><br><span class="line">    CheckboxGroup,</span><br><span class="line">    Select</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(components).forEach(<span class="function"><span class="params">key</span> =&gt;</span> Vue.use(components[key]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; install &#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>main.js</code> 里使用这个插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> elementComponent <span class="keyword">from</span> <span class="string">&#x27;./config/elementComponent&#x27;</span></span><br><span class="line">Vue.use(elementComponent)</span><br></pre></td></tr></table></figure><h3 id="优雅导出请求接口"><a href="#优雅导出请求接口" class="headerlink" title="优雅导出请求接口"></a>优雅导出请求接口</h3><p>不知道大伙是如何定义请求接口的，就我目前这个项目而言，是这么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api.js</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;./config/httpServer.js&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 登入页面获取公钥 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getPublicKey = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http(&#123; <span class="attr">url</span>: <span class="string">&#x27;/userGateway/user/getPublicKey&#x27;</span> &#125;, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> login = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http(&#123; <span class="attr">url</span>: <span class="string">&#x27;/userGateway/userSentry/login&#x27;</span> &#125;, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证码登录</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loginByCode = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http(&#123; <span class="attr">url</span>: <span class="string">&#x27;/userGateway/userSentry/loginByCode&#x27;</span> &#125;, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中使用接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; getPublicKey &#125; <span class="keyword">from</span> <span class="string">&#x27;./config/api.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        getPublicKey().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// xxx</span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// xxx</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这一切都很正常，但，我们这个项目总共有200多个接口，按照上面这种定义方式的话，一个接口定义加上空行需要占用 5 行，所以如果把全部接口都定义到这个 <code>api.js</code> 里需要占用 1000 行左右，看了实在让人心很慌呀。所以觉得应该这个地方应该可以优化一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/userGateway/user/getPublicKey</span><br></pre></td></tr></table></figure><p>上面这是一个后端给接口路径，斜杆把这个路径划分成 3 个子串，而最后一个子串必定是唯一的，所以我们可以从中做文章。于是乎就有了下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api.js</span></span><br><span class="line"><span class="keyword">const</span> apiList = [</span><br><span class="line">    <span class="string">&#x27;/userGateway/user/getPublicKey&#x27;</span>,  <span class="comment">// 登入页面获取公钥</span></span><br><span class="line">    <span class="string">&#x27;/userGateway/userSentry/login&#x27;</span>,  <span class="comment">// 用户登录</span></span><br><span class="line">    <span class="string">&#x27;/userGateway/userSentry/loginByCode&#x27;</span>,  <span class="comment">// 验证码登录</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apiName, API = &#123;&#125;</span><br><span class="line">apiList.forEach(<span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用正则取到接口路径的最后一个子串，比如: getPublicKey</span></span><br><span class="line">    apiName = <span class="regexp">/(?&lt;=\/)[^/]+$/</span>.exec(path)[<span class="number">0</span>]</span><br><span class="line">    API[apiName] = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> http(&#123;<span class="attr">url</span>: path&#125;, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> &#123; API &#125;</span><br></pre></td></tr></table></figure><p>这样大概就把定义一个接口需要占用 5 行缩小到只需要 1 行了，大大减小了文件内容。在浏览这个文件的时候，我的鼠标滚轮也不会一直在滚滚滚了。</p><p>如果是这样定义接口的话，那在使用的时候还需要做点变化的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; API &#125; <span class="keyword">from</span> <span class="string">&#x27;./config/api.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        API.getPublicKey().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// xxx</span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// xxx</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="4种-event传参方式"><a href="#4种-event传参方式" class="headerlink" title="4种$event传参方式"></a>4种$event传参方式</h2><p>在进行实际项目开发的时候经常会需要通过事件传递参数，这里总结了4种应用场景。</p><h3 id="用于组件通信"><a href="#用于组件通信" class="headerlink" title="用于组件通信"></a>用于组件通信</h3><p>比如子组件通过 <code>$emit</code> 来调用父组件方法的时候，可以在父组件中用 <code>$event</code> 接收到从子组件传递过来的参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;changeText&#x27;, &#x27;18px&#x27;)&quot;</span>&gt;</span>点击加大字号<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> @<span class="attr">changeText</span>=<span class="string">&quot;changeText(&#x27;article&#x27;, $event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">changeText(type, value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(type, value)  <span class="comment">// &#x27;article&#x27; &#x27;18px&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子组件传递过来的参数有多个，这个时候用 <code>$event</code> 就不太行了，此时可以用 <code>arguments</code> 代替：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;changeText&#x27;, &#x27;red&#x27;, &#x27;18px&#x27;)&quot;</span>&gt;</span>点击改变样式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> @<span class="attr">changeText</span>=<span class="string">&quot;changeText(...arguments, &#x27;article&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">changeText(...value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( value )  <span class="comment">// [&#x27;red&#x27;, &#x27;18px&#x27;, &#x27;article&#x27;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递原生DOM事件对象"><a href="#传递原生DOM事件对象" class="headerlink" title="传递原生DOM事件对象"></a>传递原生DOM事件对象</h3><p>比如我们需要获取到当前的点击元素，就可以通过给点击事件传递 <code>$event</code> 参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;submit(&#x27;first&#x27;, $event)&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">submit(type, event) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = event.target.tagName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用于第三方类库事件回调"><a href="#用于第三方类库事件回调" class="headerlink" title="用于第三方类库事件回调"></a>用于第三方类库事件回调</h3><p>比如有一个组件里使用了好几个 <code>element-ui</code> 的分页组件，每个分页都有一个 <code>current-change</code> 事件，用来处理当分页改变之后的事情，这样的话我们就需要写多个回调函数，但是如果用以下方式，我们就也可以只写一个函数，通过 <code>type</code> 来判断是哪个分页的回调，而 <code>$event</code> 则用来传递 <code>current-change</code> 回调默认的参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面列表的分页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span> </span></span><br><span class="line"><span class="tag">    @<span class="attr">current-change</span>=<span class="string">&quot;changePage(&#x27;main&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 弹窗A列表的分页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span> </span></span><br><span class="line"><span class="tag">    @<span class="attr">current-change</span>=<span class="string">&quot;changePage(&#x27;modalA&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 弹窗B列表的分页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span> </span></span><br><span class="line"><span class="tag">    @<span class="attr">current-change</span>=<span class="string">&quot;changePage(&#x27;modalB&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">changePage(type, page) &#123;</span><br><span class="line">    <span class="keyword">const</span> types = [<span class="string">&#x27;main&#x27;</span>, <span class="string">&#x27;modalA&#x27;</span>, <span class="string">&#x27;modalB&#x27;</span>]</span><br><span class="line">    types[type] &amp;&amp; (<span class="built_in">this</span>[types[type]].pageIndex = page) &amp;&amp; <span class="built_in">this</span>.getList(type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用箭头函数处理"><a href="#使用箭头函数处理" class="headerlink" title="使用箭头函数处理"></a>使用箭头函数处理</h3><p>对于第三种场景，使用第三方类库组件的时候，需要给事件回调增加额外的参数，如果默认的回调参数只有1个那么我们就可以使用上面的那种方式，但是如果回调参数有多个的话，用 <code>$event</code> 就不好处理了，可以使用箭头函数。比如文件上传的时候，有个 <code>on-change</code> 属性，当文件变化的时候就会触发回调，正常情况下我们这样写是没问题的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span> <span class="attr">:on-change</span>=<span class="string">&quot;changeFile&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">changeFile(file, fileList) &#123;&#125;</span><br></pre></td></tr></table></figure><p>但是如果一个组件里有多个文件上传，而我们又不想写多个 <code>changeFile</code>，那就需要传递额外的参数 <code>type</code> 了 ：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span> <span class="attr">:on-change</span>=<span class="string">&quot;(file, fileList) =&gt; changeFile(&#x27;org&#x27;, file, fileList)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">changeFile(type, file, fileList) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="3种深入watch的用法"><a href="#3种深入watch的用法" class="headerlink" title="3种深入watch的用法"></a>3种深入watch的用法</h2><h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><p><code>watch</code> 是 <code>Vue</code> 中的侦听器，可以侦听一个 <code>Vue</code> 实例上的数据，当数据变动的时候，就会触发该侦听器。所以他的应用场景就是：当某个数据变动后需要做什么的时候就可以使用 <code>watch</code> 啦。<br>对于 <code>watch</code>，平常我们写得最多的估计是如下这种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    list: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getMsg()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们希望组件初始化的时候就执行一次 <code>getMsg</code> 方法，可以直接在 <code>mounted</code> 里调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">this</span>.getMsg()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，还有一种更加简便的写法，通过给 <code>watch</code> 设置 <code>immediate: true</code> ，即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    list: &#123;</span><br><span class="line">        handler(val) &#123;  <span class="comment">// 注意别写错成 handle</span></span><br><span class="line">            <span class="built_in">this</span>.getMsg()</span><br><span class="line">        &#125;,</span><br><span class="line">        immediate: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度监听"><a href="#深度监听" class="headerlink" title="深度监听"></a>深度监听</h3><p>侦听器对于属性变更后会自动调用一次，但是仅限于该属性本身，如果变更的是属性的属性，则不会触发侦听回调，如果想要实现这个功能可以给 <code>watch</code> 加上 ‘deep: true’ 即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">        handler(val) &#123; <span class="comment">// do something &#125;,</span></span><br><span class="line">        deep: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">this</span>.obj.name = <span class="string">&#x27;bubuzou&#x27;</span>  <span class="comment">// 将触发 handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个handlers"><a href="#多个handlers" class="headerlink" title="多个handlers"></a>多个handlers</h3><p>实际上，<code>watch</code> 可以设置为数组，支持类型为 <code>String</code>、<code>Object</code> 和 <code>Function</code>。触发后，多个处理函数都将被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    obj: [</span><br><span class="line">        <span class="string">&#x27;print&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            handler: <span class="string">&#x27;print&#x27;</span>,</span><br><span class="line">            deep: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">val, oldValue</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(val)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5个其他开发小技巧"><a href="#5个其他开发小技巧" class="headerlink" title="5个其他开发小技巧"></a>5个其他开发小技巧</h2><p>掌握 <code>Vue</code> 的开发小技巧，在一些特定的场景下真的很管用，这里列了一些常用的小技巧。</p><h3 id="函数式组件实现零时变量"><a href="#函数式组件实现零时变量" class="headerlink" title="函数式组件实现零时变量"></a>函数式组件实现零时变量</h3><p>我们在使用插槽的时候，知道有一个叫做插槽 <code>prop</code> 的知识，今天我们用他和函数式组件结合在一块，实现一个零时变量的组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tempvar.vue</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    functional: <span class="literal">true</span>,</span><br><span class="line">    render(h, context) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; props,  scopedSlots&#125; = context</span><br><span class="line">        <span class="keyword">return</span> scopedSlots.default &amp;&amp; scopedSlots.default(props || &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>定义好了函数式组件，我们就可以在需要的地方引入且使用他：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tempvar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:var1</span>=<span class="string">&quot;`hello $&#123;user.name&#125;`&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:var2</span>=<span class="string">&quot;user.age ? user.age : &#x27;18&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123;var1, var2&#125;&quot;</span>&gt;</span></span><br><span class="line">       姓名： &#123;&#123; var1 &#125;&#125;</span><br><span class="line">       年龄：&#123;&#123; var2 &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tempvar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> tempvar <span class="keyword">from</span> <span class="string">&#x27;@/components/tempvar.vue&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                user: &#123;</span><br><span class="line"><span class="javascript">                    name: <span class="string">&#x27;bubuzou&#x27;</span>,</span></span><br><span class="line">                    age: 12,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        components: &#123;</span><br><span class="line">            tempvar</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可能细心的小伙伴发现了，要把名字前加个 <code>hello</code>、默认年龄设置为 <code>18</code> 用计算属性就可以了呀？为啥还要搞那么复杂，专门用一个函数式组件去实现呢？其实这个小技巧还是很有必要存在的，当许多组件都有这种数据的重新计算的时候，如果没有使用这个技巧，那么就需要写很多很多的计算属性，而有了函数式组件 <code>tempvar</code> 后，只需要在组件里引入他，然后写插槽就好了。就相当于把写计算属性的功夫花在了写插槽上了。总而言之，两种方式都可以实现类似的属性计算功能，该怎么选，随你喜欢啦。</p><h3 id="调试template（不推荐）"><a href="#调试template（不推荐）" class="headerlink" title="调试template（不推荐）"></a>调试template（不推荐）</h3><p>在开发调试的时候经常会需要通过 <code>console.log</code> 来打印出某个数据对象来查看其内部的结构或者字段值，但是这样做肯定不必在 <code>template</code> 里将其输出更直接。比如有这样一个数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj: &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">    age: <span class="number">21</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模板中展示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面渲染完成后会看到：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;name&quot;: &quot;bubuzou&quot;, &quot;age&quot;: 21 &#125;</span><br></pre></td></tr></table></figure><p>对于这样的渲染结果虽然没什么问题，但是如果这个 <code>obj</code> 是层级很深且字段很多的数据，显示出来就会一堆数据砸在一块，丝毫没有阅读体验。</p><p>因此基于这个背景，我们可以将 <code>console.log</code> 挂载在 <code>Vue</code> 的实例原型上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$log = <span class="built_in">window</span>.console.log</span><br></pre></td></tr></table></figure><p>然后就可以开开心心在模板中使用他了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; $log( obj ) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样会在浏览器控制台输出当前的数据对象，在显示效果上和 <code>console.log</code> 直接打印别无二致。</p><p>但说了这么多，使用 <code>Vue</code> 进行开发调试还是强烈推荐官方的<a href="https://github.com/vuejs/vue-devtools">vue-devtools</a> 工具，谁用谁知道。</p><h3 id="监听子组件的钩子函数"><a href="#监听子组件的钩子函数" class="headerlink" title="监听子组件的钩子函数"></a>监听子组件的钩子函数</h3><p>通常如果我们想在子组件钩子函数触发的时候通知父组件，我们可以这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> @<span class="attr">mounted</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;mounted&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其实还有一种更加简单的写法，那就是使用 <code>hookEvent</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> @<span class="attr">hook:mounted</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>钩子函数除了以上用法，还可以通过动态注册做一些别的事情，比如组件销毁前进行资源的释放：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">let</span> setIntervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">888</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.$once(<span class="string">&quot;hook:beforeDestroy&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(setIntervalId)</span><br><span class="line">        setIntervalId = <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由参数解耦"><a href="#路由参数解耦" class="headerlink" title="路由参数解耦"></a>路由参数解耦</h3><p>参数解耦，啥意思呢？别着急，我们先来看比如对于这么一串路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = [&#123;</span><br><span class="line">    path: <span class="string">&#x27;/home/:type/:id&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>当前页面的路径是 <code>http://xxx/detail/preview/21?sex=male</code>，平时我们写代码的时候或多或少的会写出这种代码，在组件里使用 <code>$route</code> 给组件传参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.$route.params.type === <span class="string">&#x27;preview&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.isPreview = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isPreview = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.id = <span class="built_in">this</span>.$route.params.id</span><br><span class="line">    <span class="built_in">this</span>.sex = <span class="built_in">this</span>.$route.query.sex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子写本身没什么问题，就是会使得组件和路由高度耦合，让组件只能在含有特定 <code>URL</code> 的页面中使用，限制了组件的通用性。其实，我们可以通过 <code>props</code> 传参，来解耦路由参数，将上面的路由配置改成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = [&#123;</span><br><span class="line">    path: <span class="string">&#x27;/home/:type/:id&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    props: <span class="function">(<span class="params">route</span>) =&gt;</span> (&#123;</span><br><span class="line">        type: route.params.type,</span><br><span class="line">        id: route.params.id,</span><br><span class="line">        sex: route.query.sex,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>然后在组件 <code>props</code> 加上参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]</span><br></pre></td></tr></table></figure><p>组件里使用参数的时候就不需要用 <code>this.$route</code>，而是可以直接 <code>this.type</code> 即可。这样一来，这个组件就可以在任何地方使用了。</p><h3 id="深度作用选择器"><a href="#深度作用选择器" class="headerlink" title="深度作用选择器"></a>深度作用选择器</h3><p>当给 <code>style</code> 加上 <code>scoped</code>，页面渲染完成后会给 <code>html</code> 和 <code>css</code> 选择器加上哈希值用于表示唯一性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span> <span class="attr">data-v-fae5bece</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-v-fae5bece</span> <span class="attr">class</span>=<span class="string">&quot;el-button el-button-primary&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.home</span> <span class="selector-class">.el-button</span><span class="selector-attr">[data-v-fae5bece]</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于在 <code>style</code> 中被加了 <code>scoped</code> 的组件，其样式将只能作用于组件内部，不会对其子组件造成影响。比如有这样一个组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>父按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.home</span> <span class="selector-class">.el-button</span> &#123;</span></span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>子按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当页面渲染出来后，会是如下结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span> <span class="attr">data-v-fae5bece</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-v-fae5bece</span> <span class="attr">class</span>=<span class="string">&quot;el-button el-button-primary&quot;</span>&gt;</span>父按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span> <span class="attr">data-v-fae5bece</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;el-button el-button-primary&quot;</span>&gt;</span>子按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据上面的 <code>html</code>，我们可以看到 <code>.home .el-button[data-v-fae5bece]</code> 这个选择器作用不到子按钮这个 <code>button</code>。</p><p>在实际项目中，我们有时候需要让父组件的样式能作用到子组件，即使父组件的 <code>style</code> 上加了 <code>scoped</code>，那这个时候就需要用到深度作用选择器 <code>&gt;&gt;&gt;</code>，比如在刚刚的例子上可以给父组件样式加上深度作用选择器。</p><blockquote><p>深度作用选择器会被 <code>Vue Loader</code> 处理，且只能在有预处理器的地方使用。由于某些预处理器比如 <code>Sass</code> 不能正确解析 <code>&gt;&gt;&gt;</code>，所以我们可以使用它的别名：<code>/deep/</code> 或 <code>::v-deep</code> 来替代。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line"><span class="selector-class">.home</span> &#123;</span><br><span class="line">    /deep/ .el-button &#123;</span><br><span class="line">        <span class="selector-tag">font-size</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>加上深度作用选择器后，选择器会由原来的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.home</span> <span class="selector-class">.el-button</span><span class="selector-attr">[data-v-fae5bece]</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>变成如下的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.home</span><span class="selector-attr">[data-v-fae5bece]</span> <span class="selector-class">.el-button</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.im/post/6844903686926254087">vue篇之事件总线（EventBus）</a></li><li>《Vue开发实战》</li></ul><h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><p>如果本文对你有帮助的话，给本文点个在看吧</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202009/gzh.png" alt="大海我来了"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序升级WePY2踩坑记</title>
      <link href="/2020/08/06/wepy2/"/>
      <url>/2020/08/06/wepy2/</url>
      
        <content type="html"><![CDATA[<p>最近有个小程序项目需要迭代，但是迭代任务不多，时间比较充裕。而这个小程序最早是在18年的时候开发的，用的开发框架是 <code>WePY</code> 的 <code>1.7.2</code> 版本，去年也就是 <code>19</code> 年的时候 <code>WePY</code> 框架进行了升级，到了 <code>2.0</code> 版本。升级之后的 <code>WePY</code>，用 <a href="https://wepyjs.github.io/wepy-docs/2.x/#/"><code>WePY</code></a> 官方文档的话来说：通过优化细节，引入 <code>Promise</code>、<code>Async Functions</code> 等让开发小程序项目变得更加简单，高效。基于这些背景，我和小伙伴一拍即合，决定对我们的项目进行框架升级，体验下到底 <code>WePY2</code> 能给我们带来什么。</p><p>本文将以项目改动为出发点，基于当前这个项目的结构和编码方式来考虑到底升级 <code>WePY2</code> 后，哪里需要改，怎么改以及有哪些需要注意的地方，通过对比 <code>2</code> 个版本的写法差异这个思路来写，不会去太较真 <code>WePY2</code> 相对于 <code>WePY1</code> 实现或原理上的区别。下面我将一条一条的列出来需要改动的点。</p><blockquote><p>本篇文章记录的是我和小伙伴这次升级框架遇到的需要改动的地方和坑，所使用的是 <code>wepy</code> 的 <code>2.1.0</code> 版本，后续如果版本升级后，本篇记录到的坑如果已经被修复了，请自行忽略本文所述的问题。另外下文中所说到的 <code>2.x</code> 版本都是指 <code>wepy_v2.1.0</code>。</p></blockquote><a id="more"></a><h2 id="初始化一个WePY2的demo"><a href="#初始化一个WePY2的demo" class="headerlink" title="初始化一个WePY2的demo"></a>初始化一个WePY2的demo</h2><p>由于本地还有其他项目用的是 <code>WePY_v1.7.2</code>，所以我们不能把 <code>WePY2</code> 的 <code>CLI</code> 工具安装在全局环境中，只能安装在当前项目中。官方推荐是直接用 <code>1.7.x</code> 的 <code>CLI</code> 去初始化 <code>2.0.x</code> 的项目:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wepy init standard#2.0.x zzodr</span><br></pre></td></tr></table></figure><p>这样就能够在本地初始化一个 <code>wepy2</code> 的项目模板，但是 <code>@wepy/core</code> 是 <code>2.0.0-alpha.16</code> 版本的，将它更新到最新的 <code>2.1.0</code> 版本，这里也一起更新下整个旧项目和新模板所用到的依赖，下面直接贴出来：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@wepy/core&quot;</span>: <span class="string">&quot;^v2.1.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@wepy/use-intercept&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@wepy/use-promisify&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@wepy/x&quot;</span>: <span class="string">&quot;^2.0.2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;miniprogram-slide-view&quot;</span>: <span class="string">&quot;0.0.3&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@babel/core&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@babel/preset-env&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@wepy/babel-plugin-import-regenerator&quot;</span>: <span class="string">&quot;0.0.2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@wepy/cli&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@wepy/compiler-babel&quot;</span>: <span class="string">&quot;^2.0.1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@wepy/compiler-sass&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@wepy/plugin-define&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;babel-eslint&quot;</span>: <span class="string">&quot;^7.2.1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cross-env&quot;</span>: <span class="string">&quot;^5.1.3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;eslint&quot;</span>: <span class="string">&quot;^3.18.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;eslint-config-standard&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;eslint-friendly-formatter&quot;</span>: <span class="string">&quot;^2.0.7&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;eslint-plugin-html&quot;</span>: <span class="string">&quot;^2.0.1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;eslint-plugin-promise&quot;</span>: <span class="string">&quot;^3.5.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;eslint-plugin-standard&quot;</span>: <span class="string">&quot;^2.0.1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;wepy-eslint&quot;</span>: <span class="string">&quot;^1.5.3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来操作主要是删除模板里的代码，然后把项目的结构和代码搬过去。</p><h2 id="wpy文件代码结构调整"><a href="#wpy文件代码结构调整" class="headerlink" title="wpy文件代码结构调整"></a>wpy文件代码结构调整</h2><p><code>WePy</code> 单文件组件主要由 <code>&lt;script&gt;</code>、<code>&lt;template&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;config&gt;</code> 四部分组成（也包括小程序 <code>&lt;wxs&gt;</code> 标签）。所以需要把 <code>WePY 1.7.2</code> 中定义在 <code>&lt;script&gt;</code> 中的 <code>config</code> 配置需要独立到外层的 <code>&lt;config&gt;</code> 中。<br><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">        config = &#123;</span><br><span class="line"><span class="javascript">            navigationBarTitleText: <span class="string">&#x27;首页&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    navigationBarTitleText: &#x27;首页&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="程序-页面-组件注册方式调整"><a href="#程序-页面-组件注册方式调整" class="headerlink" title="程序/页面/组件注册方式调整"></a>程序/页面/组件注册方式调整</h2><p>注册方式将不再使用继承的方式，而是改成直接调用对应的实例方法。<br><code>1.7.2</code> 写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">app</span> </span>&#123;&#125;  <span class="comment">// 注册程序</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;&#125;  <span class="comment">// 注册页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">LIST</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">component</span> </span>&#123;&#125;  <span class="comment">// 注册组件</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wepy.app(&#123;&#125;)  <span class="comment">// 注册程序</span></span><br><span class="line">wepy.page(&#123;&#125;)  <span class="comment">// 注册页面</span></span><br><span class="line">wepy.component(&#123;&#125;)  <span class="comment">// 注册组件</span></span><br></pre></td></tr></table></figure><h2 id="代码结构由类结构变成对象结构"><a href="#代码结构由类结构变成对象结构" class="headerlink" title="代码结构由类结构变成对象结构"></a>代码结构由类结构变成对象结构</h2><p>由于注册方式的改变，那么自然的代码结构也要有所调整。<br><code>1.7.2</code> 写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    methods = &#123;&#125;</span><br><span class="line">    onLoad() &#123;&#125;</span><br><span class="line">    onShow() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wepy.page(&#123;</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    onLoad() &#123;&#125;,</span><br><span class="line">    onShow() &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面仅仅只是以页面做为例子，<code>wepy.app()</code> 和 <code>wepy.component()</code> 也要对应调整。</p><h2 id="自定义方法和组件事件处理函数需要移到-methods-里"><a href="#自定义方法和组件事件处理函数需要移到-methods-里" class="headerlink" title="自定义方法和组件事件处理函数需要移到 methods 里"></a>自定义方法和组件事件处理函数需要移到 methods 里</h2><p>在 <code>WePY 1.7.2</code> 中注册的页面或者组件函数有这么几种类型：</p><ul><li>生命周期函数，比如 <code>onLoad</code>、<code>onShow</code> 等；</li><li><code>wxml</code> 事件处理函数，即在 <code>wxml</code> 中绑定的事件，这类函数需要定义在 <code>methods</code>，比如：<code>bindtap</code>、<code>bindchange</code> 等；</li><li>组件间事件处理函数，响应组件之间通过 <code>$broadcast</code>、<code>$emit</code>、<code>$invoke</code> 所传递的事件函数，这类函数需要定义在 <code>events</code> 对象里；</li><li>自定义函数，即用于被其他函数直接调用的函数，需要定义在和 <code>methods</code> 同级的位置。</li></ul><p>而在 <code>WePY 2</code> 中需要将组件处理函数和自定义函数都放到 <code>methods</code> 里。下面假设 <code>HOME</code> 页面有一个子组件 <code>child</code>，且子组件里会执行这句 <code>this.$emit(&#39;updateList)</code>，基于这个背景看下 <code>2</code> 个版本下的写法差异：</p><p><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">&quot;tapBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line"><span class="javascript">    onLoad() &#123;&#125;  <span class="comment">// 生命周期函数</span></span></span><br><span class="line"><span class="javascript">    onShow() &#123;&#125;  <span class="comment">// 生命周期函数</span></span></span><br><span class="line">    events = &#123;</span><br><span class="line"><span class="javascript">        updateList:<span class="function">() =&gt;</span> &#123;&#125;  <span class="comment">// 组件间事件处理函数</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    methods = &#123;</span><br><span class="line"><span class="javascript">        tapBox() &#123;  <span class="comment">// wxml事件处理函数</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.getMsg()  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    getMsg() &#123;&#125;  <span class="comment">// 自定义函数</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> @<span class="attr">tap</span>=<span class="string">&quot;tapBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">wepy.page(&#123;</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line"><span class="javascript">    onLoad() &#123;&#125;,  <span class="comment">// 生命周期函数</span></span></span><br><span class="line"><span class="javascript">    onShow() &#123;&#125;,  <span class="comment">// 生命周期函数</span></span></span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">        tapBox() &#123;  <span class="comment">// wxml事件处理函数</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.getMsg()  </span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        updateList() &#123;&#125;,  <span class="comment">// 组件间事件处理函数</span></span></span><br><span class="line"><span class="javascript">        getMsg() &#123;&#125;,  <span class="comment">// 自定义函数</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件引入方式变更"><a href="#组件引入方式变更" class="headerlink" title="组件引入方式变更"></a>组件引入方式变更</h2><p>在 <code>2.x</code> 版本中组件引入不再通过 <code>import</code> 进行导入，而是直接定义在页面的配置 <code>&lt;config&gt;</code> 中。<br><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&#x27;./components/child.wpy&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">    components = &#123;</span><br><span class="line">        child: Child</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">wepy.page(&#123;&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    usingComponents: &#123;</span><br><span class="line">        &#x27;child&#x27;: &#x27;./components/child.wpy&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，<code>2.x</code> 中已经再不支持在 <code>app.wpy</code> 里定义全局组件，而 <code>1.7.2</code> 中是可以的。</p><h2 id="生命周期函数调整"><a href="#生命周期函数调整" class="headerlink" title="生命周期函数调整"></a>生命周期函数调整</h2><p>在 <code>2.x</code> 中生命周期函数基本和原生保持一致，和 <code>1.7.2</code> 相比，只是需要把组件中的 <code>onLoad</code> 改成了 <code>ready</code> 即可，其他无需变动。</p><table><thead><tr><th align="center">级别</th><th align="center">1.7.2</th><th align="center">2.x</th></tr></thead><tbody><tr><td align="center">app</td><td align="center">onLaunch</td><td align="center">onLaunch</td></tr><tr><td align="center">app</td><td align="center">onShow</td><td align="center">onShow</td></tr><tr><td align="center">page</td><td align="center">onLoad</td><td align="center">onLoad</td></tr><tr><td align="center">page</td><td align="center">onShow</td><td align="center">onShow</td></tr><tr><td align="center">page</td><td align="center">onReady</td><td align="center">onReady</td></tr><tr><td align="center">component</td><td align="center">-</td><td align="center">created</td></tr><tr><td align="center">component</td><td align="center">-</td><td align="center">attached</td></tr><tr><td align="center">component</td><td align="center">onLoad</td><td align="center">ready</td></tr></tbody></table><p><code>2.x</code> 生命周期执行顺序：</p><p><code>app onLaunch</code> -&gt; <code>app onShow</code> -&gt; <code>component created</code> -&gt; <code>component attached</code> -&gt; <code>page onLoad</code> -&gt; <code>page onShow</code> -&gt; <code>component ready</code> -&gt; <code>page onReady</code> -&gt; <code>page onUnload</code> -&gt; <code>component detached</code></p><blockquote><p><code>page onHide</code> 在当前页面通过 <code>wx.navigateTo</code> 打开新页面的时候会执行，而如果是在当前页面点击返回上一个页面或者 <code>wx.redirectTo</code> 并不会执行。</p></blockquote><h2 id="不再支持请求拦截器（坑）"><a href="#不再支持请求拦截器（坑）" class="headerlink" title="不再支持请求拦截器（坑）"></a>不再支持请求拦截器（坑）</h2><p>在 <code>1.7.2</code> 中可以在 <code>wepy.app</code> 的构造函数里通过配置拦截器可以对请求进行拦截，请求被拦截后可以加上更多的请求参数以及请求响应后可以进行统一的错误处理，功能还是挺好用的。但是在 <code>2.x</code> 中这个功能至少从文档上是没看到，虽然源码里提供了一个 <a href="https://github.com/Tencent/wepy/tree/master/packages/use-intercept">use-intercept</a>拦截器的包，但是经过我几番尝试之后还是报错，所以就打算弃用拦截器了，直接在请求里进行参数增加和错误处理。<br><code>request.js</code> 这里贴一份大概的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wepy <span class="keyword">from</span> <span class="string">&quot;@wepy/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HOST &#125; <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">url, data, handler = toast, header = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 头参数添加</span></span><br><span class="line">    header[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">    header[<span class="string">&quot;cType&quot;</span>] = <span class="string">&quot;WECHAT&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wepy.wx.request(&#123;  <span class="comment">// 这里 wepy.wx.request 这种写法，需要在app.wpy里配置promisify，</span></span><br><span class="line">        method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        data: data || &#123;&#125;,</span><br><span class="line">        header,</span><br><span class="line">        url: <span class="string">`<span class="subst">$&#123;HOST&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 请求成功处理代码放这儿</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(data)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 错误处理代码放这儿</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>wepy.wx.request</code> 这种写法需要在 <code>app.wpy</code> 里配置 <code>promisify</code>，可以参考这里 <a href="https://github.com/Tencent/wepy/tree/master/packages/use-promisify">use-promisify</a></p><h2 id="标签属性的值必须被双引号包裹"><a href="#标签属性的值必须被双引号包裹" class="headerlink" title="标签属性的值必须被双引号包裹"></a>标签属性的值必须被双引号包裹</h2><p>在 <code>1.7.2</code> 中对单引号和双引号没有强制要求，但是在 <code>2.x</code> 中必须是双引号，不然编译会报错。<br><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">bindtap</span>=<span class="string">&#x27;change&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">       &lt;view class&#x3D;&quot;title&quot; bindtap&#x3D;&quot;change&quot;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h2 id="调用原生事件需要传入参数-wx"><a href="#调用原生事件需要传入参数-wx" class="headerlink" title="调用原生事件需要传入参数$wx"></a>调用原生事件需要传入参数$wx</h2><p>小程序原生事件会传递一个 event 参数。而 <code>WePY</code> 的事件分发器在处理事件时会有一个 <code>$event</code> 参数。 <code>$event</code> 参数是对 <code>event</code> 进行了一层包装，目地是为了无侵入地对齐 <code>Web Event</code> 标准属性。而其中 <code>$event.$wx === event</code>。 因此，<code>WePY</code> 中响应事件获得的事件参数均是指 <code>$event</code>。如果想拿到原生事件参数，请使用 <code>$event.$wx</code>。<br><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">bindinput</span>=<span class="string">&quot;setInput&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;name&#125;&#125;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">    data = &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">    methods = &#123;</span><br><span class="line">        setInput(e) &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.name = e.detail.value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法，只需要将 <code>bindinput=&quot;setInput&quot;</code> 改成 <code>@input=&quot;setInput($wx)&quot;</code> 即可。</p><h2 id="模板语法修改"><a href="#模板语法修改" class="headerlink" title="模板语法修改"></a>模板语法修改</h2><p><code>2.x</code> 的模板语法继承了 <code>WXML</code> 的基本模板语法，并支持大部分 <code>Vue</code> 模板语法。<br>对于标签：<code>2.x</code> 支持绝大部分的 <code>HTML</code> 标签，经过编译后会转成标准的 <code>WXML</code> 模板语法。但是对于 <code>1.7.2</code> 中的有一个标签 <code>&lt;repeat&gt;</code> 不再支持，需要将其替换成 <code>&lt;view&gt;</code> 并且用 <code>v-for</code> 进行循环渲染。</p><p>下面是一些常用的模板语法对于 <code>2</code> 个版本之间写法的对比：<br><code>1.7.2</code> 写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 属性绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">&quot;&#123;&#123; id &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 数据绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 事件绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">&quot;change(&#123;&#123; index &#125;&#125;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- class绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;change &#123;&#123;hasData ? &#x27;has-data&#x27; : &#x27;&#x27; &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- style绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;&#123;&#123; &#x27;color:&#x27; + color + &#x27;;&#x27; + &#x27;font-size:&#x27; + fontSize + &#x27;;&#x27; &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 条件判断 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123; flag1 &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123; flag2 &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 显示判断 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">hidden</span>=<span class="string">&quot;&#123;&#123; !isShow &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 列表渲染，默认是：item、index --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123; array &#125;&#125;&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;idx&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;itemName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 属性绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">:id</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 数据绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 事件绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> @<span class="attr">tap</span>=<span class="string">&quot;change( index )&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- class绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;change&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; &#x27;has-data&#x27;: hasData &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- style绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;&#x27;color&#x27;: color, &#x27;font-size&#x27;: fontSize &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 条件判断 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-if</span>=<span class="string">&quot;flag1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-else-if</span>=<span class="string">&quot;flag2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 显示判断 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 列表渲染，默认是：item、index --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in array&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于 <code>v-for</code> 循环列表的时候这里有一个（坑）不得不提一下，<a href="https://github.com/Tencent/wepy/issues/2673#issue-673257402">github issues</a>直接看下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">v-for</span>=<span class="string">&quot;item in array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> @<span class="attr">tap</span>=<span class="string">&quot;tapItem(index)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于上面的代码，<code>&lt;view&gt;&#123;&#123; index &#125;&#125;&lt;/view&gt;</code> 可以正常显示索引值 <code>index</code>，但是 <code>tapItem</code> 传的参数却是 <code>undefined</code>，这所以我们需要显示的声明索引 <code>v-for=&quot;(item, index) in array&quot;</code> 即可。</p><h2 id="表单双向绑定调整"><a href="#表单双向绑定调整" class="headerlink" title="表单双向绑定调整"></a>表单双向绑定调整</h2><p><code>2.x</code> 中直接用 <code>v-model</code> 进行表单绑定，而不需要再定义一个函数对其进行赋值操作。<br><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; name &#125;&#125;&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;setInput&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">    data = &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">    methods = &#123;</span><br><span class="line">        bindtap(e) &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.name = e.detail.value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">wepy.page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="全局数据属性获取方式调整"><a href="#全局数据属性获取方式调整" class="headerlink" title="全局数据属性获取方式调整"></a>全局数据属性获取方式调整</h2><p>我们有时候需要在 <code>app.wpy</code> 里定义全局数据属性 <code>globalData</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">app</span> </span>&#123;</span><br><span class="line">    globalData = &#123;</span><br><span class="line">        isBack: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>2.x</code> 中定义方式没变，但是获取方式有所调整：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.7.2 获取方式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.globalData.isBack)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.x 获取方式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$app.$options.globalData.isBack)</span><br></pre></td></tr></table></figure><h2 id="全局样式对组件无效"><a href="#全局样式对组件无效" class="headerlink" title="全局样式对组件无效"></a>全局样式对组件无效</h2><p><code>2.x</code> 中对组件的实现方式保留了很多原生小程序的特性，比如这一条，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html">组件样式</a> 中明确说明：除继承样式外， <code>app.wxss</code> 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项），虽然可以通过更改组件样式隔离选项使得组件可以被全局样式作用到，但有时候也会带来弊端，比如在标签的属性 <code>class</code> 前面加上 <code>~</code>，可以使组件获取全局样式，但是这样一来也带来一个问题，就是定义在组件里的该 <code>class</code> 样式会失效😭。这样的升级真的让写样式很难受，所以为了让样式写得尽量方便简单，我还是老老实实的把组件的样式就定义在组件里，不从全局拿样式了。</p><h2 id="组件通信不再支持-broadcast"><a href="#组件通信不再支持-broadcast" class="headerlink" title="组件通信不再支持$broadcast"></a>组件通信不再支持$broadcast</h2><p>父组件给子组件传递数据可以通过设置静态或者动态的 <code>prop</code> 属性或者通过广播 <code>$broadcast</code> 来让所有子组件都收到父组件的信息，而子组件给父组件通信可以通过在父级自定义事件，在子组件中通过 <code>$emit</code> 来通信。但是在 <code>2.x</code> 中不再支持父级给子组件进行事件广播了，而是可以通过给子组件加上 <code>ref</code> 属性后，通过 <code>this.$refs</code> 来直接操作子组件函数来达成通信的目的，如下代码：<br><code>parent.wpy</code>: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">wepy.page(&#123;</span><br><span class="line">    onLoad() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$refs.child.getList()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>child.wpy</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">wepy.component(&#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getList() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="组件prop不再支持双向绑定"><a href="#组件prop不再支持双向绑定" class="headerlink" title="组件prop不再支持双向绑定"></a>组件prop不再支持双向绑定</h2><p>在 <code>1.7.2</code> 中可以通过可以通过设置 <code>prop</code> 给子组件传参，如果设置的时候加上 <code>.sync</code> 那么当父组件参数更新的时候，传递给子组件的也会自动更新，而如果在子组件的 <code>prop</code> 里加上 <code>twoWay: true</code> 则子组件数据可以绑定到父组件。从而实现组件数据的双向绑定。功能还是挺好用的，但遗憾的是在 <code>2.x</code> 中已经不再支持通过 <code>twoWay: true</code> 的方式从子组件绑定数据到父组件，父到子是可以的，但是不再需要设置 <code>sync</code>。那子组件需要更新父组件的数据，只能通过自定义事件，然后在子组件通过 <code>$emit</code> 进行更新数据了。<br><code>1.7.2</code> 写法：<br>父页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:title.sync</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tempalte</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default class CHILD extends wepy.component &#123;</span><br><span class="line">    props = &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            default: &#x27;&#x27;,</span><br><span class="line">            twoWay: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：<br>父页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span> @<span class="attr">changeTitle</span>=<span class="string">&quot;changeTitle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tempalte</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">        data = &#123;</span><br><span class="line"><span class="javascript">            title: <span class="string">&#x27;最开始的标题&#x27;</span>,</span></span><br><span class="line">        &#125;</span><br><span class="line">        events = &#123;</span><br><span class="line">            changeTitle(val) &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.title = val</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wepy.page(&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            default: &#x27;&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onLoad()&#123;</span><br><span class="line">        this.$emit(&#x27;changeTitle&#x27;, &#x27;改变之后的标题&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h2 id="组件插槽slot代码插入后层级错乱问题（坑）"><a href="#组件插槽slot代码插入后层级错乱问题（坑）" class="headerlink" title="组件插槽slot代码插入后层级错乱问题（坑）"></a>组件插槽slot代码插入后层级错乱问题（坑）</h2><p>这个问题已经提到 <a href="https://github.com/Tencent/wepy/issues/2649#issue-655560396">github issues</a> 中，且已经被作者标记为 <code>bug</code>。<br>原始代码：<br><code>parent.wpy</code> 父页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span>&gt;</span>child view<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>child.wpy</code> 子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span>&gt;</span>child<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>期望的编译后（正确）的 <code>template</code> 是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span>&gt;</span>child<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span>&gt;</span>child view<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而实际 <code>2.x</code> 编译后的 <code>template</code> 是会将对应的内容插入到子组件与根元素并列那级：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span>&gt;</span>child<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>child view<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>针对老项目里用到 <code>slot</code> 的地方，我只能改写代码来避开这个坑了。</p><h2 id="资源引入调整"><a href="#资源引入调整" class="headerlink" title="资源引入调整"></a>资源引入调整</h2><p>资源引入方式调整主要是介绍组件引入和图片引入两种。首先来看组件引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;config&gt;</span><br><span class="line">&#123;</span><br><span class="line">  usingComponents: &#123;</span><br><span class="line">    <span class="string">&#x27;load-more&#x27;</span>: <span class="string">&#x27;/components/loadMore&#x27;</span>,  <span class="comment">// 绝对路径 </span></span><br><span class="line">    <span class="string">&#x27;btn&#x27;</span>: <span class="string">&#x27;../btn&#x27;</span>,  <span class="comment">// 相对路径</span></span><br><span class="line">    <span class="string">&#x27;list&#x27;</span>: <span class="string">&#x27;~@/components/list&#x27;</span>,  <span class="comment">// 通过wepy.config.js配置别名@指向src，实际上也是绝对路径</span></span><br><span class="line">    <span class="string">&#x27;van-icon&#x27;</span>: <span class="string">&#x27;module:van-icon&#x27;</span>,  <span class="comment">// 模块引入</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure><p>对于图片引入，存在两种方式：一种是静态的，程序在编译的时候就知道需要把哪些图片加载出来，另一种是动态的，只有在程序执行的时候才知道要加载哪些图片。对于第一种方式，通过相对路径、绝对路径或者 <code>@</code> 都可以引入到图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;../bg.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/images/icon.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;@/images/nodata.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于第二种方式，需要将动态的图片放置在某个固定的位置，比如 <code>/src/images/static</code>，然后再 <code>wepy.config.js</code> 里配置 <code>static: [&#39;/src/images/static&#39;]</code> 这样在编译的时候就会把这个路径下的文件都拷贝到输出后的目录，从而能够准确引用这些动态图片。<br><code>wepy.config.js</code> 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="keyword">static</span>: [<span class="string">&#x27;src/images/static&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">:src</span>=<span class="string">&quot;&#x27;../images/static/&#x27; + fileType + &#x27;.png&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">:src</span>=<span class="string">&quot;imgSrc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    wepy.page(&#123;</span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            imgSrc: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        onLoad() &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.imgSrc = <span class="string">&#x27;/images/static/icon.png&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>静态图片特殊处理：单独放到一个目录里，然后再WePY.config.js里配置static</p><h2 id="scss里如果引入-wxss文件会直接终止编译进程"><a href="#scss里如果引入-wxss文件会直接终止编译进程" class="headerlink" title="scss里如果引入.wxss文件会直接终止编译进程"></a>scss里如果引入.wxss文件会直接终止编译进程</h2><p>下面的代码是一个页面的 <code>scss</code> 样式里，引入了 <code>wxss</code> 文件，最终会导致编译进程终止。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;./btn.scss&quot;</span>;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;./styles/common.wxss&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;./btn.scss&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style lang=&quot;wxss&quot; type=&quot;text/wxss&quot;&gt;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;./styles/common.wxss&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="scss样式里存在特殊字符会导致编译报错（坑）"><a href="#scss样式里存在特殊字符会导致编译报错（坑）" class="headerlink" title="scss样式里存在特殊字符会导致编译报错（坑）"></a>scss样式里存在特殊字符会导致编译报错（坑）</h2><p>这里的特殊字符其实也是正常的需求，比如引入了字体图标，那可能会有这种样式 <code>content: &#39;\6499&#39;</code>, 然后因为有反斜杠会直接导致报错编译错误。解决思路是把这种带有特殊字符的样式放到 <code>wxss</code> 里，然后通过另外一个 <code>style</code> 引入进来，编译器进行编译的时候会对 <code>scss</code> 样式进行编译处理，但是对于 <code>wxss</code> 会直接拷贝到输入目录，而不进行编译处理，所以能绕过这个坑。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;./btn.scss&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style lang=&quot;wxss&quot; type=&quot;text/wxss&quot;&gt;</span><br><span class="line">    <span class="selector-class">.icon-success</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&#x27;\e8921&#x27;</span>;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="数据绑定机制调整"><a href="#数据绑定机制调整" class="headerlink" title="数据绑定机制调整"></a>数据绑定机制调整</h2><p><code>1.7.2</code> 中用脏检查进行数据绑定，通过 <code>$apply()</code> 方法使得数据能够及时更新，页面重新渲染。在 <code>2.x</code> 中使用了 <code>Vue Observer</code> 实现数据绑定，告别 <code>$apply()</code>，但是遇到一个问题，某个数组项的某个属性更新后，数组虽然是更新了，但是不能够触发页面进行重新渲染，即使使用 <code>splice</code> 也不行。不过可以通过浅拷贝一个引用类型，重新赋值，从而触发页面重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">wepy.page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        list: [&#123;</span><br><span class="line">            name: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">            hasBorder: <span class="literal">true</span>,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: <span class="string">&#x27;bbb&#x27;</span>,</span><br><span class="line">            hasBorder: <span class="literal">false</span>,</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">            <span class="built_in">this</span>.list[<span class="number">1</span>].hasBorder = <span class="literal">true</span>  <span class="comment">// 不会重新渲染页面</span></span><br><span class="line">            <span class="built_in">this</span>.list.splice(<span class="number">1</span>, <span class="number">1</span>, &#123;  <span class="comment">// 也不会重新渲染页面</span></span><br><span class="line">                name: <span class="string">&#x27;bbb&#x27;</span>,</span><br><span class="line">                hasBorder: <span class="literal">true</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="built_in">this</span>.list = [...this.list]  <span class="comment">// 浅拷贝，使得this.list的引用地址变化了，使得页面重新渲染</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序、wepy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的数据类型</title>
      <link href="/2020/07/29/js-datatype/"/>
      <url>/2020/07/29/js-datatype/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中有哪些数据类型？"><a href="#JavaScript中有哪些数据类型？" class="headerlink" title="JavaScript中有哪些数据类型？"></a>JavaScript中有哪些数据类型？</h2><p>计算机世界中定义的数据类型其实就是为了描述现实世界中存在的事实而定义的。比如我们用人来举例：</p><ol><li><p>有没有人在房间里？这里的有和没有就是是或者非的概念，在 <code>JS</code> 中对应 <code>Boolean</code> 类型，<code>true</code> 表示是，<code>false</code> 表示非；</p></li><li><p>有几个人在房间里？这里的几个表示的是一个量级概念，在 <code>JS</code> 中对应 <code>Number</code> 类型，包含整数和浮点数，还有一些特殊的值，比如：<code>-Infinity</code> 表示负无穷大、<code>+Infinity</code> 表示正无穷大、<code>NaN</code>     表示不是一个数字；</p></li><li><p>房间里的这些人都是我的朋友。这是一句陈述语句，这种文本类的信息将会以字符串形式进行存储，在 <code>JS</code> 中对应 <code>String</code> 类型；</p></li><li><p>房间里没有人。这里的没有代表无和空的概念，在 <code>JS</code> 中 <code>null</code> 和 <code>undefined</code> 都可以表示这个意思；</p></li><li><p>现实世界中所有人都是独一无二的，这在 <code>JS</code> 中对应 <code>Symbol</code> 类型，表示唯一且不可改变；</p></li><li><p><code>Number</code> 所表示的整数是有范围的，超出范围的数据就没法用 <code>Number</code> 表示了，于是 <code>ES10</code> 中提出了一种新的数据类型 <code>BigInt</code>，能表示任何位数的整数；</p></li><li><p>以上提到的 <code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>null</code>、<code>undefined</code>、<code>Symbol</code> 和 <code>BigInt</code> 等7种类型都是 <code>JavaScript</code> 中的原始类型，还有一种是非原始类型叫做对象类型；比如：一个人是对象，这个人有名字、性别、年龄等；</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">    sex: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    age: <span class="number">26</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h2 id="为什么要区分原始类型和对象类型？他们之间有什么区别？"><a href="#为什么要区分原始类型和对象类型？他们之间有什么区别？" class="headerlink" title="为什么要区分原始类型和对象类型？他们之间有什么区别？"></a>为什么要区分原始类型和对象类型？他们之间有什么区别？</h2><h3 id="原始类型的不可变性"><a href="#原始类型的不可变性" class="headerlink" title="原始类型的不可变性"></a>原始类型的不可变性</h3><p>在回答这个问题之前，我们先看一下变量在内存中是如何存储的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="keyword">let</span> name2 = name1.concat(<span class="string">&#x27;.com&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(name1)  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure><p>执行完上面这段代码，我们发现变量 <code>name1</code> 的值还是不变，依然是 <code>bubuzou</code>。这就说明了字符串的不可变性。但是你看了下面的这段代码，你就会产生疑问了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">name1 += <span class="string">&#x27;.com&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(name1)  <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure><p>你说字符串是不可变的，那现在不是变了嘛？<br>其实这只是变量的值变了，但是存在内存中的字符串依然不变。这就涉及到变量在内存中的存储了。<br>在 <code>JavaScript</code> 中，变量在内存中有2种存储方式：存在栈中和存在堆中。那么栈内存和堆内存有啥区别呢？</p><p>栈内存：</p><ul><li>顺序存储结构，特点是先进后出。就像一个兵乒球盒子一样，兵乒球从外面一个个的放入盒子里，最先取出来的一定是最后放入盒子的那个。</li><li>存储空间固定</li><li>可以直接操作其保存的值，执行效率高</li></ul><p>堆内存：</p><ul><li>无序的存储结构</li><li>存储空间可以动态变化</li><li>无法直接操作其内部的存储，需要通过引用地址操作</li></ul><p>了解完变量在内存中的存储方式有2种，那我们继续以上面那串代码为例，画出变量的存储结构图：<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype01.png" alt="js_datatype_01-w548"><br>然后我们可以描述下当计算机执行这段代码时候的发生了什么？首先定义了一个变量 <code>name1</code> 并且给其赋值 <code>bubuzou</code> 这个时候就会在内存中开辟一块空间用来存储字符串 <code>bubuzou</code>，然后变量指向了这个内存空间。然后再执行第二行代码 <code>let name2 = name1.concat(&#39;.com&#39;)</code> 这里的拼接操作其实是产生了一个新字符串 <code>bubuzou.com</code>，所以又会为这个新字符串创建一块新内存，并且把定义的变量 <code>name2</code> 指向这个内存地址。 所以我们看到其实整个操作 <code>bubuzou</code> 这个字符串所在的内存其实是没有变化的，即使在第二段代码中执行了 <code>name1 += &#39;.com&#39;</code> 操作，其实也只是变量 <code>name1</code> 指向了新的字符串 <code>bubuzou.com</code> 而已，旧的字符串 <code>bubuzou</code> 依然存在内存中，不过一段时间后由于该字符串没有被变量所引用，所以会被当成垃圾进行回收，从而释放掉该块内存空间。</p><p>从而我们得出结论：原始类型的值都是固定的，而对象类型则是由原始类型的键值对组合成一个复杂的对象；他们在内存中的存储方式是不一样的，原始类型的值直接存在栈内存中，而对象类型的实际值是存在堆内存中的，在栈内存中保存了一份引用地址，这个地址指向堆内存中的实际值，所以对象类型又习惯被叫做引用类型。</p><blockquote><p>想一个问题为什么引用类型的值要存储到堆内存中？能不能存到栈内存中呢？答案一：因为引用类型大小不固定，而栈的大小是固定的，堆空间的大小是可以动态变化的，所以引用类型的值适合存在堆中；答案二：在代码执行过程中需要频繁的切换执行上下文的时候，如果把引用类型的值存到栈中，将会造成非常大的内存开销。</p></blockquote><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>当我们对两个变量进行比较的时候，不同类型的变量是有不同表现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( str1 === str2 ) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( person1 === person2 )  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们定义了2个字符串变量和2个对象变量，他们都长一模一样，但是字符串变量会相等，对象变量却不相等。这是因为在 <code>JavaScript</code> 中，原型类型进行比较的时候比较的是存在栈中的值是否相等；而引用类型进行比较的时候，是比较栈内存中的引用地址是否相等。<br>如上几个变量在内存中的存储模型如图所示：<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype02.png" alt="js_datatype_02"></p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>变量进行复制的时候，原始类型和引用类型变量也是有区别的，来看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = str1</span><br><span class="line">str2 = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( str1 ) <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype03.png" alt="js_datatype_02"></p><ol><li><code>let str1 = &#39;hello&#39;</code>: 复制前，定义了一个变量 <code>str1</code>，并且给其赋值 <code>hello</code>，这个时候 <code>hello</code> 这个字符串就会在栈内存中被分配一块空间进行存储，然后变量 <code>str1</code> 会指向这个内存地址；</li><li><code>let str2 = str1</code>：复制后，把 <code>str1</code> 的值赋值给 <code>str2</code>，这个时候会在栈中新开辟一块空间用来存储 <code>str2</code> 的值；</li><li><code>str2 = &#39;world&#39;</code>：给 <code>str2</code> 赋值了一个新的字符串 <code>world</code>，那么将新建一块内存用来存储 <code>world</code>，同时 <code>str2</code> 原来的值 <code>hello</code> 的内存空间因为没有变量所引用，所以一段时间后建被当成垃圾回收；</li><li><code>console.log( str1 )</code>：因为 <code>str1</code> 和 <code>str2</code> 的栈内存地址是不一样的，所以即使 <code>str2</code> 的值被改变，也不会影响到 <code>str1</code>。</li></ol><p>然后我们继续往下，看下引用类型的复制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let person1 &#x3D; &#123;</span><br><span class="line">    name: &#39;bubuzou&#39;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line">let person2 &#x3D; person1</span><br><span class="line">person2.name &#x3D; &#39;bubuzou.com&#39;</span><br><span class="line">console.log( person1.name)  &#x2F;&#x2F; &#39;bubuzou.com&#39;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype04.png" alt="js_datatype_02"><br>原始类型进行复制的时候是变量的值进行重新赋值，而如上图所示：引用类型进行复制的时候是把变量所指向的引用地址进行赋值给新的变量，所以复制后 <code>person1</code> 和 <code>person2</code> 都指向堆内存中的同一个值，所以当改变 <code>person2.name</code> 的时候， <code>person1.name</code> 也会被改变就是这个原因。</p><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>先说一下结论，在 <code>JavaScript</code> 中，所有函数的参数传递都是按值进行传递的。看如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">changeName(name)</span><br><span class="line"><span class="built_in">console</span>.log( name )  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure><p>定义了一个变量 <code>name</code>，并赋值为 <code>bubuzou</code>，函数调用的时候传入 <code>name</code>，这个时候会在函数内部创建一个局部变量 <code>name</code> 并且把全局变量的值 <code>bubuzou</code> 传递给他，这个操作其实是在内存里新建了一块空间用来存放局部变量的值，然后又把局部变量的值改成了 <code>bubuzou.com</code>，这个时候其实内存中会有3块地址空间分别用来存放全局变量的值 <code>bubuzou</code>、局部变量原来的值 <code>bubuzou</code>、和局部变量新的值 <code>bubuzou.com</code>；一旦函数调用结束，局部变量将被销毁，一段时间后由于局部变量新旧值没有变量引用，那这两块空间将被回收释放；所以这个时候全局 <code>name</code> 的值依然是 <code>bubuzou</code>。</p><p>再来看看引用类型的传参，会不会有所不同呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changePerosn</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    person.name = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">changePerosn( person )</span><br><span class="line"><span class="built_in">console</span>.log( person.name )  <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure><p>引用类型进行函数传参的时候，会把引用地址复制给局部变量，所以全局的 <code>person</code> 和函数内部的局部变量 <code>person</code> 是指向同一个堆地址的，所以一旦一方改变，另一方也将被改变，所以至此我们是不是可以下结论说：当函数进行传参的时候如果参数是引用类型那么就是引用传递嘛？</p><p>将上面的例子改造下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changePerosn</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    person.name = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">    person = &#123;</span><br><span class="line">        name: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">changePerosn( person )  </span><br><span class="line"><span class="built_in">console</span>.log( person.name )  <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure><p>如果 <code>person</code> 是引用传递的话，那就会自动指向值被改为 <code>hello world</code> 的新对象；事实上全局变量 <code>person</code> 的引用地址自始至终都没有改变，倒是局部变量 <code>person</code> 的引用地址发生了改变。</p><h2 id="null-和-undefined-傻傻分不清？"><a href="#null-和-undefined-傻傻分不清？" class="headerlink" title="null 和 undefined 傻傻分不清？"></a>null 和 undefined 傻傻分不清？</h2><p><code>null</code> 在 <code>JavaScript</code> 中自成一种原始类型，只有一个值 <code>null</code>，表示无、空、值未知等特殊值。可以直接给一个变量赋值为 <code>null</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><code>undefined</code> 和 <code>null</code> 一样也是自成一种原始类型，表示定义了一个变量，但是没有赋值，则这个变量的值就是 <code>undefined</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s</span><br><span class="line"><span class="built_in">console</span>.log( s)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>虽然可以给变量直接赋值为 <code>undefined</code> 也不会报错，但是原则上如果一个变量值未定，或者表示空，则直接赋值为 <code>null</code> 比较合适，不建议给变量赋值 <code>undefined</code>。<br><code>null</code> 和 <code>undefined</code> 在进行逻辑判断的时候都是会返回 <code>false</code> 的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>, b</span><br><span class="line"><span class="built_in">console</span>.log( a ? <span class="string">&#x27;a&#x27;</span> : b ? <span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;c&#x27;</span>) <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><p><code>null</code> 在转成数字类型的时候会变成 <code>0</code>，而 <code>undefined</code> 会变成 <code>NaN</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>, b</span><br><span class="line"><span class="built_in">console</span>.log( +<span class="literal">null</span> )  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log( + b )  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="认识新的原始类型-Symbol"><a href="#认识新的原始类型-Symbol" class="headerlink" title="认识新的原始类型 Symbol"></a>认识新的原始类型 Symbol</h2><p><code>Symbol</code> 值表示唯一标识符，是 <code>ES6</code> 中新引进的一种原始类型。可以通过 <code>Symbol()</code> 来创建一个重要的值，也可以传入描述值；其唯一性体现在即使是传入一样的描述，他们两者之间也是不会相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log( a === b )  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="全局的-Symbol"><a href="#全局的-Symbol" class="headerlink" title="全局的 Symbol"></a>全局的 Symbol</h3><p>那还是不是任意2个描述一样的 <code>Symbol</code> 都是不相等的呢？答案是否定的。可以通过 <code>Symbol.for()</code> 来查找或新建一个 <code>Symbol</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log( a === b )  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用 <code>Symbol.for()</code> 可以在根据传入的描述在全局范围内进行查找，如果没找到则新建一个 <code>Symbol</code>，并且返回；所以当执行第二行代码 <code>Symbol.for(&#39;bubuzou&#39;)</code> 的时候，就会找到全局的那个描述为 <code>bubuzou</code> 的 <code>Symbol</code>，所以这里  <code>a</code> 和 <code>b</code> 是会绝对相等的。</p><p>居然可以通过描述找到 <code>Symbol</code>， 那是否可以通过 <code>Symbol</code> 来找到描述呢？答案是肯定的，但是必须是全局的 <code>Symbol</code>，如果没找到则会返回 <code>undefined</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> desc = <span class="built_in">Symbol</span>.keyFor( a )</span><br><span class="line"><span class="built_in">console</span>.log( desc )  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure><p>但是对于任何一个 <code>Symbol</code> 都有一个属性 <code>description</code>，表示这个 <code>Symbol</code> 的描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log( a.description )  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-作为对象属性"><a href="#Symbol-作为对象属性" class="headerlink" title="Symbol 作为对象属性"></a>Symbol 作为对象属性</h3><p>我们知道对象的属性键可以是字符串，但是不能是 <code>Number</code> 或者 <code>Boolean</code>；<code>Symbol</code> 被设计出来其实最大的初衷就是用于对象的属性键：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="built_in">Symbol</span>(<span class="string">&#x27;20&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">    [age]: <span class="string">&#x27;20&#x27;</span>,  <span class="comment">// 在对象字面量中使用 `Symbol` 的时候需要使用中括号包起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给 <code>person</code> 定义了一个 <code>Symbol</code> 作为属性键的属性，这个相比于用字符串作为属性键有啥好处呢？最明显的好处就是如果这个 <code>person</code> 对象是多个开发者进行开发维护，那么很容易再给 <code>person</code> 添加属性的时候出现同名的，如果是用字符串作为属性键那肯定是冲突了，但是如果用 <code>Symbol</code> 作为属性键，就不会存在这个问题了，因为它是唯一标识符，所以可以使对象的属性受到保护，不会被意外的访问或者重写。</p><p>注意一点，如果用 <code>Symbol</code> 作为对象的属性键的时候，<code>for in</code> 、<code>Object.getOwnPropertyNames</code>、或 <code>Object.keys()</code> 这里循环是无法获取 <code>Symbol</code> 属性键的，但是可以通过 <code>Object.getOwnPropertySymbols()</code> 来获取；在上面的代码基础上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( o ) <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log (<span class="built_in">Object</span>.keys( person )) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames( person ))  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols( person ))  <span class="comment">// [Symbol(20)]</span></span><br></pre></td></tr></table></figure><h2 id="你可能不知道的-Number-类型"><a href="#你可能不知道的-Number-类型" class="headerlink" title="你可能不知道的 Number 类型"></a>你可能不知道的 Number 类型</h2><p><code>JavaScript</code> 中的数字涉及到了两种类型：一种是 <code>Number</code> 类型，以 <code>64</code> 位的格式 <code>IEEE-754</code> 存储，也被称为双精度浮点数，就是我们平常使用的数字，其范围是 $2^{52}$ 到 -$2^{52}$；第二种类型是 <code>BigInt</code>，能够表示任意长度的整数，包括超出 $2^{52}$ 到 -$2^{52}$ 这个范围外的数。这里我们只介绍 <code>Number</code> 数字。</p><h3 id="常规数字和特殊数字"><a href="#常规数字和特殊数字" class="headerlink" title="常规数字和特殊数字"></a>常规数字和特殊数字</h3><p>对于一个常规的数字，我们直接写即可，比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>但是还有一种位数特别多的数字我们习惯用科学计数法的表示方法来写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> billion = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1e9</span></span><br></pre></td></tr></table></figure><p>以上两种写法是一个意思， <code>1e9</code> 表示 1 x $10^9$；如果是 <code>1e-3</code> 表示 1 / $10^3$ = 0.001。<br>在 <code>JavaScript</code> 中也可以用数字表示不同的进制，比如：十进制中的 <code>10</code> 在 二、八和十六进制中可以分别表示成 <code>0b1010</code>、<code>0o12</code> 和 <code>0xa</code>；其中的 <code>0b</code> 是二进制前缀，<code>0o</code> 是八进制前缀，而 <code>ox</code> 是十六进制的前缀。</p><p>我们也可以通过 <code>toString(base)</code> 方法来进行进制之间的转换， <code>base</code> 是进制的基数，表示几进制，默认是 <code>10</code> 进制的，会返回一个转换数值的字符串表示。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log( num.toString( <span class="number">2</span> ))  <span class="comment">// &#x27;1010&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( num.toString( <span class="number">8</span> ))  <span class="comment">// &#x27;12&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( num.toString( <span class="number">16</span> ))  <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>数字也可以直接调用方法，<code>10..toString( 2 )</code> 这里的  2个 <code>.</code> 号不是写错了，而是必须是2个，否则会报 <code>SyntaxError</code> 错误。第一个点表示小数点，第二个才是调用方法。点符号首先会被认为是数字常量的一部分，其次再被认为是属性访问符，如果只写一个点的话，计算机无法知道这个是表示一个小数呢还是去调用函数。数字直接调用函数还可以有以下几种写法：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>).toString(<span class="number">2</span>)  <span class="comment">// 将10用括号包起来</span></span><br><span class="line"><span class="number">10.0</span>.toString(<span class="number">2</span>)  <span class="comment">// 将10写成10.0的形式</span></span><br><span class="line"><span class="number">10</span> .toString(<span class="number">2</span>)   <span class="comment">// 空格加上点符号调用</span></span><br></pre></td></tr></table></figure><p><code>Number</code> 类型除了常规数字之外，还包含了一些特殊的数字：</p><ul><li><p><code>NaN</code>：表示不是一个数字，通常是由不合理的计算导致的结果，比如数字除以字符串 <code>1 / &#39;a&#39;</code>;<br><code>NaN</code> 和任何数进行比较都是返回 <code>false</code>，包括他自己： <code>NaN == NaN</code> 会返回 <code>false</code>;<br>如何判断一个数是不是 <code>NaN</code> 呢？有四种方法：</p><p>  方法一：通过 <code>isNaN()</code> 函数，这个方法会对传入的字符串也返回 <code>true</code>，所以判断不准确，不推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>( <span class="number">1</span> / <span class="string">&#x27;a&#x27;</span>)<span class="string">`  // true</span></span><br><span class="line"><span class="string">isNaN( &#x27;a&#x27; )  // true</span></span><br></pre></td></tr></table></figure><p>  方法二：通过 <code>Number.isNaN()</code>，推荐使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN( <span class="number">1</span> / <span class="string">&#x27;a&#x27;</span>)<span class="string">`  // true</span></span><br><span class="line"><span class="string">Number.isNaN( &#x27;a&#x27; )  // false</span></span><br></pre></td></tr></table></figure><p>  方法三：通过 <code>Object.is(a, isNaN)</code>:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is( <span class="number">0</span>/<span class="string">&#x27;a&#x27;</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is( <span class="string">&#x27;a&#x27;</span>, <span class="literal">NaN</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>  方法四：通过判断 <code>n !== n</code>，返回 <code>true</code>， 则 <code>n</code> 是 <code>NaN</code> :</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="number">1</span>/<span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( s !== s )  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>+Infinity</code>：表示正无穷大，比如 <code>1/0</code> 计算的结果, <code>-Infinity</code> 表示负无穷大，比如 <code>-1/0</code> 的结果。</p></li><li><p><code>+0</code> 和 <code>-0</code>，<code>JavaScript</code> 中的数字都有正负之分，包括零也是这样，他们会绝对相等：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( +<span class="number">0</span> === <span class="number">-0</span> )  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="为什么-0-1-0-2-不等于-0-3"><a href="#为什么-0-1-0-2-不等于-0-3" class="headerlink" title="为什么 0.1 + 0.2 不等于 0.3"></a>为什么 0.1 + 0.2 不等于 0.3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span> )  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>有没有想过为什么上面的会不相等？因为数字在 <code>JavaScript</code> 内部是用二进制进行存储的，其遵循 <code>IEEE 754</code> 标准的，用 <code>64</code> 位来存储一个数字，<code>64</code> 位又被分隔成 <code>1</code>、<code>11</code> 和 <code>52</code> 位来分别表示符号位、指数位和尾数位。<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype05.png" alt="js_datatype_05"><br>比如十进制的 <code>0.1</code> 转成二进制后是多少？我们手动计算一下，十进制小数转二进制小数的规则是“乘2取整，顺序排列”，具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 * 2 &#x3D; 0.2  &#x2F;&#x2F; 第1步：整数为0，小数0.2</span><br><span class="line">0.2 * 2 &#x3D; 0.4  &#x2F;&#x2F; 第2步：整数为0，小数0.4</span><br><span class="line">0.4 * 2 &#x3D; 0.8  &#x2F;&#x2F; 第3步：整数为0，小数0.8</span><br><span class="line">0.8 * 2 &#x3D; 1.6  &#x2F;&#x2F; 第4步：整数为1，小数0.6</span><br><span class="line">0.6 * 2 &#x3D; 1.2  &#x2F;&#x2F; 第5步：整数为1，小数0.2</span><br><span class="line">0.2 * 2 &#x3D; 0.4  &#x2F;&#x2F; 第6步：整数为0，小数0.4</span><br><span class="line">0.4 * 2 &#x3D; 0.8  &#x2F;&#x2F; 第7步：整数为0，小数0.8</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们这样依次计算下去之后发现得到整数的顺序排列是 <code>0001100110011001100....</code> 无限循环，所以理论上十进制的 <code>0.1</code> 转成二进制后会是一个无限小数 <code>0.0001100110011001100...</code>，用科学计数法表示后将是 <code>1.100110011001100...</code> x $2^{-4}$ ，但是由于 <code>IEEE 754</code> 标准规定了一个数字的存储位数只能是 <code>64</code> 位，有效位数是 <code>52</code> 位，所以将会对 <code>1100110011001100....</code> 这个无限数字进行舍入总共 <code>52</code> 位作为有效位，然后二进制的末尾取舍规则是看后一位数如果是 <code>1</code> 则进位，如果是 <code>0</code> 则直接舍去。那么由于 <code>1100110011001100....</code> 这串数字的第 <code>53</code> 位刚好是 <code>1</code> ，所以最终的会得到的数字是 <code>1100110011001100110011001100110011001100110011001101</code>，即<br><code>1.100110011001100110011001100110011001100110011001101</code> x $2^{-4}$。<br>十进制转二进制也可以用 <code>toString</code> 来进行转化:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">0.1</span>.toString(<span class="number">2</span>) )  <span class="comment">// &#x27;0.0001100110011001100110011001100110011001100110011001101&#x27;</span></span><br></pre></td></tr></table></figure><p>我们发现十进制的 <code>0.1</code> 在转化成二进制小数的时候发生了精度的丢失，由于进位，它比真实的值更大了。而 <code>0.2</code> 其实也有这样的问题，也会发生精度的丢失，所以实际上 <code>0.1 + 0.2</code> 不会等于 <code>0.3</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">0.1</span> + <span class="number">0.2</span> )  <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>那是不是没办法判断两个小数是否相等了呢？答案肯定是否定的，想要判断2个小数 <code>n1</code> 和 <code>n2</code> 是否相等可以如下操作：</p><ul><li><p>方法一：两小数之差的绝对值如果比 <code>Number.EPSILON</code> 还小，那么说明两数是相等的。</p><p>  <code>Number.EPSILON</code> 是 <code>ES6</code> 中的误差精度，实际值可以认为等于 $2^{-52}$。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">Math</span>.abs( n1 - n2 ) &lt; <span class="built_in">Number</span>.EPSILON ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;n1 和 n2 相等&#x27;</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：通过 <code>toFixed(n)</code> 对结果进行舍入，<code>toFixed()</code> 将会返回字符串，我们可以用 一元加 <code>+</code> 将其转成数字：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="built_in">console</span>.log( +sum.toFixed(<span class="number">2</span>) === <span class="number">0.3</span> )  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数值的转化"><a href="#数值的转化" class="headerlink" title="数值的转化"></a>数值的转化</h3><p>对数字进行操作的时候将常常遇到数值的舍入和字符串转数字的问题，这里我们巩固下基础。先来看舍入的：</p><ul><li><p><code>Math.floor()</code>，向下舍入，得到一个整数:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">2.2</span>)  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">2.8</span>)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>Math.ceil()</code>，向上舍入，得到一个整数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">2.2</span>)  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">2.8</span>)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>Math.round()</code>，对第一位小数进行四舍五入：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(<span class="number">2.26</span>)  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">2.46</span>)  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">2.50</span>)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.prototype.toFixed(n)</code>，和 <code>Math.round()</code> 一样会进行四舍五入，将数字舍入到小数点后 <code>n</code> 位，并且以字符串的形式返回：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12.</span>.toFixed(<span class="number">2</span>)  <span class="comment">// &#x27;12.00&#x27;</span></span><br><span class="line"><span class="number">12.14</span>.toFixed(<span class="number">1</span>)  <span class="comment">// &#x27;12.1&#x27;</span></span><br><span class="line"><span class="number">12.15</span>.toFixed(<span class="number">1</span>)  <span class="comment">// &#x27;12.2&#x27;</span></span><br></pre></td></tr></table></figure><p>  为什么 <code>6.35.toFixed(1)</code> 会等于 <code>6.3</code> ？因为 <code>6.35</code> 其实是一个无限小数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.35</span>.toFixed(<span class="number">20</span>)  <span class="comment">// &quot;6.34999999999999964473&quot;</span></span><br></pre></td></tr></table></figure><p>  所以在 <code>6.35.toFixed(1)</code> 求值的时候会得到 <code>6.3</code>。</p></li></ul><p>再来看看字符串转数字的情况：</p><ul><li><p><code>Number(n)</code> 或 <code>+n</code>，直接将 <code>n</code> 进行严格转化：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27; &#x27;</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log( +<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;010&#x27;</span>)  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log( +<span class="string">&#x27;010&#x27;</span> )  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;12a&#x27;</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log( +<span class="string">&#x27;12a&#x27;</span> )  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li><p><code>parseInt()</code>，非严格转化，从左到右解析字符串，遇到非数字就停止解析，并且把解析的数字返回：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12a&#x27;</span>)  <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;a12&#x27;</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xA&#x27;</span>)  <span class="comment">// 10，0x开头的将会被当成十六进制数</span></span><br></pre></td></tr></table></figure><p>  <code>parseInt()</code> 默认是用十进制去解析字符串的，其实他是支持传入第二个参数的，表示要以多少进制的    基数去解析第一个参数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1010&#x27;</span>, <span class="number">2</span>)  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>)  <span class="comment">// 255</span></span><br></pre></td></tr></table></figure></li></ul><p>如何判断一个数是不是整数？介绍两种方法：</p><ul><li><p>方法一：通过 <code>Number.isInteger()</code>:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">12.0</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">12.2</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>方法二：<code>typeof num == &#39;number&#39; &amp;&amp; num % 1 == 0</code></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInteger</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> num == <span class="string">&#x27;number&#x27;</span> &amp;&amp; num % <span class="number">1</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>除了原始类型外，还有一个特别重要的类型：引用类型。高程里这样描述他：引用类型是一种数据结构， 用于将数据和功能组织在一起。到目前为止，我们看到最多的引用类型就是 <code>Object</code>，创建一个 <code>Object</code> 有两种方式：</p><ul><li><p>方式一：通过 <code>new</code> 操作符：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">person.age = <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p>方式二：通过对象字面量，这是我们最喜欢用的方式：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="内置的引用类型"><a href="#内置的引用类型" class="headerlink" title="内置的引用类型"></a>内置的引用类型</h3><p>除了 <code>Object</code> 外，在 <code>JavaScript</code> 中还有别的内置的引用类型，比如：</p><ul><li><code>Array</code> 数组</li><li><code>Date</code> 日期</li><li><code>RegExp</code> 正则表达式</li><li><code>Function</code> 函数</li></ul><p>他们的原型链的顶端都会指向 <code>Object</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">console</span>.log( d.__proto__.__proto__.constructor )  <span class="comment">// ƒ Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>先来看一个问题，为什么原始类型的变量没有属性和方法，但是却能够调用方法呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">str.substring(<span class="number">0</span>, <span class="number">3</span>)  <span class="comment">// &#x27;bub&#x27;</span></span><br></pre></td></tr></table></figure><p>因为 <code>JavaScript</code> 为了更好地操作原始类型，设计出了几个对应的包装类型，他们分别是：</p><ul><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li></ul><p>上面那串代码的执行过程其实是这样的：</p><ol><li>创建 String 类型的一个实例;</li><li>在实例上调用指定的方法;</li><li>销毁这个实例</li></ol><p>用代码体现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line">str.substring(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">str = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>原始类型调用函数其实就是自动进行了装箱操作，将原始类型转成了包装类型，然后其实原始类型和包装类型是有本质区别的，原始类型是原始值，而包装类型是对象实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log( str1 === str2 )  <span class="comment">// fasle</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">typeof</span> str1 )  <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">typeof</span> str2 )  <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><p>居然有装箱操作，那肯定也有拆箱操作，所谓的拆箱就是包装类型转成原始类型的过程，又叫 <code>ToPromitive</code>，来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    toString: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;bubuzou&#x27;</span> &#125;,</span><br><span class="line">    valueOf: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">20</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( +obj )  <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">`<span class="subst">$&#123;obj&#125;</span>`</span> )  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure><p>在拆箱操作的时候，默认会尝试调用包装类型的 <code>toString()</code> 和 <code>valueOf()</code> 方法，对于不同的 <code>hint</code> 调用顺序会有所区别，如果 <code>hint</code> 是 <code>string</code> 则优先调用 <code>toString()</code>，否则的话，则优先调用 <code>valueOf()</code>。<br>默认情况下，一个 <code>Object</code> 对象具有 <code>toString()</code> 和 <code>valueOf()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log( obj.toString() )  <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( obj.valueOf() )  <span class="comment">// &#123;&#125;，valueOf会返回对象本身</span></span><br></pre></td></tr></table></figure><h2 id="类型装换"><a href="#类型装换" class="headerlink" title="类型装换"></a>类型装换</h2><p><code>Javascript</code> 是弱类型的语音，所以对变量进行操作的时候经常会发生类型的转换，尤其是隐式类型转换，可能会让代码执行结果出乎意料之外，比如如下的代码你能理解其执行结果嘛？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] + &#123;&#125;  <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line">&#123;&#125; + []  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h3><p>所以我们需要知道类型转换的规则，以下整理出一个表格，列出了常见值和类型以及转换之后的结果，仅供参考。</p><table><thead><tr><th align="center">转换前的值</th><th align="center">转换前类型</th><th align="center">toBoolean</th><th align="center">toNumber</th><th align="center">toString</th></tr></thead><tbody><tr><td align="center">true</td><td align="center">Boolean</td><td align="center">-</td><td align="center">1</td><td align="center">“true”</td></tr><tr><td align="center">false</td><td align="center">Boolean</td><td align="center">-</td><td align="center">0</td><td align="center">“false”</td></tr><tr><td align="center">null</td><td align="center">Null</td><td align="center">false</td><td align="center">0</td><td align="center">“null”</td></tr><tr><td align="center">undefined</td><td align="center">Undefined</td><td align="center">false</td><td align="center">NaN</td><td align="center">“undefined”</td></tr><tr><td align="center">123</td><td align="center">Number</td><td align="center">true</td><td align="center">-</td><td align="center">“123”</td></tr><tr><td align="center">Infinity</td><td align="center">Number</td><td align="center">true</td><td align="center">-</td><td align="center">“Infinity”</td></tr><tr><td align="center">0</td><td align="center">Number</td><td align="center">false</td><td align="center">-</td><td align="center">“0”</td></tr><tr><td align="center">NaN</td><td align="center">Number</td><td align="center">false</td><td align="center">-</td><td align="center">“NaN”</td></tr><tr><td align="center">“”</td><td align="center">String</td><td align="center">false</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">“ “</td><td align="center">String</td><td align="center">true</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">“0”</td><td align="center">String</td><td align="center">true</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">“123”</td><td align="center">String</td><td align="center">true</td><td align="center">123</td><td align="center">-</td></tr><tr><td align="center">“123abc”</td><td align="center">String</td><td align="center">true</td><td align="center">NaN</td><td align="center">-</td></tr><tr><td align="center">Symbol()</td><td align="center">Symbol</td><td align="center">true</td><td align="center">TypeError</td><td align="center">TypeError</td></tr><tr><td align="center">{}</td><td align="center">Object</td><td align="center">true</td><td align="center">NaN</td><td align="center">“[object Object]”</td></tr><tr><td align="center">[]</td><td align="center">Object</td><td align="center">true</td><td align="center">0</td><td align="center">“”</td></tr><tr><td align="center">[“0”]</td><td align="center">Object</td><td align="center">true</td><td align="center">0</td><td align="center">“0”</td></tr><tr><td align="center">[“0”, “a”]</td><td align="center">Object</td><td align="center">true</td><td align="center">NaN</td><td align="center">“0,a”</td></tr><tr><td align="center">[“0”, undefined, “a”]</td><td align="center">Object</td><td align="center">true</td><td align="center">Nan</td><td align="center">“0,,a”</td></tr></tbody></table><h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><p>我们平时写代码的时候应该尽量让写出来的代码通俗易懂，让别人能阅读后知道你是要做什么，所以在对类型进行判断的时候应该尽量显示的处理。<br>比如将字符串转成数字，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>( <span class="string">&#x27;21&#x27;</span> )  <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">Number</span>( <span class="string">&#x27;21.8&#x27;</span> )  <span class="comment">// 21.8</span></span><br><span class="line">+<span class="string">&#x27;21&#x27;</span>  <span class="comment">// 21 </span></span><br></pre></td></tr></table></figure><p>将数字显示转成字符串可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">21</span>)  <span class="comment">// &#x27;21&#x27;</span></span><br><span class="line"><span class="number">21.</span>.toString()  <span class="comment">// &#x27;21&#x27;</span></span><br></pre></td></tr></table></figure><p>显示转成布尔类型可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;21&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>( <span class="literal">undefined</span> )  <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">NaN</span>  <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&#x27;21&#x27;</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>除了以上之外，还有一些关于类型转换的冷门操作，有时候也挺管用的：<br>直接用一元加操作符获取当前时间的毫秒数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">new</span> <span class="built_in">Date</span>()  <span class="comment">// 1595517982686</span></span><br></pre></td></tr></table></figure><p>用 <code>~</code> 配合 <code>indexOf()</code> 将操作结果直接转成布尔类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (~str.indexOf(<span class="string">&#x27;.com&#x27;</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;str如果包含了.com字符串，则会打印这句话&#x27;</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>~~</code> 对字符或数字截取整数，和 <code>Math.floor()</code> 有稍许不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="number">21.1</span>  <span class="comment">// 21</span></span><br><span class="line">~~<span class="number">-21.9</span>  <span class="comment">// -21</span></span><br><span class="line">~~<span class="string">&#x27;1.2a&#x27;</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.floor( <span class="number">21.1</span> )  <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">Math</span>.floor( <span class="number">-21.9</span> )  <span class="comment">// -22</span></span><br></pre></td></tr></table></figure><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换发生在 <code>JavaScript</code> 的运行时，通常是由某些操作符或语句引起的，有下面这几种情况：</p><ul><li><p>隐式转成布尔类型：</p><ol><li><p><code>if (..)</code>语句中的条件判断表达式。</p></li><li><p><code>for ( .. ; .. ; .. )</code>语句中的条件判断表达式(第二个)。</p></li><li><p><code>while (..)</code> 和 <code>do..while(..)</code> 循环中的条件判断表达式。</p></li><li><p><code>? :</code>中的条件判断表达式。</p></li><li><p>逻辑运算符 <code>||</code> (逻辑或)和 <code>&amp;&amp;</code> (逻辑与)左边的操作数(作为条件判断表达式)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">42</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="string">&#x27;bubuzou&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">null</span> ? <span class="string">&#x27;存在&#x27;</span> : <span class="string">&#x27;不存在&#x27;</span>  <span class="comment">// &#x27;不存在&#x27;</span></span><br></pre></td></tr></table></figure><p>上例中的非布尔值会被隐式强制类型转换为布尔值以便执行条件判断。<br>需要特别注意的是 <code>||</code> 和 <code>&amp;&amp;</code> 操作符。<code>||</code> 的操作过程是只有当左边的值返回 <code>false</code> 的时候才会对右边进行求值且将它作为最后结果返回，类似 <code>a ? a : b</code> 这种效果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;a&#x27;</span> || <span class="string">&#x27;b&#x27;</span>  <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;c&#x27;</span>  <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><p>而 <code>&amp;&amp;</code> 的操作过程是只有当左边的值返回 <code>true</code> 的时候才对右边进行求值且将右边的值作为结果返回，类似 <code>a ? b : a</code> 这种效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;a&#x27;</span> &amp;&amp; <span class="string">&#x27;b&#x27;</span>  <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">&#x27;c&#x27;</span>  <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>数学操作符 <code>- * /</code> 会对非数字类型的会优先转成数字类型，但是对 <code>+</code> 操作符会比较特殊：</p><ol><li>当一侧为 <code>String</code> 类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li><li>当一侧为 <code>Number</code> 类型，另一侧为原始类型，则将原始类型转换为 <code>Number</code> 类型。</li><li>当一侧为 <code>Number</code> 类型，另一侧为引用类型，将引用类型和 <code>Number</code> 类型转换成字符串后拼接。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span> + <span class="string">&#x27;bubuzou&#x27;</span>  <span class="comment">// &#x27;42bubuzou&#x27;</span></span><br><span class="line"><span class="number">42</span> + <span class="literal">null</span>  <span class="comment">// 42</span></span><br><span class="line"><span class="number">42</span> + <span class="literal">true</span>  <span class="comment">// 43</span></span><br><span class="line"><span class="number">42</span> + []  <span class="comment">// &#x27;42&#x27;</span></span><br><span class="line"><span class="number">42</span> + &#123;&#125;  <span class="comment">// &#x27;42[object Object]&#x27;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>宽松相等和严格相等<br>  宽松相等（<code>==</code>）和严格相等（<code>===</code>）在面试的时候经常会被问到，而回答一般是 <code>==</code> 是判断值是否相等，而 <code>===</code> 除了判断值会不会相等之外还会判断类型是否相等，这个答案不完全正确，更好的回答是：<code>==</code> 在比较过程中允许发生隐式类型转换，而 <code>===</code> 不会。 那 <code>==</code> 是怎么进行类型转换的呢？</p><ol><li><p>数字和字符串比，字符串将转成数字进行比较：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> == <span class="string">&#x27;20&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="number">20</span> === <span class="string">&#x27;20&#x27;</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>别的类型和布尔类型比较，布尔类型将首先转成数字进行比较，<code>true</code> 转成数字 <code>1</code>, <code>false</code> 转成数字 <code>0</code>，注意这个是非常容易出错的一个点：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;bubuzou&#x27;</span> == <span class="literal">true</span>  <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>  <span class="comment">// false,</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>  <span class="comment">// false</span></span><br><span class="line">[] == <span class="literal">true</span>  <span class="comment">// false</span></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>]  == <span class="literal">true</span>  <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p> 所以写代码进行判断的时候一定不要写成 <code>x == true</code> 或 <code>x == false</code> 这种，而应该直接 <code>if (x)</code> 判断。</p></li><li><p><code>null</code> 和 <code>undefined</code>: <code>null == undefined</code> 比较结果是 <code>true</code>，除此之外，<code>null</code>、<code>undefined</code> 和其他任何结果的比较值都为 <code>false</code>。可以认为在 <code>==</code> 的情况下，<code>null</code> 和 <code>undefined</code> 可以相互的进行隐式类型转换。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>原始类型和引用类型比较，引用类型会首先进行 <code>ToPromitive</code> 转成原始类型然后进行比较，规则参考上面介绍的拆箱操作：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;42&#x27;</span>  == [<span class="number">42</span>]  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;1,2,3&#x27;</span>  == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;[object Object]&#x27;</span> == &#123;&#125;  <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == [<span class="literal">undefined</span>]  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>特殊的值 </p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>  <span class="comment">// false</span></span><br><span class="line">+<span class="number">0</span> == <span class="number">-0</span>  <span class="comment">// true</span></span><br><span class="line">[] == ![]  <span class="comment">// true，![]的优先级比==高，所以![]先转成布尔值变成false；即变成[] == false，false再转成数字0，[]转成数字0，所以[] == ![]</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;\n&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><h3 id="用typeof检测原始类型"><a href="#用typeof检测原始类型" class="headerlink" title="用typeof检测原始类型"></a>用typeof检测原始类型</h3><p><code>JavaScript</code> 中有 <code>null</code>、<code>undefined</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>Symbol</code> 等六种原始类型，我们可以用 <code>typeof</code> 来判断值是什么原始类型的，会返回类型的字符串表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>  <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>  <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;42&quot;</span>  <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()  <span class="comment">// &#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><p>但是原始类型中有一个例外，<code>typeof null</code> 会得到 ‘object’，所以我们用 <code>typeof</code> 对原始值进行类型判断的时候不能得到一个准确的答案，那如何判断一个值是不是 <code>null</code> 类型的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="literal">null</span></span><br><span class="line">!o &amp;&amp; <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> <span class="comment">// 用于判断 o 是否是 null 类型</span></span><br></pre></td></tr></table></figure><blockquote><p><code>undefined</code> 和 <code>undeclared</code> 有什么区别？前者是表示在作用域中定义了但是没有赋值的变量，而后者是表示在作用域中没有定义的变量；分别表示 <code>undefined</code> 未定义、<code>undeclared</code> 未声明。</p></blockquote><p><code>typeof</code> 能够对原始类型进行判断，那是否也能判断引用类型呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>()  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>()  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>()  <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面的结果我们可以得到这样一个结论： <code>typeof</code> 对引用类型判断的时候只有 <code>function</code> 类型可以正确判断，其他都无法正确判断具体是什么引用类型。</p><h3 id="用instanceof检测引用类型"><a href="#用instanceof检测引用类型" class="headerlink" title="用instanceof检测引用类型"></a>用instanceof检测引用类型</h3><p>我们知道 <code>typeof</code> 只能对部分原始类型进行检测，对引用类型毫无办法。<code>JavaScript</code> 提供了一个操作符 <code>instanceof</code>，我们来看下他是否能检测引用类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>  <span class="comment">// true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>我们发现数组即是 <code>Array</code> 的实例，也是 <code>Object</code> 的实例，因为所以引用类型原型链的终点都是 <code>Object</code>，所以 <code>Array</code> 自然是 <code>Object</code> 的实例。那么我们得出结论：<code>instanceof</code> 用于检测引用类型好像也不是很靠谱的选择。</p><h3 id="用toString进行类型检测"><a href="#用toString进行类型检测" class="headerlink" title="用toString进行类型检测"></a>用toString进行类型检测</h3><p>我们可以使用 <code>Object.prototype.toString.call()</code> 来检测任何变量值的类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)  <span class="comment">// &#x27;[object Boolean]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)  <span class="comment">// &#x27;[object Undefined]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)  <span class="comment">// &#x27;[object Null]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">20</span>)  <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;bubuzou&#x27;</span>)  <span class="comment">// &#x27;[object String]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>())  <span class="comment">// &#x27;[object Symbol]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])  <span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)  <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)  <span class="comment">// &#x27;[object Function]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>())  <span class="comment">// &#x27;[object Date]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>())  <span class="comment">// &#x27;[object RegExp]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>)  <span class="comment">// &#x27;[object JSON]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(MATH)  <span class="comment">// &#x27;[object MATH]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>)  <span class="comment">// &#x27;[object RegExp]&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.im/post/5cec1bcff265da1b8f1aa08f">【JS 进阶】你真的掌握变量和类型了吗</a></li><li><a href="https://book.douban.com/subject/26854244/">你不知道的JS中卷-第四章</a></li><li><a href="https://juejin.im/post/5d116a9df265da1bb47d717b">JS中的栈内存堆内存</a></li><li><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用nvm来管理Node版本</title>
      <link href="/2020/03/26/nvm/"/>
      <url>/2020/03/26/nvm/</url>
      
        <content type="html"><![CDATA[<h2 id="使用nvm来管理Node版本"><a href="#使用nvm来管理Node版本" class="headerlink" title="使用nvm来管理Node版本"></a>使用nvm来管理Node版本</h2><p><code>nvm</code> 是 <code>Node.js</code> 的版本管理工具，可以创建不同版本 <code>Node</code> 的隔离环境，从而避免不同版本包之间的干扰。<a href="https://github.com/nvm-sh/nvm">官方 github</a></p><h3 id="卸载全局安装的Node"><a href="#卸载全局安装的Node" class="headerlink" title="卸载全局安装的Node"></a>卸载全局安装的Node</h3><p>最近在做项目的时候，发现编译速度特别慢，而升级 <code>Node</code> 版本之后速度会明显提升。所以这才有使用 <code>nvm</code> 来管理 <code>Node</code> 的故事。</p><p>目前本地全局安装的 <code>Node</code> 版本是 <code>9.11.1</code>， 这个版本还是18年4月左右更新的，是相当的跟不上节奏了。<a href="https://nodejs.org/zh-cn/download/releases/">这里可以查看 Node 历史版本</a>。</p><p>安装 <code>nvm</code> 之前最好是将现有的全局 <code>Node</code> 进行卸载，否则会发生冲突。</p><a id="more"></a><ol><li><p>终端下查看 <code>Node</code> 的全局安装目录：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ccp:~ ccp$ which node</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node</span><br></pre></td></tr></table></figure></li><li><p><code>Mac</code> 环境下全局的 <code>Node</code> 会被安装在 <code>/usr/local/bin/</code> 目录下，接下来我们要打开这个目录；</p></li><li><p>打开访达，然后按下快捷键 <code>⇧ + ⌘ + G</code>，输入上面的目录，即可打开对应的目录；</p></li><li><p>接下来依次检查并且删除这些目录下的 <code>node</code> 和 <code>node_modules</code> 相关文件和文件夹：</p><ul><li><code>/usr/local/lib</code></li><li><code>/usr/local/include</code></li></ul></li><li><p>打开 <code>/usr/local/bin</code> 并删除 <code>node</code> 可执行文件;</p></li><li><p>如果你是使用的 <code>brew install node</code> 安装的 <code>Node</code>，那么你还需要在终端中执行 <code>brew uninstall node</code> 命令来卸载。</p></li></ol><p>过程中，你可能还需要在终端中执行一些指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm</span><br><span class="line">sudo rm &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1&#x2F;node.1</span><br><span class="line">sudo rm &#x2F;usr&#x2F;local&#x2F;lib&#x2F;dtrace&#x2F;node.d</span><br><span class="line">sudo rm -rf ~&#x2F;.npm</span><br><span class="line">sudo rm -rf ~&#x2F;.node-gyp</span><br><span class="line">sudo rm &#x2F;opt&#x2F;local&#x2F;bin&#x2F;node</span><br><span class="line">sudo rm &#x2F;opt&#x2F;local&#x2F;include&#x2F;node</span><br><span class="line">sudo rm -rf &#x2F;opt&#x2F;local&#x2F;lib&#x2F;node_modules</span><br></pre></td></tr></table></figure><p>至此，全局安装的 <code>Node</code> 才算卸载干净。</p><h3 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h3><ol><li><p>在终端里执行如下脚本：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.35.3&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure><p> 然后在终端输入命令 <code>command -v nvm</code>，如果显示 <code>nvm</code> 则表示安装成功；否则如果显示 <code>nvm: command not found</code>，则需要做如下操作：</p></li><li><p>在 <code>.nvm</code> 同级目录下创建 <code>.bash_profile</code> 文件，终端键入如下命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>把以下代码贴到上面的文件中：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR&#x3D;~&#x2F;.nvm</span><br><span class="line">source ~&#x2F;.nvm&#x2F;nvm.sh</span><br></pre></td></tr></table></figure></li></ol><p><code>nvm</code> 安装后，可以用 <code>nvm ls</code> 来查看，如果会显示安装的 <code>Node</code> 版本列表，则显示安装成功。有了 <code>nvm</code> 后，在用 <code>npm install xxx -g</code> 进行全局安装的时候会把包安装对应版本的 <code>Node</code> 下，如果是 <code>Mac</code> 则目录 <code>user/.nvm/versions/node/v12.16.1/bin</code> 下可以看到对应的全局命令。</p><h3 id="nvm常用命令"><a href="#nvm常用命令" class="headerlink" title="nvm常用命令"></a>nvm常用命令</h3><ul><li><code>nvm ls-remote</code>  查看 <code>Node</code> 远程版本库</li><li><code>nvm install node</code>  将安装最新版本的 <code>Node</code></li><li><code>nvm install v12.7.0</code>  将安装 <code>12.7.0</code> 版本的 <code>Node</code></li><li><code>nvm uninstall v12.7.0</code>  卸载 <code>12.7.0</code> 版本的 <code>Node</code></li><li><code>nvm ls</code>  查看已经安装的 <code>Node</code> 版本</li><li><code>nvm use v12.7.0</code> 切换 <code>12.7.0</code> 为当前使用的版本</li><li><code>nvm alias default v12.7.0</code> 将 <code>12.7.0</code> 设置为 <code>Node</code> 的默认版本</li><li><code>nvm which v12.7.0</code> 查看 <code>12.7.0</code> 版本的 <code>Node</code> 的安装目录，比如：<code>/Users/ccp/.nvm/versions/node/v12.7.0/bin/node</code></li><li><code>nvm --help</code>  查看更多命令用法</li></ul><h3 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h3><ul><li><code>command -v nvm</code>  查看 <code>nvm</code> 是否安装成功</li><li><code>node -v</code> 查看当前使用的 <code>Node</code> 版本</li><li><code>which node</code>  查看当前 <code>Node</code> 的安装目录</li></ul><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ol><li>由于 <code>Node</code> 版本的升级，所以当编译项目的时候可能会报依赖包的错误，这个时候就需要升级依赖包，将项目的 <code>node_modules</code> 目录删了，重新执行 <code>npm install</code>。</li><li>升级 <code>Node</code> 后，由于内存 <code>2048M</code> 的限制，编译项目的时候很有可能会报 <code>JS stack trace</code> 内存溢出的错误，这个时候可以用 <a href="https://www.npmjs.com/package/increase-memory-limit"><code>increase-memory-limit</code></a> 来解决。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web综合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Test-Utils + Jest 单元测试入门与实践</title>
      <link href="/2019/10/24/Vue-Test-Utils+Jest/"/>
      <url>/2019/10/24/Vue-Test-Utils+Jest/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://vue-test-utils.vuejs.org/zh/"><code>Vue-Test-Utils</code></a> 是 <code>Vue.js</code> 官方的单元测试实用工具库，它提供了一系列的 <code>API</code> 来使得我们可以很便捷的去写 <code>Vue</code> 应用中的单元测试。</p><p>主流的单元测试运行器有很多，比如 <a href="https://jestjs.io/docs/zh-Hans/getting-started"><code>Jest</code></a>、<a href="https://mochajs.org/"><code>Mocha</code></a> 和 <code>Karma</code> 等，这几个在 <code>Vue-Test-Utils</code> 文档里都有对应的教程，这里我们只介绍 <code>Vue-Test-Utils + Jest</code> 结合的示例。</p><blockquote><p>Jest 是一个由 Facebook 开发的测试框架。Vue 对其进行描述：是功能最全的测试运行器。它所需的配置是最少的，默认安装了 JSDOM，内置断言且命令行的用户体验非常好。不过你需要一个能够将单文件组件导入到测试中的预处理器。我们已经创建了 vue-jest 预处理器来处理最常见的单文件组件特性，但仍不是 vue-loader 100% 的功能。</p></blockquote><a id="more"></a><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>通过脚手架 <code>vue-cli</code> 来新建项目的时候，如果选择了 <code>Unit Testing</code> 单元测试且选择的是 <code>Jest</code> 作为测试运行器，那么在项目创建好后，就会自动配置好单元测试需要的环境，直接能用 <code>Vue-Test-Utils</code> 和 <code>Jest</code> 的 <code>API</code> 来写测试用例了。</p><p>但是新建项目之初没有选择单元测试功能，需要后面去添加的话，有两种方案：</p><p>第一种配置：</p><p>直接在项目中添加一个 <a href="https://github.com/vuejs/vue-docs-zh-cn/tree/master/vue-cli-plugin-unit-jest"><code>unit-jest</code></a> 插件，会自动将需要的依赖安装配置好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue add @vue&#x2F;unit-jest</span><br></pre></td></tr></table></figure><p>第二种配置：</p><p>这种配置会麻烦一点，下面是具体的操作步骤。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ul><li><p>安装 <code>Jest</code> 和 <code>Vue Test Utils</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jest @vue&#x2F;test-utils</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>babel-jest</code> 、 <code>vue-jest</code> 和 <code>7.0.0-bridge.0</code> 版本的 <code>babel-core</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-jest vue-jest babel-core@7.0.0-bridge.0</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>jest-serializer-vue</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jest-serializer-vue</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置-Jest"><a href="#配置-Jest" class="headerlink" title="配置 Jest"></a>配置 <code>Jest</code></h3><p><code>Jest</code> 的配置可以在 <code>package.json</code> 里配置；也可以新建一个文件 <code>jest.config.js</code>， 放在项目根目录即可。这里我选择的是配置在 <code>jest.config.js</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    moduleFileExtensions: [</span><br><span class="line">        <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    transform: &#123;</span><br><span class="line">        <span class="string">&#x27;^.+\\.vue$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/node_modules/vue-jest&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;^.+\\.js$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/node_modules/babel-jest&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    moduleNameMapper: &#123;</span><br><span class="line">        <span class="string">&#x27;^@/(.*)$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/src/$1&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    snapshotSerializers: [</span><br><span class="line">        <span class="string">&#x27;jest-serializer-vue&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    testMatch: [<span class="string">&#x27;**/__tests__/**/*.spec.js&#x27;</span>],</span><br><span class="line">    transformIgnorePatterns: [<span class="string">&#x27;&lt;rootDir&gt;/node_modules/&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各配置项说明：</p><ul><li><code>moduleFileExtensions</code> 告诉 <code>Jest</code> 需要匹配的文件后缀</li><li><code>transform</code> 匹配到 <code>.vue</code> 文件的时候用 <code>vue-jest</code> 处理， 匹配到 <code>.js</code> 文件的时候用 <code>babel-jest</code> 处理</li><li><code>moduleNameMapper</code> 处理 <code>webpack</code> 的别名，比如：将 <code>@</code> 表示 <code>/src</code> 目录</li><li><code>snapshotSerializers</code> 将保存的快照测试结果进行序列化，使得其更美观 </li><li><code>testMatch</code> 匹配哪些文件进行测试</li><li><code>transformIgnorePatterns</code> 不进行匹配的目录</li></ul><h3 id="配置-package-json"><a href="#配置-package-json" class="headerlink" title="配置 package.json"></a>配置 <code>package.json</code></h3><p>写一个执行测试的命令脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;jest&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一个测试用例"><a href="#第一个测试用例" class="headerlink" title="第一个测试用例"></a>第一个测试用例</h2><p>为了保证环境的一致性，我们从创建项目开始一步一步演示操作步骤。</p><h3 id="用-vue-cli-创建一个项目"><a href="#用-vue-cli-创建一个项目" class="headerlink" title="用 vue-cli 创建一个项目"></a>用 <code>vue-cli</code> 创建一个项目</h3><p>当前我用到的是 <code>3.10.0</code> 版本的 <code>vue-cli</code>。开始创建项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create first-vue-jest</span><br></pre></td></tr></table></figure><p>选择 <code>Manually select features</code> 进行手动选择功能配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v3.10.0</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│  Update available: 4.0.4  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">? Please pick a preset:</span><br><span class="line">  VUE-CLI3 (vue-router, node-sass, babel, eslint)</span><br><span class="line">  default (babel, eslint)</span><br><span class="line">❯ Manually select features</span><br></pre></td></tr></table></figure><p>勾选 <code>Babel</code>、<code>Unit Testing</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">? Check the features needed for your project:</span><br><span class="line"> ◉ Babel</span><br><span class="line"> ◯ TypeScript</span><br><span class="line"> ◯ Progressive Web App (PWA) Support</span><br><span class="line"> ◯ Router</span><br><span class="line"> ◯ Vuex</span><br><span class="line"> ◯ CSS Pre-processors</span><br><span class="line"> ◯ Linter &#x2F; Formatter</span><br><span class="line"> ◉ Unit Testing</span><br><span class="line"> ◯ E2E Testing</span><br></pre></td></tr></table></figure><p>选择 <code>Jest</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Pick a unit testing solution:</span><br><span class="line">  Mocha + Chai</span><br><span class="line">❯ Jest</span><br></pre></td></tr></table></figure><p>选择 <code>In dedicated config files</code> 将各配置信息配置在对应的 <code>config</code> 文件里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)</span><br><span class="line">❯ In dedicated config files</span><br><span class="line">  In package.json</span><br></pre></td></tr></table></figure><p>输入n，不保存预设：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? Save this as a preset for future projects? (y&#x2F;N) n</span><br></pre></td></tr></table></figure><p>项目创建完成后，部分文件的配置信息如下：</p><p><code>babel.config.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    presets: [</span><br><span class="line">        <span class="string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>jest.config.js</code>， 这个文件的配置默认是预设插件的，可以按实际需求改成上面提到的配置 <code>Jest</code> 里的配置一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    preset: <span class="string">&#x27;@vue/cli-plugin-unit-jest&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>package.json</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;first-vue-jest&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;test:unit&quot;</span>: <span class="string">&quot;vue-cli-service test:unit&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;core-js&quot;</span>: <span class="string">&quot;^3.1.2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.6.10&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@vue/cli-plugin-babel&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@vue/cli-plugin-unit-jest&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@vue/cli-service&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@vue/test-utils&quot;</span>: <span class="string">&quot;1.0.0-beta.29&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;vue-template-compiler&quot;</span>: <span class="string">&quot;^2.6.10&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行测试命令"><a href="#执行测试命令" class="headerlink" title="执行测试命令"></a>执行测试命令</h3><p>用上面的步骤创建的项目完成项目后，我们可以在 <code>package.json</code> 的 <code>scripts</code> 项中看到有个 <code>test:unit</code> ，执行它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd first-vue-jest</span><br><span class="line">npm run test:unit</span><br></pre></td></tr></table></figure><p>然后终端里会看到输出结果，<code>PASS</code> 表示测试用例通过了，这个是官方提供单元测试例子。下面我们来写点自己的东西。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/2019/vue_jest_01.png" alt="first-vue-jest-result"></p><h2 id="实现一个ToDoList"><a href="#实现一个ToDoList" class="headerlink" title="实现一个ToDoList"></a>实现一个ToDoList</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/2019/vue_jest_02.png" alt="to-do-list"></p><p>看上面的原型图，有这么几点明确的需求：</p><ul><li>在头部右侧输入框输入要做的事情，敲回车后，内容跑到待完成列表里，同时清空输入框</li><li>输入框为空的时候敲回车，不做任何变化</li><li>待完成列表支持编辑功能，已完成列表不能进行编辑</li><li>每个列表项的右侧都有删除按钮，用 <code>-</code> 号表示，点击后删除该项</li><li>待完成列表有标记为已完成的按钮，用 <code>√</code> 号表示，点击后当前项移动到已完成列表</li><li>已完成列表有标记为未完成的按钮，用 <code>x</code> 号表示，点击后当前项移动到未完成列表</li><li>列表序号从1开始递增</li><li>当待完成列表为空的时候，不显示待完成字样</li><li>当已完成列表为空的时候，不显示已完成字样</li></ul><h3 id="先把上面的页面写好"><a href="#先把上面的页面写好" class="headerlink" title="先把上面的页面写好"></a>先把上面的页面写好</h3><p>写页面之前先把创建项目的时候生成的 <code>HelloWorld.vue</code> 和对应的测试文件 <code>example.spec.js</code> 删除；同时修改 <code>App.vue</code> 文件，引入 <code>ToDoList</code> 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ToDoList</span>&gt;</span><span class="tag">&lt;/<span class="name">ToDoList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> ToDoList <span class="keyword">from</span> <span class="string">&#x27;./components/ToDoList&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123;</span><br><span class="line">        ToDoList</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>src/compoents</code> 下新建一个文件 <code>ToDoList.vue</code>，样式较多就不贴出来了，具体可以去看<a href="https://github.com/Bulandent/first-vue-jest.git">本项目源码</a>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;todolist&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h5</span>&gt;</span>ToDoList<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;to-do-text&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">v-model</span>=<span class="string">&quot;toDoText&quot;</span> </span></span><br><span class="line"><span class="tag">                @<span class="attr">keyup.enter</span>=<span class="string">&quot;enterText&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">placeholder</span>=<span class="string">&quot;输入计划要做的事情&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">v-show</span>=<span class="string">&quot;toDoList.length &gt; 0&quot;</span>&gt;</span>待完成<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;wait-to-do&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in toDoList&quot;</span> <span class="attr">:keys</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">i</span>&gt;</span>&#123;&#123;index + 1&#125;&#125;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;item&quot;</span> @<span class="attr">blur</span>=<span class="string">&quot;setValue(index, $event)&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;move&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;removeToComplete(item, index)&quot;</span>&gt;</span>√<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;del&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteWait(index)&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">v-show</span>=<span class="string">&quot;completedList.length &gt; 0&quot;</span>&gt;</span>已完成<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;has-completed&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in completedList&quot;</span> <span class="attr">:keys</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">i</span>&gt;</span>&#123;&#123;index + 1&#125;&#125;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;item&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;move&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;removeToWait(item, index)&quot;</span>&gt;</span>x<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;del&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteComplete(index)&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            toDoText: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            toDoList: [],</span><br><span class="line">            completedList: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        setValue(index, e) &#123;</span><br><span class="line">            <span class="built_in">this</span>.toDoList.splice(index, <span class="number">1</span>, e.target.value)</span><br><span class="line">        &#125;,</span><br><span class="line">        removeToComplete(item, index) &#123;</span><br><span class="line">            <span class="built_in">this</span>.completedList.splice(<span class="built_in">this</span>.completedList.length, <span class="number">0</span>, item)</span><br><span class="line">            <span class="built_in">this</span>.toDoList.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        removeToWait(item, index) &#123;</span><br><span class="line">            <span class="built_in">this</span>.toDoList.splice(<span class="built_in">this</span>.toDoList.length, <span class="number">0</span>, item)</span><br><span class="line">            <span class="built_in">this</span>.completedList.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        enterText() &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.toDoText.trim().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.toDoList.splice(<span class="built_in">this</span>.toDoList.length, <span class="number">0</span>, <span class="built_in">this</span>.toDoText)</span><br><span class="line">                <span class="built_in">this</span>.toDoText = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        deleteWait(index) &#123;</span><br><span class="line">            <span class="built_in">this</span>.toDoList.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        deleteComplete(index) &#123;</span><br><span class="line">            <span class="built_in">this</span>.completedList.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>页面写完，原型上的需求也大概开发完成，页面大概长如下样子：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/2019/vue_jest_03.png"></p><h3 id="修改目录配置"><a href="#修改目录配置" class="headerlink" title="修改目录配置"></a>修改目录配置</h3><p>接下来就是开始编写单元测试文件了，写之前我们先把测试文件目录修改下为 <code>__tests__</code>，同时修改 <code>jest.config.js</code> 为如下配置，注意其中的 <code>testMatch</code> 已经修改为匹配 <code>__tests__</code> 目录下的所有 <code>.js</code> 文件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    moduleFileExtensions: [</span><br><span class="line">        <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    transform: &#123;</span><br><span class="line">        <span class="string">&#x27;^.+\\.vue$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/node_modules/vue-jest&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;^.+\\.js$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/node_modules/babel-jest&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    moduleNameMapper: &#123;</span><br><span class="line">        <span class="string">&#x27;^@/(.*)$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/src/$1&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    snapshotSerializers: [</span><br><span class="line">        <span class="string">&#x27;jest-serializer-vue&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    testMatch: [<span class="string">&#x27;**/__tests__/**/*.spec.js&#x27;</span>],</span><br><span class="line">    transformIgnorePatterns: [<span class="string">&#x27;&lt;rootDir&gt;/node_modules/&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写测试文件"><a href="#编写测试文件" class="headerlink" title="编写测试文件"></a>编写测试文件</h3><p>在 <code>__tests__/unit/</code> 目录下新建文件 <code>todolist.spec.js</code>，我们约定测试某个 <code>vue</code> 文件，那么它的单元测试文件习惯命名成 <code>*.spec.js</code> 或 <code>*.test.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ToDoList <span class="keyword">from</span> <span class="string">&#x27;@/components/ToDoList&#x27;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;test ToDoList&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    it(<span class="string">&#x27;输入框初始值为空字符串&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">        expect(wrapper.vm.toDoText).toBe(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面这个测试文件简要说明：</p><ul><li><code>shallowMount</code> 将会创建一个包含被挂载和渲染的 <code>Vue</code> 组件的 <code>Wrapper</code>，只存根当前组件，不包含子组件。</li><li><code>describe(name, fn)</code> 这边是定义一个测试套件，<code>test ToDoList</code> 是测试套件的名字，<code>fn</code> 是具体的可执行的函数</li><li><code>it(name, fn)</code> 是一个测试用例，<code>输入框初始值为空字符串</code> 是测试用例的名字，<code>fn</code> 是具体的可执行函数；一个测试套件里可以保护多个测试用例。</li><li><code>expect</code> 是 <code>Jest</code> 内置的断言风格，业界还存在别的断言风格比如 <code>Should</code>、<code>Assert</code> 等。</li><li><code>toBe</code> 是 <code>Jest</code> 提供的断言方法， 更多的可以到<a href="https://jestjs.io/docs/zh-Hans/expect"><code>Jest Expect</code></a> 查看具体用法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;待完成列表初始值应该为空数组&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    expect(wrapper.vm.toDoList.length).toBe(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">&#x27;已完成列表初始值应该为空数组&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    expect(wrapper.vm.completedList).toEqual([])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>待完成和已完成列表，居然是列表，所以存放数据的字段必须是 <code>Array</code> 类型，空列表就是空数组。如果第二个测试用例改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(wrapper.vm.completedList).toBe([])</span><br></pre></td></tr></table></figure><p>将会报错，因为 <code>toBe</code> 方法内部是调用 <code>Object.is(value1, value2)</code> 来比较2个值是否相等的，和 <code>==</code> 或 <code>===</code> 的判断逻辑不一样。显然 <code>Object.is([], [])</code> 会返回 <code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;输入框值变化的时候，toDoText应该跟着变化&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    wrapper.find(<span class="string">&#x27;.to-do-text&#x27;</span>).setValue(<span class="string">&#x27;晚上要陪妈妈逛超市&#x27;</span>)</span><br><span class="line">    expect(wrapper.vm.toDoText).toBe(<span class="string">&#x27;晚上要陪妈妈逛超市&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">&#x27;输入框没有值，敲入回车的时候，无变化&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    <span class="keyword">const</span> length = wrapper.vm.toDoList.length</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">&#x27;.to-do-text&#x27;</span>)</span><br><span class="line">    input.setValue(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    input.trigger(<span class="string">&#x27;keyup.enter&#x27;</span>)</span><br><span class="line">    expect(wrapper.vm.toDoList.length).toBe(length)</span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">&#x27;输入框有值，敲入回车的时候，待完成列表将新增一条数据，同时清空输入框&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    <span class="keyword">const</span> length = wrapper.vm.toDoList.length</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">&#x27;.to-do-text&#x27;</span>)</span><br><span class="line">    input.setValue(<span class="string">&#x27;晚上去吃大餐&#x27;</span>)</span><br><span class="line">    input.trigger(<span class="string">&#x27;keyup.enter&#x27;</span>)</span><br><span class="line">    expect(wrapper.vm.toDoList.length).toBe(length + <span class="number">1</span>)</span><br><span class="line">    expect(wrapper.vm.toDoText).toBe(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>setValue</code> 可以设置一个文本控件的值并更新 <code>v-model</code> 绑定的数据。</li><li><code>.to-do-text</code> 是一个 <code>CSS</code> 选择器；<code>Vue-Test-Utils</code> 提供了 <code>find</code> 方法来通过查找选择器，来返回一个 <code>Wrapper</code>；选择器可以是 <code>CSS</code> 选择器、可以是 <code>Vue</code> 组件也可以是一个对象，这个对象包含了组件的 <code>name</code> 或 <code>ref</code> 属性，比如可以这样用：<code>wrapper.find(&#123; name: &#39;my-button&#39; &#125;)</code></li><li><code>wrapper.vm</code> 是一个 <code>Vue</code> 实例，只有 <code>Vue</code> 组件的包裹器才有 <code>vm</code> 这个属性；通过 <code>wrapper.vm</code> 可以访问所有 <a href="https://vuejs.org/v2/api/#Instance-Properties"><code>Vue</code> 实例的属性和方法</a>。比如：<code>wrapper.vm.$data</code>、<code>wrapper.vm.$nextTick()</code>。</li><li><code>trigger</code> 方法可以用来触发一个 <code>DOM</code> 事件，这里触发的事件都是同步的，所以不必将断言放到 <code>$nextTick()</code> 里去执行；同时支持传入一个对象，当捕获到事件的时候，可以获取到传入对象的属性。可以这样写：<code>wrapper.trigger(&#39;click&#39;, &#123;name: &quot;bubuzou.com&quot;&#125;)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;待完成列表支持编辑功能，编辑后更新toDoList数组&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    wrapper.setData(&#123;<span class="attr">toDoList</span>: [<span class="string">&#x27;跑步半小时&#x27;</span>]&#125;)</span><br><span class="line">    wrapper.find(<span class="string">&#x27;.wait-to-do li&#x27;</span>).find(<span class="string">&#x27;input&#x27;</span>).setValue(<span class="string">&#x27;绕着公园跑3圈&#x27;</span>) </span><br><span class="line">    wrapper.find(<span class="string">&#x27;.wait-to-do li&#x27;</span>).find(<span class="string">&#x27;input&#x27;</span>).trigger(<span class="string">&#x27;blur&#x27;</span>) </span><br><span class="line">    expect(wrapper.vm.toDoList[<span class="number">0</span>]).toBe(<span class="string">&#x27;绕着公园跑3圈&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>先用 <code>setData</code> 给 <code>toDoList</code> 设置一个初始值，使其渲染出一个列表项；然后找到这个列表项，用 <code>setValue</code> 给其设置值，模拟了编辑；列表项的输入框是用 <code>:value=&quot;item&quot;</code> 绑定的 <code>value</code>, 所以 <code>setValue</code> 无法触发更新；只能通过 <code>trigger</code> 来触发更新 <code>toDoList</code> 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;待完成列表点击删除，同时更新toDoList数组&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    wrapper.setData(&#123;<span class="attr">toDoList</span>: [<span class="string">&#x27;睡前看一小时书&#x27;</span>]&#125;)</span><br><span class="line">    expect(wrapper.vm.toDoList.length).toBe(<span class="number">1</span>)</span><br><span class="line">    wrapper.find(<span class="string">&#x27;.wait-to-do li&#x27;</span>).find(<span class="string">&#x27;.del&#x27;</span>).trigger(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">    expect(wrapper.vm.toDoList.length).toBe(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">&#x27;点击待完成列表中某项的已完成按钮，数据对应更新&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    wrapper.setData(&#123;<span class="attr">toDoList</span>: [<span class="string">&#x27;中午饭后吃一个苹果&#x27;</span>]&#125;)</span><br><span class="line">    expect(wrapper.vm.toDoList.length).toBe(<span class="number">1</span>)</span><br><span class="line">    expect(wrapper.vm.completedList.length).toBe(<span class="number">0</span>)</span><br><span class="line">    wrapper.find(<span class="string">&#x27;.wait-to-do li&#x27;</span>).find(<span class="string">&#x27;.move&#x27;</span>).trigger(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">    expect(wrapper.vm.toDoList.length).toBe(<span class="number">0</span>)</span><br><span class="line">    expect(wrapper.vm.completedList.length).toBe(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">&#x27;点击已完成列表中某项的未完成按钮，数据对应更新&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    wrapper.setData(&#123;<span class="attr">completedList</span>: [<span class="string">&#x27;唱了一首歌&#x27;</span>]&#125;)</span><br><span class="line">    expect(wrapper.vm.toDoList.length).toBe(<span class="number">0</span>)</span><br><span class="line">    expect(wrapper.vm.completedList.length).toBe(<span class="number">1</span>)</span><br><span class="line">    wrapper.find(<span class="string">&#x27;.has-completed li&#x27;</span>).find(<span class="string">&#x27;.move&#x27;</span>).trigger(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">    expect(wrapper.vm.toDoList.length).toBe(<span class="number">1</span>)</span><br><span class="line">    expect(wrapper.vm.completedList.length).toBe(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">&#x27;列表序号从1开始递增&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    wrapper.setData(&#123;<span class="attr">toDoList</span>: [<span class="string">&#x27;早上做作业&#x27;</span>, <span class="string">&#x27;下午去逛街&#x27;</span>]&#125;)</span><br><span class="line">    expect(wrapper.vm.toDoList.length).toBe(<span class="number">2</span>)</span><br><span class="line">    expect(wrapper.find(<span class="string">&#x27;.wait-to-do&#x27;</span>).html()).toMatch(<span class="string">&#x27;&lt;i&gt;1&lt;/i&gt;&#x27;</span>)</span><br><span class="line">    expect(wrapper.find(<span class="string">&#x27;.wait-to-do&#x27;</span>).html()).toMatch(<span class="string">&#x27;&lt;i&gt;2&lt;/i&gt;&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">&#x27;当待完成列表为空的时候，不显示待完成字样&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(ToDoList)</span><br><span class="line">    wrapper.setData(&#123;<span class="attr">toDoList</span>: []&#125;)</span><br><span class="line">    expect(wrapper.find(<span class="string">&#x27;h4&#x27;</span>).isVisible()).toBeFalsy()</span><br><span class="line">    wrapper.setData(&#123;<span class="attr">toDoList</span>: [<span class="string">&#x27;明天去爬北山&#x27;</span>]&#125;)</span><br><span class="line">    expect(wrapper.find(<span class="string">&#x27;h4&#x27;</span>).isVisible()).toBeTruthy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一个测试用例中可以写多个 <code>expect</code> 以保证断言的准确性。</p><h3 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h3><p>最后我们为了模拟异步测试，所以加一个需求，即页面加载的时候会去请求远程待完成列表的数据。<br>在项目根目录新建 <code>__mocks__</code> 目录，同时新建 <code>axios.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toToList = &#123;</span><br><span class="line">    success: <span class="literal">true</span>,</span><br><span class="line">    data: [<span class="string">&#x27;上午去图书馆看书&#x27;</span>, <span class="string">&#x27;下去出去逛街&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> get = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (url === <span class="string">&#x27;toToList.json&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (toToList.success) &#123;</span><br><span class="line">                resolve(toToList)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>ToDoList.vue</code>，导入 <code>axios</code> 和增加 <code>mounted</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> axios <span class="keyword">from</span> <span class="string">&#x27;../../__mocks__/axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">        axios.get(<span class="string">&#x27;toToList.json&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.toDoList = res.data</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试用例编写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;当页面挂载的时候去请求数据，请求成功后应该会返回2条数据&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    wrapper.vm.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        expect(wrapper.vm.toDoList.length).toBe(<span class="number">2</span>)</span><br><span class="line">        done()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于异步的代码，写断言的时候需要放在 <code>wrapper.vm.$nextTick()</code> 里，且手动调用 <code>done()</code>。</p><h3 id="配置测试覆盖率"><a href="#配置测试覆盖率" class="headerlink" title="配置测试覆盖率"></a>配置测试覆盖率</h3><p>测试用例写了部分，如果我们看下覆盖率如何，就需要要配置测试覆盖率。在 <code>jest.config.js</code> 里新增配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collectCoverage: <span class="literal">true</span>,</span><br><span class="line">collectCoverageFrom: [<span class="string">&quot;**/*.&#123;js,vue&#125;&quot;</span>, <span class="string">&quot;!**/node_modules/**&quot;</span>],</span><br></pre></td></tr></table></figure><p>在 <code>package.json</code> 的 <code>scripts</code> 中新增一条配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;test:cov&quot;: &quot;vue-cli-service test:unit --coverage&quot;</span><br></pre></td></tr></table></figure><p>然后我们在终端运行： <code>npm run test:cov</code>，结果如下：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/2019/vue_jest_04.png" alt="test:cov1"></p><p>运行测试覆盖率命名后会在项目根目录生成 <code>coverage</code> 目录，浏览器打开里面的 <code>index.html</code> ：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/2019/vue_jest_05.png" alt="test:cov2"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jest </tag>
            
            <tag> vue-test-utils </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用操作，一文打尽</title>
      <link href="/2019/09/24/git-all-actions/"/>
      <url>/2019/09/24/git-all-actions/</url>
      
        <content type="html"><![CDATA[<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/2019/git_all_01.png" alt="git_flow"></p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><ul><li><code>git clone url</code>  克隆远程版本库</li><li><code>git init</code>  初始化本地版本库</li></ul><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><code>git config --global user.name &#39;chengcp&#39;</code>  配置<code>global</code>级别的用户名</li><li><code>git config --global user.email &#39;1326895569@qq.com&#39;</code>  配置<code>global</code>级别的邮箱</li><li><code>git config --global -l</code>  查看<code>global</code>级别的配置列表</li><li><code>git config --global --unset user.name</code>  删除用户名</li><li><code>git config --global alias.last &#39;log -1 HEAD&#39;</code>  配置<code>last</code>别名，使用<code>git last</code>将显示最近的一次提交记录</li></ul><h2 id="添加和删除文件"><a href="#添加和删除文件" class="headerlink" title="添加和删除文件"></a>添加和删除文件</h2><ul><li><code>git add file1 file2</code>  添加指定文件到暂存区</li><li><code>git add dir</code>  添加指定目录到暂存区</li><li><code>git add .</code>  添加当前目录的所有文件到暂存区</li><li><code>git mv oldname newname</code>  对一个已经追踪过的文件进行改名，同时加入暂存区</li><li><code>git rm file1 file2</code>  删除工作区文件，同时将这次删除放入暂存区  </li><li><code>git rm --cached file</code>  停止追踪指定文件，但该文件会保留在工作区；<code>tracked</code>变成<code>untracked</code></li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><ul><li><code>git commit file1 file 2 -m message</code>  提交暂存区指定文件到本地仓库</li><li><code>git commit -m message</code>  提交暂存区所有文件到本地仓库</li><li><code>git commit -a -m message</code>  自动暂存所有已经追踪过的文件，且提交到本地仓库   </li><li><code>git commit --amend -m message</code>  使用一次新的提交，替代上次提交</li></ul><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul><li><code>git branch</code>  查看所有本地分支</li><li><code>git branch –r</code>  查看所有远程分支</li><li><code>git branch –a</code>  查看所有远程和本地分支</li><li><code>git branch –v</code>  查看本地所有分支最新一次提交信息</li><li><code>git branch [branch]</code>  新建分支   </li><li><code>git checkout –b [branch]</code>  新建一个分支，并且切换过去</li><li><code>git branch [branch] [commit]</code>  基于某次提交，建立一个分支</li><li><code>git branch --track [branch] [remote-branch]</code>  建立一个分支，并且与远程分支建立追踪关系</li><li><code>git branch --set-upstream [branch] [remote-branch]</code>  在现有的本地分支和远程分支之间建立追踪关系</li><li><code>git branch –m [old-branch] [new-branch]</code>  重命名分支</li><li><code>git merge [branch]</code>  把指定分支合并到当前分支</li><li><code>git chery-pick [commit] [commit]</code>  选择提交，合并进当前分支</li><li><code>git branch –d [branch]</code>  删除本地分支</li><li><code>git push origin –d [branch]</code>  删除远程分支</li><li><code>git checkout [branch]</code>  切换分支</li><li><code>git checkout -</code>  切换到上一个最近使用过的分支</li></ul><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li><code>git tag</code>  列出所有标签</li><li><code>git show [tag]</code>  查看指定标签信息</li><li><code>git tag [tag]</code>  给最近一次提交打一个标签</li><li><code>git tag [tag] [commit]</code>  在某次提交上打一个标签</li><li><code>git tag –d [tag]</code>  删除本地指定标签</li><li><code>git push origin –d tag [tag]</code>  删除远程的标签</li><li><code>git push origin [tag]</code>  推送指定标签</li><li><code>git push origin --tags</code>  推送所有标签</li></ul><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><ul><li><code>git status</code>  查看文件状态</li><li><code>git help [command]</code>  获取帮助文档</li><li><code>git [command] --help</code>  获取帮助文档</li><li><code>git log</code>  查看当前分支的提交记录</li><li><code>git log –all</code>  查看所有分支的提交记录</li><li><code>git log -5 --oneline --graph</code>   查看最近5次提交记录，以单行、树状图形式显示</li><li><code>git reflog</code>  查看本地所有变更记录</li><li><code>git diff</code>  查看工作区和暂存区的差异</li><li><code>git diff -- file</code>  某个文件在工作区和暂存区的差异</li><li><code>git diff HEAD</code>   工作区和最新一次提交的差异</li><li><code>git diff --cached</code>  暂存区和HEAD的差异</li><li><code>git diff branch_a branch_b – file</code>  某文件在两个分支间的差异</li></ul><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><ul><li><code>git remote -v</code>  查看所有远程仓库</li><li><code>git ls-remote origin</code>  查看远程仓库引用列表</li><li><code>git remote show origin</code>  查看远程仓库信息</li><li><code>git fetch origin</code>  拉取远程仓库最新提交</li><li><code>git pull origin master</code>  拉取远程<code>master</code>，并且合并到本地当前分支</li><li><code>git remote add  upstream url</code>  添加一个新的远程仓库，命名为<code>upstream</code></li><li><code>git push origin master</code>  推送到远程<code>origin</code>的<code>master</code>分支</li><li><code>git push origin --all</code>  推送所有分支到远程仓库</li><li><code>git remote prune origin</code>  删除远程仓库中不存在的分支</li></ul><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li><code>git reset --soft HEAD</code>  回滚到指定版本，保留工作区和暂存区</li><li><code>git reset --mixed HEAD</code>  回滚到指定版本，保留工作区，清空暂存区；<code>--mixed</code>是默认参数，即等同于<code>git reset HEAD</code></li><li><code>git reset --hard HEAD</code>  回滚到指定版本，清空工作区和暂存区</li><li><code>git reset HEAD -- file</code>  清空暂存区中某个文件的修改</li><li><code>git checkout -- file</code>  检出暂存区的文件到工作目录 </li><li><code>git checkout .</code>  检出暂存区的所有文件到工作目录</li><li><code>git revert HEAD~ 2</code>  回滚到2个祖先提交的版本，同时产生新的提交记录</li><li><code>git revert --continue</code>  冲突解决，且把修改提交到暂存区后执行回滚，生成一个新的提交</li><li><code>git revert –abort</code>  取消回滚，回到之前的状态</li></ul><h2 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h2><ul><li><code>git stash</code>  将工作区和暂存区的变更保存到储藏堆栈中，同时工作区和暂存区恢复到<code>HEAD</code>一样</li><li><code>git stash list</code>  查看储藏列表</li><li><code>git stash pop</code>  应用最近的一次储藏，并且从储藏栈中移除该条记录</li><li><code>git stash apply stash@&#123;0&#125;</code>  应用最近的一次储藏，不移除记录；等同于 <code>git stash apply</code></li><li><code>git stash pop --index</code>  应用最近一次储藏，<code>--index</code>表示暂存区的变更也会更新，否则只更新工作区变更</li><li><code>git stash drop  stash@&#123;0&#125;</code>  移除储藏记录</li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-quill-editor插入图片路径太长问题解决</title>
      <link href="/2019/07/26/vue-quill-editor/"/>
      <url>/2019/07/26/vue-quill-editor/</url>
      
        <content type="html"><![CDATA[<p>最近做项目的时候有一个发布新闻的需求，新闻编辑的时候要求能发布带格式的文本内容和能展示支持图片。<br>由于项目是用vue开发的，所以找编辑器的时候选了 <code>vue-quill-editor</code> 。编辑器长如下的样子：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/2019/quill_01.png" alt="quill_01"></p><a id="more"></a><h2 id="现在的问题"><a href="#现在的问题" class="headerlink" title="现在的问题"></a>现在的问题</h2><p>但是这个编辑器会把插入的图片会转成 <code>base64</code> 位的编码，使得编辑器内容保存进数据库的时候会超出限制长度，从而报错。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/2019/quill_02.png" alt="quill_01"></p><h2 id="从问题来源着手"><a href="#从问题来源着手" class="headerlink" title="从问题来源着手"></a>从问题来源着手</h2><p>首先要明白导致这个问题的原因是 <code>vue-quill-editor</code> 编辑器默认把上传的图片给转成 <code>base64</code> 编码，那是不是有这么一个配置参数可以设置上传后图片的格式呢？经过一番文档的查找，貌似是没有。但是提供了一个 <code>handlers</code> 可以自定义图片上传的方式，那就从这里下文章。大概意思是点击这个图片按钮的时候，会出发一个回调，可以在回调里触发自己的文件上传开关。这里我用的文件上传是 <code>element-ui</code> 的 <code>el-upload</code>。</p><h2 id="安装vue-quill-editor"><a href="#安装vue-quill-editor" class="headerlink" title="安装vue-quill-editor"></a>安装<code>vue-quill-editor</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-quill-editor --save</span><br></pre></td></tr></table></figure><h2 id="配置vue-quill-editor"><a href="#配置vue-quill-editor" class="headerlink" title="配置vue-quill-editor"></a>配置<code>vue-quill-editor</code></h2><p>配置 <code>html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">quill-editor</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">&quot;ruleForm.content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">&quot;myQuillEditor&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:options</span>=<span class="string">&quot;editorOption&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;ql-editor&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">&quot;operationType.includes(&#x27;check&#x27;) ? &#x27;disabled&#x27; : &#x27;&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:disabled</span>=<span class="string">&quot;operationType.includes(&#x27;check&#x27;)&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">quill-editor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入<code>vue-quill-editor</code> 且设置<code>components</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; quillEditor &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-quill-editor&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        quillEditor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置<code>options</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">editorOption:&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        toolbar: &#123;</span><br><span class="line">            container: [</span><br><span class="line">                [<span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;italic&#x27;</span>, <span class="string">&#x27;underline&#x27;</span>, <span class="string">&#x27;strike&#x27;</span>],</span><br><span class="line">                [<span class="string">&#x27;blockquote&#x27;</span>, <span class="string">&#x27;code-block&#x27;</span>],</span><br><span class="line">                [&#123; <span class="string">&#x27;list&#x27;</span>: <span class="string">&#x27;ordered&#x27;</span> &#125;, &#123; <span class="string">&#x27;list&#x27;</span>: <span class="string">&#x27;bullet&#x27;</span> &#125;],</span><br><span class="line">                [&#123; <span class="string">&#x27;script&#x27;</span>: <span class="string">&#x27;sub&#x27;</span> &#125;, &#123; <span class="string">&#x27;script&#x27;</span>: <span class="string">&#x27;super&#x27;</span> &#125;],</span><br><span class="line">                [&#123; <span class="string">&#x27;indent&#x27;</span>: <span class="string">&#x27;-1&#x27;</span> &#125;, &#123; <span class="string">&#x27;indent&#x27;</span>: <span class="string">&#x27;+1&#x27;</span> &#125;],</span><br><span class="line">                [&#123; <span class="string">&#x27;size&#x27;</span>: [<span class="string">&#x27;small&#x27;</span>, <span class="literal">false</span>, <span class="string">&#x27;large&#x27;</span>, <span class="string">&#x27;huge&#x27;</span>] &#125;],</span><br><span class="line">                [&#123; <span class="string">&#x27;header&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="literal">false</span>] &#125;],</span><br><span class="line">                [&#123; <span class="string">&#x27;color&#x27;</span>: [] &#125;, &#123; <span class="string">&#x27;background&#x27;</span>: [] &#125;],</span><br><span class="line">                [&#123; <span class="string">&#x27;align&#x27;</span>: [] &#125;],</span><br><span class="line">                [<span class="string">&#x27;clean&#x27;</span>],</span><br><span class="line">                [<span class="string">&#x27;link&#x27;</span>, <span class="string">&#x27;image&#x27;</span>]</span><br><span class="line">            ],</span><br><span class="line">            handlers: &#123;</span><br><span class="line">                image: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                        <span class="comment">// 触发element-ui的文件上传</span></span><br><span class="line">                        <span class="built_in">document</span>.querySelector(<span class="string">&quot;.avatar-uploader input&quot;</span>).click();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.quill.format(<span class="string">&quot;image&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    placeholder: <span class="string">&#x27;请输入&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>引入相关<code>style</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">  <span class="keyword">@import</span> <span class="string">&#x27;~quill/dist/quill.core.css&#x27;</span>;</span><br><span class="line">  <span class="keyword">@import</span> <span class="string">&#x27;~quill/dist/quill.snow.css&#x27;</span>;</span><br><span class="line">  <span class="keyword">@import</span> <span class="string">&#x27;~quill/dist/quill.bubble.css&#x27;</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="配置el-upload"><a href="#配置el-upload" class="headerlink" title="配置el-upload"></a>配置<code>el-upload</code></h2><p><code>template</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">&quot;quillUploader&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;avatar-uploader&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:action</span>=<span class="string">&quot;serverUrl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:show-file-list</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:auto-upload</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:on-change</span>=<span class="string">&quot;onChangeQuill&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:before-upload</span>=<span class="string">&quot;beforeUpload&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:limit</span>=<span class="string">&quot;20&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:multiple</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:accept</span>=<span class="string">&quot;acceptFile&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>onChange</code>的时候执行文件上传，这里的文件上传用的是腾讯的对象存储服务，<code>cosUtils</code>封装了一些对象存储的一些工具方法，你们可以自行替换成自己后端的上传接口。下面这段代码的大概意思是文件上传到对象存储服务器成功之后，拿到具体的图片地址，插入到编辑器光标所在的位置，这个时候图片就显示出来了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onChangeQuill(file, fileList) &#123; </span><br><span class="line">    <span class="keyword">let</span> fileName = file.uid + file.name</span><br><span class="line">    cosUtils.putObject(fileName, file.raw, <span class="string">&#x27;operate/&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;  <span class="comment">// 新闻图片存到operate/目录下</span></span><br><span class="line">        <span class="built_in">console</span>.log(err || data)</span><br><span class="line">        <span class="keyword">if</span> (!err) &#123; </span><br><span class="line">            <span class="keyword">let</span> quill = <span class="built_in">this</span>.$refs.myQuillEditor.quill</span><br><span class="line">            <span class="keyword">let</span> length = quill.getSelection().index</span><br><span class="line">            <span class="comment">// 图片上传到对象存储后的具体地址</span></span><br><span class="line">            <span class="keyword">let</span> imgSrc =  <span class="string">`https://huzhouhuanzi-xxxxxxx.cos.ap-shanghai.myqcloud.com/operate/<span class="subst">$&#123;fileName&#125;</span>`</span></span><br><span class="line">            quill.insertEmbed(length, <span class="string">&quot;image&quot;</span>, imgSrc)</span><br><span class="line">            <span class="comment">// 调整光标到最后</span></span><br><span class="line">            quill.setSelection(length + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像 </tag>
            
            <tag> upload </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序根据打包命令区分不同环境的API</title>
      <link href="/2019/06/27/wepy-plugins-preprocess/"/>
      <url>/2019/06/27/wepy-plugins-preprocess/</url>
      
        <content type="html"><![CDATA[<p>一般来讲项目都会有开发版、测试版和生产版这三个版本，不同版本对应不同的API域名，比如可能会是这样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOST_DEV = <span class="string">&#x27;https://dev-bubuzouapi.com/&#x27;</span>  <span class="comment">// 开发环境API</span></span><br><span class="line"><span class="keyword">const</span> HOST_TEST = <span class="string">&#x27;https://test-bubuzouapi.com/&#x27;</span>  <span class="comment">// 测试环境API</span></span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">&#x27;https://bubuzouapi.com/&#x27;</span>  <span class="comment">// 生产环境API</span></span><br></pre></td></tr></table></figure><p>前端项目里要如何区分用什么时候用哪个API呢？比较笨的方法是，比如这次我要打一个测试环境给测试用，那我必须手动的把 <code>HOST_TEST</code> 这个变量的值设置到请求的 <code>url</code> 里。如果下次需要打其他环境的包，那我就需要再次手动更改 <code>url</code> 为别的值，这样显得很不方便。</p><a id="more"></a><h2 id="wepy-plugin-preprocess"><a href="#wepy-plugin-preprocess" class="headerlink" title="wepy-plugin-preprocess"></a>wepy-plugin-preprocess</h2><p>如果你的小程序用的是 <code>wepy</code> 框架来构建的话，你可以用 <code>wepy-plugin-preprocess</code> <a href="https://www.npmjs.com/package/wepy-plugin-preprocess">这个插件</a>来对 <code>js</code> 进行一个预处理，可以使得每次设置到请求里的 <code>url</code> 的值是根据打包命令来的。</p><p><code>wepy-plugin-preprocess</code> 是依赖于 <code>preprocess</code> 这个包的，这个包里定义了一些用于预处理的指令，比如 <code>@if VAR=&#39;value&#39;</code>、<code>@ifdef VAR</code>、<code>@include</code> 这种，想要了解更多用法，<a href="https://www.npmjs.com/package/preprocess">请点击这里。</a></p><p>安装插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install wepy-plugin-preprocess --save-dev</span><br></pre></td></tr></table></figure><h2 id="配置wepy-config-js文件"><a href="#配置wepy-config-js文件" class="headerlink" title="配置wepy.config.js文件"></a>配置wepy.config.js文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ENV = process.env.NODE_ENV</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: &#123;</span><br><span class="line">        preprocess: &#123;</span><br><span class="line">            filter: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            context: &#123; ENV &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置package-json文件"><a href="#设置package-json文件" class="headerlink" title="设置package.json文件"></a>设置package.json文件</h2><p>想要区分不同的环境，就需要配置几个不同环境的打包命令。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=dev wepy build --watch&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=test wepy build --no-cache&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prod&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=prod wepy build --no-cache&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义常量文件"><a href="#定义常量文件" class="headerlink" title="定义常量文件"></a>定义常量文件</h2><p>常量文件里可以定义一些项目里用到的常量，比如这里会定义 <code>API</code> 域名。然后把常量导出去，需要用的地方再导入即可使用这些常量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @if ENV=&#x27;dev&#x27; **</span></span><br><span class="line"><span class="comment">const HOST = exports.HOST =  &#x27;https://dev-bubuzouapi.com/&#x27;  // 开发环境API</span></span><br><span class="line"><span class="comment">const HOST_SOCKET = exports.HOST_SOCKET = &#x27;wss://dev-bubuzouapi.com/&#x27;  // 开发环境socket</span></span><br><span class="line"><span class="comment">/* @endif */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @if ENV=&#x27;test&#x27; **</span></span><br><span class="line"><span class="comment">const HOST = exports.HOST = &#x27;https://test-bubuzouapi.com/&#x27;  // 测试环境API</span></span><br><span class="line"><span class="comment">const HOST_SOCKET = exports.HOST_SOCKET = &#x27;wss://test-bubuzouapi.com/&#x27; // 测试环境socket</span></span><br><span class="line"><span class="comment">/* @endif */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @if ENV=&#x27;prod&#x27; **</span></span><br><span class="line"><span class="comment">const HOST = exports.HOST = &#x27;https://bubuzouapi.com/&#x27;  // 生产环境API</span></span><br><span class="line"><span class="comment">const HOST_SOCKET = exports.HOST_SOCKET = &#x27;wss://bubuzouapi.com/&#x27;  // 生产环境socket</span></span><br><span class="line"><span class="comment">/* @endif */</span></span><br></pre></td></tr></table></figure><h2 id="通过命令切换api域名"><a href="#通过命令切换api域名" class="headerlink" title="通过命令切换api域名"></a>通过命令切换api域名</h2><p>切换成开发环境：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev  <span class="comment">// 编译完成后请求的域名就是&#x27;https://dev-bubuzouapi.com/&#x27;</span></span><br></pre></td></tr></table></figure><p>切换成测试环境：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run test</span><br></pre></td></tr></table></figure><p>切换成生产环境：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run prod</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-ui文件上传一次请求上传多个文件</title>
      <link href="/2019/03/26/once-request-to-upload-multiple-files/"/>
      <url>/2019/03/26/once-request-to-upload-multiple-files/</url>
      
        <content type="html"><![CDATA[<p>最近在做项目的时候有一个需求，需要导入word文档，并且需要支持多选。<code>element-ui</code> 的 <code>upload</code> 组件支持多选文件，只需要配置参数 <code>multiple</code> 为 <code>true</code> 即可。但是这个组件默认会将多选的文件分多次进行上传，于是就会存在多次的上传请求，由于后台的接口要求是一次请求能够上传多个文件，且我们也知道请求多了会对服务器造成更大的压力，因而基于多种原因，这个 <code>upload</code> 的上传行为得进行改造一番。</p><a id="more"></a><h2 id="先来看下改造前后的结果"><a href="#先来看下改造前后的结果" class="headerlink" title="先来看下改造前后的结果"></a>先来看下改造前后的结果</h2><p>改造前的结果：同时上传2个文件，会发出2次对接口的请求，每次请求里包含了一个文件。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/2019/upload_result_before.png" alt="upload_result_after"></p><p>改造后的结果：同时上传2个文件，会发出一次接口请求，接口入参里包含2个文件。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/2019/upload_result_after.png" alt="upload_result_after"></p><h2 id="方法一：通过配置file-list（推荐使用）"><a href="#方法一：通过配置file-list（推荐使用）" class="headerlink" title="方法一：通过配置file-list（推荐使用）"></a>方法一：通过配置file-list（推荐使用）</h2><p>html部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;upload-demo list-uploadbtn&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">&quot;upload&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:action</span>=<span class="string">&quot;curBastUrl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:auto-upload</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:on-remove</span>=<span class="string">&quot;updataRemove&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:before-upload</span>=<span class="string">&quot;beforeUpload&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:on-change</span>=<span class="string">&quot;updatachange&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:file-list</span>=<span class="string">&quot;fileList&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:multiple</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span>&gt;</span>点击上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;submitUpload&quot;</span>&gt;</span>确 定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">submitUpload() &#123;  <span class="comment">// 导入</span></span><br><span class="line">    <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData();  <span class="comment">//  用FormData存放上传文件</span></span><br><span class="line">    <span class="built_in">this</span>.fileList.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123; </span><br><span class="line">        formData.append(<span class="string">&#x27;file&#x27;</span>, file.raw)        </span><br><span class="line">    &#125;) </span><br><span class="line">    　　    </span><br><span class="line">    formData.append(<span class="string">&#x27;categoryDirectory&#x27;</span>, <span class="built_in">this</span>.filedata.categoryDirectory)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// importCase是上传接口</span></span><br><span class="line">    importCase(formData).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="comment">//手动上传无法触发成功或失败的钩子函数，因此这里手动调用 </span></span><br><span class="line">    　　<span class="built_in">this</span>.updataSuccess(res.data) </span><br><span class="line">    &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    　　 </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码说明：</p><ul><li><code>auto-upload</code> 设置为 <code>false</code> 用于关闭组件的自动上传；</li><li><code>file-list</code> 配置一个数组用于接收上传的文件列表；</li><li><code>multiple</code> 设置为 <code>true</code> 表示支持多选文件；</li><li><code>action</code> 配置为完整的上传接口url，不配置会报错</li><li>不用配置 <code>data</code>、<code>on-success</code>、<code>on-error</code>等参数，因为手动上传不会用到这些配置信息；</li><li>最后通过点击按钮手动调用上传函数     <code>submitUpload</code> ，创建一个 <code>FormData</code> 把 <code>fileList </code> 的文件存进去。</li></ul><h2 id="方法二：通过配置http-request"><a href="#方法二：通过配置http-request" class="headerlink" title="方法二：通过配置http-request"></a>方法二：通过配置http-request</h2><p>html部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;upload-demo list-uploadbtn&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">&quot;upload&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:action</span>=<span class="string">&quot;curBastUrl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:auto-upload</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:http-request</span>=<span class="string">&quot;uploadFile&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:on-remove</span>=<span class="string">&quot;updataRemove&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:before-upload</span>=<span class="string">&quot;beforeUpload&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:on-change</span>=<span class="string">&quot;updatachange&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:multiple</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span>&gt;</span>点击上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;submitUpload&quot;</span>&gt;</span>确 定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">submitUpload() &#123;  <span class="comment">// 导入</span></span><br><span class="line">    <span class="keyword">let</span> tempData =  <span class="built_in">this</span>.filedata</span><br><span class="line">    <span class="built_in">this</span>.filedata = <span class="keyword">new</span> FormData()  <span class="comment">//  用FormData存放上传文件</span></span><br><span class="line">    <span class="built_in">this</span>.$refs.upload.submit()  <span class="comment">// 会循环调用uploadFile方法，多个文件调用多次</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.filedata.append(<span class="string">&#x27;categoryDirectory&#x27;</span>, tempData.categoryDirectory)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// importCase是上传接口</span></span><br><span class="line">    importCase(<span class="built_in">this</span>.filedata).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">//手动上传无法触发成功或失败的钩子函数，因此这里手动调用 </span></span><br><span class="line">    　　<span class="built_in">this</span>.updataSuccess(res.data) </span><br><span class="line">    &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    　　 </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">uploadFile(file) &#123;</span><br><span class="line">    <span class="built_in">this</span>.filedata.append(<span class="string">&#x27;file&#x27;</span>, file.file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码说明：</p><ul><li><code>http-request</code> 自定义上传方法；</li><li>最后通过点击按钮手动调用上传函数     <code>submitUpload</code> ，创建一个 <code>FormData</code>, 调用 <code>upload</code> 组件的 <code>submit</code> 方法的时候会循环调用 <code>http-request</code> 配置的方法，从而往 <code>FormData </code> 里存放文件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> upload </tag>
            
            <tag> vue </tag>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中类数组的遍历以及性能探究</title>
      <link href="/2017/08/28/traverse-of-array-like/"/>
      <url>/2017/08/28/traverse-of-array-like/</url>
      
        <content type="html"><![CDATA[<h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p>在 <code>JS</code> 中我们都知道有一种数据类型叫数组，平常也用得很多，这里看到<a href="http://bubuzou.com/2016/11/js-array/">数组</a>的介绍。但什么是类数组呢？<br>在 <code>JS</code> 中存在一些对象，它们都带有 <code>length</code> 属性，却又不具备数组的那些方法，这些对象我们它叫做类数组。那么类数组有哪些呢？</p><ul><li><p><code>jQuery</code>对象</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aList = $(<span class="string">&#x27;.tagcloud&#x27;</span>).find(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log( aList.length );  <span class="comment">// &gt;= 0</span></span><br></pre></td></tr></table></figure><p>  如上通过jQuery获取的元素集合就是一个典型的类数组。</p></li></ul><a id="more"></a><ul><li><p><code>NodeList</code></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h2s = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;h2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log( h2s.constructor );  <span class="comment">// ƒ NodeList() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>  <code>NodeList</code>是节点集合，既包括了元素节点也包含了文本节点，比如<code>node.childNodes</code>也是一个 <code>NodeList</code>.</p></li><li><p><code>HTMLCollection</code></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h4s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;h4&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log( h4s <span class="keyword">instanceof</span> HTMLCollection );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  <code>HTMLCollection</code> 是元素集合，<a href="http://www.w3school.com.cn/xmldom/dom_htmlcollection.asp">更多详细信息可以看这里</a></p></li></ul><p>类数组虽然没有数组的那些方法，但是可以通过 <code>call</code> 方法将其转成数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h2s = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;h2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log( h2s.constructor );  <span class="comment">// ƒ NodeList() &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="built_in">Array</span>.prototype.slice.call(h2s, <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log( temp <span class="keyword">instanceof</span> <span class="built_in">Array</span> );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="遍历类数组"><a href="#遍历类数组" class="headerlink" title="遍历类数组"></a>遍历类数组</h2><p>数组或者类数组的遍历方式很多，下面我们一一来介绍。</p><ul><li><p>普通 <code>for</code> 循环</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最普通也是最经典的 <code>for</code> 循环，大多数开发都喜欢用的方式。</p></li><li><p>优化版 <code>for</code> 循环</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = arr.length; i &lt; l; i++ ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  优化后的<code>for</code>循环，把数组长度的取值放到了定义变量的时候，避免了每次判断都要去取数组长度，从而节约了一定时间。</p></li><li><p>弱化版<code>for</code>循环</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; arr[i] != <span class="literal">null</span>; i++ ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这种循环方式和上面两种都差不了多少，只不过是没有使用<code>length</code>判断，而使用变量本身判断。</p></li><li><p><code>forEach</code>循环</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"> item </span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  JS数组自带的遍历方法。</p></li><li><p>新版<code>forEach</code></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arr, <span class="function"><span class="keyword">function</span>(<span class="params"> ele </span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  借用了原型的<code>call</code>方法来遍历类数组。</p></li><li><p><code>for in</code>循环</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> temp <span class="keyword">in</span> arr ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>for of循环</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> v <span class="keyword">of</span> arr ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>ES6</code>中新提出的一种循环方式。</p></li><li><p><code>map</code>循环</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">e, i</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>while循环</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( flag++ &lt; arr.length ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>这里测试里主要是通过控制外循环次数、数组的长度和循环体的复杂度来达到模拟性能测试的目的。<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201708/array_like_01.png" alt="array_like_01"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line"><span class="keyword">var</span> t4 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> j = <span class="number">0</span>; j &lt; count; j++ ) &#123;  <span class="comment">// 外循环</span></span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"> cha </span>) </span>&#123;  <span class="comment">// 内循环</span></span><br><span class="line">        contextFn( cha );  <span class="comment">// 循环体</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - t4) );</span><br></pre></td></tr></table></figure><p>内循环里是分别替换到不同的遍历方式，通过设置循环次数和数组长度来测试了一些数据，也可以来<a href="http://bubuzou.com/demos/201708/traverse-of-array-like.html">这里看demo</a></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201708/array_like_02.png" alt="array_like_02"></p><p>从上面的测试结果大致可以看出速度最快的遍历方式应该是优化后的 <code>for</code> 循环了。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/background_01.png" alt="younghz的Markdown库"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>良好的CSS编码习惯</title>
      <link href="/2017/07/18/css-coding-standards/"/>
      <url>/2017/07/18/css-coding-standards/</url>
      
        <content type="html"><![CDATA[<p>一个 <code>css</code> 文件的核心内容是由许许多多的 <code>css</code> 规则组成的，而每个规则又包含了两部分：选择器和声明；声明块里可能又包含多个声明，每个声明又是由属性和值组成的。这个大概就是 <code>css</code> 的代码结构。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201707/css_coding_standards_01.png" alt="css_rules"></p><p>这么多的规则就像一个小镇上的房子一样，如果房子建造之初，毫无规划胡乱建造，那等房子建造起来的时候，从远远望去就会非常地错杂不堪，难以入目，给人的心里埋下了非常糟糕的印象；又可能后期，由于发展的需要，要给小镇加修道路或者新建个学校，由于房子与房子之间连接得很混乱，所以这给后期重建镇子的人带来了很大的困难。</p><p>同样，在 <code>css</code> 的世界里，代码的排列布局也是非常重要的。良好的代码书写习惯能够让代码看起来更加干净简洁，给阅读者一种赏心悦目的感觉；好的代码便于开发发现错误，提高工作效率。所以作为一名好前端，很有必要养成一个良好的 <code>css</code> 编码习惯。</p><a id="more"></a><h2 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h2><p><code>web</code> 项目中的所有资源文件名称应遵循相同的命名约定。<code>css</code> 文件也不例外，来看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Not recommended *&#x2F;</span><br><span class="line">MyScript.js</span><br><span class="line">myCamelCaseName.css</span><br><span class="line">i_love_underscores.html</span><br><span class="line">1001-scripts.js</span><br><span class="line">my-file-min.css</span><br><span class="line"> </span><br><span class="line">&#x2F;* Recommended *&#x2F;</span><br><span class="line">my-script.js</span><br><span class="line">my-camel-case-name.css</span><br><span class="line">i-love-underscores.html</span><br><span class="line">thousand-and-one-scripts.js</span><br><span class="line">my-file.min.css</span><br></pre></td></tr></table></figure><p>一般来说资源文件的名字习惯如下命名：</p><ul><li>以字母开头，避免数字开头</li><li>全部用小写，这样的话不容易在引用的时候因为大小写而出错</li><li>用-来分隔单词，而不是下划线</li><li>对于压缩过的文件，比如 <code>css</code> 或者 <code>js</code> 文件，使用 <code>.min</code> 代替 <code>-min</code></li></ul><h2 id="设置编码"><a href="#设置编码" class="headerlink" title="设置编码"></a>设置编码</h2><p>在 <code>css</code> 文件的最顶部设置编码格式为 <code>utf-8</code> ，否则有可能使得 <code>css</code> 文件出现乱码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;utf-8&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p><code>css</code> 文件里包含了许许多多的 <code>css</code> 规则，而每条 <code>css</code> 规则又由两部分组成，分别是选择器和声明块；声明块里包含了多个声明，而声明又是属性和值组成的。格式化里将要介绍的就是它们的结构和摆放位置，包括缩进、空格、换行以及个别声明的书写习惯等。</p><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p><code>css</code> 代码的缩进让代码结构更加清晰，<code>css</code> 代码缩进需要遵循以下几点：</p><ul><li>一个制表符( <code>Tab</code> 键)相当于4个空格(空格键)，<code>css</code> 的缩进占位一般是一个制表符的宽度。</li><li>缩进占位里不要混杂着制表符和空格，建议设置好编辑器的一个制表符等于4个空格宽度。</li><li>声明需要缩进；在 <code>media query</code> 里的所有 <code>css</code> 规则也需要缩进。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">640px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#f8f8f8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>在 <code>css</code> 的世界里为了让代码看起来不那么拥挤，所以需要在适当的地方使用空格：</p><ul><li>选择器和声明块的左大括号{之间。</li><li>声明中属性的冒号之后，属性值之前。</li><li>对于只有一条声明的声明块，声明的左右两边与左右大括号之间。</li><li>对于一个属性中有多个属性值，且放在同一行的时候，用来分隔各个属性值的逗号的后面。</li><li>对于一些特别的属性值里存在逗号分隔的情况，比如 <code>rgba(248, 248, 248, .5)</code>，需要在每个逗号后加上空格</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.heavy</span> &#123; <span class="attribute">font-weight</span>: <span class="number">700</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Georgia, serif;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">248</span>, <span class="number">248</span>, <span class="number">248</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="换行和空行"><a href="#换行和空行" class="headerlink" title="换行和空行"></a>换行和空行</h3><p>换行和空行的目的也是为了 <code>css</code> 代码的美观性和结构更加清晰：</p><ul><li>每个 <code>css</code> 规则之间需要一个空行。</li><li>单行注释的前面需要一个空行。</li><li>一个规则里存在多个选择器的时候，每个选择器的逗号后换行。</li><li>一个声明块里有多个声明的时候，每条声明后都需要换行；只有一条声明的时候，声明和选择器同行。</li><li>对于逗号分隔且非常长的属性值，可以考虑换行并且缩进一个制表符。</li><li><code>media query</code> 声明的第一行空行，这样就不会和第一条声明杂在一起，显得拥挤。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.modal</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.modal</span> <span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-class">.modal</span> <span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: <span class="number">#41b883</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* common */</span></span><br><span class="line"><span class="selector-class">.shadow</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>:</span><br><span class="line">        <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#000</span>,</span><br><span class="line">        <span class="number">2px</span> <span class="number">2px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#ccc</span> inset;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">640px</span>) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="selector-class">.modal</span> <span class="selector-class">.modal-con</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>选择器这块主要是介绍命名、书写习惯以及为了更高的匹配效率而建议的写法等。</p><h3 id="ID和Class的命名规范"><a href="#ID和Class的命名规范" class="headerlink" title="ID和Class的命名规范"></a>ID和Class的命名规范</h3><p><code>ID</code> 和 <code>Class</code> 的主要习惯于如下命名方式：</p><ul><li><p>全部字母用小写，避免使用驼峰命名法。</p></li><li><p>使用短横线-来作为连接单词之间的字符，避免使用下划线_。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-title</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#41b883</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命名尽可能语义化，让人一目了然。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-class">.fw-800</span> &#123; <span class="attribute">font-weight</span>: <span class="number">800</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.red</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span> </span><br><span class="line"><span class="selector-class">.heavy</span> &#123; <span class="attribute">font-weight</span>: <span class="number">800</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.important</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="尽可能避免使用ID选择器"><a href="#尽可能避免使用ID选择器" class="headerlink" title="尽可能避免使用ID选择器"></a>尽可能避免使用ID选择器</h3><p>在 <code>css</code> 的世界里不太欢迎 <code>ID</code> 选择器，因为 <code>ID</code> 是作为某个元素的唯一标识而设定的，但是元素的样式是可以被重复定义，层层覆盖的。所以建议不要使用 <code>ID</code> 选择器，取而代之的是多用类选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-id">#article</span> <span class="selector-tag">p</span> &#123; <span class="attribute">line-height</span>: <span class="number">28px</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.article</span> <span class="selector-tag">p</span> &#123; <span class="attribute">line-height</span>: <span class="number">28px</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="避免使用标签进行双重限定"><a href="#避免使用标签进行双重限定" class="headerlink" title="避免使用标签进行双重限定"></a>避免使用标签进行双重限定</h3><p>这是什么意思呢？看了下面的例子你就知道了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.desc</span> &#123; <span class="attribute">color</span>: <span class="number">#666</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.desc</span> &#123; <span class="attribute">color</span>: <span class="number">#666</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="尽可能的精确，但是最好不要超过3级"><a href="#尽可能的精确，但是最好不要超过3级" class="headerlink" title="尽可能的精确，但是最好不要超过3级"></a>尽可能的精确，但是最好不要超过3级</h3><p><code>css</code> 的选择判定也存在效率问题，所以书写的时候尽量要精确；选择器的嵌套层级最好不要超过3级，否则显得很冗长，效率上也未必更高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-class">.content</span> <span class="selector-class">.title</span> &#123; <span class="attribute">font-size</span>: <span class="number">2rem</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.content</span> &gt; <span class="selector-class">.content-body</span> &gt; <span class="selector-class">.title</span> &#123; <span class="attribute">font-size</span>: <span class="number">2rem</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="属性选择器记得使用双引号"><a href="#属性选择器记得使用双引号" class="headerlink" title="属性选择器记得使用双引号"></a>属性选择器记得使用双引号</h3><p>属性选择器记得使用双引号，避免单引号和不用引号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span> &#123; <span class="attribute">line-height</span>: <span class="number">1.2</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span> &#123; <span class="attribute">line-height</span>: <span class="number">1.2</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="声明块"><a href="#声明块" class="headerlink" title="声明块"></a>声明块</h2><p>作为 <code>css</code> 规则中的第二部分，声明块中自然也有许多需要注意的地方。比如声明的顺序、属性和值的写法以及一些个例等。</p><h3 id="声明的顺序"><a href="#声明的顺序" class="headerlink" title="声明的顺序"></a>声明的顺序</h3><p>在 <code>css</code> 中存在好几百个属性，如果需要一个 <code>css</code> 规则里几乎可以写满这些属性。如果这些声明毫无顺序章法可言，那么在需要修改的时候就会非常的头痛了，一大块声明杂在一个规则里，你就需要慢慢地找慢慢地看了。但是如果你的声明都是按照一定的逻辑顺序来书写，那么声明的层次就非常清晰。声明的时候一般比较重要的属性会优先书写。</p><ol><li>如果包含了 <code>content</code>属性，则应该最优先书写，即写到声明块的最上面。</li><li>定位相关的属性，比如<code>position</code>、<code>top</code>、<code>left</code>、<code>z-index</code>、<code>display</code>、<code>float</code>、<code>visibility</code>和<code>overflow</code>、<code>flex</code>等。</li><li>布局相关的属性，比如<code>display</code>、<code>float</code>、<code>visibility</code>、<code>overflow</code>、<code>flex</code>和<code>clear</code>等。</li><li>盒模型相关的属性，比如<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>border</code>以及<code>box-sizing</code>等。</li><li>文本排版印刷相关的属性，比如<code>font</code>、<code>line-height</code>、<code>vertical-align</code>、<code>text-align</code>和<code>white-space</code>、<code>text-decoration</code>等。</li><li>视觉感官上相关的属性，比如<code>color</code>、<code>background</code>、<code>list-style</code>、<code>transform</code>、<code>transition</code>和<code>animation</code>等。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="comment">/* Positioning */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Layout */</span></span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Box-model */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Typography */</span></span><br><span class="line">    <span class="attribute">font</span>: normal <span class="number">13px</span> <span class="string">&quot;Helvetica Neue&quot;</span>, sans-serif;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Visual */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尽可能的使用简写属性"><a href="#尽可能的使用简写属性" class="headerlink" title="尽可能的使用简写属性"></a>尽可能的使用简写属性</h3><p>在 <code>css</code> 中存在一些属性是可以拆分成其他独立属性的，比如<code>background</code>、<code>border</code>、<code>font</code>、<code>list-style</code>、<code>margin</code> 和 <code>padding</code> 等。这些属性在 <code>css</code> 里被称为复合属性，又因为一个属性包含了多个独立属性，所以在书写的时候使得代码更加简洁，所以又喜欢称其为简写属性，这里的简写也可以理解为动词。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123; <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="每条声明都以分号结尾"><a href="#每条声明都以分号结尾" class="headerlink" title="每条声明都以分号结尾"></a>每条声明都以分号结尾</h3><p>在 <code>css</code> 里，如果声明不以分号结尾是会出问题的，但是也有一个例外，那就是声明块的最后一个声明是可以不用分号结尾的。但是如果改变了声明的顺序或者新增了声明，那原来的那条没有带分号的声明就有可能不是最后一条声明了，肯定就出问题了，所以为了避免这种不必要的错误发生，我们要习惯给每个声明都加上分号。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-class">.post-content</span> <span class="selector-tag">h6</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#4e4a4a</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.post-content</span> <span class="selector-tag">h6</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#4e4a4a</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><p>在 <code>css</code> 的世界里很多地方是很有必要用引号的，为了避免混淆，建议需要引号的地方都使用双引号，而不用单引号。</p><p>对于 <code>font-family</code> 属性，如果属性值是带空格的英文比如 <code>Helvetica Neue</code> 或者是中文，那么建议加上双引号，比如<code>content</code> 属性。<br>对于 <code>URI</code> 资源的引用，有使用到<code>url()</code>引入资源的时候，不用带引号。比如引入背景图片、字体定义的时候引入字体包等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tip</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Dosis, <span class="string">&quot;Source Sans Pro&quot;</span>, <span class="string">&quot;Helvetica Neue&quot;</span>, Arial, sans-serif;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(../img/tip.png) no-repeat center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尽量不要使用-important"><a href="#尽量不要使用-important" class="headerlink" title="尽量不要使用 !important"></a>尽量不要使用 <code>!important</code></h3><p><code>css</code>规则的定义顺序很重要，同层级的声明，定义文件后面的会覆盖定义在前面的，但是如果使用了 <code>!important</code> 来限定声明，则可以将优先级提升到最高，这是非常霸道的规则。有时候因为使用了 <code>!important</code>，使得脚本程序改变不了样式渲染的结果，非常可恶。所以建议不要使用这个属性，取而代之的是，如果真的需要提高某个选择器的优先级，可以通过增加样式的层级来达到这个目的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-class">.heavy</span> &#123; <span class="attribute">font-weight</span>: <span class="number">700</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.heavy</span> <span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-class">.heavy</span> <span class="selector-tag">a</span> &#123; <span class="attribute">font-weight</span>: <span class="number">700</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h3><ul><li><p>所有属性和值尽量都用小写。</p></li><li><p>属性值为0的时候，不要带单位。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-class">.info-item</span> &#123; <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">10px</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.info-item</span> &#123; <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p>当可能的时候尽量使用三位的十六进制计数法，比如表示颜色的时候。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-class">.pink-color</span> &#123; <span class="attribute">color</span>: <span class="number">#ff33aa</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.pink-color</span> &#123; <span class="attribute">color</span>: <span class="number">#f3a</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>font-weight</code>使用数值化表示方法，用400代替 <code>normal</code>、700代替 <code>bold</code>。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-class">.heavy</span> &#123; <span class="attribute">font-weight</span>: bold; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.heavy</span> &#123; <span class="attribute">font-weight</span>: <span class="number">700</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>line-height</code>尽量不要带单位，除非必须用px来标定。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-class">.content</span> <span class="selector-tag">p</span> &#123; <span class="attribute">line-height</span>: <span class="number">1.2em</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.content</span> <span class="selector-tag">p</span> &#123; <span class="attribute">line-height</span>: <span class="number">1.2</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p>当属性值是介于0到1之间的小数时，可以直接把0省略。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-class">.pannel</span> &#123; <span class="attribute">opacity</span>: <span class="number">0.8</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-class">.pannel</span> &#123; <span class="attribute">opacity</span>: .<span class="number">8</span>; &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="文件或模块注释"><a href="#文件或模块注释" class="headerlink" title="文件或模块注释"></a>文件或模块注释</h3><p>文件顶部（<code>@charset</code>之后）最好是需要一块注释，大概介绍的是这个文件是关于什么内容的，作者是谁，最后更新时间等。当然如果一个 <code>css</code> 文件非常大，涉及到很多组件模块相关的代码，那可能每个模块都需要一个注释。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @name: bubuzou.css</span></span><br><span class="line"><span class="comment">  * @description: hexo-theme-bubuzou的主题样式</span></span><br><span class="line"><span class="comment">  * @author: typeR(zgrlbq@126.com)</span></span><br><span class="line"><span class="comment">  * @update: 2017-7-21 16:21:02</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>星号与内容之间必须保留一个空格。如果是单条声明需要注释，则写到声明的分号后分隔一个空格开始注释。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is a comment about this selector */</span></span><br><span class="line"><span class="selector-class">.another-selector</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>; <span class="comment">/* I should explain why this is so important */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>星号要一列对齐，星号与内容之间必须保留一个空格。多行的注释和规则之间最好加一个空格，才不会显得那么拥挤。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description of left, whether or not it has media queries, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.left</span> &#123; <span class="attribute">float</span>: left; &#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/gionkunz/chartist-js/blob/develop/CODINGSTYLE.md">Web Styleguide - Style guide to harmonize HTML, Javascript and CSS / Sass coding style</a></li><li><a href="https://make.wordpress.org/core/handbook/best-practices/coding-standards/css/">CSS Coding Standards</a></li><li><a href="http://codeguide.co/#css-syntax">css-syntax</a></li><li><a href="http://www.cnblogs.com/coco1s/p/7159192.html">CSS样式书写规范</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jpg、gif、png和svg用于web上，我们该如何选择最合适的图像格式？</title>
      <link href="/2017/06/29/jpeg-gif-png-svg-on-web/"/>
      <url>/2017/06/29/jpeg-gif-png-svg-on-web/</url>
      
        <content type="html"><![CDATA[<p>要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：<code>jpg</code>、<code>gif</code>、<code>png</code>和<code>svg</code>。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？<code>logo</code>应该是选择 <code>svg</code> 还是 <code>png</code> ？而截图是选 <code>jpg</code> 还是 <code>png</code> 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。</p><p>在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。</p><h2 id="先来看几个概念"><a href="#先来看几个概念" class="headerlink" title="先来看几个概念"></a>先来看几个概念</h2><ul><li>有损(<code>Lossless</code>)和无损(<code>Lossy</code>)：一般我们聊到图片的时候经常会听到别人提到有损或者无损的字眼，那么什么是有损和无损呢？无损就是图片在压缩保存后虽然占用的存储更小了，但是图像的呈现质量依然如旧；而有损则是相反，图像随着一次又一次的压缩后，质量会变得越来越差。</li><li>索引色(<code>Indexed color</code>)和直接色(<code>Direct color</code>)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过256种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。</li><li>光栅格式(<code>raster</code>)和矢量格式(<code>vector</code>)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 <code>Photoshop</code> 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。</li></ul><a id="more"></a><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><p><code>JEPG</code>由联合图像专家小组（<code>Joint Photographic Experts Group</code>）于1992年创建，并以创建者命名。<code>JPEG</code>是一种有损光栅图像格式，这意味着每次压缩保存JPEG时，一些信息将发生不可逆转地丢失；且存储的颜色无限制，这就对存储照片这种颜色非常丰富复杂的图像就很友好了。</p><p>因为 <code>JPEG</code> 压缩在亮度和色彩上面的优越性，所以 <code>JPEG</code> 非常适合用于照片、色彩梯度明显的图像比如渐变和阴影这些地方。</p><p><code>JPEG</code> 的压缩可以用 <code>Photoshop</code> 里存储为 <code>web</code> 格式的时候可以直接选择压缩品质，一般用于 <code>web</code> 的 <code>JPG</code> 图片选择 <code>50%-60%</code> 质量的即可，因为它兼顾不错的图像质量和较小的文件尺寸。另外也可以用在线压缩工具 <code>TinyJPG</code>。</p><p>下面这个图，我用的是 <code>50%</code>的品质压缩出来的 <code>JPG</code>，很明显质量要比 <code>GIF</code> 的要好很多，而且文件尺寸也小不少。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_01.png" alt="webgra_01"></p><blockquote><p><code>JPEG</code> 和 <code>JPG</code> 的区别：<code>JPEG</code> 更多的指的是 <code>.jpg</code> 图像格式的一种压缩算法，而 <code>JPG</code> 就是一种图像存储的格式。</p></blockquote><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><p>可移植网络图形（<code>Portable Network Graphics</code>）也是一种自1995年以来就一直存在的光栅图像格式。它与 <code>JPEG</code> 不同，因为它是一种无损格式，并且是目前网络上最常见的无损格式。这意味着由于它的压缩算法，当文件被保存和压缩时，不会丢失任何信息。</p><h3 id="PNG格式"><a href="#PNG格式" class="headerlink" title="PNG格式"></a>PNG格式</h3><p><code>PNG</code>其实可以细分为好几个格式的，有<code>PNG 8</code>、<code>PNG 24</code>和<code>PNG 32</code>。那么怎么区分一个 <code>PNG</code> 图片是什么格式的呢？</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_02.png" alt="png_24"></p><p>打开上面这张图片的属性面板，从详细信息里看到有一个属性叫做位深度，它的值是24，那么就表示他是 <code>PNG 24</code> 格式的图片。同样，<code>PNG 8</code> 和 <code>PNG 32</code> 的位深度分别是8和32。</p><blockquote><p>位深度表示图像能够存储颜色的最大数值。8位就是2的8次方（2^8=256）种颜色，所以 <code>PNG 8</code> 最多只能存储256种颜色。<code>PNG 24</code> 和 <code>PNG 32</code>又叫真彩色，最多存储2的24次方种颜色，可以达到人眼分辨的极限了；<code>PNG 32</code>中剩余的8位存储的是<code>Alpha</code> 通道的透明色。</p></blockquote><p>然后如何生成这些不同格式的图片呢？<br>自然是用专业的图像处理软件啦，比如可以用 <code>Photoshop</code> 或者 <code>Fireworks</code>。这里以 <code>Photoshop</code> 为例子，文件-&gt;存储为 <code>Web</code> 所用格式， 可以看到下拉这里只有 <code>PNG-8</code> 和 <code>PNG-24</code>，而没有 <code>PNG-32</code> 呢？是因为 <code>Photoshop</code>不支持这个格式嘛？并不是。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_04.png" alt="png_generate"></p><p>在 <code>Photoshop</code> 里导出 <code>PNG-32</code> 格式的图片是通过选择 <code>PNG-24</code>格式，并且勾选下面的透明度，这样生成的图片位数才是32位的，如果不勾选透明度的话就是 <code>PNG-24</code> 格式。由此看来 <code>PNG-24</code> 是不支持透明的，<code>PNG-32</code> 是支持透明的。</p><h3 id="PNG透明度"><a href="#PNG透明度" class="headerlink" title="PNG透明度"></a>PNG透明度</h3><p>从 <code>Fireworks 8</code>的优化面板里可以看到 <code>PNG</code> 格式存在三种透明格式：不透明、索引透明和 <code>Alpha</code>透明。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_05.png" alt="png_transparency"></p><ul><li><p><code>PNG 8</code>透明度</p><p>  从上面那个图里可以看出 <code>PNG 8</code> 是支持这三种不透明格式的。但是 <code>Photoshop</code> 只支持导出不透明和索引透明格式。在<code>Photoshop</code> 中如果选择 <code>PNG 8</code>，且勾选了透明度，那么导出的图片就是 <code>PNG 8</code> 索引透明，否则就是 <code>PNG 8</code> 不透明。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_06.png" alt="png_8_index"></p><p>  用 <code>Photoshop</code> 和 <code>Fireworks 8</code> 导出 <code>PNG 8</code> 的各种格式如下所示：</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_03.png" alt="png_8_transparency"></p><p>  根据以上图片我们可以得出结论：</p><ul><li><p><code>Photoshop</code> 导出的 <code>PNG 8</code> 图片都带有锯齿。</p></li><li><p><code>PNG 8</code> 索引透明都带有锯齿，且 <code>Fireworks 8</code> 导出的 <code>PNG 8</code>索引透明的锯齿是白色的。</p><p>再来看看这些格式在不同浏览器下的表现情况：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_07.png" alt="png_8_Compatibility"></p><p>根据以上图片我们可以得出结论：</p></li><li><p><code>PNG 8</code> 索引透明和 <code>Alpha</code> 透明都兼容<code>IE 6</code>；但美中不足的是，<code>PNG 8Alpha</code>透明在 <code>IE 6</code>下会产生锯齿。</p></li><li><p>其他格式的图片在各个浏览器下的表现一致。</p></li><li><p><code>Fireworks 8</code>导出的 <code>PNG 8</code>索引透明带有白色锯齿，但是如果图片是放到白色的背景的容器下，那么这个白色锯齿就完全看不出来了，表现得和正常效果一样。</p></li></ul></li><li><p><code>PNG 24</code> 和 <code>PNG 32</code></p><p>  <code>PNG 24</code> 是不透明的；<code>PNG 32</code> 是支持透明的，且是 <code>Alpha</code> 透明。来看下它们在不同浏览器下的表现：</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_08.png" alt="png_2432_Compatibility"></p><p>  <code>PNG 32</code> 图片的透明区域在 <code>IE 6</code> 下将不再透明，而是颜色值为 <code>f0f0f0</code> 的灰色填充，在更高级版本的 <code>IE</code> 下是正常的。<code>PNG 32</code> 图片不会有锯齿。</p></li></ul><h3 id="PNG压缩"><a href="#PNG压缩" class="headerlink" title="PNG压缩"></a>PNG压缩</h3><p>本文前面提到了 <code>JPEG</code> 在照片片这类颜色丰富的图像上的优秀表现，所以现在将它和 <code>PNG</code> 的3种格式进行对比。主要是对比压缩前后的存储体积以及表现效果等方面。用的是免费的在线压缩工具 <a href="https://tinypng.com/">TinyPNG</a>，这个工具可以压缩 <code>JPEG</code> 和 <code>PNG</code> 格式。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_09.png" alt="png_jpeg"></p><p>从上图这个图中，我们可以从不同角度得出一些结论：</p><ul><li><code>PNG 8</code> 格式的图片颜色过度处理得很突兀，能看到很明显的波浪褶皱，这就是因为它最多只能存储256种颜色导致的，所以<code>PNG 8</code>不适合用于存储颜色复杂的图像。相反，由于其相对于 <code>PNG 24</code> 或者 <code>PNG 32</code> 有先天的存储体积小优势，所以它非常适合应用于图标、颜色简单的或透明的图像上。</li><li>对比100%质量的 <code>JPG</code>、55%质量的 <code>JPG</code>、<code>PNG 24</code> 和 <code>PNG 32</code>，肉眼上看他们的图像表现效果都差不多，但是各自所占用的存储空间却是差得有些离谱。压缩前，当属55%质量的 <code>JPG</code> 占用存储最小；压缩后，<code>PNG 24</code> 和 <code>PNG 32</code> 一样，会比55%质量的 <code>JPG</code> 小一些，但是由于 <code>PNG 32</code> 支持透明，所以对于颜色丰富的图像建议用 <code>PNG 32</code> 格式导出，然后用压缩工具压缩一下即可。</li><li>对比压缩前后的 <code>PNG 24</code> 和 <code>PNG 32</code> 两者的存储体积相差巨大，但是表现效果却相差无几，所以用于 <code>web</code> 上的 <code>PNG 24</code> 或 <code>PNG 32</code> 图像一定要记得压缩，这对于客户端的性能优化将提供非常大的帮助。</li></ul><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><p>图形交换格式（<code>Graphics Interchange Format</code>）也是一种光栅格式，最多只能存储256种颜色，支持透明度，而且在 <code>IE 6</code> 下也支持得很好，唯一美中不足的是除了 <code>Fireworks 8</code> 导出的 <code>GIF</code> 不透明格式外，所有的其他 <code>GIF</code> 格式的图片都存在锯齿。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_10.png" alt="gif"></p><p>但是 <code>GIF</code> 也不是一无是处，最大的优点就是支持简单的动画。如下面简单的交通灯动画：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/traffic-light.gif" alt="gif_ani"></p><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>可伸缩矢量图形（<code>Scalable Vector Graphics</code>），顾名思义它是矢量的，而非光栅格式。区别于光栅格式的依靠像素点来存储图像，矢量图是通过XML格式来数据化的记录图像的信息。所以 <code>SVG</code> 相对于光栅格式的图像具有以下优势：</p><ul><li>任意伸缩图像，而不会破坏图像的清晰度和细节。</li><li>完全支持 <code>DOM</code>，以及 <code>JavaScript</code> 能够很好的访问到它。</li><li>总体来讲，<code>SVG</code>的文件会比 <code>GIF</code> 或 <code>JPG</code> 的会小很多。</li></ul><p>就像其它矢量格式，<code>SVG</code> 图片能不丢失任何细节地放大到任何大小。打个比方，同一个图标，可以以多种尺寸使用，并且在任何屏幕分辨率（比如 <code>Retina</code> 显示器）中都将看起来很清晰，而不需要存成多个文件。比如下面这个这个图对比，右边的是矢量图，左边的是其他格式图片：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_11.png" alt="svg"></p><h2 id="SVG用途"><a href="#SVG用途" class="headerlink" title="SVG用途"></a>SVG用途</h2><p><code>SVG</code> 在线条艺术，<code>LOGO</code>，图标，插画和数据可视化方面用途广泛。但它不适用于写实图像和有许多细节的复杂图片。在一些情况下，<code>SVG</code> 和 <code>PNG</code> 都能很好地达到同一个目的。对于线条艺术，<code>SVG</code> 通常能生成较小的文件。但是这不是必然的，实际情况会根据矢量图像究竟有多少个锚点，它甚至可能会生成比PNG更大的文件。 <code>SVG</code> 真正出色的地方是数据可视化。由于可以使用<code>JavaScript</code> 来操纵和创建矢量动画，诸如 <code>D3</code> 之类的库提供了无限的可能性。<code>LOGO</code>, 图标和数据可视化是 <code>SVG</code> 使用的优秀范例。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_12.png" alt="svg_use"></p><h2 id="SVG压缩"><a href="#SVG压缩" class="headerlink" title="SVG压缩"></a>SVG压缩</h2><p>比较好的 <code>SVG</code> 方法应该是通过清除 <code>SVG</code> 矢量图形中不必要的锚点、元素和属性来减少文件大小。锚点绘制了矢量图像，因此，你需要确保已移除的锚点不会影响矢量图形的最终形状。如果您使用 <code>Adobe Illustrator</code> 编辑 <code>SVG</code>，请确保使用导 -&gt; 导出为，而不是文件 -&gt; 另存为进行保存，因为这样才能生成一个最小化的文件。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201706/webgra_13.png" alt="svg_compress"> </p><p>清理不必要的节点是缩减 <code>SVG</code> 尺寸的一种途径。<br>元素标签是包含在 <code>SVG</code> 文件内的所有内容，包括开始和结束标签。<br>矢量编辑软件，如 <code>Adobe Illustrator</code> 和 <code>Sketch</code> 可能会到处含有非必要元素和属性的 <code>SVG</code> 。<br><code>SVG</code> 压缩器可用于删除这种多余的信息。<code>Compresso</code> 和 <code>SVGOMG</code> 等在线工具可以完成此工作。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://web.jobbole.com/91599/">在网页上使用JPG、PNG和SVG：新手指南</a></li><li><a href="http://www.cnblogs.com/PeunZhang/archive/2013/05/30/3050394.html">PNG使用技巧</a></li><li><a href="https://stackoverflow.com/questions/2336522/png-vs-gif-vs-jpeg-vs-svg-when-best-to-use">PNG vs. GIF vs. JPEG vs. SVG - When best to use?</a></li><li><a href="https://www.sitepoint.com/gif-png-jpg-which-one-to-use/">JPG vs PNG vs GIF vs SVG – What is the Difference?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web综合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svg </tag>
            
            <tag> 图像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS自定义属性</title>
      <link href="/2017/05/04/css-custom-property/"/>
      <url>/2017/05/04/css-custom-property/</url>
      
        <content type="html"><![CDATA[<p><code>CSS</code> 自定义属性，很多人又把它称之为 <code>CSS</code> 变量，是由用户自己定义的用来指定 <code>CSS</code> 属性值的变量。来看一个简单的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">--color-red</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--color-red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子中，首先在 <code>:root</code>(文档根元素即 <code>html</code> )处定义了一个全局变量，变量名称叫 <code>color-red</code>。然后在 <code>red</code> 元素里使用了这个变量，那么该元素颜色将变成红色。</p><a id="more"></a><h2 id="变量申明与使用"><a href="#变量申明与使用" class="headerlink" title="变量申明与使用"></a>变量申明与使用</h2><p>参照上面的例子，你可能很容易看出 <code>CSS</code> 变量的声明方式：使用 <code>--*</code> 声明一个变量。这里的 <code>*</code> 表示变量名称。变量名称的组成可以是数组<code>[0-9]</code>、字母<code>[a-zA-Z]</code>、下划线_或者连字符-组合而成，更厉害的是变量名称甚至可以是中文，另外变量名称是区分大小写字母的。<code>CSS</code> 变量的取值可以是单值 <code>10px</code>、复合属性的值 <code>1px solid #ddd</code>，计算值 <code>calc( 10px * 2 )</code>，甚至属性值里又可以引用变量 <code>var(--size) 10px</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 变量申明，注意观察变量名称和属性值的定义 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">--10</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">--marginTop</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">--color-red</span>: red; </span><br><span class="line">    --特殊的内间距: 10px 0 20px;</span><br><span class="line">    <span class="selector-tag">--padv</span>: <span class="selector-tag">calc</span>( <span class="selector-tag">var</span>(<span class="selector-tag">--10</span>) * 2 ) 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的使用方式：使用 <code>var(--*)</code> 使用变量，其实比较完整的使用规则是这样的：<code>var( &lt;–变量名称&gt; [, &lt;默认值&gt; ]? )</code>，比如下面这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="built_in">var</span>(--size, <span class="number">10px</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表示，当 <code>--size</code> 这个变量未定义的时候，则使用默认值 <code>10px 0</code>，注意这个地方不能加分号。</p><p>还有一种情况是，假如定义了一个变量，但是变量值是不合法的，这个时候就会取属性的缺省值。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">--color</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#369</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">var</span>(--color, #cd0000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的例子，此时的 <code>body</code> 的背景颜色到底是什么呢？<code>A. transparent</code>、<code>B. 20px</code>、<code>C. #369</code>、<code>D. #cd0000</code><br>答案是 <code>A</code>，因为这个时候变量 <code>color</code> 的值用在这里是不合法的，所以会取 <code>background-color</code> 的缺省值即默认替代值<code>transparent</code>，也不会用 <code>#cd0000</code></p><p>再来看个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">--size</span>: <span class="number">20</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="built_in">var</span>(--size)<span class="built_in">px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍看上面这个例子，<code>body</code> 的字号是 <code>20px</code>，其实不然。<code>var(--size)px</code> 会解析完成后会变成 <code>20 px</code>，这个值是不合法的，所以会取缺省值 <code>16px</code>。注意到这个问题，稳妥的做法还是在变量申明的时候带上单位。或者使用 <code>calc()</code> 来计算：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">--size</span>: <span class="number">20</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="built_in">calc</span>(var(--size) * <span class="number">1px</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS变量作用域"><a href="#CSS变量作用域" class="headerlink" title="CSS变量作用域"></a>CSS变量作用域</h2><p>居然是变量，那么自然的有作用域这一说法，在 <code>CSS</code> 变量中，也是存在作用域的。全局作用域，直接将变量定义在根元素上：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">--color-red</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">局部作用域是会直接在某个元素上定义变量，且这个变量只在该元素及后代元素中有效：</span><br><span class="line"></span><br><span class="line">``` <span class="selector-tag">css</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--color-red);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">--color-red</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>body</code> 的颜色不会被设置成红色。另外值得一提的是，变量的申明和变量的使用与定义在文件里的先后位置无关。</p><p>当存在多个变量的时候，变量的覆盖规则由 <code>CSS</code> 选择器的权重决定，但并无 <code>!important</code> 这种用法，因为没有必要，<code>!important</code>设计初衷是干掉 <code>JS</code> 的 <code>style</code> 设置，但对于变量的定义则没有这样的需求。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">--color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">--color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时有一个 <code>div</code> 元素，那么其颜色值会是蓝色的。</p><h2 id="来实践一下"><a href="#来实践一下" class="headerlink" title="来实践一下"></a>来实践一下</h2><p>先来看一个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d2d2d2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#d2d2d2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这两种设置的边框效果都是一样的，区别是一个用的是复合属性，一个是独立属性。在 <code>CSS</code> 里存在许许多多的属性值是由多个值组成的属性，比如 <code>border</code>、<code>animation</code> 等。如果要单独地修改这些多个属性值里的某一个，复合属性就可以直接修改它的独立属性，但是对于那种不是复合属性却有多个属性值的 <code>CSS</code> 属性就头大了，比如 <code>box-shadow</code>，特别是在 <code>OOCSS</code> 的世界里，这种情况就更尴尬了。但是现在有了 <code>CSS</code> 自定义属性，问题就可以迎刃而解了。比如，<code>box-shadow: 1px 2px 3px 4px #ddd</code>，这里可以把这5个值分别用5个全局变量表示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">--box-shadow-offset-x</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">--box-shadow-offset-y</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">--box-shadow-blur</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">--box-shadow-spread</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">--box-shadow-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要单独地修改某个值的时候，直接用 <code>js</code> 修改全局变量的值即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement.style.setProperty( &#x27;--box-shadow-offset-x&#x27;, &#x27;3px&#x27; );</span><br></pre></td></tr></table></figure><p>是不是很方便，是不是很好玩，戳我给你看一个例子。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201705/custom_property_02.png" alt="custom_property"></p><h2 id="CSS变量存在的意义"><a href="#CSS变量存在的意义" class="headerlink" title="CSS变量存在的意义"></a>CSS变量存在的意义</h2><p>在构建大型站点时，作者通常会面对可维护性的挑战。在这些网页中， 所使用的 <code>CSS</code> 的数量是非常庞大的，并且在许多场合大量的信息会重复使用。例如，在网页中维护一个配色方案，意味着一些颜色在 <code>CSS</code> 文件中多次出现，并被重复使用。当你修改配色方案时，不论是调整某个颜色或完全修改整个配色，都会成为一个复杂的问题，不容出错，而单纯查找替换是远远不够的。</p><p>如果使用了 <code>CSS</code> 框架，这种情况会变得尤其糟糕，此时如果要修改颜色，则需要对框架本身进行修改。在这些场合使用 <code>LESS</code> 或 <code>Sass</code> 类似的预处理器是非常有帮助的，但是这种通过添加额外步骤的方式，可能会增加系统的复杂性。CSS变量为我们带来一些预处理器的便利，并且不需要额外的编译。</p><p>这些变量的第二个优势就是名称本身就包含了语义的信息。<code>CSS</code> 文件变得易读和理解。<code>main-text-color</code> 比文档中的<code>#00ff00</code> 更容易理解，特别是同样的颜色出现在不同的文件中的时候。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><code>CSS</code> 自定义属性在 <code>IE</code> 上完全不支持啊，在其他浏览器上支持性还是不错的。戳我</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201705/custom_property_01.png" alt="caniuse"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://www.zhangxinxu.com/wordpress/?p=5804">小tips:了解CSS/CSS3原生变量var</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_variables">使用CSS变量</a></li><li><a href="https://css-tricks.com/now-css-custom-properties-thing-value-parts-can-changed-individually/">Now that CSS Custom Properties are a Thing, All Value Parts Can Be Changed Individually</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 Flexbox：你需要知道这些</title>
      <link href="/2017/04/18/flexbox/"/>
      <url>/2017/04/18/flexbox/</url>
      
        <content type="html"><![CDATA[<p><code>flexbox</code> 顾名思义 <code>flexible box</code> 弹性盒子，是 <code>css3</code> 中定义的一种新的布局方式。通过在某元素上使用 <code>display: flex;</code> 即可把该元素定义为 <code>flex</code> 容器 ( <code>flex container</code> )，而容器的所有子元素就是 <code>flex</code> 项目 ( <code>flex item</code> )。再介绍 <code>flex</code> 语法之前，先来看看一个重要的东西。</p><h2 id="flex轴线"><a href="#flex轴线" class="headerlink" title="flex轴线"></a>flex轴线</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/flex_axis.png" alt="flex-axis"></p><a id="more"></a><p>在 <code>flex</code> 容器里，存在两条轴，<code>main axis</code> 和 <code>cross axis</code>，又分别叫做主轴和交叉轴。主轴之所以叫做主轴而不叫做 <code>x</code> 轴，是因为主轴不一定是在水平线上的，也有可能是垂直方向上，比如当 <code>flex-direction: column;</code> 的时候，主轴就是在垂直方向上。另外主轴和交叉轴都是有方向的，<code>flex</code> 项目就是沿着主轴方向进行布局。主轴默认方向是从左到右，交叉轴则是从上到下。</p><p><code>css3</code> 里关于 <code>flexbox</code> 定义了2类的样式，分别是作用于 <code>flex</code> 容器上的和作用于 <code>flex</code> 项目上的。</p><h2 id="flex容器"><a href="#flex容器" class="headerlink" title="flex容器"></a>flex容器</h2><p>能作用到 <code>flex</code> 容器上的样式有这么几个：<code>flex-direction</code>，<code>flex-wrap</code>，<code>flex-flow</code>，<code>justify-content</code>，<code>align-items</code> 和 <code>align-content</code>。看到这么几个东西，别被它们吓坏了，多读几遍你就能猜个八九不离十它们是干嘛用的了。下面我们一一来介绍这些样式。</p><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>相信你也大概知道了这个样式的作用了，对了就是和方向有关的。<code>flex-direction</code> 这个样式就是用来控制 <code>main axis</code> 的方向的，默认值 <code>row</code>，表示水平从左到右。</p><ul><li>row，默认的属性值，水平方向，从左到右</li><li>column，垂直方向，从上到下</li><li>row-reverse，水平方向，从右到左</li><li>column-reverse，垂直方向，从下到上</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row; <span class="comment">/* column || row-reverse || column-reverse */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来一张图，你就更好理解了：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/flex_direction.png" alt="flex-direction"></p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><code>flex-wrap</code> 规定了 <code>flex</code> 项目在主轴上是按照一行还是多行显示。</p><ul><li><code>nowrap</code>，默认属性，单行显示，会尽力的压缩每个 <code>flex</code> 项目直到刚好容下里面的内容，实在压缩不了的时候 <code>flex</code> 项目就可能会溢出容器。</li><li><code>wrap</code>，允许多行显示，当一行显示不下的时候，会变成多行显示。</li><li><code>wrap-reverse</code>，多行显示，且行的显示顺序是从下到上，即第一行显示在容器的底部。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap; <span class="comment">/* wrap || wrap-reverse */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/flex_wrap.png" alt="flex-wrap"></p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code> 是一个复合属性，是由 <code>flex-direction</code> 和 <code>flex-wrap</code> 组成的属性。如果只定义了一个属性，那么另外一个属性取默认值。且属性书写顺序没有特别要求。</p><ul><li><code>row nowrap</code>，这是默认属性值</li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/flex_flow.png" alt="flex-flow"></p><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code> 规定了 <code>flex</code> 项目在主轴的对齐方式。比如当 <code>flex-direction</code> 被设置为 <code>column</code> 时，<code>justify-content</code> 定义的是垂直方向上的对齐方式。</p><ul><li><code>flex-start</code>, 默认属性值，<code>flex</code>项目将向着主轴起始位置对齐</li><li><code>flex-end</code>, <code>flex</code> 项目将向着主轴结束位置对齐</li><li><code>center</code>, <code>flex</code> 项目将在主轴上居中对齐</li><li><code>space-between</code>, <code>flex</code> 项目将在主轴上以相同的间距贴着轴的两端对齐</li><li><code>space-around</code>, <code>flex</code> 项目将在主轴上以相同的间距靠着两端对齐，且第一个头尾项目和轴的两端之间存在间距，间距是两个项目间距的一半</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/justify_content.png" alt="justify-content"></p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>居然有主轴上的对齐方式，那么肯定也有相关的属性是用来定义交叉轴上的对齐规则的。和 <code>justify-content</code> 一样，<code>align-items</code> 也有5个属性定义，其中 <code>flex-start</code>，<code>flex-end</code> 和 <code>center</code> 是一样的，就不多介绍了。来说说两个不同的：</p><ul><li><code>stretch</code>，默认属性值，<code>flex</code> 项目在交叉轴上的尺寸如果没有指定或者是被设置为 <code>auto</code>，那么它将在这个方向上尽量延伸，直到靠着容器边界，但是同时延伸的程度也会受到 <code>max-height</code> 或者 <code>max-width</code> 的影响</li><li><code>baseline</code>，<code>flex</code>项目在交叉轴上的对齐方式将是由每个项目内容的基线决定</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/align_items.png" alt="align-items"></p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>理解了 <code>justify-content</code> 和 <code>align-items</code> 的对齐方式，再来看 <code>align-content</code> 就容易理解多了。它只作用于容器，且只能是存在多个行的容器。注意这里的行是相对于交叉轴来说的。属性值有6个：<code>flex-start</code>，<code>flex-end</code>，<code>center</code>，<code>stretch</code>，<code>space-between</code> 和 <code>space-around</code>，这些对齐方式上面都介绍过了，大同小异。其中默认值是<code>stretch</code>。结合下图来加深理解：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">align-content</span>: space-around</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/align_content.png" alt="align-content"></p><h2 id="flex项目"><a href="#flex项目" class="headerlink" title="flex项目"></a>flex项目</h2><p>上面介绍了定义在 <code>flex</code> 容器上的 <code>css</code> 属性，规范了整个容器里所有项目的全局呈现。这样不够灵活多变，不足以表现某些需要特别显示的项目，所以针对这一现状，<code>w3c</code> 社区又推出了一套作用于 <code>flex</code> 项目上的 <code>css</code> 属性。他们分别是：<code>align-self</code>，<code>order</code>，<code>flex-grow</code>，<code>flex-shrink</code>，<code>flex-basis</code> 和 <code>flex</code> 等 <code>css</code> 属性。</p><ul><li><code>align-self</code></li></ul><p><code>align-self</code> 规定了单个 <code>flex</code> 项目在交叉轴上的对齐方式，属性值可以是下面一个：<code>flex-start</code>，<code>flex-end</code>，<code>center</code>，<code>stretch</code>，<code>baseline</code>和 <code>auto</code>，其中 <code>auto</code> 为默认属性值，如果被设置为了 <code>auto</code>，那么该 <code>flex</code> 项目最终的对齐方式将是由容器的 <code>align-items</code>决定。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/align_self.png" alt="align-self"></p><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p><code>order</code> 定义了 <code>flex</code> 项目在容器里的排列顺序。取值可以是负整数、0、正整数，默认取值是0。数值越大越靠近轴向的末端，数值相同则按照 <code>html</code> 里的顺序排列。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/order.png" alt="order"></p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><code>flex-grow</code> 规定了 <code>flex</code> 项目的伸展性，其值只能是 0 或者正整数，默认值是 0。如果一个 <code>flex</code> 项目同时设置了<code>width</code> 和值为正整数的 <code>flex-grow</code> 属性，则 <code>width</code> 属性将失效。取值如果是0表示不进行伸展；如果是正整数，则会进行伸展，且伸展的尺寸将和数值的大小有关，值越大，伸展得越大。伸展的具体计算数值是该项目占所有可伸展项目总和的比与这些所有可伸展项目占的尺寸的乘积。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/flex_grow.png" alt="order"></p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>与伸展相对应的属性是 <code>flex-shrink</code>，定义了项目的收缩性，值也只能是 0 或者正整数，默认值是 1。如果是 0 表示不进行收缩，如果是正整数则表示进行收缩。如果一个项目同时显示设置了尺寸和收缩值为 1，那么该项目将进行收缩，定义的尺寸将失效。<br>项目能够进行收缩的前提是必须产生溢出，即所有项目所占尺寸之和必须大于容器尺寸。这个时候容器里所有可收缩的项目就需要通过收缩来消化掉这部分溢出的尺寸。而每个项目具体的收缩量则由其设置的收缩比例决定，数值越大，收缩得越厉害。比如一个容器的尺寸是 <code>400px</code>，只有2个项目且尺寸都是 <code>300px</code>，收缩比例是 1 比 3，那么容器将溢出 <code>200px</code>，所以第一个项目需要收缩 <code>50px</code>，第二个项目需要收缩 <code>150px</code>，那么收缩完成后它们占据的尺寸分别是 <code>250px</code> 和 <code>150px</code>。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/flex_shrink.png" alt="flex-shrink"></p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><code>flex-basis</code> 定义了项目在伸缩之前的初始尺寸，可以是长度设置（<code>px</code>、<code>rem</code> 和 <code>em</code> 等）；可以是用百分比基于父级来计算尺寸；也可以是默认的 <code>auto</code>，表示其尺寸由内容决定。除了 <code>auto</code> 外，如果尺寸溢出容器了，那么设置了 <code>flex-basis</code> 的项目间，则会根据每项设置的基准值，按比率伸缩剩余空间。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/flex_basis.png" alt="flex-basic"></p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex</code> 是一个复合属性，是由<code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 组成的。</p><ul><li><code>flex-grow</code> ，用来指定扩展比率，在 <code>flex</code> 属性中该值如果被省略则默认为1</li><li><code>flex-shrink</code>，用来指定收缩比率，在收缩的时候收缩比率会以伸缩基准值加权，在 <code>flex</code> 属性中该值如果被省略则默认为1</li><li><code>flex-basis</code>，用来指定伸缩基准值，即在根据伸缩比率计算出剩余空间的分布之前，表示尺寸的起始数值。在 <code>flex</code> 属性中该值如果被省略则默认为 <code>0%</code>。在flex属性中该值如果被指定为 <code>auto</code>，则伸缩基准值的计算值是自身的 <code>width</code> 设置，如果自身的宽度没有定义，则长度取决于内容。</li></ul><p>一些缩写说明：</p><ul><li><code>flex: 1</code>, 则其计算值为<code>1 1 0%</code></li><li><code>flex: auto</code>, 则其计算值为<code>1 1 auto</code></li><li><code>flex: none</code>, 则其计算值为<code>0 0 auto</code></li><li><code>flex: 0 auto</code> 或者<code>flex: initial</code>, 则其计算值为<code>0 1 auto</code></li></ul><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/flex.png" alt="flex"></p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><code>flex</code> 布局在现代浏览器中兼容性还是比较令人满意的。<a href="http://caniuse.com/#feat=flexbox">可以去caniuse里看看</a>，或者直接看这个用 <code>flex</code> 布局写的案例catty-music</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201704/caniuse.png" alt="caniuse"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html">理解Flexbox：你需要知道的一切</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS居中完整篇</title>
      <link href="/2017/04/13/css-center-skill/"/>
      <url>/2017/04/13/css-center-skill/</url>
      
        <content type="html"><![CDATA[<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ul><li><p><code>inline</code> 或 <code>inline-*</code> 元素</p><p>  此类元素需要水平居中，则父级元素必须是块级元素(<code>block level</code>)，且父级元素上需要这样设置样式：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>块级元素</p><p>  块级元素水平居中，需要设置 <code>margin-left</code> 和 <code>margin-right</code> 为 <code>auto</code>，且需要显示设置宽度，不然就占满整行，就无所谓水平居中了。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>同一行多个块级元素</p><p>  如果是在同一行里需要居中多个块级元素，可以尝试下面的两种方法：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法一 */</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 方法二 */</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">-webkit-box-pack</span>: center;</span><br><span class="line">    <span class="attribute">-ms-flex-pack</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>垂直居中在 <code>CSS</code> 中比较不好处理。</p><ul><li><p>单行文本</p><p>  通过设置上下内间距一致达到垂直居中的效果：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.single-line</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过设置 <code>height</code> 和 <code>line-height</code> 一致达到垂直居中：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.single-line</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多行文本</p><p>  通过使用表格来垂直居中，但是这种方法显得很累赘：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>通过表格使得多行文本自动垂直居中通过表格使得多行文本自动垂直居中通过表格使得多行文本自动垂直居中<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  通过设置 <code>vertical-align</code> 属性和将元素设置为 <code>table-cell</code>，且父元素要设置为 <code>table</code> 元素，这个和上面那种原理其实是一样的：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过伸缩盒来垂直居中：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-vertically</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-align-items</span>: center;</span><br><span class="line">    <span class="attribute">-ms-flex-align</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>块级元素垂直居中</p><p>  知道块元素的高度，那么使用绝对定位和负的 <code>margin</code> 即可实现垂直居中：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  块级元素高度是可变的，这个时候就需要用 <code>transform</code> 的Y轴平移来实现了：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  也可以使用 <code>flexbox</code>:</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flexbox;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果对于块级元素高度不是固定的，且不由内容决定，那么还可以这么设置：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">30%</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>水平垂直居中就是把上面介绍的方法相结合就可以了。</p><ul><li><p>知道宽高的盒子</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: realtive;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">posotion</span>: absoltue;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不知道宽高的盒子</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: realtive;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">posotion</span>: absoltue;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>flexbox</code></p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome开发者工具实用小技巧</title>
      <link href="/2017/03/30/chrome-devtools/"/>
      <url>/2017/03/30/chrome-devtools/</url>
      
        <content type="html"><![CDATA[<p><code>chrome</code> 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 <code>chrome</code> 开发者工具都有哪些很常用或实用的功能。<br>写这篇文章的时候，chrome的版本如下：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_01.png" alt="chrome版本"></p><a id="more"></a><h2 id="Elements面板篇"><a href="#Elements面板篇" class="headerlink" title="Elements面板篇"></a>Elements面板篇</h2><ul><li><p>在 <code>Elements</code> 面板中，使用 <code>Ctrl + F</code> 打开搜索输入框，可以输入常规字符串或选择器来选择 <code>HTML</code> 元素。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_02.png" alt="ctrl+f"></p></li><li><p>在元素前面的小黑三角上用 <code>Alt +</code> 鼠标左键即可展开收起当前元素下的所有子元素。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_03.png" alt="alt+left"></p></li><li><p>css数值使用快捷键调整：</p><ul><li><p><code>Up / Down</code>：增加减少1</p></li><li><p><code>Ctrl + Up / Ctrl + Down</code>：增加减少100</p></li><li><p><code>Shift + Up / Shift + Down</code>：增加减少10</p></li><li><p><code>Alt + Up / Alt + Down</code>： 增加减少0.1</p></li><li><p><code>Up / Down</code> 等同于鼠标滚轮</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_04.png" alt="css-number-value"></p></li></ul></li><li><p>查看事件监听器。选中一个元素，然后点击 <code>Event Listeners</code> 面板，可以看到当前元素绑定的所有事件。然后找到任一事件类型下的 <code>handler</code>，右键单击选择 <code>Show function definition</code> 即可在 <code>Source</code> 面板中打开且定位到当前事件的处理函数的所在位置。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_05.png" alt="event-listeners"></p></li><li><p>点击颜色方格会打开 <code>chrome</code> 的调色板。如下图第1块是着色和阴影选择器。第2块像笔那个按钮( <code>toggle color picker</code> )是取色器，蓝色的时候表示激活状态，就可以在页面任何一处进行取色；右边绿色圆形的是当前的颜色值，点击会将当前颜色值的代码复制到剪贴板；再右边的两块条分别表示色调选择器和不透明度选择器。第3块是表示当前颜色的显示模式，后边的按钮可以切换显示模式。第4块，<code>Color Palettes</code> 里分3小块，分别是：<code>Material Design</code>，一组符合 <code>Material Design</code> 规范的颜色；<code>Page Colors</code>，一组从页面的 <code>CSS</code> 自动生成的颜色；<code>Custom</code>，自定义颜色。第5块颜色面板，长按颜色块可以弹出10个当前颜色由浅至深的小色块，这个功能对于精确定制网页主题颜色非常有帮助。第6块是自定义颜色，这里可以添加删除自定义颜色，并且会永久保存在 <code>chrome</code> 的 <code>DevTools</code> 里，不会因为刷新或关闭浏览器而消失。第7块是生成了一些和页面相关的颜色值。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_06.png" alt="color-palette"></p></li><li><p>可视化 <code>Shadow DOM</code>。在 <code>dom</code> 元素列表中，都是我们写的看得见的元素。其实在构建 <code>dom</code> 的时候，也存在一部分东西是我们没写的，但是实际存在而被浏览器隐藏起来的元素。如果想看到这些元素就可以通过勾选 <code>Settings</code> -&gt; <code>Preferences</code> -&gt; <code>Elements</code> 下的 <code>Show user agent shadow DOM</code> 来显示这样构建的元素。这样一来就可以很好的这些元素的样式了。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_07.png" alt="shadow-dom"></p></li><li><p>给元素添加状态。元素有4种用户行为状态：:<code>active</code>、<code>:hover</code>、<code>:focus</code>、<code>:visited</code>。可以通过2中方式主动触发用户行为。选中一个元素，然后右键点击选中一个状态即可，如果有设置对于的样式，就可以看到区别。另外一种方式是在 <code>Styles</code>面板中进行设置。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_08.png" alt="ele-state"></p></li><li><p>使用 <code>Tab</code> 键可以在 <code>CSS</code> 样式规则中进行遍历选定，选定的目标包括：选择器、属性和属性值。如果想跳回上一个目标，使用 <code>Shift + Tab</code>。但是再使用快捷键切换选定之前需要先让光标在 <code>Styles</code> 面板，处于输入状态即可。</p></li></ul><h2 id="Console面板篇"><a href="#Console面板篇" class="headerlink" title="Console面板篇"></a>Console面板篇</h2><ul><li><p>使用 <code>$0-$4</code> 选择元素。<code>$0</code> 返回最后一次选择的元素，<code>$1</code> 返回仅在最后一次之前选择的元素，以此类推。<code>$(selector)</code> 返回带有指定 <code>CSS</code> 选择器的第一个DOM元素的引用。<code>$$(selector)</code> 返回 <code>CSS</code> 选择所有匹配的元素数组。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_09.png" alt="$_selector"></p>  <div class="tip">      如果页面使用了类 `Jquery` 库，则 `$(selector)` 功能将被覆盖， `$` 将与该库的实现对应。  </div></li><li><p>一些实用的方法:</p><ul><li><p><code>console.log()</code>、<code>console.info()</code>、<code>console.warn()</code>、<code>console.error()</code>打印不同的状态信息</p></li><li><p>使用CSS设置控制台输出样式，利用CSS格式说明符%c。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_17.png" alt="css-format"></p></li><li><p><code>copy(object)</code>，将指定对象的字符串表示复制到剪贴板。</p></li><li><p><code>getEventListeners(object)</code>，返回一个在指定元素上绑定的所有事件监听器的数组。但是这里看不了事件的处理函数，也没有像 <code>Event Listeners</code> 面板那边 <code>show function definition</code> 那样的功能。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_13.png" alt="ctrl+p"></p></li><li><p><code>inspect(elem)</code>， 跳转到 <code>Elements</code> 面板的指定元素节点</p></li></ul></li><li><p><code>console.time(str)</code> 和 <code>console.timeEnd(str)</code> 返回这中间间隔的时间。下图的 <code>4.24e+3ms</code> 是数字的科学计数法表示，表示的实际值是：<code>4.24*10*10*10ms</code>，即4.24秒。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_12.png" alt="console.time"></p></li></ul><h2 id="Sources面板篇"><a href="#Sources面板篇" class="headerlink" title="Sources面板篇"></a>Sources面板篇</h2><ul><li><p><code>Ctrl + Shift + F</code>，根据文件内容查找所有站内资源文件，返回找出匹配的文件内容。这个功能很好用。比如我在别人的站点看到一个效果，但是不知道写到哪个文件里了，这个时候我就可以根据关键的 <code>className</code> 或者 <code>id</code> 把这个文件找出来。</p></li><li><p><code>Ctrl + P</code>，根据文件名查找所有站内资源文件。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_11.png" alt="ctrl+p"></p></li><li><p>漂亮打印。对于 <code>Sources</code> 里的资源文件，可以将杂乱的或是压缩过的内容按照一定的缩进和换行规则进行打印输出。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_14.png" alt="pretty-print"></p></li><li><p>在 <code>Sources</code> 面板中找到图片资源，然后在图片上右键即可获取图片的 <code>Data URI</code>。</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_15.png" alt="data-uri"></p></li><li><p>使用 <code>console.dir( ele )</code> 将 <code>DOM</code> 元素格式化为 <code>JavaScript</code> 对象</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_18.png" alt="console.dir"></p></li><li><p>在 <code>Sources</code> 面板编辑文件小技巧</p><ul><li><p>使用 <code>Ctrl + p</code> 打开输入框输入 <code>:20:30</code> 回车后，光标位置将跳转到当前文件的第20行第30列</p></li><li><p>使用使用 <code>Alt + -</code> 和 <code>Alt + =</code> 可以在上一个鼠标位置和下一个鼠标位置之间跳转</p></li><li><p>使用 <code>Ctrl +</code> 鼠标左键可以添加多个光标输入位置</p></li><li><p>使用 <code>Alt +</code> 鼠标拖动可以拉出一块矩形选区</p><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/chrome_16.png" alt="alt-move"></p></li></ul></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://developers.google.com/web/tools/chrome-devtools/">chrome-devtools</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web综合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS特性检测@supports与Modernizr</title>
      <link href="/2017/03/13/detect-css-property/"/>
      <url>/2017/03/13/detect-css-property/</url>
      
        <content type="html"><![CDATA[<p>什么是 <code>CSS</code> 特性检测？我们知道，前端技术日新月异的今天，各种新技术新属性层出不穷。在 <code>CSS</code> 层面亦不例外。</p><p>一些新属性能极大提升用户体验以及减少工程师的工作量，并且在当下的前端氛围下：</p><ul><li>很多实验性功能未成为标准却被大量使用；</li><li>需要兼容多终端，多浏览器，而各浏览器对某一新功能的实现表现的天差地别；</li></ul><p>所以有了优雅降级和渐进增强的说法，在这种背景下，又想使用新的技术给用户提供更好的体验，又想做好回退机制保证低版本终端用户的基本体验，<code>CSS</code> 特性检测就应运而生了。</p><p><code>CSS</code> 特性检测就是针对不同浏览器终端，判断当前浏览器对某个特性是否支持。运用 <code>CSS</code> 特性检测，我们可以在支持当前特性的浏览器环境下使用新的技术，而不支持的则做出某些回退机制。</p><p>本文将主要介绍两种 <code>CSS</code> 特性检测的方式：</p><ul><li><code>@supports</code></li><li><code>modernizr</code></li><li>用 <code>javascript</code> 进行特性检测</li></ul><a id="more"></a><h2 id="CSS-supports"><a href="#CSS-supports" class="headerlink" title="CSS @supports"></a>CSS @supports</h2><p>传统的 <code>CSS</code> 特性检测都是通过 <code>javascript</code> 实现的，但是未来，原生 <code>CSS</code> 即可实现。<br><code>CSS @supports</code> 通过 <code>CSS</code> 语法来实现特性检测，并在内部 <code>CSS</code> 区块中写入如果特性检测通过希望实现的 <code>CSS</code> 语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@supports &lt;supports_condition&gt; &#123;</span><br><span class="line">    <span class="comment">/* specific rules */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">&#125;</span><br><span class="line">@supports (position:sticky) &#123;</span><br><span class="line">    div &#123;</span><br><span class="line">        position:sticky;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法，首先定义了 <code>div</code> 的 <code>position: fixed</code> ，紧接着下面一句 <code>@supports (position:sticky)</code> 则是特性检测括号内的内容，如果当前浏览器支持 <code>@supports</code> 语法，并且支持 <code>position:sticky</code> 语法，那么 <code>div</code> 的 则会被设置为 <code>position:sticky</code> 。</p><p>我们可以看到，<code>@supports</code> 语法的核心就在于这一句：<code>@supports (...) &#123; &#125;</code> ，括号内是一个 <code>CSS</code> 表达式，如果浏览器判断括号内的表达式合法，那么接下来就会去渲染括号内的 <code>CSS</code> 表达式。除了这种最常规的用法，还可以配合其他几个关键字：</p><h2 id="supports-not"><a href="#supports-not" class="headerlink" title="@supports not"></a>@supports not</h2><p><code>not</code> 操作符可以放在任何表达式的前面来产生一个新的表达式，新的表达式为原表达式的值的否定。看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@supports not (background: linear-gradient(<span class="number">90</span>deg, red, yellow)) &#123;</span><br><span class="line">    div &#123;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为添加了 <code>not</code> 关键字，所以与上面第一个例子相反，这里如果检测到浏览器不支持线性渐变 <code>background: linear-gradient(90deg, red, yellow)</code> 的语法，则将 <code>div</code> 的颜色设置为红色 <code>background: red</code> 。</p><h2 id="supports-and"><a href="#supports-and" class="headerlink" title="@supports and"></a>@supports and</h2><p>用 <code>and</code> 操作符连接两个原始的表达式。只有两个原始表达式的值都为真，生成的表达式才为真，反之为假。来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br><span class="line">@supports (display:-webkit-box) and (-webkit-line-clamp:<span class="number">2</span>) and (-webkit-box-orient:vertical) &#123;</span><br><span class="line">    p &#123;</span><br><span class="line">        display: -webkit-box;</span><br><span class="line">        -webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">        -webkit-box-orient: vertical;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面同时，检测 <code>@supports (display:-webkit-box) and (-webkit-line-clamp:2) and (-webkit-box-orient:vertical)</code> 了三个语法，如果同时支持，则设定三个 <code>CSS</code> 规则。这三个语法必须同时得到浏览器的支持，如果表达式为真。</p><h2 id="supports-or"><a href="#supports-or" class="headerlink" title="@supports or"></a>@supports or</h2><p><code>@supports or</code> 表示只要表达式里存在一个是真的，那么这个表达式就是返回真。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@supports (background:-webkit-linear-gradient(<span class="number">0</span>deg, yellow, red)) or (background:linear-gradient(<span class="number">90</span>deg, yellow, red))&#123;</span><br><span class="line">    div &#123;</span><br><span class="line">        background:-webkit-linear-gradient(<span class="number">0</span>deg, yellow, red);</span><br><span class="line">        background:linear-gradient(<span class="number">90</span>deg, yellow, red)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="supports的兼容性"><a href="#supports的兼容性" class="headerlink" title="@supports的兼容性"></a>@supports的兼容性</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/supports_01.png" alt="younghz的Markdown库"></p><p>这仍是一个实验中的功能，虽然大部分浏览器都已经支持了，但是目前看来，即是在移动端想要全部兼容仍需要等待一段时间。但是我们已经可以开始使用起来了，使用 <code>@supports</code> 实现渐进增强的效果。</p><div class="tip">渐进增强（`progressive enhancement`）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验：</div><h2 id="CSS-supports-1"><a href="#CSS-supports-1" class="headerlink" title="CSS.supports()"></a>CSS.supports()</h2><p>谈到了 <code>@supports</code>，就有必要再说说 <code>CSS.supports()</code> 。<br>它是作为 <code>@supports</code> 的另一种形式出现的，我们可以使用 <code>javascript</code> 的方式来获得 <code>CSS</code> 属性的支持情况。<br>可以打开控制台，输入 <code>CSS.supports</code> 试试：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/supports_02.png" alt="function@supports"></p><p>如果没有自己实现 <code>CSS.supports</code> 这个方法，输出上述信息，表示浏览器是支持 <code>@supports</code> 语法的，使用如下：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/supports_03.png" alt="supports@demos"></p><p>那它有什么用呢？如果你的页面需要动态添加一些你不确定哪些浏览器支持的新的属性，那它也许会派上用场。以及，它可以配合我们下文即将要讲的 <code>modernizr</code> 。</p><h2 id="modernizr"><a href="#modernizr" class="headerlink" title="modernizr"></a>modernizr</h2><p>上面介绍了 <code>CSS</code> 方式的特性检测，在以前，通常是使用 <code>javascript</code> 来进行特性检测的，其中 <code>modernizr</code> 就是其中最为出色的佼佼者。<br><code>modernizr</code>（戳我查看 <code>Github</code> ）是一个开源的 <code>javascript</code> 库。有着将近 <code>2W</code> 的 <code>star</code> ，其优秀程度可见一斑。<br>简单看看使用方法，假设页面已经引用了 <code>modernizr</code> ，语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listen to a test, give it a callback</span></span><br><span class="line">Modernizr.on(<span class="string">&#x27;testname&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> result </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;The test passed!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;The test failed!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 或者是类似 CSS.supports()</span></span><br><span class="line">Modernizr.testAllProps(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;linear-gradient(90deg, #888, #ccc)&#x27;</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="特性检测原理"><a href="#特性检测原理" class="headerlink" title="特性检测原理"></a>特性检测原理</h2><p>如果嫌引入整一个 <code>Modernizr</code> 库太大，页面又不支持 <code>@supports</code> ，其实我们自己用简单的 <code>javascript</code> 实现也非常方便简单。<br>想要知道浏览器支持多少 <code>CSS</code> 属性，可以在调试窗口试试：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/supports_04.png" alt="html.style"></p><p>上面图片截取的只是打印出来的一小部分。如果我们要检测某个属性样式是否被支持，在任意的 <code>element.style</code> 检测它是否存在即可。<br>当然，元素可能有 <code>background</code> 属性，但是不支持具体的 <code>linear-gradinet()</code> 属性值。这个时候该如何检测呢？只需要将具体的值赋值给某一元素，再查询这个属性值能否被读取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = <span class="built_in">document</span>.documentElement;</span><br><span class="line">root.style.backgroundImage = <span class="string">&#x27;linear-gradient(90deg, #888, #ccc)&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(root.style.backgroundImage) &#123;</span><br><span class="line">    <span class="comment">// 支持</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不支持</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各种方式间的优劣"><a href="#各种方式间的优劣" class="headerlink" title="各种方式间的优劣"></a>各种方式间的优劣</h2><ul><li><p>原生的 <code>@supports</code> 的性能肯定是最好的，而且无需引入外部 <code>javascript</code> ，首推这个，但是无奈兼容问题，目前来看不是最好的选择。</p></li><li><p><code>Modernizr</code> 功能强大，兼容性好，但是需要引入外部 <code>javascript</code>，多一个 <code>http</code> 请求，如果只是进行几个特性检测，有点杀鸡用牛刀的感觉。</p></li><li><p>针对需要的特性检测，使用 <code>javascript</code> 实现一个简单的函数，再把上面用到的方法封装一下：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于简单的 CSS 特性检测</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>[String] property 需要检测的 CSS 属性名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>[String] value 样式的具体属性值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return </span>[Boolean] 是否通过检查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cssTest</span>(<span class="params">property, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用于测试的元素，隐藏在页面上</span></span><br><span class="line">    <span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-display-none&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 只有一个参数的情况</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(property <span class="keyword">in</span> ele.style) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 两个参数的情况</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">2</span>)&#123;</span><br><span class="line">        ele.style[property] = value;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(ele.style[property]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/supports_05.png" alt="supports@demos"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>background属性</title>
      <link href="/2017/03/10/background-property/"/>
      <url>/2017/03/10/background-property/</url>
      
        <content type="html"><![CDATA[<p>一个元素可以使用 <code>background</code> 来设置他的背景特性，<code>background</code> 是一个复合的属性，包括了 <code>8</code> 个子属性。</p><h2 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h2><p><code>background-color</code> 用于定义元素的背景颜色，值可以是具体的十六进制颜色值 <code>#dedd6f</code>，可以是 <code>rgb</code> 颜色值<code>rgb(222, 221, 111)</code> ，或者直接用颜色对应的英文表示 <code>gray</code> ，甚至是用关键字 <code>transparent</code> 来表示透明的颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.yellow</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#dedd6f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gray</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tran</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/background_01.png" alt="younghz的Markdown库"></p><h2 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h2><p><code>background-image</code> 用来定义元素的背景图像，可以通过 <code>url(...)</code> 来引入图片，也可以设置为 <code>none</code> 表示背景为空，还可以设置多张背景且中间用逗号隔开，写到前面的图片将会覆盖写到后面的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.url</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../images/cow.png)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.none</span> &#123;</span><br><span class="line">    <span class="attribute">background-image </span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.muliple</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../images/penguin.jpg), <span class="built_in">url</span>(../images/cow.png);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">81%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/background_02.png" alt="younghz的Markdown库"></p><h2 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h2><p><code>background-repeat</code> 定义了背景图像将以何种方式进行平铺。必须先指定 <code>background-image</code> 属性。如果设置2个属性，那么第一个用于横向，第二个作用于纵向。如果提供一个参数，则用于横向和纵向。其中，<code>repeat-x</code> 和 <code>repeat-y</code> 只能单独使用。</p><ul><li>repeat-x：横向平铺</li><li>repeat-y：纵向平铺</li><li>repeat：横向和纵向都平铺</li><li>no-repeat：不平铺</li><li>round：背景图像自动缩放直至适应填充满整个容器</li><li>space: 背景图像按照相同的间距平铺直至适应填充满整个容器或某个方向</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.repeat-x</span> &#123;</span><br><span class="line">    <span class="attribute">background-repeat</span>: repeat-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.repeat-y</span> &#123;</span><br><span class="line">    <span class="attribute">background-repeat</span>: repeat-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.repeat</span> &#123;</span><br><span class="line">    <span class="attribute">background-repeat</span>: repeat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.no-repeat</span> &#123;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.round</span> &#123;</span><br><span class="line">    <span class="attribute">background-repeat</span>: round;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.space</span> &#123;</span><br><span class="line">    <span class="attribute">background-repeat</span>: space;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.round-space</span> &#123;</span><br><span class="line">    <span class="attribute">background-repeat</span>: round space;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.space-round</span> &#123;</span><br><span class="line">    <span class="attribute">background-repeat</span>: space round;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/background_03.png" alt="younghz的Markdown库"></p><h2 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h2><p><code>background-size</code> 定义了背景图像的尺寸，可以用关键字来定义。<code>contain</code> 按照图片比例将背景图像等比缩放到完全适应容器，而 <code>cover</code> 是图像缩放到完全覆盖区域为止。也可以用长度值或者百分比值来设置。如果设置了2个参数，则分别表示横向和纵向。如果只设置了一个值，那表示横向宽度，纵向为 <code>auto</code>.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.contain</span> &#123;</span><br><span class="line">    <span class="attribute">background-size</span>: contain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cover</span> &#123;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.size-demo</span> <span class="selector-class">.w100</span> &#123;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../images/cow.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.rate5080</span> &#123;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/background_04.png" alt="younghz的Markdown库"></p><h2 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h2><p><code>background-positioin</code> 定义了背景图像在容器里的显示位置，可以用关键字 <code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>、<code>center</code> 等来表示，当用1个参数的时候设置的时候，另一个方向默认是 <code>center</code>。当用2个关键字来设置的时候，和书写顺序无关。另外还可以用具体数值和百分比来设置，用这些方式来设置的时候第一个参数表示横向，第二个是纵向。如果只有一个参数，则表示横向，纵向默认是居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.position-demo</span> <span class="selector-class">.top</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.position-demo</span> <span class="selector-class">.bottom-right</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: bottom right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.position-demo</span> <span class="selector-class">.w20h40</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">20px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.position-demo</span> <span class="selector-class">.p20</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">20%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/background_05.png" alt="younghz的Markdown库"></p><h2 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h2><p><code>background-attachment</code> 控制背景图像在可视区或元素内如何滚动。<code>fixed</code> 是相对可视区域进行定位，背景图像相对于可视区域进行定位，不随元素滚动而滚动。<code>scroll</code> 背景图像将在元素区域内固定，不会随着元素内容的滚动而滚动。<code>local</code> 背景图像相对于元素内容占据的区域进行定位，当元素内容滚动的时候，背景图像随之滚动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.attachment-demo</span> <span class="selector-class">.fixed</span> &#123;</span><br><span class="line">    <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">    <span class="attribute">background-position</span>: bottom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.attachment-demo</span> <span class="selector-class">.scroll</span> &#123;</span><br><span class="line">    <span class="attribute">background-attachment</span>: scroll;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.attachment-demo</span> <span class="selector-class">.local</span> &#123;</span><br><span class="line">    <span class="attribute">background-attachment</span>: local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/background_06.png" alt="younghz的Markdown库"></p><h2 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h2><p><code>background-origin</code> 规定了背景图像相对于盒模型的哪个区域来定位，对背景颜色无效。<code>content-box</code> 相对于内容区域定义，<code>padding-box</code> 相对于内边距区域定位，<code>border-box</code> 相对边框区域定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.origin-demo</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">background-origin</span>: content-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.origin-demo</span> <span class="selector-class">.padding</span> &#123;</span><br><span class="line">    <span class="attribute">background-origin</span>: padding-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.origin-demo</span> <span class="selector-class">.border</span> &#123;</span><br><span class="line">    <span class="attribute">background-origin</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/background_07.png" alt="younghz的Markdown库"></p><h2 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h2><p><code>background-clip</code> 指定背景向外裁剪的区域。<code>padding-box</code> 从 <code>padding</code> 区域（不含 <code>padding</code> ）开始向外裁剪背景。<code>border-box</code> 从 <code>border</code> 区域（不含 <code>border</code> ）开始向外裁剪背景。<br><code>content-box</code> 从 <code>content</code> 区域开始向外裁剪背景。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clip-demo</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">background-clip</span>: content-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clip-demo</span> <span class="selector-class">.padding</span> &#123;</span><br><span class="line">    <span class="attribute">background-clip</span>: padding-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clip-demo</span> <span class="selector-class">.border</span> &#123;</span><br><span class="line">    <span class="attribute">background-clip</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/background_08.png" alt="younghz的Markdown库"></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高阶函数</title>
      <link href="/2016/12/06/higher-order-functions/"/>
      <url>/2016/12/06/higher-order-functions/</url>
      
        <content type="html"><![CDATA[<p>高阶函数是指满足下列条件之一的函数：</p><p>函数可以作为参数进行传递<br>函数可以作为返回值进行输出<br><code>JavaScript</code> 语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当做参数传递，还是让函数的执行结果返回给另外一个函数，这两种情形都有很多应用场景。</p><h2 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h2><p>把函数当做参数进行传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来就可以分离业务代码中变化和不变的部分。</p><a id="more"></a><ul><li><p>回调函数</p><p>  在 <code>ajax</code> 异步请求的应用中，回调函数的使用非常频繁。当我们想在 <code>ajax</code> 请求返回之后做些事情，但又并不知道请求返回的确切时间时，最常见的方案是把 <code>callback</code> 函数当做参数传入发起的 <code>ajax</code> 请求的方法中，待请求完成之后执行<code>callback</code> 函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getUserInfo = <span class="function"><span class="keyword">function</span>(<span class="params"> userId, callback </span>) </span>&#123;</span><br><span class="line">    $.ajax( <span class="string">&#x27;http://bubuzou.com/getUserInfo?&#x27;</span> + userId, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            callback( data );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  再来看一个例子，假设有这样一个需求，需要创建 <code>100</code> 个 <code>div</code>元素，同时把他们隐藏起来，那么可以看到下面这种实现：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> appendDiv = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">&#x27;div&#x27;</span> );</span><br><span class="line">        div.innerHTML = i;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">        div.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">appendDiv();</span><br></pre></td></tr></table></figure><p>  把 <code>div.style.display = &#39;none&#39;</code>的逻辑硬编码在 <code>appendDiv</code> 里显然是不合理的，<code>appendDiv</code> 未免有点个性化，成为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏。于是我们把这段代码抽离出来，用回调函数的形式传入 <code>appendDiv</code> 方法：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> appendDiv = <span class="function"><span class="keyword">function</span>(<span class="params"> callback </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">&#x27;div&#x27;</span> );</span><br><span class="line">        div.innerHTML = i;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            callback( div );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line">appendDiv(<span class="function"><span class="keyword">function</span>(<span class="params"> node </span>) </span>&#123;</span><br><span class="line">    node.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>Array.prototype.sort</code></p><p>  <code>Array.prototype.sort</code> 接受一个函数作为参数，这个函数里面封装了数组元素的排序顺序。我们的目的是对数组进行排序，这是不变的部分；但用什么规则去排序这是可变的部分。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从小到大排序</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>].sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h2><ul><li><p>判断数据的类型</p><p>  判断一个数据是否是数组，在以往的实现当中，可以基于鸭子类型的概念来判断，比如这个数据有没有 <code>length</code> 属性，有没有<code>sort</code> 方法等。但更好的方法是用 <code>Object.prototype.toString</code> 来计算。根据<code>Object.prototype.toString.call( [1, 2, 3] )</code> 总是返回 <code>’[object Array]’</code> ，<code>Object.prototype.toStrng.call( ‘str’ )</code> 也总是返回 <code>’[object Array]’</code> 得出，<br>  它总是会返回一个类似结构的字符串。于是用循环语句来批量注册类型判断的函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> Type = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, type; type = [<span class="string">&#x27;String&#x27;</span>, <span class="string">&#x27;Array&#x27;</span>, <span class="string">&#x27;Number&#x27;</span>][i++]; ) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params"> type </span>) </span>&#123;</span><br><span class="line">            Type[ <span class="string">&#x27;is&#x27;</span> + type ] = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">&#x27;[object &#x27;</span> + type + <span class="string">&#x27;]&#x27;</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)( type );</span><br><span class="line">    &#125;</span><br><span class="line">    Type.isArray( [] );  <span class="comment">// true</span></span><br><span class="line">    Type.isString( <span class="string">&#x27;&#x27;</span> );  <span class="comment">// true</span></span><br><span class="line">    <span class="string">``</span><span class="string">``</span></span><br><span class="line">    </span><br><span class="line">- getSingle</span><br><span class="line"></span><br><span class="line">    下面是一个单例模式的例子：</span><br><span class="line"></span><br><span class="line">    <span class="string">``</span><span class="string">` js</span></span><br><span class="line"><span class="string">    var getSingle = function( fn ) &#123;</span></span><br><span class="line"><span class="string">        var ret;</span></span><br><span class="line"><span class="string">        return function() &#123;</span></span><br><span class="line"><span class="string">            return ret || ( ret = fn.apply( this, arguments ));</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    // 来看看这个单例的效果</span></span><br><span class="line"><span class="string">    var getScript = getSingle(function() &#123;</span></span><br><span class="line"><span class="string">        return document.createElement( &#x27;script&#x27; );</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    var script1 = getScript();</span></span><br><span class="line"><span class="string">    var script2 = getScript();</span></span><br><span class="line"><span class="string">    console.log( script1 === script2 );  // true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h2><p><code>AOP</code>（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来后，再通过“动态植入”的方式掺入业务逻辑模块中。这样做的好处是首先保证了业务逻辑模块的纯洁和高内聚性，其实是可以很方便的复用这些日志统计等功能模块。在 <code>JavaScript</code> 中，我们可以通过<code>Function.prototype</code> 来实现 <code>AOP</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params"> beforeFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        beforeFn.apply( <span class="built_in">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">        <span class="keyword">return</span> _self.apply( <span class="built_in">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params"> afterFn </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = _self.apply( <span class="built_in">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">        afterFn.apply( <span class="built_in">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line">func = func.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;);</span><br><span class="line">func();  <span class="comment">// 换行打印：1 2 3</span></span><br></pre></td></tr></table></figure><h2 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h2><ul><li><p><code>currying</code></p><p>  <code>currying</code> 的概念最早由俄国数学家 <code>Moses Schoofinkel</code> 发明，而后由著名的数理逻辑学家 <code>Haskell Curry</code> 将其丰富和发展，<code>currying</code> 由此得名。</p><p>  <code>currying</code> 又称部分求值。这里我们讨论的是函数柯里化( <code>function currying</code> )。一个柯里化函数首先会接受一些参数，接受了这些参数会后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正求值的时候，之前传入的所有参数都会被一次性用于求值。来看一个例子：<br>  假设我们要编写一个计算每月开销的函数。在每天结束之前，我们都要记录几天花掉了多少钱。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> monthCost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> cost = <span class="function"><span class="keyword">function</span>(<span class="params"> money </span>) </span>&#123;</span><br><span class="line">    monthCost += money;</span><br><span class="line">&#125;;</span><br><span class="line">cost( <span class="number">100</span> );  第一天</span><br><span class="line">cost( <span class="number">200</span> );  第二天</span><br><span class="line">cost( <span class="number">300</span> );  第三天</span><br><span class="line"><span class="built_in">console</span>.log( monthCost );  <span class="comment">// 600</span></span><br></pre></td></tr></table></figure><p>  通过这段代码，我们可以看到每天都花了多少钱，但是如果我们只想知道每个月的消费如何的话，那就没必要计算每天的花费了。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cost = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">arguments</span>.length === <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">var</span> money = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = args.length; i &lt; l; i++ ) &#123;</span><br><span class="line">                money += args[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> money;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [].push.apply( args, <span class="built_in">arguments</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">cost( <span class="number">100</span> );</span><br><span class="line">cost( <span class="number">200</span> );</span><br><span class="line">cost( <span class="number">300</span> );</span><br><span class="line"><span class="built_in">console</span>.log( cost() );  <span class="comment">// 600</span></span><br></pre></td></tr></table></figure><p>  接下来编写一个通用的柯里化函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">arguments</span>.length === <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply( <span class="built_in">this</span>, args );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [].push.apply( args, <span class="built_in">arguments</span> );</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cost = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> money = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ ) &#123;</span><br><span class="line">            money += <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> cost = currying( cost );</span><br><span class="line">cost( <span class="number">100</span> );</span><br><span class="line">cost( <span class="number">200</span> );</span><br><span class="line">cost( <span class="number">300</span> );</span><br><span class="line"><span class="built_in">console</span>.log( cost() );  <span class="comment">// 600</span></span><br></pre></td></tr></table></figure></li><li><p><code>uncurrying</code></p><p>  <code>uncurrying</code> 是反柯里化，大概意思是扩大函数的应用范围，将本来只有特定对象才能使用的方法，扩展到更多的对象。<br>  比如我们常常让类数组对象去借用 <code>Array.prototype</code> 的方法：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.push.call( <span class="built_in">arguments</span>, <span class="number">4</span> );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">arguments</span> );  <span class="comment">// [1, 2, 3, 4]     </span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>  <code>uncurrying</code>第一种实现：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="built_in">Array</span>.prototype.shift.call( <span class="built_in">arguments</span> );</span><br><span class="line">        <span class="keyword">return</span> self.apply( obj, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, fn, ary = [<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;forEach&#x27;</span>]; fn = ary[i++]; ) &#123;</span><br><span class="line">    <span class="built_in">Array</span>[ fn ] = <span class="built_in">Array</span>.prototype[ fn ].uncurrying();   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;length&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;0&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;2&quot;</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Array</span>.push( obj, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log( obj.length );  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> first = <span class="built_in">Array</span>.shift( obj ); </span><br><span class="line"><span class="built_in">console</span>.log( first );  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log( obj );  <span class="comment">// &#123;0:2, 1:3, 2:4, length: 3&#125;</span></span><br><span class="line"><span class="built_in">Array</span>.forEach( obj, <span class="function"><span class="keyword">function</span>(<span class="params"> i, n </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( n );  <span class="comment">// 分别输出：0, 1, 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  <code>uncurrying</code>的第二种实现：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply( self, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>函数节流</p><p>  在 <code>JavaScript</code> 中，大部分的函数都是由用户主动调动触发的。但是也存在少数情况，这些情况下函数的触发并不是又用户直接控制的。这个时候函数就有可能被频繁地调用，而造成大的性能问题。以下几个场景函数将被频繁调用：给 <code>window</code> 绑定了<code>onresize</code> 事件的时候，如果存在 <code>DOM</code> 相关的操作，那这个时候是非常耗性能的，严重的时候浏览器可能会卡顿；<code>mousemove</code> 事件，如果给某个元素绑定了拖拽事件，那么该函数也会被频繁的触发；在比如上传一个文件的时候，可能需要频繁的通知进度信息等。</p><p>  函数节流就是为了避免函数被频繁地调用而存在的一种解决方案，从而优化性能。通常是用 <code>setTimeout</code> 来实现：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params"> fn, interval </span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> _self = fn, </span><br><span class="line">    timer,</span><br><span class="line">    firstTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>,</span><br><span class="line">            _me = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> ( firstTime ) &#123;</span><br><span class="line">            _self.apply( _me, args );</span><br><span class="line">            <span class="keyword">return</span> firstTime = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( timer ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>( timer );</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            _self.apply( _me, args );</span><br><span class="line">        &#125;, interval || <span class="number">500</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></li><li><p>分时函数</p><p>  上面我们介绍了一种解决函数被频繁调用的方法。但是有时候，用户确实有这种需求，比如需要在短时间内把 <code>1000</code> 个 <code>qq</code> 好友渲染到列表上，这个时候就可能会很卡。但是如果把 <code>1000ms</code> 创建 <code>1000</code> 个节点，改成每 <code>200ms</code> 创建 <code>8</code> 个节点。这个时候就避免这种问题。<br>  分时函数接受 <code>3</code> 个参数：第一个是创建节点的时候需要用到的数据，第二个是封装了创建节点的函数，第三个是每一批创建的节点数量。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeChunk = <span class="function"><span class="keyword">function</span>(<span class="params"> ary, fn, count </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj,</span><br><span class="line">        t,</span><br><span class="line">        start;</span><br><span class="line">    start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min( count || <span class="number">1</span>, ary.length ); i++ ) &#123;</span><br><span class="line">            <span class="keyword">var</span> obj = ary.shift();</span><br><span class="line">            fn( obj );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        t = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ( ary.length === <span class="number">0</span> ) &#123;  <span class="comment">// 如果全部节点都已经创建好</span></span><br><span class="line">                <span class="built_in">clearInterval</span>( t );</span><br><span class="line">            &#125;</span><br><span class="line">            start();</span><br><span class="line">        &#125;, <span class="number">200</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  分时函数有了，现在我们来测试一下。假设有 <code>1000</code> 个好友，利用 <code>timeChunk</code> 函数，每批往页面上渲染 <code>8</code> 个：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [];</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++ ) &#123;</span><br><span class="line">    ary.push( i );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> renderFriendList = timeChunk( ary, <span class="function"><span class="keyword">function</span>(<span class="params"> n </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">&#x27;div&#x27;</span> );</span><br><span class="line">    div.innerHTML = n;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">&#125;, <span class="number">8</span>);</span><br><span class="line">renderFriendList();</span><br></pre></td></tr></table></figure></li><li><p>惰性加载函数</p><p>  在 <code>web</code> 开发的过程中，因为浏览器之间的实现差异，一些嗅探工作总是避免不了的。比如我们需要一个能在各个浏览器都能通用的事件绑定函数 <code>addEvent</code>，常见的写法如下：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handler </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">window</span>.addEventListener ) &#123;</span><br><span class="line">        <span class="keyword">return</span> elem.addEventListener( type, handler, <span class="literal">false</span> );</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">window</span>.attachEvent ) &#123;</span><br><span class="line">        <span class="keyword">return</span> elem.attachEvent( <span class="string">&#x27;on&#x27;</span> + type, handler );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这种写法的缺点是每次调用函数都必须执行里面的if判断，虽然开销不大，但是有办法能避免这种操作：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">window</span>.addEventListener ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handler </span>) </span>&#123;</span><br><span class="line">            elem.addEventListener( type, handler, <span class="literal">false</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">window</span>.attachEvent ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handler </span>) </span>&#123;</span><br><span class="line">            elem.attachEvent( <span class="string">&#x27;on&#x27;</span> + type, handler );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>  把嗅探的操作提前到代码加载之前，在代码加载的时候就即可进行一次判断，以便让 <code>addEvent</code>返回一个正确的事件绑定函数。<br>  但是这种写法还是存在缺点的，如果我们从头到尾都不需要进行事件绑定，那么前面那次的嗅探动作就显得多余了。<br>  第三种方案是惰性载入函数方案，第一次进入 <code>addEvent</code> 函数的时候会重写事件绑定函数，在下次进去的时候就会直接执行事件绑定了。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handler </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">window</span>.addEventListener ) &#123;</span><br><span class="line">        addEvent =  <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handler </span>) </span>&#123;</span><br><span class="line">            elem.addEventListener( type, handler, <span class="literal">false</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">window</span>.attachEvent ) &#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handler </span>) </span>&#123;</span><br><span class="line">            elem.attachEvent( <span class="string">&#x27;on&#x27;</span> + type, handler );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEvent( elem, type, handler );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2016/11/30/closure/"/>
      <url>/2016/11/30/closure/</url>
      
        <content type="html"><![CDATA[<p>对于 <code>JavaScript</code> 的程序员来说，闭包是一个难懂又必须征服的概念。在介绍闭包前，先来看看和闭包息息相关的变量作用域和变量的生存周期。</p><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字 <code>var</code> 来声明此变量，那么它就是局部变量，如果没有 <code>var</code> 那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用 <code>var</code> 将变量声明在函数的外面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;bubuzou.com&#x27;</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;bubuzou&#x27;</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">    age = <span class="number">12</span>;  <span class="comment">// 全局变量，建议少用这种全局变量的定义方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在 <code>JavaScript</code> 中，函数可以用来创造函数作用域。函数内部可以看到外面的变量，而外面看不到函数里的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，直到搜索到全局变量为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log( b );  <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">console</span>.log( a );  <span class="comment">// 1</span></span><br><span class="line">    &#125; </span><br><span class="line">    func2();</span><br><span class="line">    <span class="built_in">console</span>.log( c );  <span class="comment">// 报错：c is not defined</span></span><br><span class="line">&#125;;</span><br><span class="line">func1();</span><br></pre></td></tr></table></figure><p>那么能不能从函数外部来访问局部变量呢？答案是可以。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( func()() );  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h2><p>全局变量的生存周期是永久的，除非我们主动的销毁这个全局变量。而对于局部变量来说，当退出函数时，这些局部变量就失去了生存的环境，所以会随着函数调用的结束而被销毁。<br>那么是否可以让局部变量在函数调用结束的时候不被销毁呢？来看下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="built_in">console</span>.log( a );</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = func();</span><br><span class="line">f();  <span class="comment">// 2</span></span><br><span class="line">f();  <span class="comment">// 3</span></span><br><span class="line">f();  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>从上面这个输出结果，我们可以看到局部变量 <code>a</code> 并没有随着 <code>f()</code> 的调用而被销毁。这是因为全局变量 <code>f</code> 保存着对 <code>func</code> 里面匿名函数的引用。而这个匿名函数是可以访问到局部变量 <code>a</code> 的，所以自然 <code>a</code> 也被保存下来了。所以这种情况下局部变量的生存周期就得以延续。上面这个匿名函数其实就是一个闭包。再来看一个闭包的经典应用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有5个div</span></span><br><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">document</span>.getElementsByTagName( <span class="string">&#x27;div&#x27;</span> );</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = nodes.length; i &lt; l; i++ ) &#123;</span><br><span class="line">    nodes[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当真正执行这段代码的时候，发现无论点击那个 <code>div</code>，最后打印的结果都是 <code>4</code>。这是因为 <code>onclick</code> 事件是异步触发的，当事件触发的时候，<code>for</code> 循环早已经结束，此时变量 <code>i</code> 的值已经是 <code>4</code>。解决方案可以是用闭包把每次的 <code>i</code> 都保存起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = nodes.length; i &lt; l; i++ ) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"> i </span>) </span>&#123;</span><br><span class="line">        nodes[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log( i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，我们编写一段代码用来判断对象类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Type = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, type; type = [ <span class="string">&#x27;String&#x27;</span>, <span class="string">&#x27;Array&#x27;</span>, <span class="string">&#x27;Number&#x27;</span> ][ i++ ]; ) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"> type </span>) </span>&#123;</span><br><span class="line">        Type[ <span class="string">&#x27;is&#x27;</span> + type ] = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">&#x27;[object &#x27;</span> + type + <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)( type );</span><br><span class="line">&#125;</span><br><span class="line">Type.isArray( [] );  <span class="comment">// true</span></span><br><span class="line">Type.isString( <span class="string">&#x27;str&#x27;</span> );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>官方的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因为这些变量也是该表达式的一部分。这个概念不好理解，我们可以简单得理解成闭包就是能够访问函数内部变量的函数。</p><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ul><li><p>可以在函数外部访问在函数内部定义的局部变量</p></li><li><p>延续局部变量的生存周期</p></li><li><p>封装变量</p><p>  闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span>  a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ ) &#123;</span><br><span class="line">        a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">mult(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>  <code>mult</code> 函数接受一些 <code>Number</code> 类型的参数，并且返回他们的乘积。现再我们觉得对于那些相同参数来说，每次再进行计算是一种浪费，所以我们决定加入缓存机制来提高函数性能：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">&#x27;&#x27;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( cache[ args ] ) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[ args ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span>  a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ ) &#123;</span><br><span class="line">        a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[ args ] = a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  我们看到 <code>cache</code> 这个变量仅仅在 <code>mult</code> 函数中被使用，所以为了避免 <code>cache</code> 污染全局变量，我们将它放到 <code>mult</code> 函数里面</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">&#x27;&#x27;</span> );</span><br><span class="line">        <span class="keyword">if</span> ( cache[ args ] ) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[ args ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span>  a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ ) &#123;</span><br><span class="line">           a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[ args ] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>  提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有利于代码的复用，如果这些小函数有一个良好的命名，那么它们本身就起到了一个很好的注释作用。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> calculate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span>  a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ ) &#123;</span><br><span class="line">           a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">&#x27;&#x27;</span> );</span><br><span class="line">        <span class="keyword">if</span> ( cache[ args ] ) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[ args ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[ args ] = calculate.apply( <span class="literal">null</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h2><p>局部变量本来应该在函数退出的时候就被结束引用，但如果局部变量被封装在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上来看，闭包确实会使一些数据无法被及时销毁。如果将来需要回收这些变量，我们可以手动把这些变量设为 <code>null</code>。<br>跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域中保存着一些 <code>DOM</code> 节点，这个时候就有可能造成内存泄露。在 <code>IE9</code> 之前的浏览器中，由于 <code>BOM</code> 和 <code>DOM</code> 中的对象是使用 <code>C++</code> 对象以 <code>COM</code> 对象的方式实现的，而 <code>COM</code> 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数的垃圾收集机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。但我们只要把循环引用中的对象设为 <code>null</code> 即可解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this、call和apply</title>
      <link href="/2016/11/28/this-call-apply/"/>
      <url>/2016/11/28/this-call-apply/</url>
      
        <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>跟别的语言不同的是，<code>JavaScript</code> 的 <code>this</code> 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。</p><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>除去不常用的 <code>eval</code> 和 <code>with</code> 语句的情况，具体到实际应用中，<code>this</code> 的指向大致可分为以下4种：</p><ul><li><p>作为对象的方法调用</p><p>  当作为对象的方法进行调用的时候，<code>this</code> 指向该对象：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="built_in">this</span> === obj );  <span class="comment">// true</span></span><br><span class="line">        <span class="built_in">console</span>.log( <span class="built_in">this</span>.name );  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>作为普通函数调用</p><p>  当函数不作为对象的属性进行调用的时候，也就是我们常说的普通函数方式，此时的 <code>this</code> 总是指向全局对象。在浏览器的<code>JavaScript</code> 里，这个全局对象是 <code>window</code> 对象。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">&#x27;bubuzou.com&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.name;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( getName() );  <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">&#x27;bubuzou.com&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = myObject.getName;</span><br><span class="line"><span class="built_in">console</span>.log( getName() );  <span class="comment">//  &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure><p>  再来看一个实际的应用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.id = <span class="string">&#x27;bubuzou&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById( <span class="string">&#x27;div&#x27;</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.id );  <span class="comment">// &#x27;div&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="built_in">this</span>.id );  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log( that.id );  <span class="comment">// &#x27;div&#x27;</span></span><br><span class="line">    &#125;;  </span><br><span class="line">    callback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  <div class="tip">  在 `ECMAScript 5` 的 `strict` 模式下，这种情况的 `this` 已经被规定不会指向全局对象了，而是 `undefined`  </div>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span> );  <span class="comment">// undefined</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>构造器调用</p><p>  <code>JavaScript</code> 中没有类，但是可以从构造器中创建对象，同时也提供了 <code>new</code> 运算符，使得构造器看起来更像一个类。<br>除了宿主提供的一些内置函数外，大多数的 <code>JavaScript</code> 函数都可以当做内置构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于调用的方式。当用 <code>new</code> 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 <code>this</code> 就是指向返回的这个对象。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log( obj.name );  <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure><p>  但是使用构造器调用需要注意一个问题，如果构造器显示的返回了一个 <code>object</code> 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们所期待的 <code>this</code>:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;bubuzou.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;     </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log( obj.name );  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Function.prototype.call</code> 或 <code>Function.prototype.apply</code> 调用</p><p>  跟普通的函数调用相比，用 <code>Function.prototype.call</code> 或 <code>Function.prototype.apply</code> 调用可以动态地改变传入函数的 <code>this</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou.com&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( obj1.getName() );  <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( obj1.getName.call( obj2 ) );  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="丢失的this"><a href="#丢失的this" class="headerlink" title="丢失的this"></a>丢失的this</h2><p><code>document.getElementById</code> 这个方法名有点长，所以我们会尝试用一个简单点的来替代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getId = <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById( id );</span><br><span class="line">&#125;;</span><br><span class="line">getId( <span class="string">&#x27;div&#x27;</span> );</span><br></pre></td></tr></table></figure><p>我们也许思考过为什么不能用下面的这个更简单的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line">getId( <span class="string">&#x27;div&#x27;</span> );</span><br></pre></td></tr></table></figure><p>当我们执行上面这段代码的时候，在 <code>Chrome</code> 浏览器中会抛出异常。这是因为许多浏览器引擎的 <code>document.getElementById</code> 方法的内部实现中需要用到 <code>this</code>。而这个 <code>this</code> 本来期望指向 <code>document</code>，当<code>getElementById</code> 方法作为 <code>document</code> 的属性来调用的时候，内部的 <code>this</code> 确实是指向 <code>document</code> 的。但当用<code>getId</code> 来引用 <code>document.getElementById</code> 之后，再调用 <code>getId</code>，此时就成了普通函数调用，函数内部的 <code>this</code> 指向了 <code>window</code>，而是不是原来的 <code>document</code>，所以会抛出异常。<br>不过我们可以尝试用 <code>apply</code> 把 <code>document</code> 当做 <code>this</code> 传入 <code>getId</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span>(<span class="params"> func </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.apply( <span class="built_in">document</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)( <span class="built_in">document</span>.getElementById );</span><br><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="built_in">console</span>.log( getId( <span class="string">&#x27;div&#x27;</span> ).id );  <span class="comment">// &#x27;div&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h2><p>两者的作用一模一样，区别只是传入的参数形式不一样。<br><code>apply</code>接受2个参数，第一个参数是指定了函数体内的 <code>this</code> 对象的指向，第二个参数为一个带下标的集合，这个集合可以是一个数组也可以是一个类数组。<br><code> call</code> 的参数就不固定了，但是第一个参数和 <code>apply</code> 是一样的，从第二个参数开始往后，每个参数被依次传入函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( [a, b, c] );  </span><br><span class="line">&#125;;</span><br><span class="line">func.apply( <span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] );  <span class="comment">// [1, 2, 3]</span></span><br><span class="line">func.call( <span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> );  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>当调用一个函数的时候，<code>JavaScript</code> 的解释器并不会计较形参和实参在数量、类型和顺序上的区别，从这个意义上来说，<code>apply</code> 比 <code>call</code> 的使用率更高。但是如果我们明确指定参数的个数，也可以用 <code>call</code> 来传送参数。</p><div class="tip">如果第一个参数是 `null`，那么函数体内的 `this` 会指向默认的宿主对象，在浏览器中是 `window`，但如果是在严格模式下，则还是为 `null`</div><h2 id="call和apply的用途"><a href="#call和apply的用途" class="headerlink" title="call和apply的用途"></a>call和apply的用途</h2><ul><li><p>改变 <code>this</code> 指向</p><p>  <code>call</code> 和 <code>apply</code> 最常见的用途是改变函数内部的 <code>this</code> 指向：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">&#x27;bubuzou&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.name );</span><br><span class="line">&#125;;</span><br><span class="line">getName();  <span class="comment">// &#x27;bubuzou&#x27;</span></span><br><span class="line">getName.apply( obj );  <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Function.prototype.bind</code></p><p>  大部分高级的浏览器都实现内置的 <code>Function.prototype.bind</code> ，用来指定函数内部的 <code>this</code> 指向，即使没有原生的<code>Function.prototype.bind</code> 实现，我们来模拟实现一个也不是难事：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"> context </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply( context, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou.com&#x27;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.name );</span><br><span class="line">&#125;.bind( obj );</span><br><span class="line">func();  <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure><p>  这是一个简化版的实现，我们可以实现得更复杂一点，使得可以往 <code>func</code> 函数中预先填入一些参数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>,</span><br><span class="line">        context = [].shift.call( <span class="built_in">arguments</span> ),</span><br><span class="line">        args = [].slice.call( <span class="built_in">arguments</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply( context, [].concat.call( args, [].slice.call( <span class="built_in">arguments</span> )));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c, d </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.name );  <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log( [a, b, c, d] );  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">&#125;.bind(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">func(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li><li><p>借用其他对象的方法</p><p>  我们知道，杜鹃既不会筑巢，也不会孵雏，而是把自己的蛋寄托给云雀等其他鸟类，让他们代为孵化和养育。同样，在<code>JavaScript</code>中也存在类似的借用现象。<br>借用的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    A.apply( <span class="built_in">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">&#125;;</span><br><span class="line">B.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B( <span class="string">&#x27;bubuzou.com&#x27;</span> );</span><br><span class="line"><span class="built_in">console</span>.log( b.getName() );  <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure><p>  借用方法的第二种运用场景跟我们的关系更加密切。函数的参数列表 <code>arguments</code> 是一个类数组对象，所以不能像数组一样，进行排序操作或往集合里添加一个新的元素。在这种情况下，我们通常会借用 <code>Array.prototype</code> 对象上的方法。比如像往<code>arguments</code> 里添加一个元素：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.push.call( <span class="built_in">arguments</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">arguments</span> );  <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>  先来看一个例子:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call( a, <span class="string">&#x27;first&#x27;</span> );</span><br><span class="line"><span class="built_in">console</span>.log( a.length );  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log( a[<span class="number">0</span>] );  <span class="comment">// &#x27;first&#x27;</span></span><br></pre></td></tr></table></figure><p>  上面这段代码在低版本IE浏览器中执行的时候，必须显式地给对象a设置length属性:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    length: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  然而并不是所有的对象都可以传入Array.prototype.push，必须满足以下2个条件:</p><ul><li><p>对象本身可以存取属性</p><p>  如果不是一个 <code>object</code> 类型的对象而是 <code>number</code> 类型，我们来看看会怎么样：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call( a, <span class="string">&#x27;first&#x27;</span> );</span><br><span class="line"><span class="built_in">console</span>.log( a.length );  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log( a[<span class="number">0</span>] );  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>对象的 <code>length</code> 属性可以读写<br>  函数的 <code>length</code> 就是只有一个只读的属性，表示形参的个数，我们尝试把一个函数当做 <code>this</code> 传入<code>Array.prototype.push</code>:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call( func, <span class="string">&#x27;first&#x27;</span> );</span><br><span class="line"><span class="built_in">console</span>.log( func.length );  <span class="comment">// 报错：Cannot assign to read only property &#x27;length&#x27; of function</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2016/11/17/js-array/"/>
      <url>/2016/11/17/js-array/</url>
      
        <content type="html"><![CDATA[<h2 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h2><p>数组字面量提供了一种非常方便的创建数组的方法。一个数组表达式是在一对方括号内包围零个或多个用逗号分隔的值的表达式。<br>数组的第一个值的属性名是 <code>0</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = [];</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="string">&#x27;zero&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>, <span class="string">&#x27;seven&#x27;</span>];</span><br><span class="line">empty[<span class="number">1</span>];  <span class="comment">// undefined</span></span><br><span class="line">numbers[<span class="number">1</span>];  <span class="comment">// &#x27;one&#x27;</span></span><br><span class="line">empty.length;  <span class="comment">// 0</span></span><br><span class="line">numbers.length;  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>在大多数语言中，一个数组的所有元素都要求是相同的类型。<code>js</code> 允许数组包含任意混合类型的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> misc = [<span class="string">&#x27;string&#x27;</span>, <span class="number">98.6</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>];</span><br><span class="line">misc.length;  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>每个数组都有一个 <code>length</code> 属性。和大多数的语言不同，<code>js</code> 中数组的 <code>length</code> 是没有上限的。如果用大于或等于 <code>length</code> 的数字作为下标来存储一个元素，那么 <code>length</code> 的值会被增大以便容纳新的值，不会发生数组越界的错误。可以直接设置 <code>length</code> 的值，如果 <code>length</code> 大于当前的 <code>length</code> 值，则更大的那些下标的值都是 <code>undefined</code>；如果更小，<br>那么将会把所有下标大于等于新 <code>length</code> 的属性给删除。通过把下标指定为一个数组的当前 <code>length</code>，可以附加一个新元素到该数组的末尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line">arr.length;  <span class="comment">// 3</span></span><br><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr;  <span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, undefined, undefined, undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr;  <span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;]</span></span><br><span class="line">arr[arr.length] = <span class="string">&#x27;last&#x27;</span>;  <span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;last&#x27;];</span></span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>由于 <code>js</code> 的数组其实就是对象，所以 <code>delete</code> 运算符可以删除数组的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">1</span>]; </span><br><span class="line">arr;  <span class="comment">// [&#x27;one&#x27;, undefined, &#x27;three&#x27;]</span></span><br></pre></td></tr></table></figure><p>遗憾的是删除后的数组直接留了一个空位值是 <code>undefined</code>，幸运的是可以通过数组的 <code>splice</code> 方法来进行调整。<code>splice</code> 方法接受 <code>2</code> 个参数，第一个是数组的序号，第二个是删除的元素个数，并且返回一个数组，这个数组包含了所有的删除元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// [undefined]</span></span><br><span class="line">arr;  <span class="comment">// [&#x27;one&#x27;, &#x27;three&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>因为 <code>js</code> 数组其实就是对象，所以 <code>for in</code> 语句可以用来遍历一个数组的所有属性。但是用 <code>for in</code>语句无法保证顺序。所以遍历还是用常规的 <code>for</code> 循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = numbers.length; i &lt; l; i++ ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( numbers[i] );  <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否是数组"><a href="#判断是否是数组" class="headerlink" title="判断是否是数组"></a>判断是否是数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><p><code>js</code> 本身对于数组和对象的区别是混乱的。<code>typeof</code> 运算符报告数组的类型是 <code>object</code>，没有任何意义。<br><code>js</code> 没有一个好的机制来区别是数组还是对象，但是我们可以自己实现一个 <code>is_array</code> 函数来弥补这个缺陷：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj &amp;&amp; </span><br><span class="line">        <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">        obj.constructor === <span class="built_in">Array</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这个判断基本在常规页面就能很好的区分出数组还是对象了。但是也有特例，比如在不同的窗口(<code>window</code>)或帧(<code>frame</code>)就会失败。这个时候可以用下面这个替换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.apply( obj ) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>判断某个对象是否是数组，还可以用原型链的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.__prototype__ === <span class="built_in">Array</span>.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p><code>array.concat(item1[, item2, item2, ...])</code></p><p>  <code>concat</code> 产生一个新数组，参数 <code>item</code> 可以是一个任意类型的值，也可以是一个数组，如果是数组，那么数组的所有元素都会被添加到新数组里。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>];</span><br><span class="line">a.concat(b, <span class="literal">true</span>);  <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;x&quot;, &quot;y&quot;, true]</span></span><br></pre></td></tr></table></figure></li><li><p><code>array.join(separator)</code></p><p>  <code>join</code> 方法把 <code>array</code> 中的每个元素构造成一个字符串，接着用一个 <code>separator</code> 分隔符把它们连接在一起。默认的<code>separator</code> 是逗号,。想要无间隔的连接，可以使用空字符串。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">a.join();  <span class="comment">// &#x27;a,b,c&#x27;</span></span><br><span class="line">a.join(<span class="string">&#x27;&#x27;</span>);  <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>  <div class="tip">  如果想把大量的字符串片段组装成一个字符串，用 `+` 元素运算符连接这些片段会比把这些片段放到一个数组中并且用 `join` 连接起来更快。</div></li><li><p><code>array.pop()</code></p><p>  <code>pop</code> 方法移除数组中的最后一个元素并返回该元素。如果 <code>array</code> 是空值，则会返回 <code>undefined</code></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">a.pop();  <span class="comment">// &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// pop可以这样实现：</span></span><br><span class="line"><span class="built_in">Array</span>.method(<span class="string">&#x27;pop&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.splice( <span class="built_in">this</span>.length - <span class="number">1</span>, <span class="number">1</span> )[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>array.push(item1[, item2, ...])</code></p><p>  <code>push</code> 方法把一个或多个参数附加到一个数组的尾部。参数可以是任何类型的值，也可以是数组。如果是数组，它会把参数数组作为这个元素添加到数组中。返回修改后的数组长度。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> c = a.push(b, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// a: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;], true]</span></span><br><span class="line"><span class="comment">// c: 5</span></span><br><span class="line"><span class="comment">// push可以这样实现：</span></span><br><span class="line"><span class="built_in">Array</span>.method(<span class="string">&#x27;push&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.splice.apply( </span><br><span class="line">    <span class="built_in">this</span>,</span><br><span class="line">    [<span class="built_in">this</span>.length, <span class="number">0</span>].</span><br><span class="line">        concat(<span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>array.reverse()</code></p><p>  <code>reverse</code> 方法反转 <code>array</code> 里的元素的顺序，并返回 <code>array</code> 本身。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.reverse();  <span class="comment">// a和b都是[&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>array.shift()</code></p><p>  <code>shift</code> 方法移除数组中的第一个元素，并且返回这个元素。如果数组为空，则返回 <code>undefined</code>。 <code>shift</code> 通常比 <code>pop</code> 慢得多。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.shift();  <span class="comment">// a: [&#x27;b&#x27;, &#x27;c&#x27;], b: &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// shift实现</span></span><br><span class="line"><span class="built_in">Array</span>.method(<span class="string">&#x27;shift&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.splice(<span class="number">0</span>, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>array.slice(start, end)</code></p><p>  <code>slice</code> 方法对数组进行一段浅复制。复制从下标 <code>start</code> 到 <code>end</code> 结束。<code>end</code> 下标默认是<code> array.length</code> 。如果两个参数任意一个是负数，那么 <code>end</code> 数值会是和 <code>array.length</code> 相加之后的值。如果 <code>start</code> 大于<code>array.length</code>，则返回一个空数组。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.slice(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// [&#x27;a&#x27;]</span></span><br><span class="line"><span class="keyword">var</span> c = a.slice(<span class="number">1</span>);  <span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="keyword">var</span> d = a.slice(<span class="number">-1</span>);  <span class="comment">// [&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>array.sort(comparefn)</code></p><p>  <code>sort</code> 方法对 <code>array</code> 里的所有元素进行排序，默认的比较函数是把被排序的元素都视为字符串。所以它不能正确地给一组数字进行排序：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>];</span><br><span class="line">n.sort();  <span class="comment">// [15, 16, 23, 4, 42, 8]</span></span><br></pre></td></tr></table></figure><p>  幸运的是你可以使用自定义的比较函数来使得一组数字能正常排序，比较函数接受两个参数，如果他们相等，则返回0，如果第一个参数应该排序在前面，则返回负数，如果第二个参数应该排在前面，则返回一个正数。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);  <span class="comment">// [4, 8, 15, 16, 23, 42]</span></span><br></pre></td></tr></table></figure><p>  如果想给包含任何简单值的数组进行排序，可以这样：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = [<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>];</span><br><span class="line">m.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="keyword">typeof</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> a &lt; <span class="keyword">typeof</span> b ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;);  <span class="comment">// [3, 5, 10, &#x27;a&#x27;, &#x27;aa&#x27;, &#x27;bb&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>array.splice(start, deleteCount, item...)</code></p><p>  <code>splice</code> 方法从 <code>array</code> 中移除一个或多个元素，并用新的 <code>item</code> 替换它们。<code>start</code> 是移除元素的起始位置，<code>deleteCount</code> 是移除个数。如果有额外的参数，则 <code>item</code> 会插入到被移除的元素的位置上。返回一个包含被移除元素的数组。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> r = a.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;ache&#x27;</span>, <span class="string">&#x27;bug&#x27;</span>);  <span class="comment">// a: [&#x27;a&#x27;, &#x27;ache&#x27;, &#x27;bug&#x27;, &#x27;c&#x27;], r: [&#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>array.unshift(item...)</code></p><p>  <code>unshift</code> 方法是把 <code>item</code> 插入到数组的开始部分。返回新数组的 <code>length</code>。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> r = a.unshift(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;$&#x27;</span>);  <span class="comment">// a: [&#x27;#&#x27;, &#x27;$&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], r: 5</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式理论篇</title>
      <link href="/2016/11/04/regexp-concept/"/>
      <url>/2016/11/04/regexp-concept/</url>
      
        <content type="html"><![CDATA[<h2 id="先来看一个例子"><a href="#先来看一个例子" class="headerlink" title="先来看一个例子"></a>先来看一个例子</h2><p>这里有一个例子，用来匹配URL的正则表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://bubuzou.com:80/goodparts?q#fragment&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> parse_url = <span class="regexp">/^(?:([A-Za-z]+):)?(\/&#123;0,3&#125;)([0-9.\-A-Z-a-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log( parse_url.exec( url ) );</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面这段代码产生的结果如下：</span></span><br><span class="line"><span class="comment">[&quot;http://bubuzou.com:80/goodparts?q#fragment&quot;, &quot;http&quot;, &quot;//&quot;, &quot;bubuzou.com&quot;, &quot;80&quot;, &quot;goodparts&quot;, &quot;q&quot;, &quot;fragment&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>现在让我们来分解parse_url的各个部分，看看它是如何工作的：</p><ul><li><code>^</code> 字符表示字符串的开始</li><li><code>(?:([A-Za-z]+):)?</code>这个因子匹配一个协议名，但是只有当它后面跟随:的时候才匹配。<code>(?:...)</code> 表示一个非捕获型的分组。后缀 <code>?</code> 表示这个分组是可选的，表示匹配 <code>0</code> 次或者 <code>1</code> 次。<br><code>(...)</code> 表示一个捕获型分组。一个捕获型分组会复制它所匹配的文本，并且将其放到 <code>result</code> 数组里。每个捕获型分组会被指定一个编号。第一个捕获型分组的编号是 <code>1</code>，所以该分组所匹配的结果会出现在 <code>result[1]</code> 中。<code>[...]</code> 表示一个字符类。<code>A-Za-z</code> 这个字符类包含 <code>26</code> 个大写字母和 <code>26</code> 个小写字母。<code>+</code> 表示这个字符类会被匹配 <code>1</code> 次或多次。<code>:</code> 会按照字面进行匹配。</li><li><code>(\/&#123;0,3&#125;)</code> 这个因子是捕获分组 <code>2</code> 。<code>\/</code> 表示匹配 <code>/</code> （斜杠），它用 <code>\</code> 来进行转义。<code>&#123;0,3&#125;</code> 表示会被匹配<code>0-3</code> 次</li><li><code>([0-9.\-A-Z-a-z]+)</code> 这个因子是捕获分组 <code>3</code> 。它会匹配一个主机名，由一个或多个数字、字母，以及 <code>.</code> 或-组成。</li><li><code>(?::(\d+))?</code> 这个因子匹配的是端口号。<code>(\d+)</code> 是捕获分组 <code>4</code>，表示匹配一个或多个数字。</li><li><code>(?:\/([^?#]*))?</code> 是一个可选的分组，以一个 <code>/</code> 开始。<code>[^?#]</code> 是捕获分组 <code>5</code> ，以一个 <code>^</code> 开始表示这个类包含除 <code>?</code> 和 <code>#</code> 之外的所有字符。 <code>*</code> 表示匹配 <code>0</code> 次或多次。</li><li><code>(?:\?([^#]*))?</code> 是一个以 <code>?</code> 开始的分组。包含捕获分组 <code>6</code>，这个分组包含 <code>0</code> 个或多个非 <code>#</code> 的字符</li><li><code>(?:#(.*))?</code> 这个可选分组是以 <code>#</code> 开始的，<code>.</code> 会匹配除了行结束符以外的所有字符。</li><li><code>$</code> 表示字符串的结束</li></ul><blockquote><p>所谓正则表达式，就是一种描述字符串结构模式的形式化表达方法。</p></blockquote><p>这是《精通正则表达式》对它的定义。<br>正则表达式又叫做规则表达式(Regular Expression，简写regexp).<br>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p><h2 id="正则表达式能干嘛"><a href="#正则表达式能干嘛" class="headerlink" title="正则表达式能干嘛"></a>正则表达式能干嘛</h2><ul><li>测试字符串是否满足某种模式。比如字符串内是否出现电话号码模式，又称为数据验证。</li><li>替换文本。可以用正则表达式来识别字符串中的特定文本，完全删除或者用其他文本替换它。</li><li>提取字符串。基本匹配模式从字符串中提取需要的子字符串。</li></ul><div class="tip">正则表达式已经在很多软件中得到广泛的应用，包括 `*nix(Linux, Unix等)`，`HP` 等操作系统，`PHP`、`C#`、`Java`等开发环境，以及很多的应用软件中，都可以看到正则表达式的影子。</div><h2 id="正则表达式结构"><a href="#正则表达式结构" class="headerlink" title="正则表达式结构"></a>正则表达式结构</h2><p>优先考虑的方法是使用正则表达式字面量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/pattern/m</span>odifiers;</span><br></pre></td></tr></table></figure><p>另一种方法是使用RegExp构造器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patt = <span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern, modifiers);</span><br></pre></td></tr></table></figure><ul><li>pattern（模式） 描述了表达式的模式</li><li>modifiers（修饰符） 用于指定全局匹配、区分大小写的匹配和多行匹配</li></ul><p>修饰符modifiers：</p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td><code>i</code></td><td>执行对大小写不敏感的匹配</td></tr><tr><td><code>g</code></td><td>执行全局匹配</td></tr><tr><td><code>m</code></td><td>执行多行匹配</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/hello/ig</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">patt.exec( str );  <span class="comment">// 将会匹配&#x27;Hello&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="正则表达因子"><a href="#正则表达因子" class="headerlink" title="正则表达因子"></a>正则表达因子</h2><p>一个正则表达式因子可以是一个字符、一个圆括号包围的组、一个字符类或者是一个转义序列。下面这些字符都会按照字面进行处理<code>\ / [ ] ( ) &#123; &#125; ? + * | . ^</code> $如果你希望这些字符按照字面意思去匹配，那需要在其前面加上\进行转义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/\.\d+/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;-12.568&#x27;</span>;</span><br><span class="line">patt.exec( str );  <span class="comment">// 匹配&#x27;.568&#x27;</span></span><br></pre></td></tr></table></figure><p>正则表达式特殊字符:</p><table><thead><tr><th>特殊字符</th><th>描述</th></tr></thead><tbody><tr><td><code>^</code></td><td>匹配输入字符串开始处的位置；但在中括号表达式中是表示对字符集求反。若要匹配 <code>^</code> 字符本身，请使用 <code>\^</code>。</td></tr><tr><td><code>$</code></td><td>匹配输入字符串结尾的位置。如果设置了 <code>RegExp</code> 对象的 <code>Multiline</code> 属性，那么 <code>$</code> 还匹配 <code>\n</code> 或 <code>\r</code> 前面的位置。若要匹配 <code>$</code> 字符本身，请使用 <code>\$</code>。</td></tr><tr><td><code>()</code></td><td>标记子表达式的开始和结束。可以捕获子表达式以供以后使用。若要匹配这两个字符，请使用 <code>\(</code> 和 <code>\)</code>。</td></tr><tr><td><code>*</code></td><td>零次或多次匹配前面的字符或子表达式。若要匹配 <code>*</code> 字符，请使用 <code>\*</code>。</td></tr><tr><td><code>+</code></td><td>一次或多次匹配前面的字符或子表达式。若要匹配 <code>+</code> 字符，请使用 <code>\+</code>。</td></tr><tr><td><code>?</code></td><td>零次或一次匹配前面的字符或子表达式，或指示“非贪心”限定符。若要匹配 <code>?</code> 字符，请使用<code>\?</code>。</td></tr><tr><td><code>.</code></td><td>匹配除换行符 <code>\n</code> 之外的任何单个字符。若要匹配 <code>.</code> 请使用 <code>\</code>。</td></tr><tr><td><code>[]</code></td><td>标记中括号表达式的开始。若要匹配这些字符，请使用 <code>\[</code> 和<code>\]</code>。</td></tr><tr><td><code>\</code></td><td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，字符 <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 <code>\</code>，序列 <code>\(</code> 匹配 <code>(</code>。</td></tr><tr><td><code>/</code></td><td>表示文本正则表达式的开始或结束。若要匹配 <code>/</code> 字符，请使用 <code>\/</code>。</td></tr><tr><td><code>&#123;&#125;</code></td><td>标记限定符表达式的开始。若要匹配这些字符，请使用 <code>\&#123;</code> 和 <code>\&#125;</code>。</td></tr><tr><td>竖线</td><td>指出在两个项之间进行选择。要匹配竖线，请使用 <code>\</code> 竖线。</td></tr></tbody></table><h2 id="正则表达式序列"><a href="#正则表达式序列" class="headerlink" title="正则表达式序列"></a>正则表达式序列</h2><p>一个正则表达式序列包含一个或多个正则表达式因子。每个因子能选择是否跟随一个量词，这个量词决定了这个因子被允许出现的次数。如果没有量词，则只匹配一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/\d&#123;3&#125;\.\d/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc1893.65d&#x27;</span>;</span><br><span class="line">patt.exec( str );  <span class="comment">// 匹配&#x27;893.6&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式分支"><a href="#正则表达式分支" class="headerlink" title="正则表达式分支"></a>正则表达式分支</h2><p>一个正则表达式分支包含一个或多个正则表达式序列。这些序列被|字符分隔。如果这些序列中的任何一项符合匹配条件，那么这个选择就被匹配。它会按照书写顺序从左到右依次匹配这些序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;information&#x27;</span>;</span><br><span class="line">str.match( <span class="regexp">/or|for/</span> );  <span class="comment">// 匹配&#x27;for&#x27;</span></span><br><span class="line">str.match( <span class="regexp">/or|orm/</span> ); <span class="comment">// 匹配&#x27;or&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式分组"><a href="#正则表达式分组" class="headerlink" title="正则表达式分组"></a>正则表达式分组</h2><p>正则表达式的分组共有6种。</p><ul><li><code>(...)</code>捕获型，捕获型分组是一个被包围在圆括号中的正则表达式分支。任何匹配这个分组的字符都会被捕获。每个捕获分组都将有一个编号。第一个捕获分组的编号是 <code>1</code>，以此类推。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(:\d+)/.exec( <span class="string">&#x27;bubuzou.com:80/&#x27;</span> ); </span><br><span class="line"><span class="comment">// 结果是[&#x27;:80&#x27;, &#x27;:80&#x27;]，第一个&#x27;:80&#x27;表示整个正则的匹配，第二个&#x27;:80&#x27;表示捕获分组1的匹配</span></span><br></pre></td></tr></table></figure><ul><li><code>(?:...)</code> 非捕获型，仅做简单的匹配，并不会捕获所匹配的文本。也不会进行编号。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(?::\d+)/.exec( <span class="string">&#x27;bubuzou.com:80/&#x27;</span> ); 结果是[<span class="string">&#x27;:80&#x27;</span>]，不包含分组捕获。</span><br></pre></td></tr></table></figure><ul><li><code>(?=pattern)</code> 正向肯定预查。匹配其跟随了 <code>pattern</code> 的字符串。这不是一个好的特性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="built_in">window</span>(?=<span class="number">95</span>|<span class="number">98</span>|<span class="number">2000</span>)/.exec( <span class="string">&#x27;window98&#x27;</span> ); <span class="comment">// 匹配&#x27;window&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>(?!pattern)</code> 正向否定预查。匹配其没有跟随了 <code>pattern</code> 的字符串。这不是一个好的特性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="built_in">window</span>(?!<span class="number">95</span>|<span class="number">98</span>|<span class="number">2000</span>)/.exec( <span class="string">&#x27;windowNT&#x27;</span> ); <span class="comment">// 匹配&#x27;window&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>(?&lt;=pattern)</code> 反向肯定预查。匹配前面带 <code>pattern</code> 的字符串。这不是一个好的特性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=<span class="number">95</span>|<span class="number">98</span>|<span class="number">2000</span>)windows/.exec( <span class="string">&#x27;95windows&#x27;</span> ); <span class="comment">// 匹配&#x27;windows&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>(?&lt;!pattern)</code> 反向否定预查。匹配前面没有带 <code>pattern</code> 的字符串。这不是一个好的特性。</li></ul><h2 id="RegExp对象方法"><a href="#RegExp对象方法" class="headerlink" title="RegExp对象方法"></a>RegExp对象方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>regexp.exec(string)</code></td><td>检索字符串中指定的值。如果匹配成功，则返回一个数组。数组中下标为 <code>0</code> 的值表示匹配的子字符串，下标为1的值是分组1捕获的文本。如果匹配失败，则会返回 <code>null</code>.</td></tr><tr><td><code>regexp.test(string)</code></td><td>检索字符串中指定的值。返回 <code>true</code> 或 <code>false</code>。 <code>test</code> 方法中不需要对 <code>regexp</code> 进行全局匹配的配置，因为结果都一样。</td></tr><tr><td><code>string.match(regexp)</code></td><td>获取匹配结果。如果没有 <code>g</code> 标识，则结果和 <code>regexp.exec(string)</code> 一样。如果有 <code>g</code> 标识，则返回包含所有匹配结果（除了分组捕获之外）的数组。</td></tr><tr><td><code>string.replace(searchValue, replaceValue)</code></td><td><code>replace</code> 方法对字符串执行查找和替换工作，并返回一个新的字符串。参数 <code>searchValue</code> 可以是一个字符串或者正则表达式。如果是字符串，则在字符串中第一次出现的地方被替换。如果是正则表达式且带有 <code>g</code>，则会替换所有匹配，如果没有g则只会替换第一个匹配。<code>replaceValue</code> 可以是一个字符串或者一个函数。如果是一个函数则有特别含义。如果是一个函数，则每遇到一个匹配函数就会被调用一次，而函数返回的字符串将作为替换的文本。</td></tr><tr><td><code>string.search(regexp)</code></td><td>和 <code>indexOf</code> 方法类似，只是它接受的参数是一个正则表达式而非字符串。如果找到匹配，则返回第一个匹配的首字符的位置，没找到就返回 <code>-1</code></td></tr><tr><td><code>string.split(separator, limit)</code></td><td>把 <code>string</code> 分割成片段来创建一个字符串数组。<code>limit</code> 可以限制分割的数量。<code>separator</code>可以是字符串或正则表达式。</td></tr></tbody></table><p><code>regexp.exec(string)：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegExpObject.exec(string);</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;user1abcuser2abc&quot;</span>,</span><br><span class="line">    patt=<span class="regexp">/user\d/g</span>,</span><br><span class="line">    result;</span><br><span class="line"><span class="keyword">while</span> ( ( result = patt.exec( str ) ) ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( result );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一次：[&quot;user1&quot;, index: 0, input: &quot;user1abcuser2abc&quot;]</span></span><br><span class="line"><span class="comment">// 第二次：[&quot;user2&quot;, index: 8, input: &quot;user1abcuser2abc&quot;]</span></span><br></pre></td></tr></table></figure><div class="tip">如果regexp带有g标识，那么查找不是从这个字符串的起始位置开始，而是从regexp.lastIndex位置开始。如果匹配成功，那么regexp.lastIndex将被设置为该匹配后第一个字符的位置。不成功的匹配会将regexp重新设置为0。</div><p><code>regexp.test(string)：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Hello/i.test( <span class="string">&#x27;hello world&#x27;</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>string.match(regexp)：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;user1abcuser2abc&#x27;</span>.match( <span class="regexp">/user\d/g</span> );  <span class="comment">// [&#x27;user1&#x27;, &#x27;user2&#x27;]</span></span><br><span class="line"><span class="string">&#x27;user1abcuser2abc&#x27;</span>.match( <span class="regexp">/user\d/</span> );  <span class="comment">// [&#x27;user1&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>string.replace(searchValue, replaceValue)：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/\((\d&#123;3&#125;)\)/g</span>,</span><br><span class="line">    str = <span class="string">&#x27;(555)666-1212&#x27;</span>.replace(patt, <span class="string">&#x27;$1-&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// 结果：&#x27;555-666-1212&#x27;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>美元符号序列</th><th>替换对象</th></tr></thead><tbody><tr><td><code>$$</code></td><td><code>$</code></td></tr><tr><td><code>$&amp;</code></td><td>整个匹配的文本</td></tr><tr><td><code>$number</code></td><td>分组匹配的文本</td></tr><tr><td><code>$</code></td><td>匹配之前的文本</td></tr><tr><td><code>$</code></td><td>匹配之后的文本</td></tr></tbody></table><p><code>string.search(regexp)：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.search( <span class="regexp">/world/</span> );  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><code>string.split(separator, limit)：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;123456&#x27;</span>.split(<span class="string">&#x27;&#x27;</span>, <span class="number">3</span>); <span class="comment">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span></span><br><span class="line"><span class="string">&#x27;last, first, middle&#x27;</span>.split(<span class="regexp">/\s*,\s*/</span>);  <span class="comment">// [&#x27;last&#x27;, &#x27;first&#x27;, &#x27;middle&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式字符表"><a href="#正则表达式字符表" class="headerlink" title="正则表达式字符表"></a>正则表达式字符表</h2><table><thead><tr><th>量词</th><th>描述</th></tr></thead><tbody><tr><td><code>*</code></td><td>零次或多次匹配前面的字符或子表达式。例如，<code>zo</code> 匹配 <code>z</code> 和 <code>zoo</code>。 等效于 <code>&#123;0,&#125;</code>。</td></tr><tr><td><code>+</code></td><td>一次或多次匹配前面的字符或子表达式。例如，<code>zo+</code> 匹配 <code>zo</code> 和 <code>zoo</code>，但不匹配 <code>z</code>。<code>+</code> 等效于 <code>&#123;1,&#125;</code>。</td></tr><tr><td><code>?</code></td><td>零次或一次匹配前面的字符或子表达式。例如，<code>do(es)?</code> 匹配 <code>do</code> 或 <code>does</code> 中的 <code>do</code>。<code>?</code> 等效于 <code>&#123;0,1&#125;</code>。</td></tr><tr><td><code>&#123;n&#125;</code></td><td><code>n</code> 是非负整数。正好匹配 <code>n</code> 次。例如，<code>o&#123;2&#125;</code> 不匹配 <code>Bob</code> 中的 <code>o</code>，但匹配 <code>food</code> 中的两个 <code>o</code>。</td></tr><tr><td><code>&#123;n,&#125;</code></td><td><code>n</code> 是非负整数。至少匹配 <code>n</code> 次。例如，<code>o&#123;2,&#125;</code> 不匹配 <code>Bob</code> 中的 <code>o</code>，而匹配 <code>foooood</code> 中的所有 <code>o</code>。<code>o&#123;1,&#125;</code> 等效于 <code>o+</code>。<code>o&#123;0,&#125;</code> 等效于 <code>o*</code>。</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td><code>m</code> 和 <code>n</code> 是非负整数，其中 <code>n &lt;= m</code>。匹配至少 <code>n</code> 次，至多 <code>m</code> 次。例如，<code>o&#123;1,3&#125;</code> 匹配 <code>fooooood</code> 中的头三个 <code>o</code>。<code>o&#123;0,1&#125;</code> 等效于 <code>o?</code>。注意：您不能将空格插入逗号和数字之间。</td></tr></tbody></table><p>方括号：方括号用于查找某个范围内的字符</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td><code>[abc]</code></td><td>查找方括号之间的任何字符</td></tr><tr><td><code>[^abc]</code></td><td>查找任何不在方括号之间的字符</td></tr><tr><td><code>[0-9]</code></td><td>查找任何从 <code>0</code> 至 <code>9</code> 的数字</td></tr><tr><td><code>[a-z]</code></td><td>查找任何从小写 <code>a</code> 至小写 <code>a</code> 的字符</td></tr><tr><td><code>()</code></td><td>匹配一个子表达式的开始和结束位置</td></tr></tbody></table><p>元字符：拥有特殊含义的字符</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td><code>.</code></td><td>查找单个字符，除了换行和行结束符</td></tr><tr><td><code>\w    </code></td><td>查找单词字符</td></tr><tr><td><code>\W</code></td><td>查找非单次字符</td></tr><tr><td><code>\b</code></td><td>匹配一个字的边界，即字与空格间的位置</td></tr><tr><td><code>\B    </code></td><td>非字符边界匹配</td></tr><tr><td><code>\d</code></td><td>查找数字</td></tr><tr><td><code>\D    </code></td><td>查找非数字字符</td></tr><tr><td><code>\s</code></td><td>查找空白字符</td></tr><tr><td><code>\S</code></td><td>查找非空白字符</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> web综合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
