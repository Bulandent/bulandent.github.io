{"meta":{"title":"步步走","subtitle":null,"description":"良好的css编码习惯能够提高开发、维护效率，所以前端很有必要养成一个好的编码习惯。","author":"typeR","url":"https://bubuzou.com","root":"/"},"pages":[{"title":"","date":"2020-07-29T06:57:38.699Z","updated":"2018-12-19T03:41:36.121Z","comments":true,"path":"google3f5e6f40d046c2a1.html","permalink":"https://bubuzou.com/google3f5e6f40d046c2a1.html","excerpt":"","text":"· 步步走 博文归档生活摄影关于2017-07-14-次访问google-site-verification: google3f5e6f40d046c2a1.html分类归档JavaScript7css7web综合2精通正则表达式1标签云JavaScript Javascript chrome css svg 图像 性能优化 正则表达式最近文章JS中类数组的遍历以及性能探究良好的CSS编码习惯jpg、gif、png和svg用于web上，我们该如何选择最合适的图像格式？CSS自定义属性理解 Flexbox：你需要知道这些搜索 (function() { var appid = 'cyt6h19Ve'; var conf = 'prod_0b4b95efa2ecfede2ddfb5adcef8c394'; var width = window.innerWidth || document.documentElement.clientWidth; if (width < 960) { window.document.write(''); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(\"head\")[0]||document.head||document.documentElement;var b=document.createElement(\"script\");b.setAttribute(\"type\",\"text/javascript\");b.setAttribute(\"charset\",\"UTF-8\");b.setAttribute(\"src\",d);if(typeof a===\"function\"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===\"loaded\"||e===\"complete\"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(\"https://changyan.sohu.com/upload/changyan.js\",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();© 2016 - 2017 typeR, powered by Hexo and hexo-theme-bubuzou 闽ICP备16007301号-2Hosted by Coding Pages(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',\"UA-65933410-1\",'auto');ga('send','pageview');"}],"posts":[{"title":"「建议收藏」送你一份精心总结的3万字ES6实用指南（全）","slug":"es6","date":"2020-11-17T07:53:04.000Z","updated":"2020-11-17T07:57:11.998Z","comments":true,"path":"2020/11/17/es6/","link":"","permalink":"https://bubuzou.com/2020/11/17/es6/","excerpt":"写本篇文章目的是为了夯实基础，基于阮一峰老师的著作 ECMAScript 6 入门 以及 tc39-finished-proposals 这两个知识线路总结提炼出来的重点和要点，涉及到从 ES2015 到 ES2021 的几乎所有知识，基本上都是按照一个知识点配上一段代码的形式来展示，所以篇幅较长，也正是因为篇幅过长，所以就没把 Stage 2 和 Stage 3 阶段的提案写到这里，后续 ES2021 更新了我再同步更新。 有 5 个提案已经列入 Expected Publication Year in 2021 所以本篇中暂且把他们归为 ES2021。","text":"写本篇文章目的是为了夯实基础，基于阮一峰老师的著作 ECMAScript 6 入门 以及 tc39-finished-proposals 这两个知识线路总结提炼出来的重点和要点，涉及到从 ES2015 到 ES2021 的几乎所有知识，基本上都是按照一个知识点配上一段代码的形式来展示，所以篇幅较长，也正是因为篇幅过长，所以就没把 Stage 2 和 Stage 3 阶段的提案写到这里，后续 ES2021 更新了我再同步更新。 有 5 个提案已经列入 Expected Publication Year in 2021 所以本篇中暂且把他们归为 ES2021。 ES6前言发展史能写好 JS 固然是重要的，但是作为一个前端，我们也要了解自己所使用语言的发展历程，这里强烈推荐看 《JavaScript 20年》，本书详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化历程。 版本说明2011 年，发布了 ECMAScript 5.1 版，而 2015 年 6 月发布了 ES6 的第一个版本又叫 ES2015。ES6 其实是一个泛指，指代 5.1 版本以后的下一代标准。TC39 规定将于每年的 6 月发布一次正式版本，版本号以当年的年份为准，比如当前已经发布了 ES2015、ES2016、ES2017、ES2018、ES2019、ES2020 等版本。 提案发布流程任何人都可以向 TC39 提案，要求修改语言标准。一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。 Stage 0 - Strawperson（展示阶段） Stage 1 - Proposal（征求意见阶段） Stage 2 - Draft（草案阶段） Stage 3 - Candidate（候选人阶段） Stage 4 - Finished（定案阶段） 一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在这里查看 ecma262。关于提案流程可以在这里 TC39_Process 看到更加详细的信息。 ES2015 声明const：声明一个常量，let：声明一个变量；const/let 声明的常量/变量都只能作用于代码块（块级作用域或函数作用域）里； 1234if (true) &#123; let name = &#x27;布兰&#x27;&#125;console.log(name) // undefined const/let 不存在变量提升，所以在代码块里必须先声明然后才可以使用，这叫暂时性死区； 123456let name = &#x27;bubuzou&#x27;if (true) &#123; name = &#x27;布兰&#x27; let name&#125;console.log(name) const/let 不允许在同一个作用域内，重复声明； 123function setName(name) &#123; let name = &#x27;&#x27; // SyntaxError&#125; const 声明时必须初始化，且后期不能被修改，但如果初始化的是一个对象，那么不能修改的是该对象的内存地址； 123456const person = &#123; name: &#x27;布兰&#x27;&#125;person.name = &#x27;bubuzou&#x27; console.log(person.name) // &#x27;bubuzou&#x27;person = &#x27;&#x27; // TypeError const/let 在全局作用域中声明的常量/变量不会挂到顶层对象（浏览器中是 window ）的属性中； 1234var name = &#x27;布兰&#x27;let age = 12console.log(window.name) // &#x27;布兰&#x27;console.log(window.age) // undefined 解构赋值解构类型： 字符串解构 12let [a, b, c = &#x27;c&#x27;] = &#x27;12&#x27;console.log(a, b, c) // &#x27;1&#x27; &#x27;2&#x27; &#x27;c&#x27; 数值解构 12let &#123;toFixed: tf&#125; = 10console.log( tf.call(Math.PI, 2) ) // 3.14 布尔值解构 12let &#123;toString: ts&#125; = trueconsole.log( ts.call(false) ) // &#x27;false&#x27; 数组解构：等号右侧的数据具有 Iterator 接口可以进行数组形式的解构赋值； 1234567// 解构不成功的变量值为 undefinedlet [a, b, c] = [1, 2]console.log(a, b, c) // 1, 2, undefined// 可以设置默认值let [x, y, z = 3] = [1, 2, null]console.log(x, y, z) // 1, 2, null 什么样的数据具有 Iterator 接口呢？如果一个对象能够通过 [Symbol.iterator] 访问，且能够返回一个符合迭代器协议的对象，那么该对象就是可迭代的。目前内置的可迭代对象有：String、Array、TypeArray、Map、Set、arguments 和 NodeList 等。 对象解构：与数组按照索引位置进行解构不同，对象解构是按照属性名进行解构赋值，如果在当前对象属性匹配不成功则会去对象的原型属性上查找： 12// 默认写法let &#123; name: name, age: age &#125; = &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 12// 简写let &#123; name, age &#125; = &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 123// 改名且设置默认值let &#123; name: name1, age: age1 = 12 &#125; = &#123; name: &#x27;布兰&#x27; &#125;console.log(name1, age1) // &#x27;布兰&#x27; 12 函数参数解构：其实就是运用上面的对象解构和数组解构规则； 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; console.log([x, y]) return [x, y];&#125;move(&#123;x: 3, y: 8&#125;) // [3, 8]move(&#123;x: 3&#125;) // [3, 0]move(&#123;&#125;) // [0, 0]move() // [0, 0] 解构要点： 只要等号两边的模式相同（同是对象或同是数组），则左边的变量会被赋予对应的值； 解构不成功的变量值为 undefined； 默认值生效的前提是当等号右边对应的值全等于 undefined 的时候； 只要等号右边的值不是对象或者数组，则会进行自动装箱将其转成对象； null 和 undefined 都无法转成对象，所以无法解构。 解构应用： 交换变量的值； 123let x = 1, y = 2;[x, y] = [y, x]console.log(x, y) // 2 1 通过函数返回对象属性 1234567function getParams() &#123; return &#123; name: &#x27;布兰&#x27;, age: 12, &#125;&#125;let &#123;name, age&#125; = getParams() 通过定义函数参数来声明变量 12345678910111213let person = &#123; name: &#x27;布兰&#x27;, age: 12&#125;init(person)// 普通用法function init(person) &#123; let &#123;name, age&#125; = person&#125;// 更简洁用法function init(&#123;name, age&#125;) &#123;&#125; 指定函数参数默认值 12345function initPerson(&#123;name = &#x27;布兰&#x27;, age = 12&#125; = &#123;&#125;) &#123; console.log(name, age)&#125;initPerson() // &#x27;布兰&#x27; 12initPerson(&#123;age: 20&#125;) // &#x27;布兰&#x27; 20 提取 JSON 数据 1234567let responseData = &#123; code: 1000, data: &#123;&#125;, message: &#x27;success&#x27;&#125;let &#123; code, data = &#123;&#125; &#125; = responseData 遍历 Map 结构 1234567let map = new Map()map.set(&#x27;beijing&#x27;, &#x27;北京&#x27;)map.set(&#x27;xiamen&#x27;, &#x27;厦门&#x27;)for (let [key, value] of map) &#123; console.log(key, value)&#125; 输入模块的指定方法和属性 1const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;) 字符串扩展 可以使用 Unicode 编码来表示一个字符： 123456// 以下写法都可以用来表示字符 z&#x27;\\z&#x27; // 转义&#x27;\\172&#x27; // 十进制表示法&#x27;\\x7A&#x27; // 十六进制表示法&#x27;\\u007A&#x27; // Unicode 普通表示法&#x27;\\u&#123;7A&#125;&#x27; // Unicode 大括号表示法 www.52unicode.com 这个网站可以查询到常见符号的 Unicode 编码。 可以使用 for...of 正确遍历字符串： 1234567let str = &#x27;😀🤣😜😍🤗🤔&#x27;for (const emoji of str) &#123; console.log(emoji) // 😀🤣😜😍🤗🤔&#125;for(let i = 0, l = str.length; i &lt; l; i++) &#123; console.log(str[i]) // 不能正确输出表情&#125; 模板字符串使用两个反引号标识（``），可以用来定义多行字符串，或者使用它在字符串中插入变量： 1234let name = &#x27;hero&#x27;let tips = `Hello $&#123;name&#125;, welcome to my world.`alert( tips ) 标签模板：在函数名后面接一个模板字符串相当于给函数传入了参数进行调用： 12345678let name = &#x27;布兰&#x27;, age = 12;let tips = parse`Hello $&#123;name&#125;, are you $&#123;age&#125; years old this year?`function parse(stringArr, ...variable) &#123; &#125;// 相当于传递如下参数进行调用 parse 函数parse([&quot;Hello &quot;, &quot;, are you &quot;, &quot; years old this year?&quot;], name, age) String.fromCodePoint() 用于从 Unicode 码点返回对应字符，可以支持 0xFFFF 的码点： 12String.fromCharCode(0x1f600) // &quot;&quot;String.fromCodePoint(0x1f600) // &quot;😀&quot; String.raw() 返回把字符串所有变量替换且对斜杠进行转义的结果： 1String.raw`Hi\\n$&#123;2+3&#125;!` // &quot;Hi\\n5!&quot; codePointAt() 返回字符的十进制码点，对于 Unicode 大于 0xFFFF 的字符，会被认为是2个字符，十进制码点转成十六进制可以使用 toString(16)： 123456let emoji = &#x27;🤣&#x27;emoji.length // 2emoji.charCodeAt(0).toString(16) // &#x27;d83d&#x27;emoji.charCodeAt(1).toString(16) // &#x27;de00&#x27;String.fromCodePoint(0xd83d, 0xde00) === &#x27;🤣&#x27; // true normalize() 方法会按照指定的一种 Unicode 正规形式将当前字符串正规化。（如果该值不是字符串，则首先将其转换为一个字符串）： 12345678let str1 = &#x27;\\u00F1&#x27;let str2 = &#x27;\\u006E\\u0303&#x27;str1 // ñstr2 // ñstr1 === str2 // falsestr1.length === str2.length // falsestr1.normalize() === str2.normalize() // true 字符串是否包含子串： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = &#x27;Hello world!&#x27;s.includes(&#x27;o&#x27;) // trues.startsWith(&#x27;Hello&#x27;) // trues.endsWith(&#x27;!&#x27;) // true 这三个方法都支持第二个参数，表示开始搜索的位置： 12345let s = &#x27;Hello world!&#x27;s.includes(&#x27;Hello&#x27;, 6) // falses.startsWith(&#x27;world&#x27;, 6) // trues.endsWith(&#x27;Hello&#x27;, 5) // true 上面代码表示，使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。 repeat(n) 将当前字符串重复 n 次后，返回一个新字符串： 12345678&#x27;x&#x27;.repeat(2) // &#x27;xx&#x27;&#x27;x&#x27;.repeat(1.9) // &#x27;x&#x27;&#x27;x&#x27;.repeat(NaN) // &#x27;&#x27;&#x27;x&#x27;.repeat(undefined) // &#x27;&#x27;&#x27;x&#x27;.repeat(&#x27;2a&#x27;) // &#x27;&#x27;&#x27;x&#x27;.repeat(-0.6) // &#x27;&#x27;，解释：0 ~ 1 之间的小数相当于 0&#x27;x&#x27;.repeat(-2) // RangeError&#x27;x&#x27;.repeat(Infinity) // RangeError 数值扩展 二进制（0b）和八进制（0o）表示法： 12345let num = 100let b = num.toString(2) // 二进制的100：1100100let o = num.toString(8) // 八进制的100：1440b1100100 === 100 // true0o144 === 100 // true Number.isFinite() 判断一个数是否是有限的数，入参如果不是数值一律返回 false： 12345Number.isFinite(-2.9) // trueNumber.isFinite(NaN) // falseNumber.isFinite(&#x27;&#x27;) // falseNumber.isFinite(false) // trueNumber.isFinite(Infinity) // false Number.isNaN() 判断一个数值是否为 NaN，如果入参不是 NaN 那结果都是 false： 123Number.isNaN(NaN) // trueNumber.isFinite(&#x27;a&#x27;/0) // trueNumber.isFinite(&#x27;NaN&#x27;) // false 数值转化：Number.parseInt() 和 Number.parseFloat()，非严格转化，从左到右解析字符串，遇到非数字就停止解析，并且把解析的数字返回： 1234parseInt(&#x27;12a&#x27;) // 12parseInt(&#x27;a12&#x27;) // NaNparseInt(&#x27;&#x27;) // NaNparseInt(&#x27;0xA&#x27;) // 10，0x开头的将会被当成十六进制数 parseInt() 默认是用十进制去解析字符串的，其实他是支持传入第二个参数的，表示要以多少进制的 基数去解析第一个参数： 12parseInt(&#x27;1010&#x27;, 2) // 10parseInt(&#x27;ff&#x27;, 16) // 255 参考：parseInt Number.isInteger() 判断一个数值是否为整数，入参为非数值则一定返回 false： 1234567Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger() // falseNumber.isInteger(null) // falseNumber.isInteger(&#x27;15&#x27;) // falseNumber.isInteger(true) // falseNumber.isInteger(3.0000000000000002) // true 如果对数据精度的要求较高，不建议使用 Number.isInteger() 判断一个数值是否为整数。 Number.EPSILON 表示一个可接受的最小误差范围，通常用于浮点数运算： 120.1 + 0.2 === 0.3 // falseMath.abs(0.1 + 0.2 - 0.3) &lt; Number.EPSILON // true Number.isSafeInteger() 用来判断一个数是否在最大安全整数（Number.MAX_SAFE_INTEGER）和最小安全整数（Number.MIN_SAFE_INTEGER）之间： 123456Number.MAX_SAFE_INTEGER === 2 ** 53 -1 // trueNumber.MAX_SAFE_INTEGER === 9007199254740991 // trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // trueNumber.isSafeInteger(2) // trueNumber.isSafeInteger(&#x27;2&#x27;) // falseNumber.isSafeInteger(Infinity) // false Math.trunc()：返回数值整数部分 Math.sign()：返回数值类型(正数 1、负数 -1、零 0) Math.cbrt()：返回数值立方根 Math.clz32()：返回数值的 32 位无符号整数形式 Math.imul()：返回两个数值相乘 Math.fround()：返回数值的 32 位单精度浮点数形式 Math.hypot()：返回所有数值平方和的平方根 Math.expm1()：返回 e^n - 1 Math.log1p()：返回 1 + n 的自然对数(Math.log(1 + n)) Math.log10()：返回以 10 为底的 n 的对数 Math.log2()：返回以 2 为底的n的对数 Math.sinh()：返回 n 的双曲正弦 Math.cosh()：返回 n 的双曲余弦 Math.tanh()：返回 n 的双曲正切 Math.asinh()：返回 n 的反双曲正弦 Math.acosh()：返回 n 的反双曲余弦 Math.atanh()：返回 n 的反双曲正切 数组扩展 数组扩展运算符（…）将数组展开成用逗号分隔的参数序列，只能展开一层数组： 123456789101112131415// 应用一：函数传参Math.max(...[1, 2, 3]) // 3// 应用二：数组合并let merge = [...[1, 2], ...[3, 4], 5, 6] // 1, 2, 3, 4, 5, 6// 应用三：浅克隆let a = [1, 2, 3]let clone = [...a]a === clone // false// 应用四：数组解构const [x, ...y] = [1, 2, 3]x // 1y // [2, 3] Array.from() 可以将类数组对象（ NodeList，arguments）和可迭代对象转成数组： 123456789101112// 应用一：字符串转数组Array.from(&#x27;foo&#x27;) // [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]// 应用二：数组合并去重let merge = [...[1, 2], ...[2, 3]]Array.from(new Set(merge)) // [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]// 应用三：arguments 转数组function f() &#123; return Array.from(arguments)&#125;f(1, 2, 3) // [1, 2, 3] 如果 Array.from() 带第二个参数 mapFn，将对生成的新数组执行一次 map 操作： 12Array.from([1, 2, 3], (x) =&gt; x * x ) // [1, 4, 9]Array.from(&#123;length: 3&#125;, (v, i) =&gt; ++i) // [1, 2, 3] Array.of() 将一组参数转成数组： 1234567Array.of(1, 2, 3) // [1, 2, 3]// 类似于function arrayOf(...params)&#123; return [].slice.call(params)&#125;arrayOf(1, 2, 3) // [1, 2, 3] Array.copyWithin() 在当前数组内部，将制定位置的成员复制到其他位置（会覆盖原来位置的成员），最后返回一个新数组。接收 3 个参数，参数为负数表示右边开始计算： target（必选）：替换位置的索引； start（可选）：从该位置开始读取数据，默认为 0； end（可选）：从该位置结束读取数据（不包括该位置的数据），默认为原数组长度； 1234[1, 2, 3, 4, 5].copyWithin(-1) // [1, 2, 3, 4, 1][1, 2, 3, 4, 5].copyWithin(1) // [1, 1, 2, 3, 4][1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, -3, -1) // [3, 4, 3, 4, 5] 查找第一个出现的子成员：find() 和 findIndex()： 12345// 找出第一个偶数[1, 6, 9].find((val, index, arr) =&gt; val % 2 === 0) // 6// 找出第一个偶数的索引位置[1, 6, 9].findIndex((val, index, arr) =&gt; val % 2 === 0) // 1 fill() 使用给定的值来填充数组，有 3 个参数： value：填充值； start（可选），开始索引，默认为 0； end（可选）：结束索引，默认为数组长度，不包括该索引位置的值； 1234// 初始化空数组Array(3).fill(1) // [1, 1, 1][1, 2, 3, 4].fill(&#x27;a&#x27;, 2, 4) // [1, 2, &#x27;a&#x27;, &#x27;a&#x27;] 通过 keys()（键名）、entries()（键值）和 values()（键值对） 获取数组迭代器对象，可以被 for...of 迭代， 12345678910let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]for (let x of arr.keys()) &#123; console.log(x) // 1, 2, 3&#125;for (let v of arr.values()) &#123; console.log(v) // &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;&#125;for (let e of arr.entries()) &#123; console.log(e) // [0, &#x27;a&#x27;] [0, &#x27;b&#x27;] [0, &#x27;c&#x27;]&#125; 数组空位，是指数组没有值，比如：[,,]，而像这种 [undefined] 是不包含空位的。由于 ES6 之前的一些 API 对空位的处理规则很不一致，所以实际操作的时候应该尽量避免空位的出现，而为了改变这个现状，ES6 的 API 会默认将空位处理成 undefined： 12[...[1, , 3].values()] // [1, undefined, 3][1, , 3].findIndex(x =&gt; x === undefined) // 1 对象扩展 对象属性简写： 1234567891011121314let name = &#x27;布兰&#x27;let person = &#123; name, getName() &#123; return this.name &#125;&#125;// 等同于let person1 = &#123; name: &#x27;布兰&#x27;, getName: function() &#123; return this.name &#125;&#125; 属性名表达式：在用对象字面量定义对象的时候，允许通过属性名表达式来定义对象属性： 1234567let name = &#x27;name&#x27;, let person = &#123; [name]: &#x27;布兰&#x27;, [&#x27;get&#x27;+ name]()&#123; return this.name &#125;&#125; 方法的 name 属性，存在好几种情况，这里仅列出常见的几种： 情况一：普通对象方法的 name 属性直接返回方法名，函数声明亦是如此，函数表达式返回变量名： 12345let person = &#123; hi()&#123;&#125;&#125;person.hi.name // &#x27;hi&#x27; 情况二：构造函数的 name 为 anonymous： 1(new Function).name // &#x27;anonymous&#x27; 情况三：绑定函数的 name 将会在函数名前加上 bound： 12function foo() &#123;&#125; foo.bind(&#123;&#125;).name // &#x27;bound foo&#x27; 情况四：如果对象的方法使用了取值函数（getter）和存值函数（setter），则 name 属性不是在该方法上面，而是该方法的属性的描述对象的 get 和 set 属性上面： 12345678let o = &#123; get foo()&#123;&#125;, set foo(x)&#123;&#125; &#125;o.foo.name // TypeError: Cannot read property &#x27;name&#x27; of undefinedlet descriptor = Object.getOwnPropertyDescriptor(o, &quot;foo&quot;) descriptor.get.name // &quot;get foo&quot; descriptor.set.name // &quot;set foo&quot; 参考：function_name 属性的可枚举性 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。可以通过 Object.getOwnPropertyDescriptor() 来获取对象某个属性的描述： 12345678let person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;Object.getOwnPropertyDescriptor(person, &#x27;name&#x27;)// &#123;// configurable: true,// enumerable: true,// value: &quot;布兰&quot;,// writable: true,// &#125; 这里的 enumerable 就是对象某个属性的可枚举属性，如果某个属性的 enumerable 值为 false 则表示该属性不能被枚举，所以该属性会被如下 4 种操作忽略： for...in ：只遍历对象自身的和继承的可枚举的属性； Object.keys()：返回对象自身的所有可枚举的属性的键名； JSON.stringify()：只串行化对象自身的可枚举的属性； Object.assign()： 只拷贝对象自身的可枚举的属性。 12345678910111213141516let person = &#123; name: &#x27;布兰&#x27; &#125;Object.defineProperty(person, &#x27;age&#x27;, &#123; configurable: true, enumerable: false, value: 12, writable: true&#125;)person // &#123; name: &#x27;布兰&#x27;, age: 12 &#125;// 以下操作都将忽略 person 对象的 age 属性for (let x in person) &#123; console.log(x) // &#x27;name&#x27;&#125;Object.keys(person) // [&#x27;name&#x27;]JSON.stringify(person) // &#x27;&#123;&quot;name&quot;: &quot;布兰&quot;&#125;&#x27;Object.assign(&#123;&#125;, person) // &#123; name: &#x27;布兰&#x27; &#125; Reflect.ownKeys(obj)： 返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举： 12// 基于上面的代码Reflect.ownKeys(person) // [&#x27;name&#x27;, &#x27;age&#x27;] super 关键字，指向对象的原型对象，只能用于对象的方法中，其他地方将报错： 123456789101112131415161718192021let person = &#123; name: &#x27;布兰&#x27;, getName() &#123; return super.name &#125;&#125;Object.setPrototypeOf(person, &#123;name: &#x27;hello&#x27;&#125;)person.getName() // &#x27;hello&#x27;// 以下几种 super 的使用将报错const obj1 = &#123; foo: super.foo&#125;const obj2 = &#123; foo: () =&gt; super.foo&#125;const obj3 = &#123; foo: function () &#123; return super.foo &#125;&#125; Object.is() 用来判断两个值是否相等，表现基本和 === 一样，除了以下两种情况： 1234+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target），如果有同名属性，则后面的会直接替换前面的： 12345let target = &#123; a: 1 &#125;let source1 = &#123; a: 2, b: 3, d: &#123;e: 1, f: 2&#125; &#125;let source2 = &#123; a: 3, c: 4, d: &#123;g: 3&#125; &#125;Object.assign(target, source1, source2)target // &#123; a: 3, b: 3, c: 4, d: &#123;g: 3&#125; &#125; Object.assign() 实行的是浅拷贝，如果源对象某个属性是对象，那么拷贝的是这个对象的引用： 12345let target = &#123;a: &#123;b: 1&#125;&#125;let source = &#123;a: &#123;b: 2&#125;&#125;Object.assign(target, source)target.a.b = 3source.a.b // 3 __proto__ 属性是用来读取和设置当前对象的原型，而由于其下划线更多的是表面其是一个内部属性，所以建议不在正式场合使用它，而是用下面的 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 Object.setPrototypeOf() 用于设置对象原型，Object.getPrototypeOf() 用于读取对象原型： 123let person = &#123;name: &#x27;布兰&#x27;&#125;Object.setPrototypeOf(person, &#123;name: &#x27;动物&#x27;&#125;)Object.getPrototypeOf(person) // &#123;name: &#x27;动物&#x27;&#125; 正则扩展 RegExp 构造函数，允许首参为正则表达式，第二个参数为修饰符，如果有第二个参数，则修饰符以第二个为准： 12let reg = new RegExp(/xYz\\d+/gi, i)reg.flags // &#x27;i&#x27; 正则方法调用变更：字符串对象的 match()、replace()、search()、split() 内部调用转为调用 RegExp 实例对应的 RegExp.prototype[Symbol.方法]； u 修饰符：含义为 Unicode 模式，用来正确处理大于 \\uFFFF 的 Unicode 字符。也就是说，如果待匹配的字符串中可能包含有大于 \\uFFFF 的字符，就必须加上 u 修饰符，才能正确处理。 1234567891011// 加上 u 修饰符才能让 . 字符正确识别大于 \\uFFFF 的字符/^.$/.test(&#x27;🤣&#x27;) // false/^.$/u.test(&#x27;🤣&#x27;) // true// 大括号 Unicode 字符表示法必须加上 u 修饰符/\\u&#123;61&#125;/.test(&#x27;a&#x27;) // false/\\u&#123;61&#125;/u.test(&#x27;a&#x27;) // true// 有 u 修饰符，量词才能正确匹配大于 \\uFFFF 的字符 /🤣&#123;2&#125;/.test(&#x27;🤣🤣&#x27;) // false/🤣&#123;2&#125;/u.test(&#x27;🤣🤣&#x27;) // true RegExp.prototype.unicode 属性表示正则是否设置了 u 修饰符： 12/🤣/.unicode // false/🤣/u.unicode // true y 修饰符，与 g 修饰符类似也是全局匹配；不同的是 g 是剩余字符中匹配即可，而 y 则是必须在剩余的第一个字符开始匹配才行，所以 y 修饰符也叫黏连修饰符： 123456789let s = &#x27;aaa_aa_a&#x27;let r1 = /a+/glet r2 = /a+/yr1.exec(s) // [&quot;aaa&quot;]r2.exec(s) // [&quot;aaa&quot;]r1.exec(s) // [&quot;aa&quot;]r2.exec(s) // null RegExp.prototype.sticky 属性表示是否设置了 y 修饰符： 1/abc/y.sticky // true RegExp.prototype.flags 属性会返回当前正则的所有修饰符： 1/abc🤣/iuy.flags // &#x27;iuy&#x27; 函数扩展 函数参数默认值。参数不能有同名的，函数体内不能用 let 和 const 声明同参数名的变量： 1function printInfo(name = &#x27;布兰&#x27;, age = 12) &#123;&#125; 使用参数默认值的时候，参数不能有同名的： 12function f(x, x, y) &#123;&#125; // 不报错function f(x, x, y = 1) &#123;&#125; // 报错 函数体内不能用 let 和 const 声明同参数名的变量： 1234// 报错function f(x, y) &#123; let x = 0&#125; 函数的 length 属性会返回没有指定默认值的参数个数，且如果设置默认值的参数不是尾参数，则 length 不再计入后面的参数： 123(function f(x, y)&#123;&#125;).length // 2(function f(x, y = 1)&#123;&#125;).length // 1(function f(x = 1, y)&#123;&#125;).length // 0 剩余（rest） 参数（…变量名）的形式，用于获取函数的剩余参数，注意 rest 参数必须放在最后一个位置，可以很好的代替 arguments 对象： 1234567function f(x, ...y) &#123; console.log(x) // 1 for (let val of y) &#123; coonsole.log(val) // 2 3 &#125;&#125;f(1, 2, 3) 严格模式：只要函数参数使用了默认值、解构赋值或者扩展运算符，那么函数体内就不能显示的设定为严格模式，因为严格模式的作用范围包含了函数参数，而函数执行的顺序是先执行参数，然后再执行函数体，执行到函数体里的 use strict 的时候，那么此时因为函数参数已经执行完成了，那函数参数还要不要受到严格模式的限制呢？这就出现矛盾了。规避限制的办法有两个：设置全局的严格模式或者在函数体外在包一个立即执行函数并且声明严格模式： 1234567891011// 解法一&#x27;use strict&#x27;function f(x, y = 2) &#123; &#125;// 解法二let f = (function()&#123; &#x27;use strict&#x27; return function(x, y = 2) &#123;&#125;&#125;)() 箭头函数语法比函数表达式更简洁，并且没有自己的 this、arguments，不能用作构造函数和用作生成器。 几种箭头函数写法： 1234567let f1 = () =&gt; &#123;&#125; // 没有参数let f2 = (x) =&gt; &#123;&#125; // 1个参数let f3 = x =&gt; &#123;&#125; // 1个参数可以省略圆括号let f4 = (x, y) =&gt; &#123;&#125; // 2个参数以上必须加上圆括号let f5 = (x = 1, y = 2) =&gt; &#123;&#125; // 支持参数默认值let f6 = (x, ...y) =&gt; &#123;&#125; // 支持 rest 参数let f7 = (&#123;x = 1, y = 2&#125; = &#123;&#125;) // 支持参数解构 箭头函数没有自己的 this： 1234567function Person()&#123; this.age = 0 setInterval(() =&gt; &#123; this.age++ &#125;, 1000)&#125;var p = new Person() // 1 秒后 Person &#123;age: 1&#125; 通过 call/apply 调用箭头函数的时候将不会绑定第一个参数的作用域： 12345678910111213141516let adder = &#123; base: 1, add: function(a) &#123; let f = v =&gt; v + this.base return f(a) &#125;, addThruCall: function(a) &#123; let f = v =&gt; v + this.base let b = &#123; base: 2 &#125; return f.call(b, a) &#125;&#125;adder.add(1) // 输出 2adder.addThruCall(1) // 仍然输出 2 箭头函数没有自己的 arguments 对象，不过可以使用 rest 参数代替： 12345678910let log = () =&gt; &#123; console.log(arguments) // ReferenceError&#125;log(2, 3)// 剩余参数代替写法let restLog = (...arr) =&gt; &#123; console.log(arr) // [2, 3]&#125;restLog(2, 3) 箭头函数不能用作构造器，和 new 一起用会抛出错误： 123let Foo = () =&gt; &#123;&#125;let foo = new Foo()// TypeError: Foo is not a constructor 箭头函数返回对象字面量，需要用圆括号包起来： 1let func2 = () =&gt; (&#123;foo: 1&#125;) 参考：Arrow_functions 尾调用和尾递归 首先得知道什么是尾调用：函数的最后一步调用另外一个函数： 123456789101112131415161718// 是尾调用function f(x) &#123; return g(x)&#125;// 以下都不是尾调用function f(x) &#123; let y = g(x) return y&#125;function f(x) &#123; let y = g(x) return g(x) + 1&#125;function f(x) &#123; g(x) // 因为最后一步是 return: undefined&#125; 尾调用有啥用？我们知道函数的相互调用是会生成“调用帧”的，而“调用帧”里存了各种信息比如函数的内部变量和调用函数的位置等，所有的“调用帧”组成了一个“调用栈”。如果在函数的最后一步操作调用了另外一个函数，因为外层函数里调用位置、内部变量等信息都不会再用到了，所有就无需保留外层函数的“调用帧”了，只要直接用内层函数的“调用帧”取代外层函数的“调用帧”即可： 123456789101112131415function f() &#123; let m = 1 let n = 2 return g(m + n)&#125;f()// 等同于function f() &#123; return g(3)&#125;f()// 等同于g(3) 这样一来就很明显的减少了调用栈中的帧数，内存占用就少了，所以这就是尾调用的优化作用。尾递归也是如此，递归如果次数多那就需要保留非常多的“调用帧”，所以经常会出现栈溢出错误，而使用了尾递归优化后就不会发生栈溢出的错误了： 12345678910111213// 常规递归的斐波那契函数function Fibonacci(n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125; return Fibonacci(n - 1) + Fibonacci(n - 2)&#125;Fibonacci(100) // 超时// 尾递归优化后的斐波那契函数function Fibonacci2(n, ac1 = 1, ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125; return Fibonacci2(n - 1, ac2, ac1 + ac2)&#125;sFibonacci2(100) // 573147844013817200000 Symbol Symbol 是一个新的原始类型，用来表示一个独一无二的值，可以通过 Symbol() 函数来创建一个 Symbol 类型的值，为了加以区分，可以传入一个字符串作为其描述： 123let s1 = Symbol(&#x27;foo&#x27;) let s2 = Symbol(&#x27;foo&#x27;)s1 === s2 // false Symbol 类型无法通过数学运算符进行隐式类型转换，但是可以通过 String() 显示转成字符串或者通过 Boolean() 显示转成布尔值： 1234let s = Symbol(&#x27;foo&#x27;)String(s) // &quot;Symbol(&#x27;foo&#x27;)&quot;s.toString() // &quot;Symbol(&#x27;foo&#x27;)&quot;Boolean(s) // true 引入 Symbol 最大的初衷其实就是为了让它作为对象的属性名而使用，这样就可以有效避免属性名的冲突了： 1234567let foo = Symbol(&#x27;foo&#x27;)let obj = &#123; [foo]: &#x27;foo1&#x27;, foo: &#x27;foo2&#x27;&#125;obj[foo] // &#x27;foo1&#x27;obj.foo // &#x27;foo2&#x27; Symbol 属性的不可枚举性，不会被 for...in、for...of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 等枚举： 12345678910let person = &#123; name: &#x27;布兰&#x27;, [Symbol(&#x27;age&#x27;)]: 12,&#125;for (let x in person) &#123; console.log(x) // &#x27;name&#x27;&#125;Object.keys(person) // [&#x27;name&#x27;]Object.getOwnPropertyNames(person) // [&#x27;name&#x27;]JSON.stringify(person) // &#x27;&#123;&quot;name&quot;:&quot;布兰&quot;&#125;&#x27; 但是可以通过 Object.getOwnPropertySymbols() 获取到对象的所有 Symbol 属性名，返回一个数组： 12// 基于上面的代码Object.getOwnPropertySymbols(person) // [Symbol(age)] 静态方法： Symbol.for() 按照描述去全局查找 Symbol，找不到则在全局登记一个： 123let s1 = Symbol.for(&#x27;foo&#x27;)let s2 = Symbol.for(&#x27;foo&#x27;)s1 === s2 // true Symbol.for() 的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。 Symbol.keyFor() 根据已经在全局登记的 Symbol 查找其描述： 12let s = Symbol.for(&#x27;foo&#x27;)Symbol.keyFor(s) // &#x27;foo&#x27; Symbol 的内置值： Symbol.hasInstance：指向一个内部方法，当其他对象使用 instanceof 运算符判断是否为此对象的实例时会调用此方法； Symbol.isConcatSpreadable：指向一个布尔，定义对象用于 Array.prototype.concat() 时是否可展开； Symbol.species：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数； Symbol.match：指向一个函数，当实例对象被 String.prototype.match() 调用时会重新定义match()的行为； Symbol.replace：指向一个函数，当实例对象被 String.prototype.replace() 调用时会重新定义 replace() 的行为； Symbol.search：指向一个函数，当实例对象被 String.prototype.search() 调用时会重新定义 search() 的行为；s Symbol.split：指向一个函数，当实例对象被 String.prototype.split() 调用时会重新定义 split() 的行为； Symbol.iterator：指向一个默认遍历器方法，当实例对象执行 for...of 时会调用指定的默认遍历器； Symbol.toPrimitive：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值； Symbol.toStringTag：指向一个函数，当实例对象被 Object.prototype.toString() 调用时其返回值会出现在 toString() 返回的字符串之中表示对象的类型； Symbol.unscopables：指向一个对象，指定使用 with 时哪些属性会被 with 环境排除； Set Set 是一种新的数据结构，类似数组，但是它没有键只有值，且值都是唯一的。可以通过构造函数生成一个新实例，接收一个数组或者可迭代数据结构作为参数： 12new Set([1, 2, 3]) // Set &#123;1, 2, 3&#125;new Set(&#x27;abc&#x27;) // Set &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125; Set 判断两个值是不是相等用的是 sameValueZero 算法，类似于 ===，唯一的区别是，在 Set 里 NaN 之间被认为是相等的： 123456let set = new Set()let a = NaNlet b = NaNset.add(a)set.add(b)set.size // 1 相同对象的不同实例也被 Set 认为是不相等的： 123456let set = new Set()let a = &#123;a: 1&#125;let b = &#123;a: 1&#125;set.add(a)set.add(b)set.size // 2 Set 是有顺序的，将按照插入的顺序进行迭代，可以使用 for...of 迭代： 123456let set = new Set([1, 3])set.add(5)set.add(7)for(let x of set) &#123; console.log(x)&#125; Set 实例属性和方法： Set.prototype.constructor：构造函数，默认就是 Set 函数； Set.prototype.size：返回 Set 实例的成员总数； Set.prototype.add(value)：添加某个值，返回 Set 结构本身； Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功； Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员； Set.prototype.clear()：清除所有成员，没有返回值； Set.prototype.keys()：返回键名的遍历器； Set.prototype.values()：返回键值的遍历器； Set.prototype.entries()：返回键值对的遍历器； Set.prototype.forEach()：使用回调函数遍历每个成员； 12345678let set = new Set([1, 3])set.add(5) // Set &#123;1, 3, 5&#125;set.size // 3set.delete(1) // true，1 已被删除set.has(1) // falseset.keys() // SetIterator &#123;3, 5&#125;set.clear()set.size // 0 Set 应用场景： 数组去重： 12[...new Set([1, 3, 6, 3, 1])] // [1, 3, 6]Array.from(new Set([1, 3, 6, 3, 1])) // [1, 3, 6] 字符串去重： 1[...new Set(&#x27;abcbacd&#x27;)].join(&#x27;&#x27;) // &#x27;abcd&#x27; 求两个集合的交集/并集/差集： 1234567891011let a = new Set([1, 2, 3])let b = new Set([4, 3, 2])// 并集let union = new Set([...a, ...b]) // Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x))) // set &#123;2, 3&#125;// （a 相对于 b 的）差集let difference = new Set([...a].filter(x =&gt; !b.has(x))) // Set &#123;1&#125; 遍历修改集合成员的值： 1234567let set = new Set([1, 2, 3])// 方法一let set1 = new Set([...set].map(val =&gt; val * 2)) // Set &#123;2, 3, 6&#125;// 方法二let set2 = new Set(Array.from(set, val =&gt; val * 2)) // Set &#123;2, 4, 6&#125; WeakSet WeakSet 对象允许将弱保持对象存储在一个集合中： 12345let ws = new WeakSet()let foo = &#123;&#125;ws.add(foo) // WeakSet &#123;&#123;&#125;&#125;ws.has(foo) // truews.delete(foo) // WeakSet &#123;&#125; 和 Set 的区别： WeakSet 只能是对象的集合，而不能是任何类型的任意值； WeakSet 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 WeakSet 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 WeakSet 中没有存储当前对象的列表。正因为这样，WeakSet 是不可枚举的，也就没有 size 属性，没有 clear 和遍历的方法。 实例方法： WeakSet.prototype.add(value)：添加一个新元素 value； WeakSet.prototype.delete(value)：从该 WeakSet 对象中删除 value 这个元素； WeakSet.prototype.has(value)：返回一个布尔值, 表示给定的值 value 是否存在于这个 WeakSet 中； Map Map 是一种类似于 Object 的这种键值对的数据结构，区别是对象的键只能是字符串或者 Symbol，而 Map 的键可以是任何类型（原始类型、对象或者函数），可以通过 Map 构造函数创建一个实例，入参是具有 Iterator 接口且每个成员都是一个双元素数组 [key, value] 的数据结构： 12345let map1 = new Map()map1.set(&#123;&#125;, &#x27;foo&#x27;)let arr = [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]let map2 = new Map(arr) Map 中的键和 Set 里的值一样也必须是唯一的，遵循 sameValueZero 算法，对于同一个键后面插入的会覆盖前面的， 12345let map = new Map()let foo = &#123;foo: &#x27;foo&#x27;&#125;map.set(foo, &#x27;foo1&#x27;)map.set(foo, &#x27;foo2&#x27;)map.get(foo) // &#x27;foo2&#x27; 对于键名同为 NaN 以及相同对象而不同实例的处理同 Set 的值一样： 1234567891011121314let a = NaNlet b = NaNlet map = new Map()map.set(a, &#x27;a&#x27;)map.set(b, &#x27;b&#x27;)map.size // 1map.get(a) // &#x27;b&#x27;let c = &#123;c: &#x27;c&#x27;&#125;let d = &#123;c: &#x27;c&#x27;&#125;map.set(c, &#x27;c&#x27;)map.set(d, &#x27;d&#x27;)map.size // 3map.get(c) // &#x27;c&#x27; 实例属性和方法： Map.prototype.size：返回 Map 对象的键值对数量； Map.prototype.set(key, value)：设置 Map 对象中键的值。返回该 Map 对象； Map.prototype.get(key)： 返回键对应的值，如果不存在，则返回 undefined； Map.prototype.has(key)：返回一个布尔值，表示 Map 实例是否包含键对应的值； Map.prototype.delete(key)： 如果 Map 对象中存在该元素，则移除它并返回 true； Map.prototype.clear()： 移除 Map 对象的所有键/值对； Map.prototype.keys()：返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键； Map.prototype.values()：返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值； Map.prototype.entries()：返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组； Map.prototype.forEach(callbackFn[, thisArg])：按插入顺序遍历 Map； 123456789101112131415let map = new Map()map.set(&#123;a: 1&#125;, &#x27;a&#x27;)map.set(&#123;a: 2&#125;, &#x27;b&#x27;)for (let [key, value] of map) &#123; console.log(key, value)&#125;// &#123;a: 1&#125; &#x27;a&#x27;// &#123;a: 2&#125; &#x27;b&#x27;for (let key of map.keys()) &#123; console.log(key)&#125;// &#123;a: 1&#125;// &#123;a: 2&#125; WeakMap 类似于 Map 的结构，但是键必须是对象的弱引用，注意弱引用的是键名而不是键值，因而 WeakMap 是不能被迭代的； 12345let wm = new WeakMap()let foo = &#123;name: &#x27;foo&#x27;&#125;wm.set(foo, &#x27;a&#x27;) // Weakwm.get(foo) // &#x27;a&#x27;wm.has(foo) // true 虽然 wm 的键对 foo 对象有引用，但是丝毫不会阻止 foo 对象被 GC 回收。当引用对象 foo 被垃圾回收之后，wm 的 foo 键值对也会自动移除，所以不用手动删除引用。 实例方法： WeakMap.prototype.delete(key)：移除 key 的关联对象； WeakMap.prototype.get(key)：返回key关联对象, 或者 undefined(没有key关联对象时)； WeakMap.prototype.has(key)：根据是否有 key 关联对象返回一个 Boolean 值； WeakMap.prototype.set(key, value)：在 WeakMap 中设置一组 key 关联对象，返回这个 WeakMap 对象； Proxy Proxy 用来定义基本操作的的自定义行为，可以理解为当对目标对象 target 进行某个操作之前会先进行拦截（执行 handler 里定义的方法），必须要对 Proxy 实例进行操作才能触发拦截，对目标对象操作是不会拦截的，可以通过如下方式定义一个代理实例 12345678let proxy = new Proxy(target, handler)let instance = new Proxy(&#123;name: &#x27;布兰&#x27;&#125;, &#123; get(target, propKey, receiver) &#123; return `hello, $&#123;target.name&#125;` &#125;,&#125;)instance.name // &#x27;hello, 布兰&#x27; 如果 handle 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上： 1234let target = &#123;&#125;let proxy = new Proxy(target, &#123;&#125;)proxy.name = &#x27;布兰&#x27;target.name // &#x27;布兰&#x27; 目标对象被 Proxy 代理的时候，内部的 this 会指向代理的实例： 123456789const target = &#123; m: function () &#123; console.log(this === proxy) &#125;&#125;const handler = &#123;&#125;const proxy = new Proxy(target, handler)target.m() // falseproxy.m() // true 静态方法： Proxy.revocable() 用以定义一个可撤销的 Proxy： 12345678let target = &#123;&#125;let handler = &#123;&#125;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler)proxy.foo = 123proxy.foo // 123revoke()proxy.foo // TypeError handle 对象的方法： get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v或proxy[&#39;foo&#39;] = v，返回一个布尔值。 has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。 ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc)、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args)。 Reflect Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。 设计的目的： 将 Object 属于语言内部的方法放到 Reflect 上； 修改某些 Object 方法的返回结果，让其变得更合理； 让 Object 操作变成函数行为； Proxy handles 与 Reflect 方法一一对应，前者用于定义自定义行为，而后者用于恢复默认行为； 静态方法： Reflect.apply(target, thisArgument, argumentsList) 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似； Reflect.construct(target, argumentsList[, newTarget]) 对构造函数进行 new 操作，相当于执行 new target(...args)； Reflect.defineProperty(target, propertyKey, attributes) 和 Object.defineProperty() 类似。如果设置成功就会返回 true； Reflect.deleteProperty(target, propertyKey) 作为函数的 delete 操作符，相当于执行 delete target[name]； Reflect.get(target, propertyKey[, receiver]) 获取对象身上某个属性的值，类似于 target[name]； Reflect.getOwnPropertyDescriptor(target, propertyKey) 类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符, 否则返回 undefined； Reflect.getPrototypeOf(target) 类似于 Object.getPrototypeOf()； Reflect.has(target, propertyKey) 判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同； Reflect.isExtensible(target) 类似于 Object.isExtensible()； Reflect.ownKeys(target) 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受 enumerable 影响)； Reflect.preventExtensions(target) 类似于 Object.preventExtensions()。返回一个 Boolean； Reflect.set(target, propertyKey, value[, receiver]) 将值分配给属性的函数。返回一个 Boolean，如果更新成功，则返回 true； Reflect.setPrototypeOf(target, prototype) 设置对象原型的函数. 返回一个 Boolean， 如果更新成功，则返回 true； Class 可以用 class 关键字来定义一个类，类是对一类具有共同特征的事物的抽象，就比如可以把小狗定义为一个类，小狗有名字会叫也会跳；类是特殊的函数，就像函数定义的时候有函数声明和函数表达式一样，类的定义也有类声明和类表达式，不过类声明不同于函数声明，它是无法提升的；类也有 name 属性 123456789101112131415// 类声明class Dog &#123; constructor(name) &#123; this.name = name &#125; bark() &#123;&#125; jump() &#123;&#125;&#125;Dog.name // &#x27;Dog&#x27;// 类表达式：可以命名（类的 name 属性取类名），也可以不命名（类的 name 属性取变量名）let Animal2 = class &#123; // xxx&#125;Animal2.name // &#x27;Animal2&#x27; JS 中的类建立在原型的基础上（通过函数来模拟类，其实类就是构造函数的语法糖），和 ES5 中构造函数类似，但是也有区别，比如类的内部方法是不可被迭代的： 12345678910111213141516class Dog &#123; constructor() &#123;&#125; bark() &#123;&#125; jump() &#123;&#125;&#125;Object.keys(Dog.prototype) // []// 类似于function Dog2()&#123;&#125;Dog2.prototype = &#123; constructor() &#123;&#125;, bark() &#123;&#125;, jump() &#123;&#125;,&#125;Object.keys(Dog2.prototype) // [&#x27;constructor&#x27;, &#x27;bark&#x27;, &#x27;jump&#x27;] 基于原型给类添加新方法： 123Object.assign(Dog.prototype, &#123; wag() &#123;&#125; // 摇尾巴&#125;) 类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，getter和 setter 都在严格模式下执行。 类内部的 this 默认指向类实例，所以如果直接调用原型方法或者静态方法会导致 this 指向运行时的环境，而类内部是严格模式，所以此时的 this 会是 undefined： 12345678910111213141516class Dog &#123; constructor(name) &#123; this.name = name &#125; bark() &#123; console.log( `$&#123;this.name&#125; is bark.` ) &#125; static jump() &#123; console.log( `$&#123;this.name&#125; is jump.` ) &#125;&#125;let dog = new Dog(&#x27;大黄&#x27;)let &#123; bark &#125; = doglet &#123; jump &#125; = Dogbark() // TypeError: Cannot read property &#x27;name&#x27; of undefinedjump() // TypeError: Cannot read property &#x27;name&#x27; of undefined 方法和关键字： constructor 方法是类的默认方法，通过 new 关键字生成实例的时候，会自动调用；一个类必须有constructor 方法，如果没有显示定义，则会自动添加一个空的；constructor 默认会返回实例对象： 12345678910111213141516171819 class Point &#123;&#125; // 等同于 class Point &#123; constructor() &#123;&#125; &#125; ``` - 通过 `get` 和 `set` 关键字拦截某个属性的读写操作： ```js class Dog &#123; get age()&#123; return 1 &#125; set age(val)&#123; this.age = val &#125; &#125; 用 static 关键字给类定义静态方法，静态方法不会存在类的原型上，所以不能通过类实例调用，只能通过类名来调用，静态方法和原型方法可以同名： 12345678910111213class Dog &#123; bark() &#123;&#125; jump() &#123; console.log(&#x27;原型方法&#x27;) &#125; static jump() &#123; console.log(&#x27;静态方法&#x27;) &#125;&#125;Object.getOwnPropertyNames(Dog.prototype) // [&#x27;constructor&#x27;, &#x27;bark&#x27;, &#x27;jump&#x27;]Dog.jump() // &#x27;静态方法&#x27;let dog = new Dog()dog.jump() // &#x27;原型方法&#x27; 公有字段和私有字段： 静态公有字段和静态方法一样只能通过类名调用；私有属性和私有方法只能在类的内部调用，外部调用将报错： 1234567891011class Dog &#123; age = 12 // 公有字段 static sex = &#x27;male&#x27; // 静态公有字段 #secret = &#x27;我是人类的好朋友&#x27; // 私有字段 #getSecret() &#123; // 私有方法 return this.#secret &#125;&#125;Dog.sex // &#x27;male&#x27;let dog = new Dog()dog.#getSecret() // SyntaxError 公共和私有字段声明是 JavaScript 标准委员会 TC39 提出的实验性功能（第 3 阶段）。浏览器中的支持是有限的，但是可以通过 Babel 等系统构建后使用此功能。 new.target 属性允许你检测函数、构造方法或者类是否是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是 undefined，子类继承父类的时候会返回子类： 123456789101112class Dog &#123; constructor() &#123; console.log(new.target.name) &#125;&#125;function fn()&#123; if (!new.target) return &#x27;new target is undefined&#x27; console.log(&#x27;fn is called by new&#x27;)&#125;let dog = new Dog() // &#x27;Dog&#x27;fn() // &#x27;new target is undefined&#x27;new fn() // &#x27;fn is called by new&#x27; 类的继承： 类可以通过 extends 关键字实现继承，如果子类显示的定义了 constructor 则必须在内部调用 super() 方法，内部的 this 指向当前子类： 1234567891011121314151617181920class Animal &#123; constructor(name) &#123; this.name = name &#125; run() &#123; console.log(`$&#123;this.name&#125; is running.`) &#125;&#125; class Dog extends Animal&#123; constructor(name)&#123; super(name) // 必须调用 this.name = name &#125; bark() &#123; console.log(`$&#123;this.name&#125; is barking.`) &#125;&#125;let dog = new Dog(&#x27;大黄&#x27;)dog.run() // &#x27;大黄 is running.&#x27; 通过 super() 调用父类的构造函数或者通过 super 调用父类的原型方法；另外也可以在子类的静态方法里通过 super 调用父类的静态方法： 12345678910111213141516171819202122232425 // 基于上面的代码改造 class Dog extends Animal&#123; constructor(name)&#123; super(name) // 调用父类构造函数 this.name = name &#125; bark() &#123; super.run() // 调用父类原型方法 console.log(`$&#123;this.name&#125; is barking.`) &#125; &#125; let dog = new Dog() dog.bark()s // &#x27;大黄 is running.&#x27; // &#x27;大黄 is barking.&#x27; ``` - 子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类；子类 `prototype` 属性的 `__proto__` 属性，表示方法的继承，总是指向父类的prototype属性： ```js class Animal &#123;&#125; class Dog extends Animal &#123;&#125; Dog.__proto__ === Animal // true Dog.prototype.__proto__ === Animal.prototype // true 子类原型的原型指向父类的原型： 1234// 基于上面的代码let animal = new Animal()let dog = new Dog()dog.__proto__.__proto__ === animal.__proto__ // true 使用 extends 还可以实现继承原生的构造函数，如下这些构造函数都可以被继承： String() Number() Boolean() Array() Object() Function() Date() RegExp() Error() 12345678910111213class MyString extends String &#123; constructor(name)&#123; super(name) this.name = name &#125; welcome() &#123; return `hello $&#123;this.name&#125;` &#125;&#125;let ms = new MyString(&#x27;布兰&#x27;)ms.welcome() // &#x27;hello 布兰&#x27;ms.length // 2ms.indexOf(&#x27;兰&#x27;) // 1 Module 浏览器传统加载模块方式： 12345678// 同步加载&lt;script src=&quot;test.js&quot;&gt;&lt;/script&gt;// defer异步加载：顺序执行，文档解析完成后执行；&lt;script src=&quot;test.js&quot; defer&gt;&lt;/script&gt;// async异步加载：乱序加载，下载完就执行。&lt;script src=&quot;test.js&quot; async&gt;&lt;/script&gt; 浏览器现在可以按照模块（加上 type=&quot;module&quot;）来加载脚本，默认将按照 defer 的方式异步加载；ES6 的模块加载依赖于 import 和 export 这 2 个命令；模块内部自动采用严格模式： 12// 模块加载&lt;script type=&quot;module&quot; src=&quot;test.js&quot;&gt;&lt;/script&gt; export 用于输出模块的对外接口，一个模块内只能允许一个 export default 存在，以下是几种输出模块接口的写法： 12345678910111213141516// person.js// 写法一：单独导出export const name = &#x27;布兰&#x27;export const age = 12// 写法二：按需导出const name = &#x27;布兰&#x27;, age = 12export &#123; name, age &#125;// 写法三：重命名后导出const name = &#x27;布兰&#x27;, age = 12export &#123; name as name1, age as age1 &#125;// 写法四：默认导出const name = &#x27;布兰&#x27;export default name import 用于输入其他模块的接口： 1234567891011121314// 按需导入import &#123; name, age &#125; &#x27;./person.js&#x27;// 导入后重命名import &#123; name1 as name, age1 as age &#125; from &#x27;./person.js&#x27;// 默认导入import person from &#x27;./person.js&#x27;// 整体导入import * as person from &#x27;./person.js&#x27;// 混合导入import _, &#123; each &#125; from &#x27;lodash&#x27; import 导入的细节： 导入的变量名必须与导出模块的名字一致，可以使用 as 进行重命名； 导入的变量都是只读的，不能改写； import 命令具有提升效果，会提升到整个模块的头部，首先执行； import 是编译时导入，所以不能将其写到代码块（比如 if 判断块里）或者函数内部； import 会执行所加载的模块的代码，如果重复导入同一个模块则只会执行一次模块； import 和 export 的复合写法：export 和 import 语句可以结合在一起写成一行，相当于是在当前模块直接转发外部模块的接口，复合写法也支持用 as 重命名。以下例子中需要在 hub.js 模块中转发 person.js 的接口： 1234567891011121314151617// person.jsconst name = &#x27;布兰&#x27;, age = 12export &#123; name, age &#125;// 按需转发接口（中转模块：hub.js）export &#123; name, age &#125; from &#x27;./person.js&#x27;// 相当于import &#123; name, age &#125; from &#x27;./person.js&#x27;export &#123; name, age &#125;// person.jsconst name = &#x27;布兰&#x27;, age = 12export default &#123; name, age &#125;// 转发默认接口（中转模块：hub.js）export &#123; default &#125; from &#x27;./person.js&#x27;// 相当于import person from &#x27;./person.js&#x27;export default person ES6 模块和 CommonJS 模块的差异： CommonJS 模块输出的是一个值的拷贝（一旦输出一个值，模块内部的变化就影响不到这个值），ES6 模块输出的是值的引用（是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值）； CommonJS 模块是运行时加载，ES6 模块是编译时输出接口； CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段； Iterator和for…of Iterator 迭代器协议，为各种数据结构提供了一种统一按照某种顺序进行访问的机制。通常部署在一个可迭代数据结构内部或其原型上。一个对象要能够成为迭代器，它必须有一个 next() 方法，每次执行 next() 方法会返回一个对象，这个对象包含了一个 done 属性（是个布尔值，true 表示可以继续下次迭代）和一个 value 属性（每次迭代的值）： 123456789101112// 生成一个迭代器let makeIterator = (arr) =&gt; &#123; let index = 0 return &#123; next()&#123; return index &lt; arr.length ? &#123; value: arr[index++], done: false &#125; : &#123; done: true &#125; &#125; &#125;&#125; iterable 可迭代数据结构：内部或者原型上必须有一个 Symbol.iterator 属性（如果是异步的则是 Symbol.asyncIterator），这个属性是一个函数，执行后会生成一个迭代器： 1234567891011121314151617let obj = &#123; [Symbol.iterator]() &#123; return &#123; index: 0, next() &#123; if (this.index &lt; 3) &#123; return &#123;value: this.index++, done: false&#125; &#125; else &#123; return &#123;done: true&#125; &#125; &#125; &#125; &#125;&#125;for (let x of obj) &#123; console.log(x) // 0 1 2&#125; 内置的一些可迭代数据结构有：String、Array、TypedArray、Map 和 Set、arguments、NodeList： 12345let si = &#x27;hi&#x27;[Symbol.iterator]()si // StringIteratorsi.next() // &#123;value: &#x27;h&#x27;, done: false&#125;si.next() // &#123;value: &#x27;i&#x27;, done: false&#125;si.next() // &#123;value: undefined, done: true&#125; for...of：用于遍历可迭代数据结构： 遍历字符串：for...in 获取索引，for...of 获取值； 遍历数组：for...in 获取索引，for...of 获取值； 遍历对象：for...in 获取键，for...of 需自行部署 [Symbol.iterator] 接口； 遍历 Set：for...of 获取值， for (const v of set)； 遍历 Map：for...of 获取键值对，for (const [k, v] of map)； 遍历类数组：包含 length 的对象、arguments 对象、NodeList对象(无 Iterator 接口的类数组可用 Array.from() 转换)； 123456789101112131415161718192021// 迭代字符串for (let x of &#x27;abc&#x27;) &#123; console.log(x) // &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;&#125;// 迭代数组for (let x of [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]) &#123; console.log(x) // &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;&#125;// 遍历 Setlet set = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])for (let x of set) &#123; console.log(x) // &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;&#125;// 遍历 Maplet map = new Map([[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]])for (let [key, value] of map) &#123; console.log(key + &#x27;: &#x27; + value) // &#x27;name: 布兰&#x27; &#x27;age: 12&#x27; &#125; for...of 和 for...in 对比 共同点：能够通过 break、continue 和 return 跳出循环； 不同点： - `for...in` 的特点：只能遍历键，会遍历原型上属性，遍历无顺序，适合于对象的遍历； - `for...of` 的特点：能够遍历值（某些数据结构能遍历键和值，比如 `Map`），不会遍历原型上的键值，遍历顺序为数据的添加顺序，适用于遍历可迭代数据结构； PromisePromise 这块知识可以直接看我之前写的一篇文章：深入理解Promise 非常完整。 Generator function* 会定义一个生成器函数，调用生成器函数不会立即执行，而是会返回一个 Generator 对象，这个对象是符合可迭代协议和迭代器协议的，换句话说这个 Generator 是可以被迭代的。 生成器函数内部通过 yield 来控制暂停，而 next() 将把它恢复执行，它的运行逻辑是如下这样的： 遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值作为返回的对象的 value 属性值； 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式； 如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值； 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined； 123456789function* gen() &#123; yield &#x27;hello&#x27; yield &#x27;world&#x27; return &#x27;end&#x27;&#125;let g = gen()g.next() // &#123;value: &#x27;hello&#x27;, done: false&#125;g.next() // &#123;value: &#x27;world&#x27;, done: false&#125;g.next() // &#123;value: &#x27;end&#x27;, done: true&#125; 在生成器函数内部可以使用 yield* 表达式委托给另一个 Generator 或可迭代对象，比如数组、字符串等；yield* 表达式本身的值是当迭代器关闭时返回的值（即 done 为 true 时）： 123456789101112function* inner() &#123; yield* [1, 2] return &#x27;foo&#x27;&#125;function* gen() &#123; let result = yield* inner() console.log(result)&#125;let g = gen()g.next()g.next()g.next() 实例方法： Generator.prototype.next()：返回一个包含属性 done 和 value 的对象。该方法也可以通过接受一个参数用以向生成器传值。如果传入了参数，那么这个参数会传给上一条执行的 yield 语句左边的变量： 123456789101112131415function* f() &#123; let a = yield 12 console.log(a) let b = yield a console.log(b)&#125;let g = f()console.log(g.next(&#x27;a&#x27;))console.log(g.next(&#x27;b&#x27;))console.log(g.next(&#x27;c&#x27;))// &#123;value: 12, done: false&#125;// &#x27;b&#x27;// &#123;value: &#x27;b&#x27;, done: false&#125;// &#x27;c&#x27;// &#123;value: undefined, done: true&#125; Generator.prototype.throw()：用来向生成器抛出异常，如果内部捕获了则会恢复生成器的执行（即执行下一条 yield 表达式），并且返回带有 done 及 value 两个属性的对象： 1234567891011121314151617function* gen() &#123; try &#123; yield &#x27;a&#x27; &#125; catch(e) &#123; console.log(e) &#125; yiele &#x27;b&#x27; yield &#x27;c&#x27;&#125;let g = gen()g.next()g.throw(&#x27;error a&#x27;)g.next()// &#123;value: &quot;a&quot;, done: false&#125;// &#x27;error a&#x27; // &#123;value: &quot;b&quot;, done: false&#125;// &#123;value: &quot;c&quot;, done: false&#125; 如果内部没有捕获异常，将中断内部代码的继续执行（类似 throw 抛出的异常，如果没有捕获，则后面的代码将不会执行），此时异常会抛到外部，可以被外部的 try...catch 块捕获，此时如果再执行一次 next()，会返回一个值为 done 属性为 true 的对象： 12345678910111213141516function* gen() &#123; yield &#x27;a&#x27; yield &#x27;b&#x27; yield &#x27;c&#x27;&#125;let g = gen()g.next()try &#123; g.throw(&#x27;error a&#x27;)&#125; catch(e) &#123; console.log(e)&#125;g.next()// &#123;value: &quot;a&quot;, done: false&#125;// &#x27;error a&#x27;// &#123;value: undefined, done: true&#125; Generator.prototype.return()：返回给定的值并结束生成器： 123456789function* gen() &#123; yield 1 yield 2 yield 3&#125; let g = gen()g.next() // &#123; value: 1, done: false &#125;g.return(&#x27;foo&#x27;) // &#123; value: &quot;foo&quot;, done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 应用： 将异步操作同步化，比如同时有多个请求，多个请求之间是有顺序的，只能等前面的请求完成了才请求后面的： 12345678910111213141516function* main() &#123; let res1 = yield request(&#x27;a&#x27;) console.log(res1) let res2 = yield request(&#x27;b&#x27;) console.log(res2) let res3 = yield request(&#x27;c&#x27;) console.log(res3)&#125;function request(url) &#123; setTimeout(function()&#123; // 模拟异步请求 it.next(url) &#125;, 300)&#125;let it = main()it.next()// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; 给对象部署 Iterator 接口： 12345678910111213function* iterEntries(obj) &#123; let keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; let key = keys[i] yield [key, obj[key]] &#125;&#125;let obj = &#123; foo: 3, bar: 7 &#125;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value)&#125;// &#x27;foo&#x27; 3// &#x27;bar&#x27; 7 ES2016 Array.prototype.includes判断一个数组是否包含某个元素，之前一般是这么做的： 1234if (arr.indexOf(el) &gt;= 0) &#123;&#125;// 或者if (~arr.indexOf(el)) &#123;&#125; 而现在你可以这么做了： 1if (arr.includes(el)) &#123;&#125; indexOf 会返回找到元素在数组中的索引位置，判断的逻辑是是否严格相等，所以他在遇到 NaN 的时候不能正确返回索引，但是 includes 解决了这个问题： 12[1, NaN, 3].indexOf(NaN) // -1[1, NaN, 3].includes(NaN) // true 求幂运算符（**）x ** y 是求 x 的 y 次幂，和 Math.pow(x, y) 功能一致： 123// x ** ylet squared = 2 ** 2 // 2 * 2 = 4let cubed = 2 ** 3 // 2 * 2 * 2 = 8 x **= y 表示求 x 的 y 次幂，并且把结果赋值给 x： 123// x **= ylet x = 2;x **= 3 // x 最后等于 8 ES2017 Object.values()返回一个由对象自身所有可遍历属性的属性值组成的数组： 123456789const person = &#123; name: &#x27;布兰&#x27; &#125;;Object.defineProperty(person, &#x27;age&#x27;, &#123; value: 12, enumrable: false // age 属性将不可遍历&#125;)console.log(Object.values(person)) // [&#x27;布兰&#x27;]// 类似 str.split(&#x27;&#x27;) 效果console.log(Object.values(&#x27;abc&#x27;)) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] Object.entries()返回一个由对象自身所有可遍历属性的键值对组成的数组： 12const person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;console.log(Object.entries(person)) // [[&quot;name&quot;, &quot;布兰&quot;], [&quot;age&quot;, 12]] 利用这个方法可以很好的将对象转成正在的 Map 结构： 123const person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;const map = new Map(Object.entries(person))console.log(map) // Map &#123; name: &#x27;布兰&#x27;, age: 12 &#125; Object.getOwnPropertyDescriptors()Object.getOwnPropertyDescriptor() 会返回指定对象某个自身属性的的描述对象，而 Object.getOwnPropertyDescriptors() 则是返回指定对象自身所有属性的描述对象： 12345678910const person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;console.log(Object.getOwnPropertyDescriptor(person, &#x27;name&#x27;))// &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;console.log(Object.getOwnPropertyDescriptors(person))//&#123; // name: &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;,// age: &#123;configurable: false, enumerable: false, value: 12, writable: false&#125;//&#125; 配合 Object.create() 可以实现浅克隆： 1234const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) String.prototype.padStart()str.padStart(length [, padStr]) 会返回一个新字符串，该字符串将从 str 字符串的左侧开始填充某个字符串 padStr（非必填，如果不是字符串则会转成字符串, 传入 undefined 和不传这个参数效果一致）直到达到指定位数 length 为止： 12345&#x27;abc&#x27;.padStart(5, 2) // &#x27;22abc&#x27;&#x27;abc&#x27;.padStart(5, undefined) // &#x27; abc&#x27;&#x27;abc&#x27;.padStart(5, &#123;&#125;) // &#x27;[oabc&#x27;&#x27;abc&#x27;.padStart(5) // &#x27; abc&#x27;&#x27;abcde&#x27;.padStart(2, &#x27;f&#x27;) // &#x27;abcde&#x27; String.prototype.padEnd()规则和 padStart 类似，但是是从字符串右侧开始填充： 1&#x27;abc&#x27;.padEnd(5, 2) // &#x27;abc22&#x27; 函数参数尾逗号允许函数在定义和调用的时候时候最后一个参数后加上逗号： 123456function init( param1, param2, ) &#123; &#125;init(&#x27;a&#x27;, &#x27;b&#x27;,) Async函数 使用 async 可以声明一个 async 函数，结合 await 可以用一种很简介的方法写成基于 Promise 的异步行为，而不需要刻意的链式调用。await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 Promise 的异步操作被兑现或被拒绝之后才会恢复进程。async 函数有如下几种定义形式： 123456789101112131415161718// 函数声明async function foo() &#123;&#125;// 函数表达式let foo = async function() &#123;&#125;// 箭头函数let foo = async () =&gt; &#123;&#125;// 对象方法lef obj = &#123; async foo() &#123;&#125;&#125;// 类方法class Dog &#123; async bark() &#123;&#125;&#125; async 函数一定会返回一个 Promise 对象，所以它可以使用 then 添加处理函数。如果一个 async 函数的返回值看起来不是Promise，那么它将会被隐式地包装在一个 Promise 中： 123456async function foo() &#123; return &#x27;a&#x27;&#125;foo().then(res =&gt; &#123; console.log(res) // &#x27;a&#x27;&#125;) 内部如果发生错误，或者显示抛出错误，那么 async 函数会返回一个 rejected 状态的 Promsie： 123456async function foo() &#123; throw new Error(&#x27;error&#x27;)&#125;foo().catch(err =&gt; &#123; console.log(err) // Error: error&#125;) 返回的 Promise 对象必须等到内部所有 await 命令 Promise 对象执行完才会发生状态改变，除非遇到 return 语句或抛出错误；任何一个 await 命令返回的 Promise 对象变 为rejected 状态，整个 Async 函数都会中断后续执行： 12345678910111213async function fn() &#123; let a = await Promise.resolve(&#x27;success&#x27;) console.log(&#x27;a_&#x27; + a) let b = await Promise.reject(&#x27;fail&#x27;) console.log(&#x27;b_&#x27; + b) // 不会执行&#125;fn().then(res =&gt; &#123; console.log(res) // 不会执行&#125;, err =&gt; &#123; console.log(err)&#125;)// &#x27;a_success&#x27;// &#x27;fail&#x27; 所以为了保证 async 里的异步操作都能完成，我们需要将他们放到 try...catch() 块里或者在 await 返回的 Promise 后跟一个 catch 处理函数： 123456789101112131415161718async function fn() &#123; try &#123; let a = await Promise.reject(&#x27;a fail&#x27;) console.log(&#x27;a_&#x27; + a) // 不会执行 &#125; catch (e) &#123; console.log(e) // &#x27;a fail&#x27; &#125; let b = await Promise.reject(&#x27;b fail&#x27;) .catch(e =&gt; &#123; console.log(e) // &#x27;b fail&#x27; &#125;) console.log(&#x27;b_&#x27; + b) // &#x27;bundefined&#x27;&#125;fn().then(res =&gt; &#123; console.log(res) // undefined&#125;, err =&gt; &#123; console.log(err) // 不会执行&#125;) 如果 async 函数里的多个异步操作之间没有依赖关系，建议将他们写到一起减少执行时间： 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()])// 写法二let fooPromise = getFoo()let barPromise = getBar()let foo = await fooPromiselet bar = await barPromise await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。 共享内存和Atomics对象 SharedArrayBuffer Atomics ES2018 Promise.prototype.finally()Promise.prototype.finally() 用于给 Promise 对象添加 onFinally 函数，这个函数主要是做一些清理的工作，只有状态变化的时候才会执行该 onFinally 函数。 123456function onFinally() &#123; console.log(888) // 并不会执行 &#125;new Promise((resolve, reject) =&gt; &#123; &#125;).finally(onFinally) finally() 会生成一个 Promise 新实例，finally 一般会原样后传父 Promise，无论父级实例是什么状态： 123456789let p1 = new Promise(() =&gt; &#123;&#125;)let p2 = p1.finally(() =&gt; &#123;&#125;)setTimeout(console.log, 0, p2) // Promise &#123;&lt;pending&gt;&#125;let p3 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p4 = p3.finally(() =&gt; &#123;&#125;)setTimeout(console.log, 0, p3) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 上面说的是一般，但是也有特殊情况，比如 finally 里返回了一个非 fulfilled 的 Promise 或者抛出了异常的时候，则会返回对应状态的新实例： 12345678910111213let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;))setTimeout(console.log, 0, p2) // Promise &#123;&lt;pending&gt;&#125;let p3 = p1.finally(() =&gt; Promise.reject(6))setTimeout(console.log, 0, p3) // Promise &#123;&lt;rejected&gt;: 6&#125;let p4 = p1.finally(() =&gt; &#123; throw new Error(&#x27;error&#x27;)&#125;)setTimeout(console.log, 0, p4) // Promise &#123;&lt;rejected&gt;: Error: error&#125; 参考：深入理解Promise 异步迭代器想要了解异步迭代器最好的方式就是和同步迭代器进行对比。我们知道可迭代数据的内部都是有一个 Symbol.iterator 属性，它是一个函数，执行后会返回一个迭代器对象，这个迭代器对象有一个 next() 方法可以对数据进行迭代，next() 执行后会返回一个对象，包含了当前迭代值 value 和 标识是否完成迭代的 done 属性： 1234let iterator = [1, 2][Symbol.iterator]()iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: undefinde, done: true &#125; 上面这里的 next() 执行的是同步操作，所以这个是同步迭代器，但是如果 next() 里需要执行异步操作，那就需要异步迭代了，可异步迭代数据的内部有一个 Symbol.asyncIterator 属性，基于此我们来实现一个异步迭代器： 12345678910111213141516171819class Emitter &#123; constructor(iterable) &#123; this.data = iterable &#125; [Symbol.asyncIterator]() &#123; let length = this.data.length, index = 0; return &#123; next:() =&gt; &#123; const done = index &gt;= length const value = !done ? this.data[index++] : undefined return new Promise((resolve, reject) =&gt; &#123; resolve(&#123;value, done&#125;) &#125;) &#125; &#125; &#125;&#125; 异步迭代器的 next() 会进行异步的操作，通常是返回一个 Promise，所以需要对应的处理函数去处理结果： 1234567891011let emitter = new Emitter([1, 2, 3])let asyncIterator = emitter[Symbol.asyncIterator]()asyncIterator.next().then(res =&gt; &#123; console.log(res) // &#123; value: 1, done: false &#125;&#125;)asyncIterator.next().then(res =&gt; &#123; console.log(res) // &#123; value: 2, done: false &#125;&#125;)asyncIterator.next().then(res =&gt; &#123; console.log(res) // &#123; value: 3, done: false &#125;&#125;) 另外也可以使用 for await...of 来迭代异步可迭代数据： 12345678let asyncIterable = new Emitter([1, 2, 3])async function asyncCount() &#123; for await (const x of asyncIterable ) &#123; console.log(x) &#125;&#125;asyncCount()// 1 2 3 另外还可以通过异步生成器来创建异步迭代器： 12345678910111213141516171819202122class Emitter &#123; constructor(iterable) &#123; this.data = iterable &#125; async *[Symbol.asyncIterator]() &#123; let length = this.data.length, index = 0; while (index &lt; length) &#123; yield this.data[index++] &#125; &#125;&#125;async function asyncCount() &#123; let emitter = new Emitter([1, 2, 3]) const asyncIterable = emitter[Symbol.asyncIterator]() for await (const x of asyncIterable ) &#123; console.log(x) &#125;&#125;asyncCount()// 1 2 3 参考： Iteration_protocols for-await…of s修饰符(dotAll模式)正则表达式新增了一个 s 修饰符，使得 . 可以匹配任意单个字符： 12/foo.bar/.test(&#x27;foo\\nbar&#x27;) // false/foo.bar/s.test(&#x27;foo\\nbar&#x27;) // true 上面这又被称为 dotAll 模式，表示点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式： 1/foo.bar/s.dotAll // true 具名组匹配正则表达式可以使用捕获组来匹配字符串，但是想要获取某个组的结果只能通过对应的索引来获取： 123456let re = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/let result = re.exec(&#x27;2015-01-02&#x27;)// result[0] === &#x27;2015-01-02&#x27;// result[1] === &#x27;2015&#x27;// result[2] === &#x27;01&#x27;// result[3] === &#x27;02&#x27; 而现在我们可以通过给捕获组 (?&lt;name&gt;...) 加上名字 name ，通过名字来获取对应组的结果： 12345let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/let result = re.exec(&#x27;2015-01-02&#x27;)// result.groups.year === &#x27;2015&#x27;// result.groups.month === &#x27;01&#x27;// result.groups.day === &#x27;02&#x27; 配合解构赋值可以写出非常精简的代码： 12let &#123;groups: &#123;year, month, day&#125;&#125; = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/.exec(&#x27;2015-01-02&#x27;)console.log(year, month, day) // 2015 01 02 具名组也可以通过传递给 String.prototype.replace 的替换值中进行引用。如果该值为字符串，则可以使用 $&lt;name&gt; 获取到对应组的结果： 123let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/let result = &#x27;2015-01-02&#x27;.replace(re, &#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;)// result === &#x27;02/01/2015&#x27; 参考：proposal-regexp-named-groups 后行断言后行断言： (?&lt;=y)x，x 只有在 y 后面才能匹配： 1/(?&lt;=\\$)\\d+/.exec(&#x27;I have $100.&#x27;) // [&#x27;100&#x27;] 后行否定断言： (?&lt;!y)x，x 只有不在 y 后面才能匹配： 1/(?&lt;!\\$)\\d+/.exec(&#x27;I have $100.&#x27;) // [&#x27;00&#x27;] Unicode属性转义允许正则表达式匹配符合 Unicode 某种属性的所有字符，\\p&#123;...&#125; 是匹配包含，\\P&#123;...&#125; 是匹配不包含的字符，且必须搭配 /u 修饰符才会生效： 12/\\p&#123;Emoji&#125;+/u.exec(&#x27;😁😭笑死我了🤣😂不行了&#x27;) // [&#x27;😁😭&#x27;]/\\P&#123;Emoji&#125;+/u.exec(&#x27;😁😭笑死我了🤣😂不行了&#x27;) // [&#x27;笑死我了&#x27;] 这里可以查询到更多的 Unicode 的属性 Full_Properties 对象扩展运算符对象的扩展运算符可以用到解构赋值上，且只能应用到最后一个变量上： 12let &#123;x, ...y&#125; = &#123;x: 1, a: 2, b: 3&#125;console.log(y) // &#123;a: 2, b: 3&#125; 对象扩展运算符不能解构原型上的属性： 1234let obj = &#123; x: 1 &#125;obj.__proto__ = &#123; y: 2 &#125;let &#123;...a&#125; = objconsole.log(a.y) // undefined 应用一：可以实现浅拷贝，但是不会拷贝原始属性： 123456789101112let person = Object.create(&#123; name: &#x27;布兰&#x27; &#125;)person.age = 12// 浅拷贝写法一let &#123; ...pClone1 &#125; = personconsole.log(pClone1) // &#123; age: 12 &#125;console.log(pClone1.name) // undefined// 浅拷贝写法二let pClone2 = &#123;...person&#125;console.log(pClone2) // &#123; age: 12 &#125;console.log(pClone2.name) // undefined 应用二：合并两个对象： 1234let ab = &#123;...a, ...b&#125;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 应用三：重写对象属性 1let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;; 应用四：给新对象设置默认值 1let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;; 应用五：利用扩展运算符的解构赋值可以扩展函数参数： 123456function baseFunction(&#123; a, b &#125;) &#123;&#125;function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123; // 使用 x 和 y 参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig)&#125; 参考： Object Spread Initializer Object Rest Destructuring 放松对标签模板里字符串转义的限制ECMAScript 6 入门 ES2019 允许省略catch里的参数异常被捕获的时候如果不需要做操作，甚至可以省略 catch(err) 里的参数和圆括号： 12345try &#123;&#125; catch &#123; &#125; JSON.stringify()变动UTF-8 标准规定，0xD800 到 0xDFFF 之间的码点，不能单独使用，必须配对使用。所以 JSON.stringify() 对单个码点进行操作，如果码点符合 UTF-8 标准，则会返回对应的字符，否则会返回对应的码点： 12JSON.stringify(&#x27;\\u&#123;1f600&#125;&#x27;) // &quot;&quot;😀&quot;&quot;JSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;&quot;\\ud834&quot;&quot; Symbol.prototype.descriptionSymbol 实例新增了一个描述属性 description： 12let symbol = Symbol(&#x27;foo&#x27;)symbol.description // &#x27;foo&#x27; Function.prototype.toString()函数的 toString() 会原样输出函数定义时候的样子，不会省略注释和空格。 Object.fromEntries()Object.fromEntries() 方法是 Object.entries() 的逆操作，用于将一个键值对数组转为对象： 123let person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;let keyValueArr = Object.entries(person) // [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]let obj = Object.fromEntries(arr) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 常用可迭代数据结构之间的装换： 12345678910111213let person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;// 对象 -&gt; 键值对数组let keyValueArr = Object.entries(person) // [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]// 键值对数组 -&gt; Maplet map = new Map(keyValueArr) // Map &#123;&quot;name&quot;: &quot;布兰&quot;, &quot;age&quot;: 12&#125;// Map -&gt; 键值对数组let arr = Array.from(map) // [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]] // 键值对数组 -&gt; 对象let obj = Array.from(arr).reduce((acc, [ key, val ]) =&gt; Object.assign(acc, &#123; [key]: val &#125;), &#123;&#125;) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 参考：Object.fromEntries 字符串可直接输入行分隔符和段分隔符JavaScript 规定有 5 个字符，不能在字符串里面直接使用，只能使用转义形式。 U+005C：反斜杠（reverse solidus) U+000D：回车（carriage return） U+2028：行分隔符（line separator） U+2029：段分隔符（paragraph separator） U+000A：换行符（line feed） 但是由于 JSON 允许字符串里可以使用 U+2028 和 U+2029，所以使得 JSON.parse() 去解析字符串的时候可能会报错，所以 ES2019 允许模板字符串里可以直接这两个字符： 123JSON.parse(&#x27;&quot;\\u2028&quot;&#x27;) // &quot;&quot;JSON.parse(&#x27;&quot;\\u2029&quot;&#x27;) // &quot;&quot;JSON.parse(&#x27;&quot;\\u005C&quot;&#x27;) // SyntaxError String.prototype.trimStart消除字符串头部空格，返回一个新字符串；浏览器还额外增加了它的别名函数 trimLeft()： 1234let str = &#x27; hello world &#x27;let newStr = str.trimStart()console.log(newStr, newStr === str) // &#x27;hello world &#x27; false String.prototype.trimEnd消除字符串尾部空格，返回一个新字符串；浏览器还额外增加了它的别名函数 trimRight()： 1234let str = &#x27; hello world &#x27;let newStr = str.trimEnd()console.log(newStr, newStr === str) // &#x27; hello world&#x27; false Array.prototype.flat()arr.flat(depth) 按照 depth （不传值的话默认是 1）深度拍平一个数组，并且将结果以新数组形式返回： 12345678// depth 默认是 1const arr1 = [1, 2, [3, 4]]console.log(arr1.flat()) // [1, 2, 3, 4]// 使用 Infinity，可展开任意深度的嵌套数组；自动跳过空数组；const arr2 = [1, , [2, [3, [4]]]]console.log(arr2.flat(Infinity))// [1, 2, 3, 4] 用 reduce 实现拍平一层数组： 123456789const arr = [1, 2, [3, 4]]// 方法一let newStr = arr.reduce((acc, cur) =&gt; acc.concat(cur), [])// 方法二const flattened = arr =&gt; [].concat(...arr)flattened(arr) 参考：flat Array.prototype.flatMap()flatMap(callback) 使用映射函数 callback 映射每个元素，callback 每次的返回值组成一个数组，并且将这个数组执行类似 arr.flat(1) 的操作进行拍平一层后最后返回结果： 1234const arr1 = [1, 2, 3, 4]arr1.flatMap(x =&gt; [x * 2])// 将 [[2], [4], [6], [8]] 数组拍平一层得到最终结果：[2, 4, 6, 8] 参考：flatMap ES2020 String.prototype.matchAll()String.prototype.matchAll() 方法，可以一次性取出所有匹配。不过，它返回的是一个 RegExpStringIterator 迭代器同是也是一个可迭代的数据结构，所以可以通过 for...of 进行迭代： 12345678let str = &#x27;test1test2&#x27;let regexp = /t(e)(st(\\d?))/glet iterable = str.matchAll(regexp)for (const x of iterable) &#123; console.log(x)&#125;// [&#x27;test1&#x27;, &#x27;e&#x27;, &#x27;st1&#x27;, &#x27;1&#x27;, index: 0, input: &#x27;test1test1&#x27;, groups: undefined]// [&#x27;test2&#x27;, &#x27;e&#x27;, &#x27;st2&#x27;, &#x27;2&#x27;, index: 5, input: &#x27;test1test2&#x27;, groups: undefined] 注意当使用 matchAll(regexp) 的时候，正则表达式必须加上 /g 修饰符。 也可以将这个可迭代数据转成数组形式： 12345// 方法一[...str.matchAll(regexp)]// 方法二Array.from(str.matchAll(regexp)) 动态import()标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。 比如按需加载一个模块可以这样： 123if (xxx) &#123; import(&#x27;./module.js&#x27;)&#125; import() 是异步导入的，结果会返回一个 Promise： 1234import(&#x27;/module.js&#x27;).then((module) =&gt; &#123; // Do something with the module.&#125;) 动态 import() 的应用场景挺多的，比如 Vue 中的路由懒加载就是使用的动态导入组件。另外由于动态性不便于静态分析工具和 tree-shaking 工作，所以不能滥用。 BigIntBigInt 是一种内置对象，它提供了一种方法来表示大于 $2^{53}$ - 1 的整数。这原本是 Javascript 中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数。 为了区分 Number，定义一个 BigInt 需要在整数后面加上一个 n，或者用函数直接定义： 12const num1 = 10nconst num2 = BigInt(20) Number 和 BigInt 之间能进行比较，但他们之间是宽松相等；且由于他们表示的是不同类型的数字，所以不能直接进行四则运算： 1234510n == 10 // true10n === 10 // false10n &gt; 8 // true10 + Number(10n) // 2010 + 10n // TypeError Promise.allSettledPromise.allSettled(iterable) 当所有的实例都已经 settled，即状态变化过了，那么将返回一个新实例，该新实例的内部值是由所有实例的值和状态组合成的数组，数组的每项是由每个实例的状态和内部值组成的对象。 12345678910111213141516171819202122function init()&#123; return 3&#125;let p1 = Promise.allSettled([ new Promise((resolve, reject) =&gt; &#123; resolve(9) &#125;).then(res =&gt; &#123;&#125;), new Promise((resolve, reject) =&gt; &#123; reject(6) &#125;), init()])let p2 = p1.then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)// [// &#123;status: &quot;fulfilled&quot;, value: undefined&#125;, // &#123;status: &quot;rejected&quot;, reason: 6&#125;, // &#123;status: &quot;fulfilled&quot;, value: 3&#125;// ] 只要所有实例中包含一个 pending 状态的实例，那么 Promise.allSettled() 的结果为返回一个这样 Promise &#123;&lt;pending&gt;&#125; 的实例。 globalThis在以前，从不同的 JavaScript 环境中获取全局对象需要不同的语句。在 Web 中，可以通过 window、self 或者 frames 取到全局对象，但是在 Web Workers 中，只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。 而现在只需要使用 globalThis 即可获取到顶层对象，而不用担心环境问题。 12// 在浏览器中globalThis === window // true import.metaimport.meta 是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 URL，import.meta 必须在一个模块里使用： 123456// 没有声明 type=&quot;module&quot;，就使用 import.meta 会报错&lt;script type=&quot;module&quot; src=&quot;./js/module.js&quot;&gt;&lt;/script&gt;// 在module.js里console.log(import.meta) // &#123;url: &quot;http://localhost/3ag/js/module.js&quot;&#125; 如果需要在配置了 Webpack 的项目，比如 Vue 里使用 import.meta 需要加一个包且配置一下参数，否则项目编译阶段会报错。 包配置详情参考：@open-wc/webpack-import-meta-loader 比如我用的是 4.x 版本的 vue-cli，那我需要在 vue.config.js 里配置： 12345678910module.exports = &#123; chainWebpack: config =&gt; &#123; config.module .rule(&#x27;js&#x27;) .test(/\\.js$/) .use(&#x27;@open-wc/webpack-import-meta-loader&#x27;) .loader(&#x27;@open-wc/webpack-import-meta-loader&#x27;) .end() &#125;&#125; 可选链操作符（?.）通常我们获取一个深层对象的属性会需要写很多判断或者使用逻辑与 &amp;&amp; 操作符，因为对象的某个属性如果为 null 或者 undefined 就有可能报错： 12345678910111213141516let obj = &#123; first: &#123; second: &#x27;布兰&#x27; &#125;&#125;// 写法一let name1 = &#x27;&#x27;if (obj) &#123; if (obj.first) &#123; name1 = obj.first.second &#125;&#125;// 写法二let name2 = obj &amp;&amp; obj.first &amp;&amp; obj.first.second ?. 操作符允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。如果某个属性为 null 或者 undefined 则结果直接为 undefined。有了可选链操作符就可以使得表达式更加简明了，对于上面例子用可选链操作符可以这么写： 1let name3 = obj?.first?.second 空值合并操作符（??）对于逻辑或 || 运算符，当对运算符左侧的操作数进行装换为 Boolean 值的时候，如果为 true，则取左边的操作数为结果，否则取右边的操作数为结果： 12let name = &#x27;&#x27; || &#x27;布兰&#x27;console.log(name) // &#x27;布兰&#x27; 我们都知道 &#39;&#39;、0、null、undefined、false、NaN 等转成 Boolean 值的时候都是 false，所以都会取右边的操作数。这个时候如果要给变量设置默认值，如果遇到本身值就可能是 &#39;&#39; 或 0 的情况那就会出错了，会被错误的设置为默认值了。 而 ?? 操作符就是为了解决这个问题而出现的，x ?? y 只有左侧的操作数为 null 或 undefined 的时候才取右侧操作数，否则取左侧操作数： 12let num = 0 ?? 1console.log(num) // 0 ES2021 如下这几个提案已经确定了会在 2021 年发布，所以把他们归到 ES2021 中。 String.prototype.replaceAll之前需要替换一个字符串里的全部匹配字符可以这样做： 1234567const queryString = &#x27;q=query+string+parameters&#x27;// 方法一const withSpaces1 = queryString.replace(/\\+/g, &#x27; &#x27;)// 方法二const withSpaces2 = queryString.split(&#x27;+&#x27;).join(&#x27; &#x27;) 而现在只需要这么做： 1const withSpace3 = queryString.replaceAll(&#x27;+&#x27;, &#x27; &#x27;) replaceAll 的第一个参数可以是字符串也可以是正则表达式，当是正则表达式的时候，必须加上全局修饰符 /g，否则报错。 参考：string-replaceall Promise.any()Promsie.any() 和 Promise.all() 一样接受一个可迭代的对象，然后依据不同的入参会返回不同的新实例： 传一个空的可迭代对象或者可迭代对象所有 Promise 都是 rejected 状态的，则会抛出一个 AggregateError 类型的错误，同时返回一个 rejected 状态的新实例： 1234let p1 = Promise.any([])let p2.catch(err =&gt; &#123;&#125;)setTimeout(console.log, 0, p1)// Promise &#123;&lt;rejected&gt;: AggregateError: All promises were rejected&#125; 只要可迭代对象里包含任何一个 fulfilled 状态的 Promise，则会返回第一个 fulfilled 的实例，并且以它的值作为新实例的值： 12345678let p = Promise.any([ 1, Promise.reject(2), new Promise((resolve, reject) =&gt; &#123;&#125;), Promise.resolve(3),])setTimeout(console.log, 0, p)// Promise &#123;&lt;fulfilled&gt;: 1&#125; 其他情况下，都会返回一个 pending 状态的实例： 1234567let p = Promise.any([ Promise.reject(2), Promise.reject(3), new Promise((resolve, reject) =&gt; &#123;&#125;),])setTimeout(console.log, 0, p)// Promise &#123;&lt;pending&gt;: undefined&#125; WeakRef我们知道一个普通的引用（默认是强引用）会将与之对应的对象保存在内存中。只有当该对象没有任何的强引用时，JavaScript 引擎 GC 才会销毁该对象并且回收该对象所占的内存空间。 WeakRef 对象允许你保留对另一个对象的弱引用，而不会阻止被弱引用的对象被 GC 回收。WeakRef 的实例方法 deref() 可以返回当前实例的 WeakRef 对象所绑定的 target 对象，如果该 target 对象已被 GC 回收则返回 undefined： 1234let person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;let wr = new WeakRef(person)console.log(wr.deref()) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 正确使用 WeakRef 对象需要仔细的考虑，最好尽量避免使用。这里面有诸多原因，比如：GC 在一个 JavaScript 引擎中的行为有可能在另一个 JavaScript 引擎中的行为大相径庭，或者甚至在同一类引擎，不同版本中 GC 的行为都有可能有较大的差距。GC 目前还是 JavaScript 引擎实现者不断改进和改进解决方案的一个难题。 参考： WeakRef 内存管理 逻辑赋值符逻辑赋值符包含 3 个： x &amp;&amp;= y：逻辑与赋值符，相当于 x &amp;&amp; (x = y) x ||= y：逻辑或赋值符，相当于 x || (x = y) x ??= y：逻辑空赋值符，相当于 x ?? (x = y) 看如下示例，加深理解： 123456789let x = 0x &amp;&amp;= 1 // x: 0x ||= 1 // x: 1x ??= 2 // x: 1let y = 1y &amp;&amp;= 0 // y: 0y ||= null // y: nully ??= 2 // y: 2 数值分隔符（_）对于下面一串数字，你一眼看上去不确定它到底是多少吧？ 1const num = 1000000000 那现在呢？是不是可以很清楚的看出来它是 10 亿： 1const num = 1_000_000_000 数值分隔符（_）的作用就是为了让数值的可读性更强。除了能用于十进制，还可以用于二级制，十六进制甚至是 BigInt 类型： 123let binarary = 0b1010_0001_1000_0101let hex = 0xA0_B0_C0let budget = 1_000_000_000_000n 使用时必须注意 _ 的两边必须要有类型的数值，否则会报错，以下这些都是无效的写法： 1234let num = 10_let binarary = 0b1011_let hex = 0x_0A0Blet budget = 1_n 参考文章 ECMAScript6入门 1.5万字概括ES6全部特性(已更新ES2020) 近一万字的ES6语法知识点补充 深入理解Promise for-await…of Iteration_protocols Object.fromEntries WeakRef 内存管理 jshistory-cn sameValueZero","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"深入理解Promise","slug":"promise","date":"2020-10-22T02:11:30.000Z","updated":"2020-10-22T02:16:34.031Z","comments":true,"path":"2020/10/22/promise/","link":"","permalink":"https://bubuzou.com/2020/10/22/promise/","excerpt":"从异步编程说起我们都知道 JavaScript 的代码执行的时候是跑在单线程上的，可以理解为只能按照代码的出现顺序，从上到下一行一行的执行，但是遇到了异步的行为，比如定时器（一定时间之后才去执行），那就需要等同步代码执行完成后的一段时间里再去执行异步代码。 对于同步行为，如下面的代码，我们能够很清楚的知道每一行会发生什么，这是因为后面的指令总是等到前面的指令执行完成后才去执行，所以这里的第二行里的变量 x 在内存里已经是定义过的。 12let x = 10;let y = x + 5;","text":"从异步编程说起我们都知道 JavaScript 的代码执行的时候是跑在单线程上的，可以理解为只能按照代码的出现顺序，从上到下一行一行的执行，但是遇到了异步的行为，比如定时器（一定时间之后才去执行），那就需要等同步代码执行完成后的一段时间里再去执行异步代码。 对于同步行为，如下面的代码，我们能够很清楚的知道每一行会发生什么，这是因为后面的指令总是等到前面的指令执行完成后才去执行，所以这里的第二行里的变量 x 在内存里已经是定义过的。 12let x = 10;let y = x + 5; 但是对于异步代码，我们就不好推断到底什么时候会执行完成了。比如举一个实际的例子，我们去动态加载某个脚本，会这样做： 12345function loadScript(src) &#123; let script = document.createElement(&#x27;script&#x27;) script.src = src document.head.append(script)&#125; 这个脚本加载完成的时候会去执行定义在脚本里的一些函数，比如初始化函数 init，那么我们可以会这样写： 1234567function loadScript(src) &#123; let script = document.createElement(&#x27;script&#x27;) script.src = src document.head.append(script)&#125;loadScript(&#x27;./js/script.js&#x27;)init() // 定义在 ./js/script.js 里的函数 但是实际执行后却发现，这样根本不行，因为加载脚本是需要花时间的，是一个异步的行为，浏览器执行 JavaScript 的时候并不会等到脚本加载完成的时候再去调用 init 函数。 以往，对于这种异步编程的做法通常就是通过给函数传递一个回调函数来处理，上面那个例子可以这样做： 123456789101112131415function loadScript(src, success, fail) &#123; let script = document.createElement(&#x27;script&#x27;) script.src = src script.onload = success script.onerror = fail document.head.append(script)&#125;loadScript(&#x27;./js/script.js&#x27;, success, fail)function success() &#123; console.log(&#x27;success&#x27;) init() // 定义在 ./js/script.js 中的函数&#125;function fail() &#123; console.log(&#x27;fail&#x27;)&#125; 上面这样做能够保证在脚本加载完成的时候，再去执行脚本里的函数。但是多考虑一个问题，如果 success 里又需要加载别的 js 文件呢，那岂不是需要多层嵌套了。是的，这样的多层嵌套会使得代码层次变得更加深入，难以阅读以及后期维护成本非常高，尤其是当里面加上了很多的判断逻辑的时候情况会更加糟糕，这就是所谓的 “回调地狱”，且又因为它的代码形状很像躺着的金字塔，所以有的人也喜欢叫它 “噩运金字塔”。 而为了避免这类 “回调地狱” 问题，目前最好的做法之一就是使用 Promise。 Promise正篇使用 Promise 可以很好的解决上面提到的 “回调地狱” 问题，直接来看结果： 123456789101112131415function loadScript(src) &#123; return new Promise(function(resolve, reject) &#123; let script = document.createElement(&#x27;script&#x27;); script.src = src; script.onload = () =&gt; resolve(script); script.onerror = () =&gt; reject(new Error(`Script load error for $&#123;src&#125;`)); document.head.append(script); &#125;);&#125;loadScript(&#x27;./scripts.js&#x27;).then(res =&gt; &#123; console.log(&#x27;success&#x27;, res); init()&#125;).catch(err =&gt; &#123; console.log(err);&#125;) 这里通过使用 Promise 实例的 then 和 catch 函数将多层嵌套的代码改成了同步处理流程，看起来效果还是不错的，那什么是 Promise 呢？ Promise 首先是一个对象，它通常用于描述现在开始执行，一段时间后才能获得结果的行为（异步行为），内部保存了该异步行为的结果。然后，它还是一个有状态的对象： pending：待定 fulfilled：兑现，有时候也叫解决（resolved） rejected：拒绝 一个 Promise 只有这 3 种状态，且状态的转换过程有且仅有 2 种： pending 到 fulfilled pending 到 rejected 可以通过如下的 Promise 对象构造器来创建一个 Promise： 1let promise = new Promise((resolve, reject) =&gt; &#123;&#125;) 传递给 new Promise 的是 executor 执行器。当 Promise 被创建的时候，executor 会立即同步执行。executor 函数里通常做了 2 件事情：初始化一个异步行为和控制状态的最终转换。 12345new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 1000)&#125;) 如上代码所示，setTimeout 函数用来描述一个异步行为，而 resolve 用来改变状态。executor 函数包含 2 个参数，他们都是回调函数，用于控制 Promise 的状态转换： resolve：用来将状态 pending 转换成 fulfilled reject：用来将状态 pending 转换成 rejected 一个 Promise 的状态一旦被转换过，则无法再变更： 12345678let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;第一次 resolve&#x27;) resolve(&#x27;第二次 resolve&#x27;) // 将被忽略 reject(&#x27;第一次 reject&#x27;) // 将被忽略 &#125;, 0)&#125;)setTimeout(console.log, 1000, p) // Promise &#123;&lt;fulfilled&gt;: &quot;第一次 resolve&quot;&#125; 可以看到执行了 2 次 resolve 函数和 1 次 reject 函数，但是 promise 的最终结果是取的第一次 resolve 的结果，印证了上面的结论。 由 new Promise 构造器返回的 Promise 对象具有如下内部属性： PromiseState：最初是 pending，resolve 被调用的时候变为 fulfilled，或者 reject 被调用时会变为 rejected； PromiseResult：最初是 undefined，resolve(value) 被调用时变为 value，或者在 reject(error) 被调用时变为 error。 比如上面例子中打印出来的 Promise 对象结果中，fulfilled 是其内部的 PromiseState，而 “第一次 resolve” 是其 PromiseResult。 1// Promise &#123;&lt;fulfilled&gt;: &quot;第一次 resolve&quot;&#125; Promise实例方法Promise.prototype.then()Promise.prototype.then() 将用于为 Promise 实例添加处理程序的函数。它接受 2 个可选的参数： onResolved：状态由 pending 转换成 fulfilled 时执行； onRejected：状态由 pending 转换成 rejected 时执行。 它可以写成这样： 123456789function onResolved(res) &#123; console.log(&#x27;resolved&#x27; + res) // resolved3&#125;function onRejected(err) &#123; console.log(&#x27;rejected&#x27; + err)&#125;new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;).then(onResolved, onRejected) 或者写成更简单的方式： 1234567new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;).then(res =&gt; &#123; console.log(&#x27;resolved&#x27; + res) // resolved3&#125;, err =&gt; &#123; console.log(&#x27;rejected&#x27; + err)&#125;) 因为状态的变化只有 2 种，所以 onResolved 和 onRejected 在执行的时候必定是互斥。 上面介绍到了 then() 的参数是可选的，当只有 onResolved 的时候可以这样写： 123new Promise((resolve, reject) =&gt; &#123; resolve()&#125;).then(res =&gt; &#123;&#125;) 当参数只有 onRejected 的时候，需要把第一个参数设置为 null： 123new Promise((resolve, reject) =&gt; &#123; reject()&#125;).then(null, err =&gt; &#123;&#125;) 如果给 then() 函数传递来了非函数参数，则会默认忽略。 Promise.prototype.catch()Promise.prototype.catch() 用于给 Promise 对象添加拒绝处理程序。只接受一个参数：onRejected 函数。实际上，下面这两种写法是等效的： 1234567function onRejected(err)&#123;&#125;new Promise((resolve, reject) =&gt; &#123; reject()&#125;).catch(onRejected)new Promise((resolve, reject) =&gt; &#123; reject()&#125;).then(null, onRejected) Promise.prototype.finally()Promise.prototype.finally() 用于给 Promise 对象添加 onFinally 函数，这个函数主要是做一些清理的工作，只有状态变化的时候才会执行该 onFinally 函数。 123456function onFinally() &#123; console.log(888) // 并不会执行 &#125;new Promise((resolve, reject) =&gt; &#123; &#125;).finally(onFinally) 因为 onFinally 函数是没有任何参数的，所以在其内部其实并不知道该 Promise 的状态是怎么样的。 链式调用链式调用里涉及到的知识点很多，我们不妨先看看下面这道题，你能正确输出其打印顺序嘛？ 1234567891011121314new Promise((resolve, reject) =&gt; &#123; resolve()&#125;).then(() =&gt; &#123; console.log(&#x27;A&#x27;) new Promise((resolve, reject) =&gt; &#123; resolve() &#125;).then(() =&gt; &#123; console.log(&#x27;B&#x27;) &#125;).then(() =&gt; &#123; console.log(&#x27;C&#x27;) &#125;)&#125;).then(() =&gt; &#123; console.log(&#x27;D&#x27;)&#125;) 这里我不给出答案，希望你能动手敲一敲代码，然后思考下为什么？容我讲完这部分知识，相信你能自己理解其中缘由。 从上面这串代码里，我们看到 new Promise 后面接了很多的 .then() 处理程序，这个其实就是 Promise 的链式调用，那它为什么能链式调用呢？ 基于onResolved生成一个新的Promise因为 Promise.prototype.then() 会返回一个新的 Promise，来看下： 123456let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.then(() =&gt; 6)setTimeout(console.log, 0, p1) // Promise &#123;&lt;fulfilled&gt;: 3&#125;setTimeout(console.log, 0, p2) // Promise &#123;&lt;fulfilled&gt;: 6&#125; 可以看到 p1 和 p2 的内部 PromiseResult 是不一样的，说明 p2 是一个新的 Promise 实例。 新产生的 Promise 会基于 onResolved 的返回值进行构建，构建的时候其实是把返回值传递给 Promise.resolve() 生成的新实例，比如上面那串代码里 p1.then(() =&gt; 6) 这里的 onResolved 函数返回了一个 6 ，所以新的 Promise 的内部值会是 6。 如果 .then() 没有提供 onResolved 这个处理程序，则 Promise.resolve() 会基于上一个实例 resolve 后的值来初始化一个新的实例： 12345let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.then()setTimeout(console.log, 0, p2) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 如果 onResolved 处理程序没有返回值，那么返回的新实例的内部值会是 undefined： 12345let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.then(() =&gt; &#123;&#125;)setTimeout(console.log, 0, p2) // Promise &#123;&lt;fulfilled&gt;: undefined&#125; 如果在 onResolved 处理程序里抛出异常，则会返回一个新的 rejected 状态的 Promise： 1234567let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.then(() =&gt; &#123; throw new Error(&#x27;这是一个错误&#x27;)&#125;)setTimeout(console.log, 0, p2) // Promise &#123;&lt;rejected&gt;: 这是一个错误&#125; 基于onRejected生成一个新的Promise基于 onRejected 的返回值也会返回一个新的 Promise，而且处理逻辑也是一样的，也是通过把返回值传递给 Promise.resolve() 产生一个新的实例： 1234567891011121314151617181920212223242526272829let p1 = new Promise((resolve, reject) =&gt; &#123; reject(3)&#125;)// 没有 `onRejected` 处理程序时，会原样向后传，不过是新实例let p2 = p1.then(() =&gt; &#123;&#125;) ssetTimeout(console.log, 0, p2) // Promise &#123;&lt;rejected&gt;: 3&#125;// 返回值为undefined时let p3 = p1.then(null, () =&gt; &#123;&#125;) setTimeout(console.log, 0, p3) // Promise &#123;&lt;fulfilled&gt;: undefined&#125; // 返回值有实际值的时候let p4 = p1.then(null, () =&gt; 6) setTimeout(console.log, 0, p4) // Promise &#123;&lt;fulfilled&gt;: 6&#125;// 当返回值是Promise时，会保留当前Promiselet p5 = p1.then(null, () =&gt; Promise.reject()) setTimeout(console.log, 0, p5) // Promise &#123;&lt;rejected&gt;: undefined&#125; // 当遇到一个错误的时候let p6 = p1.then(null, () =&gt; &#123; throw new Error(&#x27;error&#x27;)&#125;) setTimeout(console.log, 0, p6) // Promise &#123;&lt;rejected&gt;: error&#125; // 当返回值是一个错误时let p7 = p1.then(null, () =&gt; new Error(&#x27;error&#x27;)) setTimeout(console.log, 0, p7) // Promise &#123;&lt;fulfilled&gt;: Error: error&#125; 这里你会不会有个疑惑？实例 resolve() 的时候，状态由 pending 变成 rejected，从而调用 onRejected 进行处理，但是为什么有时候会返回一个 fulfilled 的新实例呢？试着想一下，如果 onRejected 返回了一个 pending 的或者 rejected 状态的新实例，那后续的链式调用就进行不下去了，看下面例子： 1234567891011new Promise((resolve, reject) =&gt; &#123; reject()&#125;).then(null, () =&gt; &#123; console.log(&#x27;A&#x27;)&#125;).then(() =&gt; &#123; console.log(&#x27;B&#x27;)&#125;).then(() =&gt; &#123; console.log(&#x27;C&#x27;)&#125;).catch(() =&gt; &#123; console.log(&#x27;D&#x27;)&#125;) 如果 A 处理函数这里返回了一个 pending 状态的新实例，那么后续所有的链式操作都无法执行；或者返回的是一个 rejected 状态的新实例，那么后续的 B 和 C 也就无法执行了，那居然都不能执行 B 和 C 所在处理程序，那定义来干嘛呢？链式操作就毫无链式可言。又，onRejected 的存在的根本意义无非就是用于捕获 Promise 产生的错误，从而不影响程序的正常执行，所以默认情况下理应返回一个 fulfilled 的新实例。 Promise.prototype.catch() 也会生成一个新的 Promise，其生成规则和 onRejected 是一样的。 finally生成一个新的Promise没想到吧，Promise.prototype.finally() 也能生成一个 Promise。finally 里的操作是和状态无关的，一般用来做后续代码的处理工作，所以 finally 一般会原样后传父 Promise，无论父级实例是什么状态。 123456789let p1 = new Promise(() =&gt; &#123;&#125;)let p2 = p1.finally(() =&gt; &#123;&#125;)setTimeout(console.log, 0, p2) // Promise &#123;&lt;pending&gt;&#125;let p3 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p4 = p3.finally(() =&gt; &#123;&#125;)setTimeout(console.log, 0, p3) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 上面说的是一般，但是也有特殊情况，比如 finally 里返回了一个非 fulfilled 的 Promise 或者抛出了异常的时候，则会返回对应状态的新实例： 12345678910111213let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;))setTimeout(console.log, 0, p2) // Promise &#123;&lt;pending&gt;&#125;let p3 = p1.finally(() =&gt; Promise.reject(6))setTimeout(console.log, 0, p3) // Promise &#123;&lt;rejected&gt;: 6&#125;let p4 = p1.finally(() =&gt; &#123; throw new Error(&#x27;error&#x27;)&#125;)setTimeout(console.log, 0, p4) // Promise &#123;&lt;rejected&gt;: Error: error&#125; 执行顺序先来看一段简单的代码： 123456789new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;A&#x27;) resolve(3) console.log(&#x27;B&#x27;)&#125;).then(res =&gt; &#123; console.log(&#x27;C&#x27;)&#125;)console.log(&#x27;D&#x27;)// 打印结果：A B D C 上面这串代码的输出顺序是：A B D C。从上面章节介绍的知识点我们知道，executor 执行器会在 new Promise 调用的时候立即同步执行的，所以先后打印 A B 是没问题的。当执行 resolve()/reject() 的时候，会将 Promise 对应的处理程序推入微任务队列，稍等这里提到的对应的处理程序具体是指什么？ resolve() 对应 .then() 里的第一个入参，即 onResolved 函数； reject() 对应 .then() 里的第二个入参，即 onRejected 函数；或者 Promise.prototype.catch() 里的回调函数； 所以当执行 resolve(3) 的时候（此时下面定义的这个箭头函数其实就是 onResolved 函数），onResolved 函数将被推入微任务队列，然后打印 D，此时所有同步任务执行完成，浏览器会去检查微任务队列，发现存在一个，所以最后会去调用 onResolved 函数，打印出 C。 123let onResolved = res =&gt; &#123; console.log(&#x27;C&#x27;)&#125; 其实除了 onResolved、onRejected 以及 Promise.prototype.catch() 里的处理程序外，Promise.prototype.finally() 的处理程序 onFinally 也是异步执行的： 12345678new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;A&#x27;) resolve(3)&#125;).finally(() =&gt; &#123; console.log(&#x27;B&#x27;)&#125;)console.log(&#x27;C&#x27;)// 打印结果：A C B Promise 链式调用的基础就是因为 onResolved、onRejected、catch() 的处理程序以及 onFinally 会产生一个新的 Promise 实例，且又因为他们都是异步执行的，所以在链式调用的时候，对于它们执行顺序会稀里糊涂琢磨不透就是这个原因。 题目一那下面我们就来看点复杂的例子，先来分析下这章开篇提到的题目： 123456789101112131415new Promise((resolve, reject) =&gt; &#123; resolve()&#125;).then(() =&gt; &#123; console.log(&#x27;A&#x27;) new Promise((resolve, reject) =&gt; &#123; resolve() &#125;).then(() =&gt; &#123; console.log(&#x27;B&#x27;) &#125;).then(() =&gt; &#123; console.log(&#x27;C&#x27;) &#125;)&#125;).then(() =&gt; &#123; console.log(&#x27;D&#x27;)&#125;)// 打印结果：A 为了方便分析，我们把上面的这串代码写得好看一点： 123456789101112131415161718new Promise(executor).then(onResolvedA).then(onResolvedD)function executor(resolve, reject) &#123; resolve()&#125;function onResolvedA() &#123; console.log(&#x27;A&#x27;) new Promise(executor).then(onResolvedB).then(onResolvedC)&#125;function onResolvedB() &#123; console.log(&#x27;B&#x27;)&#125;function onResolvedC() &#123; console.log(&#x27;C&#x27;)&#125;function onResolvedD() &#123; console.log(&#x27;D&#x27;)&#125; 执行过程： 执行 new Promise()，立即同步执行 executor 函数，调用 resolve()，此时会将 onResolvedA 推入微任务队列 1，截止目前所有同步代码执行完成； 检查微任务队列，执行 onResolvedA 函数，打印 A，执行 new Promise(executor)，调用 resolve() 函数，此时将 onResolvedB 推入微任务队列 2； 截止目前微任务队列 1 的代码全部执行完成，即 onResolvedA 函数执行完成。我们知道 onResolved 函数会基于返回值生成一个新的 Promise，而 onResolvedA 函数没有显示的返回值，所以其返回值为 undefined，那么经过 Promise.resolve(undefined) 初始化后会生成一个这样的新实例：Promise &#123;&lt;fulfilled&gt;: undefined&#125;；由于这个新的实例状态已经变成 fulfilled，所以会立即将其处理函数 onResolvedD 推入微任务队列 3； 开始执行微任务队列 2 里的内容，打印 B，同上一条原理，由于 onResolvedB 函数的返回值为 undefined，所以生成了一个 resolved 的新实例，则会立即将 onResolvedC 推入微任务队列 4； 执行微任务队列 3，打印 D； 执行微任务队列 4，打印 C； 至此全部代码执行完成，最终的打印结果为：A B D C。 题目二123456789101112131415new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;).then(res =&gt; &#123; console.log(&#x27;A&#x27;)&#125;).finally(() =&gt; &#123; console.log(&#x27;B&#x27;)&#125;)new Promise((resolve, reject) =&gt; &#123; resolve(2)&#125;).then(res =&gt; &#123; console.log(&#x27;C&#x27;)&#125;).finally(() =&gt; &#123; console.log(&#x27;D&#x27;)&#125;)// 打印结果：A C B D 应该很多人会和我当初一样好奇：为什么打印结果不是 A B C D 呢？这里涉及到一个知识点：如果给 Promise 实例添加了多个处理函数，当实例状态变化的时候，那么执行的过程就是按照添加时的顺序而执行的。 1234567891011new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;).then(onResolvedA).finally(onFinally)function onResolvedA() &#123; console.log(&#x27;A&#x27;)&#125;function onFinally() &#123; console.log(&#x27;B&#x27;)&#125;// 打印结果： A B 对于上面这串代码，其实 finally() 处理程序执行的时候已经不是通过 new Promise() 初始化的实例，而是执行完 onResolvedA 函数的时候生成的新实例，不信我们将上面代码中的函数 onResolvedA 稍微改动下： 123456789101112new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;).then(onResolvedA).finally(onFinally)function onResolvedA() &#123; console.log(&#x27;A&#x27;) return new Promise(() =&gt; &#123;&#125;)&#125;function onFinally() &#123; console.log(&#x27;B&#x27;)&#125;// 打印结果： A 由于 onResolvedA 返回了一个这样的 Promise &#123;&lt;pending&gt;&#125; 新实例，这个新实例的状态没有发生变化，所以不会执行 finally 处理程序 onFinally，所以不会打印 B。这个就说明了，链式调用的时候处理程序的执行是一步一步来的，只要前面的执行完了，生成了新的实例，然后根据新实例的状态变化，才去执行后续的处理程序。 所以拿最开始那道题来说： 123456789101112131415new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;).then(res =&gt; &#123; console.log(&#x27;A&#x27;)&#125;).finally(() =&gt; &#123; console.log(&#x27;B&#x27;)&#125;)new Promise((resolve, reject) =&gt; &#123; resolve(2)&#125;).then(res =&gt; &#123; console.log(&#x27;C&#x27;)&#125;).finally(() =&gt; &#123; console.log(&#x27;D&#x27;)&#125;)// 打印结果：A C B D 他的执行过程应该是这样的： 执行 resolve(1)，将处理程序 A 推入微任务队列 1； 执行 resolve(2)，将处理程序 C 推入微任务队列 2； 同步任务执行完成，执行微任务队列 1 里的内容，打印 A，A 所在函数执行完成后生成了一个 fulfilled 的新实例，由于新实例状态变化，所以会立即执行 finally() 处理程序 B 推入微任务队列 3； 执行微任务队列 2 的内容，打印 C，C 所在函数执行完成后，同上条原理会将处理程序 D 推入微任务队列 4； 执行微任务队列 3 的内容，打印 B； 执行微任务队列 4 的内容，打印 D； 代码全部执行完成，最终打印：A C B D。 题目就先做到这里，相信你和我一样，对 Promise 的执行过程应该有更深入的理解了。接下来我们将继续学习 Promise 的相关 API。 Promise与错误处理平时我们写代码遇到错误，都习惯用 try/catch 块来处理，但是对于 Promise 产生的错误，用这个是处理不了的，看下面这段代码： 12345678910111213try &#123; new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;A&#x27;) throw new Error() console.log(&#x27;B&#x27;) &#125;) &#125; catch(err) &#123; console.log(err)&#125;console.log(&#x27;C&#x27;)// A// C // Uncaught (in promise) Error 从执行结果我们可以看到，报错的信息出现在打印 C 之后，说明抛出错误这个动作是在异步任务中做的，所以 catch 捕获不到该错误就在情理之中了，否则就不会打印 C 了。可见，传统的 try/catch 语句并不能捕获 Promise 产生的错误，而需要使用 onRejected 处理程序： 123456789101112let p1 = new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;A&#x27;) throw new Error(&#x27;error&#x27;) console.log(&#x27;B&#x27;)&#125;)let p2 = p1.catch((err) =&gt; &#123; console.log(err)&#125;) setTimeout(console.log, 0, p2)// A// Error: error// Promise &#123;&lt;fulfilled&gt;: undefined&#125; onRejected 捕获了上面抛出的错误后，使得程序正常执行，最后还生成了一个 fulfilled 的新实例。 除了以上这种直接在 executor 里通过 throw 主动抛出一个错误外，还可以通过以下方式产出需要 onRejected 处理的错误： 1234567891011121314151617new Promise((resolve, reject) =&gt; &#123; init() // 被动出错，调用了不存在的函数&#125;)new Promise((resolve, reject) =&gt; &#123; reject()&#125;)new Promise((resolve, reject) =&gt; &#123; resolve()&#125;).then(() =&gt; Promise.reject())new Promise((resolve, reject) =&gt; &#123; resolve()&#125;).then(() =&gt; &#123; throw new Error()&#125;) 注意，如果只是产生了一个错误，却没有抛出来是不会报错的： 1234// 不会报错new Promise((resolve, reject) =&gt; &#123; reject()&#125;).then(() =&gt; new Error()) Promise 出现了错误就需要使用 onRejected 处理程序处理，否则程序就会报错，执行不下去了。 Promise APIPromise.resolve()并非所有的 Promise 的初始状态都是 pending，可以通过 Promise.resolve(value) 来初始化一个状态为 fulfilled，值为 value 的 Promise 实例： 12let p = Promise.resolve(3)console.log(p) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 这个操作和下面这种创建一个 fulfilled 的 Promise 在效果上是一样的： 12let p = new Promise(resolve =&gt; resolve(3))console.log(p) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 使用这个静态方法，理论上可以把任何一个值转换成 Promise： 123setTimeout(console.log, 0, Promise.resolve()) // Promise &#123;&lt;fulfilled&gt;: undefined&#125;setTimeout(console.log, 0, Promise.resolve(3, 6, 9)) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 多余的参数将被忽略setTimeout(console.log, 0, Promise.resolve(new Error(&#x27;error&#x27;))) // Promise &#123;&lt;fulfilled&gt;: Error: error&#125; 这个被转换的值甚至可以是一个 Promise 对象，如果是这样，Promise.resolve 会将其原样输出： 12let p = Promise.resolve(3)setTimeout(console.log, 0, p === Promise.resolve(p)) // true Promise.reject()和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise，且会抛出一个错误，该错误只能通过拒绝处理程序捕获。 12345Promise .reject(3) .catch(err =&gt; &#123; console.log(err) // 3 &#125;) 对于初始化一个 rejected 状态的实例，以下两种写法都可以达到这个目的： 12let p1 = Promise.reject()let p2 = new Promise((resolve, reject) =&gt; reject()) 与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值： 12let p = Promise.reject(3)setTimeout(console.log, 0, p === Promise.reject(p)) // false Promise.all()Promise.all(iterable) 用来将多个 Promise 实例合成一个新实例。参数必须是一个可迭代对象，通常是数组。 1234Promise.all([ Promise.resolve(3), Promise.resolve(6)]) 可迭代对象里的所有元素都会通过 Promise.resolve() 转成 Promise： 1Promise.all([3, 6, 9]) 所有 Promise 都 resolve 后，Promise.all() 才会生成一个 fulfilled 的新实例。且新实例的内部值是由所有 Promise 解决后的值组成的数组： 1234567891011let p1 = Promise.all([ Promise.resolve(&#x27;3&#x27;), Promise.resolve(), 6])let p2 = p1.then(res =&gt; &#123; console.log(res)&#125;)setTimeout(console.log, 0, p1)// [&quot;3&quot;, undefined, 6]// Promise &#123;&lt;fulfilled&gt;: Array(3)&#125; 所有 Promise 中，只要出现一个 pending 状态的实例，那么合成的新实例也是 pending 状态的： 1234567let p1 = Promise.all([ 3, Promise.resolve(6), new Promise(() =&gt; &#123;&#125;)])setTimeout(console.log, 0, p1)// Promise &#123;&lt;pending&gt;&#125; 所有 Promise 中，只要出现一个 rejected 状态的实例，那么合成的新实例也是 rejected 状态的，且新实例的内部值是第一个拒绝 Promise 的内部值： 12345678910111213let p1 = Promise.all([ 3, Promise.reject(6), new Promise((resolve, reject) =&gt; &#123; reject(9) &#125;)])let p2 = p1.catch(err =&gt; &#123; console.log(err)&#125;)setTimeout(console.log, 0, p1)// 6// Promise &#123;&lt;rejected&gt;: 6&#125; Promise.race()Promise.race(iterable) 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。 12345678910111213141516let p1 = Promise.race([ 3, Promise.reject(6), new Promise((resolve, reject) =&gt; &#123; resolve(9) &#125;).then(res =&gt; &#123; console.log(res) &#125;)])let p2 = p1.then(res =&gt; &#123; console.log(err)&#125;)setTimeout(console.log, 0, p1)// 9// 3// Promise &#123;&lt;fulfilled&gt;: 3&#125; 来将上面这串代码变动下： 1234567891011121314151617181920212223242526function init()&#123; console.log(3) return 3&#125;let p1 = Promise.race([ new Promise((resolve, reject) =&gt; &#123; resolve(9) &#125;).then(res =&gt; &#123; console.log(res) return &#x27;A&#x27; &#125;), new Promise((resolve, reject) =&gt; &#123; reject(6) &#125;), init(),])let p2 = p1.then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)setTimeout(console.log, 0, p1)// 3// 9// 6// Promise &#123;&lt;rejected&gt;: 6&#125; 想要知道 Promise.race() 的结果，无非是要知道到底谁才是第一个状态变化的实例，让我们来具体分析下代码执行过程： 迭代第一个元素，执行同步代码 resolve(9)，由 new Promise 初始化的实例的状态已经变为了 fulfilled，所以第一个状态变化的实例已经出现了吗？其实并没有，因为迭代第一个元素的代码还没执行完成呢，然后会将 return &#39;A&#39; 所在函数的这段处理程序推入微任务队列 1； 迭代第二个元素，执行 reject(6)，所以由 new Promise 初始化的实例的状态已经变为 rejected，由于该实例没有处理函数，所以迭代第二个元素的代码已经全部执行完成，此时，第一个状态变化的实例已经产生； 迭代第三个元素，是一个函数，执行同步代码打印出 3，然后用 Promise.resolve 将函数返回值 3 转成一个 Promise &#123;&lt;fulfilled&gt;: 3&#125; 的新实例，这是第二个状态发生变化的实例； 此时所有迭代对象遍历完成，即同步代码执行完成，开始执行微任务队列 1 的内容，打印 res，其值是 9，然后处理程序返回了 ‘A’，此时根据之前提到的知识点，这里会新生成一个 Promise &#123;&lt;fulfilled&gt;: &#39;A&#39;&#125; 的实例，这是第三个状态发生变化的实例。此时，第一个迭代元素的代码已经全部执行完成，所以第一个迭代元素最终生成的实例是第三次状态发生变化的这个； 此时 p1 已经产生，它是 Promise &#123;&lt;rejected&gt;: 6&#125;，所以会将它的处理程序 console.log(err) 所在函数推入微任务队列 2； 执行微任务队列 2 的内容，打印 err，其值是 6； 所有微任务执行完成，开始执行 setTimeout 里的宏任务，打印 p1，至此全部代码执行完成。 Promise.allSettled()Promise.allSettled(iterable) 当所有的实例都已经 settled，即状态变化过了，那么将返回一个新实例，该新实例的内部值是由所有实例的值和状态组合成的数组，数组的每项是由每个实例的状态和内部值组成的对象。 12345678910111213141516171819202122function init()&#123; return 3&#125;let p1 = Promise.allSettled([ new Promise((resolve, reject) =&gt; &#123; resolve(9) &#125;).then(res =&gt; &#123;&#125;), new Promise((resolve, reject) =&gt; &#123; reject(6) &#125;), init()])let p2 = p1.then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)// [// &#123;status: &quot;fulfilled&quot;, value: undefined&#125;, // &#123;status: &quot;rejected&quot;, reason: 6&#125;, // &#123;status: &quot;fulfilled&quot;, value: 3&#125;// ] 只要所有实例中包含一个 pending 状态的实例，那么 Promise.allSettled() 的结果为返回一个这样 Promise &#123;&lt;pending&gt;&#125; 的实例。 Promise.allSettled() 是 ES2020 中新增的方法，所以有一些浏览器可能还暂时不支持。 对于不支持的浏览器，可以写 polyfill： 12345678910111213if(!Promise.allSettled) &#123; Promise.allSettled = function(promises) &#123; return Promise.all(promises.map(p =&gt; Promise.resolve(p) .then(value =&gt; (&#123; status: &#x27;fulfilled&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;rejected&#x27;, reason &#125;)) )); &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"详细设计一个文章页目录插件","slug":"article-catalog","date":"2020-10-14T02:19:26.000Z","updated":"2020-10-14T03:16:39.189Z","comments":true,"path":"2020/10/14/article-catalog/","link":"","permalink":"https://bubuzou.com/2020/10/14/article-catalog/","excerpt":"在说这个插件之前，可以先去 https://bubuzou.com/ 这个网站体验下这个插件的效果，好有个大概的印象。 通过阅读这篇文章，你可以收获什么？ 用 JS 直接操作 DOM 浏览器 BOM 相关知识 性能优化思考 插件设计思考 背景平时我们在用 Markdown 写的文章，如果放到自己的博客或者投稿到掘金等平台，其内容会被浏览器解析成 HTML。而 Markdown 里面的一级（#）、二级（##）、三级标题（###）分别对应于页面的文章标题、一级目录、二级目录。基于此，就可以很好的利用该生成的页面实现一个目录，便于更直观方便的的浏览文章内容，而这就是最初我想为博客里的文章页实现一个目录功能的理由。 这个插件是基于 Hexo 生成的网页来实现的，且目前只支持一级和二级目录，因为作为一篇文章来说有两个层级已经可以很好的将一块内容划分细说得很清楚了。","text":"在说这个插件之前，可以先去 https://bubuzou.com/ 这个网站体验下这个插件的效果，好有个大概的印象。 通过阅读这篇文章，你可以收获什么？ 用 JS 直接操作 DOM 浏览器 BOM 相关知识 性能优化思考 插件设计思考 背景平时我们在用 Markdown 写的文章，如果放到自己的博客或者投稿到掘金等平台，其内容会被浏览器解析成 HTML。而 Markdown 里面的一级（#）、二级（##）、三级标题（###）分别对应于页面的文章标题、一级目录、二级目录。基于此，就可以很好的利用该生成的页面实现一个目录，便于更直观方便的的浏览文章内容，而这就是最初我想为博客里的文章页实现一个目录功能的理由。 这个插件是基于 Hexo 生成的网页来实现的，且目前只支持一级和二级目录，因为作为一篇文章来说有两个层级已经可以很好的将一块内容划分细说得很清楚了。 需求分析位置 首先我打算将文章的目录放置在文章内容的右侧，且是悬浮固定在那里不随浏览器的滚动而滚动。因为我们都习惯从上到下从左到右的去浏览文章，所以我希望首先映入眼帘的是文章内容而不是文章目录；另外因为我的博客的首页和文章列表页都是左侧是浏览区域而右侧是操作区域，所以把目录放到右侧能保持整站的布局统一以及操作的便利性。 需要做什么 首先需要根据文章内容的二级和三级标题生成目录； 然后，页面从上到下滚动过程中，需要在右侧目录里高亮当前的标题，而高亮的原则是当前标题所在的位置到浏览器可视区域顶部的距离需要小于或等于一个固定值，如上图所示； 在合适的时候滚动目录列表，使得当前高亮的子目录会出现在滚动区域内部，且尽量处于滚动区域的中间区域； 当点击某个子目录的时候需要高亮当前点击的目录，且文章内容滚动到对应目录的位置，使得点击目录对应的文章标题所在的位置距离可视区域顶部的距离刚好等于一个固定值。 滚动目录的机制是怎样的对于的第三点提到在合适的时候滚动目录，那什么时候才算合适呢？目录能不能滚动，以及怎么滚动总共分为以下 5 种情况： 当目录能在滚动区域完全显示的时候，即滚动区域高度大于所有目录子项高度总和的时候，不进行目录滚动，如上面的图 ① ； 当目录不能在滚动区域完全显示的时候，目录需要滚动。所以需要做的就是在一个划定的区域内滚动目录，超出该区域的目录子项将会自动隐藏。通过滚动目录，我们可以实现目录列表的头尾两个目录子项都能很好的在划定区域里显示出来。随着页面的滚动，目录将从头滚到尾，那么滚动的范围是从第一个子目录贴着滚动区域的顶部到最后一个子目录贴着滚动区域的底部为止； 当页面在最顶部的时候，当前高亮的子目录肯定是第一个，随着页面的向下滚动，高亮的位置也在不断下移，当高亮位置移动到在目录滚动区域的上半部分之前，这段不进行目录滚动，如上面的图 ② 到 图 ③ 的变化过程； 当第一个子目录贴着滚动区域的顶部，且高亮位置在中位往下继续滚动的时候，需要进行目录滚动，滚动的距离是当前高亮目录所在位置距离滚动区域中间位置的高度差，如上面的图 ③ 到图 ④ 的变化过程； 如果这个高度差过于大，使得滚动后最后一个子元素不能贴着滚动区域底部的时候，则不按照这个高度差进行滚动，而真实需要滚动的距离是最后一个子目录到滚动区域底部的距离，如上面的图 ④ 到图 ⑤ 的变化过程。 功能实现由于文章页是由 Hexo 基于 Markdown 生成而来的，所以它有自己特定的 HTML 格式，它的格式大概是如下这样： 123456789101112131415&lt;h2 id=&quot;7种组件通信方式随你选&quot;&gt; &lt;a href=&quot;&quot; class=&quot;headerlink&quot; title=&quot;7种组件通信方式随你选&quot;&gt;&lt;/a&gt; 7种组件通信方式随你选&lt;/h2&gt;&lt;!-- 这里是部分文章内容 --&gt;&lt;h3 id=&quot;props-on-emit&quot;&gt; &lt;a href=&quot;&quot; class=&quot;headerlink&quot; title=&quot;props/@on+$emit&quot;&gt;&lt;/a&gt; props/@on+$emit&lt;/h3&gt;&lt;!-- 这里是部分文章内容 --&gt;&lt;h3 id=&quot;$attrs和$listeners&quot;&gt; &lt;a href=&quot;&quot; class=&quot;headerlink&quot; title=&quot;$attrs和$listeners&quot;&gt;&lt;/a&gt; $attrs和$listeners&lt;/h3&gt;&lt;!-- 这里是部分文章内容 --&gt; 可以看到所有的二级标题（H2）和三级标题（H3）都是在同一个父元素下面，且每个标题下面都包含了一个带有 headerlink 类名的链接，另外还有标题属性。 这个时候我们就能很容易的获取到所有的标题： 1let arContentAnchor = document.querySelectorAll(&#x27;.headerlink&#x27;) 上面这串代码的结果会返回一个 NodeList，有了它我们就可以去生成目录了。 生成目录 生成目录无非就是产生一串 HTML，除此之外还有哪些要做的呢？首先要确定下，目录都包含了哪些部分，如上图所示这里大概是包含了 3 部分：目录条、序号和标题。那么就可以先确定好 HTML 结构： 123456789101112&lt;div class=&quot;arCatalog&quot;&gt; &lt;div class=&quot;arCatalog-line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;arCatalog-body&quot;&gt; &lt;dl&gt; &lt;dd class=&quot;arCatalog-tack1 on&quot;&gt; &lt;span class=&quot;arCatalog-index&quot;&gt;1&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;7种组件通信方式随你选&lt;/a&gt; &lt;span class=&quot;arCatalog-dot&quot;&gt;&lt;/span&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt;&lt;/div&gt; 其中，arCatalog-line 表示目录条，arCatalog-body 是滚动区域，dl 是滚动列表，dd 是目录子项，arCatalog-index 是目录序号，链接里放的是子目录标题。有了 HTML ，接下来要做的就是把目录的样式写好，写完后样式比较多，所以就不在这里贴出来了。 生成目录到这里就完事了吗？并没有，由于浏览器可视区域是不固定的，所以我们需要计算出目录所在滚动区域的高度。 滚动高度 = n个目录子项 * 子项的实际高度 先说子项的实际高度，对于目录子项的样式上，我这里没有用内间距和外边距，而是通过 line-height 来控制他们之间的间隙，那么： 子项的实际高度 = 子项的行高 再说 n 个目录子项，那到底 n 是多少呢？在目录的 Y 轴方向上，除了有目录，还有顶部的菜单，以及为了美观还需要适当的留白，所以： n = (视口高度 - （顶部菜单高度 + 留白高度））/ 子项行高 所以，最终我们可以计算出滚动高度： 123456789101112131415let DEFAULT = &#123; lineHeight: 28, // 每个菜单的行高是 28 moreHeight: 10, // 菜单左侧的线比菜单多出的高度 surplusHeight: 180, // 除了菜单高度+留白高度 delay: 200, // 防抖的延迟时间 duration: 200, // 滚动的动画持续时间 toTopDistance: 80, // 距离视口顶部多少高度之内时候触发高亮 selector: &#x27;.headerlink&#x27;, // 文章内容中标题标签的 selector&#125;// maxCatalogCount 就是上面提到的 n 个目录子项中的 nlet maxCatalogCount = Math.floor((window.innerHeight - DEFAULT.surplusHeight) / DEFAULT.lineHeight) // 滚动区域高度let catalogHeight = arContentAnchor.length &gt; maxCatalogCount ? maxCatalogCount * DEFAULT.lineHeight : arContentAnchor.length * DEFAULT.lineHeight; 完整的生成目录的函数代码如下： 1234567891011121314151617181920212223242526272829303132333435363738// 生成目录function generateCatalog()&#123; let catalogHeight = arContentAnchor.length &gt; maxCatalogCount ? maxCatalogCount * DEFAULT.lineHeight : arContentAnchor.length * DEFAULT.lineHeight; let retStr = ` &lt;div class=&quot;arCatalog&quot;&gt; &lt;div class=&quot;arCatalog-line&quot; style=&quot;height: $&#123;catalogHeight + DEFAULT.moreHeight&#125;px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;arCatalog-body&quot; style=&quot;max-height: $&#123;catalogHeight&#125;px; height: $&#123;catalogHeight&#125;px&quot;&gt; &lt;dl style=&quot;margin-top: $&#123;marginTop&#125;px&quot;&gt;`; let h2Index = 0, h3Index = 1, acIndex = &#x27;&#x27;, tagName = &#x27;&#x27;, index = 0; for (let currNode of arContentAnchor) &#123; tagName = currNode.parentElement.tagName if ( tagName === &#x27;H3&#x27; ) &#123; acIndex = `$&#123;h2Index&#125;.$&#123;h3Index++&#125;` className = &#x27;arCatalog-tack2&#x27; &#125; else &#123; acIndex = ++h2Index h3Index = 1 className = &#x27;arCatalog-tack1&#x27; &#125; retStr += ` &lt;dd class=&quot;$&#123;className&#125; $&#123;index++ === lastOnIndex ? &#x27;on&#x27; : &#x27;&#x27;&#125;&quot;&gt; &lt;span class=&quot;arCatalog-index&quot;&gt;$&#123;acIndex&#125;&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;$&#123;currNode.title&#125;&lt;/a&gt; &lt;span class=&quot;arCatalog-dot&quot;&gt;&lt;/span&gt; &lt;/dd&gt;` &#125;; retStr += `&lt;/dl&gt;&lt;/div&gt;&lt;/div&gt;` document.getElementById(&#x27;arAnchorBar&#x27;).innerHTML = retStr&#125; 设置滚动监听事件给 window 加上滚动事件，用于监听当滚动的时候去做一些操作，这里的操作就是设置高亮和滚动目录。 12345678910window.addEventListener(&#x27;scroll&#x27;, function() &#123; setHighlight()&#125;, false)// 只有目录总数超过滚动区域可容纳最大目录数的时候，目录才需要滚动if (catalogLength &gt; maxCatalogCount) &#123; window.addEventListener(&#x27;scroll&#x27;, function() &#123; scrollCatalog() &#125;, false)&#125; 如上这样就能监听浏览器滚动事件，从而做一些事情啦。但是这样会导致函数被频繁调用，从而存在性能问题，其实我们更希望当滚动开始到滚动结束的时候，只执行一次函数即可，那这个直接上防抖即可： 12345678910// 防抖：触发高频事件 n 秒后只会执行一次，如果 n 秒内事件再次触发，则会重新计时。function debounce(fn, delay = 200) &#123; return function(args) &#123; const _this = this clearTimeout(fn.id) fn.id = setTimeout(function() &#123; fn.apply(_this, args) &#125;, delay) &#125;&#125; 然后我们只需要把 scroll 监听回调里的函数对应换成如下的即可： 12345678910window.addEventListener(&#x27;scroll&#x27;, function() &#123; debounce(setHighlight, DEFAULT.delay)() debounce(resetStatus, DEFAULT.delay)()&#125;, false)if (catalogLength &gt; maxCatalogCount) &#123; window.addEventListener(&#x27;scroll&#x27;, function() &#123; debounce(scrollCatalog, DEFAULT.delay)() &#125;, false)&#125; 高亮当前目录 这部分内容开始前，我们先来复习一个 API，该方法会返回元素的大小及其相对于视口的位置： 1Element.getBoundingClientRect() 需求分析的时候有提到，高亮的原则是当前标题所在的位置到浏览器可视区域顶部的距离需要小于或等于一个固定值： 1arContentAnchor[index].getBoundingClientRect().top &lt;= DEFAULT.toTopDistance 所以当遍历 arContentAnchor 这个列表，某项的位置小于固定值，且差值最小的时候，该项对应的目录就应该被设置为高亮： 1234567891011121314151617let curr = document.querySelector(&#x27;.arCatalog .on&#x27;)curr.classList.remove(&#x27;on&#x27;)let nextOnIndex = 0, currNode;while (nextOnIndex &lt; arContentAnchor.length) &#123; currNode = arContentAnchor[nextOnIndex] if (currNode.getBoundingClientRect().top &lt;= DEFAULT.toTopDistance) &#123; nextOnIndex++ &#125; else &#123; break &#125;&#125;nextOnIndex = nextOnIndex === arContentAnchor.length ? nextOnIndex - 1 : nextOnIndex;let catalogDd = document.querySelectorAll(&#x27;.arCatalog dd&#x27;)catalogDd[nextOnIndex].classList.add(&#x27;on&#x27;) 到此一切都看起来很美好，但是上面这段代码存在性能问题，只要页面一滚动就会从第一个目录到最后一个目录之间进行查找，知道找到那个符合要求的为止，这样的话遍历次数太多了。 我们知道页面滚动无非就是在当前这个位置的前提下，往上滚动或者向下滚动，如果我们把 nextOnIndex 记为滚动前的索引，在根据滚动方向进行加加减减不就可以很好的减少遍历次数嘛？想法貌似不错，来试一下。 首先我们要判断当前滚动是向上还是向下滚动，可以根据两次滚动前后的偏移量来判断： 向上滚动 = 滚动后偏移量 &lt; 滚动前偏移量 1234567891011let lastSH = window.pageYOffset// 获取最近一次页面的滚动方向function getScrollDirection() &#123; let sh = window.pageYOffset, ret = &#x27;bottom&#x27; if (sh &lt; lastSH) &#123; ret = &#x27;top&#x27; &#125; lastSH = sh return ret&#125; 知道了滚动方向，我们就可以很好的写出设置高亮的优化代码： 12345678910111213141516171819202122let curr = document.querySelector(&#x27;.arCatalog .on&#x27;)let nextOnIndex = onIndex;if (defaultDirec === &#x27;bottom&#x27;) &#123; while (nextOnIndex &lt; catalogLength) &#123; let currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top if ( currTop &gt; DEFAULT.toTopDistance &amp;&amp; nextOnIndex &gt; 0)&#123; nextOnIndex-- break &#125; nextOnIndex++ &#125;&#125; else &#123; while (nextOnIndex &gt;= 0) &#123; let currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top if ( currTop &lt;= DEFAULT.toTopDistance)&#123; break &#125; nextOnIndex-- &#125;&#125;nextOnIndex = nextOnIndex === arContentAnchor.length ? nextOnIndex - 1 : nextOnIndex &lt; 0 ? 0 : nextOnIndex catalogDd[nextOnIndex].classList.add(&#x27;on&#x27;) 优化后的遍历次数明显减少，而且遍历次数基本上是小于或等于滚动前后目录索引的差值。虽然经过优化后，已经明显的减少了遍历次数，但是我还想再优化一下。纳尼？ 很多文章页很长，所以有回到顶部这种功能，试想一下，如果当前页面已经滚动到最底部，这个时候来一下回到顶部，那刚刚写的优化代码会遍历几次？答案是：遍历次数将会是目录子项的总数。文章最开始提到的那个体验地址的那篇文章 34条我能告诉你的Vue之实操篇 有 43 个子目录，所以需要遍历 43 次，真的不能接受结果，所以再来优化一次。 二次优化主要是处理边际问题，即滚动到头尾部的时候加上判断，最终二次优化后的高亮当前目录函数如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 高亮当前目录function setHighlight()&#123; defaultDirec = getScrollDirection() if (hasStopSetHighlight) &#123; return &#125; let &#123; scrollTop, &#125; = document.scrollingElement; let curr = document.querySelector(&#x27;.arCatalog .on&#x27;) let onIndex = [].indexOf.call(catalogDd, curr), // 当前高亮索引 nextOnIndex = onIndex; // 滚动后高亮索引 curr.classList.remove(&#x27;on&#x27;) let scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight if (arContentAnchor[catalogLength - 1].getBoundingClientRect().top &lt;= DEFAULT.toTopDistance || window.innerHeight + window.pageYOffset === scrollHeight) &#123; // 尾部 lastOnIndex = catalogLength - 1 catalogDd[lastOnIndex].classList.add(&#x27;on&#x27;) &#125; else if (scrollTop &lt;= firstDdTop) &#123; // 顶部 catalogDd[0].classList.add(&#x27;on&#x27;) lastOnIndex = 0 &#125; else &#123; // 中间：使用缓存，直接从上一次索引（onIndex）位置开始查找 if (defaultDirec === &#x27;bottom&#x27;) &#123; while (nextOnIndex &lt; catalogLength) &#123; let currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top if ( currTop &gt; DEFAULT.toTopDistance &amp;&amp; nextOnIndex &gt; 0)&#123; nextOnIndex-- break &#125; nextOnIndex++ &#125; &#125; else &#123; while (nextOnIndex &gt;= 0) &#123; let currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top if ( currTop &lt;= DEFAULT.toTopDistance)&#123; break &#125; nextOnIndex-- &#125; &#125; nextOnIndex = nextOnIndex === catalogLength ? nextOnIndex - 1 : nextOnIndex &lt; 0 ? 0 : nextOnIndex lastOnIndex = nextOnIndex catalogDd[nextOnIndex].classList.add(&#x27;on&#x27;) &#125;&#125; 滚动目录 根据之前需求分析里的说明，我们可以知道当浏览器向下滚动的时候，会分成 3 种情况： 滚动后的高亮子目录处于于滚动区域上半部分，即中位线以上，此时目录不进行滚动，如上图 ①； 滚动后的高亮子目录处于滚动区域的下半部分，即中位线以下，此时目录的滚动距离将是滚动后高亮子目录的底部位置到中位线的高度差，如上图 ②； 滚动后的高亮目录处于中位线以下且最后一个子目录需要贴着滚动区域底部，此时目录的滚动距离将是滚动列表底部到滚动区域底部的高度差，如上图 ③。 1234567891011let catalogBody = document.querySelector(&#x27;.arCatalog-body&#x27;), initBodyTop = catalogBody..getBoundingClientRect().top, bodyMidBottom = initBodyTop + Math.ceil((maxCatalogCount / 2 )) * DEFAULT.lineHeight; // 中位线位置 if (curr.bottom + (maxCatalogCount / 2) * DEFAULT.lineHeight &lt;= bodyBCR.bottom) &#123; // 上半部分 // 不滚动&#125; else if (curr.bottom - bodyMidBottom &lt; list.bottom - bodyBCR.bottom) &#123; // 中位以下 marginTop += -Math.floor((curr.bottom - bodyMidBottom ) / DEFAULT.lineHeight) * DEFAULT.lineHeight&#125; else if (bodyBCR.bottom &lt;= list.bottom) &#123; // 当剩余滚动距离 marginTop = bodyBCR.bottom - initDlBottom&#125; 同理，当浏览器向上滚动的时候，也能很好的得出其滚动逻辑： 1234567if (bodyBCR.top + (maxCatalogCount / 2) * DEFAULT.lineHeight &lt;= curr.top) &#123; // 不滚动&#125; else if (bodyMidBottom - curr.top &lt; bodyBCR.top - list.top) &#123; marginTop += Math.floor((bodyMidBottom - curr.top) / DEFAULT.lineHeight) * DEFAULT.lineHeight&#125; else if (list.top &lt;= bodyBCR.top) &#123; marginTop = 0&#125; 最终的滚动目录函数完整代码： 1234567891011121314151617181920212223242526// 自动滚动目录树，使得当前高亮目录在可视范围内function scrollCatalog() &#123; let currentCatalog = document.querySelector(&#x27;.arCatalog .on&#x27;); let curr = currentCatalog.getBoundingClientRect(), list = catalogDl.getBoundingClientRect(); if (defaultDirec === &#x27;bottom&#x27;) &#123; // 向下滚动 if (curr.bottom + (maxCatalogCount / 2) * DEFAULT.lineHeight &lt;= bodyBCR.bottom) &#123; // 上半部分 // 不滚动 &#125; else if (curr.bottom - bodyMidBottom &lt; list.bottom - bodyBCR.bottom)&#123; // 中位以下 marginTop += -Math.floor((curr.bottom - bodyMidBottom ) / DEFAULT.lineHeight) * DEFAULT.lineHeight &#125; else if (bodyBCR.bottom &lt;= list.bottom) &#123; // 当剩余滚动距离 marginTop = bodyBCR.bottom - initDlBottom &#125; &#125; else &#123; // 向上滚动 if (bodyBCR.top + (maxCatalogCount / 2) * DEFAULT.lineHeight &lt;= curr.top) &#123; // 不滚动 &#125; else if (bodyMidBottom - curr.top &lt; bodyBCR.top - list.top) &#123; marginTop += Math.floor((bodyMidBottom - curr.top) / DEFAULT.lineHeight) * DEFAULT.lineHeight &#125; else if (list.top &lt;= bodyBCR.top) &#123; marginTop = 0 &#125; &#125; catalogDl.style.marginTop = marginTop + &#x27;px&#x27;&#125; 子目录点击事件当点击子目录的时候需要做 2 件事情，第一是滚动页面到对应的目录位置，然后是高亮当前点击的目录； 滚动页面到对应的目录位置： 12345678910// 给目录子项绑定事件let catalogDd = document.querySelectorAll(&#x27;.arCatalog dd&#x27;); catalogDd.forEach((curr, index) =&gt; &#123; curr.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() let currTop = arContentAnchor[index].getBoundingClientRect().top document.documentElement.scrollTop = document.body.scrollTop = currTop + window.pageYOffset - DEFAULT.toTopDistance &#125;, false)&#125;); 这样实现页面的滚动是没什么问题，就是体验不太好，突然从一个位置滚动到另外一个位置，显得突兀，能不能来点动画效果？类似 jQuery 的 animate() ？没问题，我们来尝试着实现一下。 用 JS 实现动画效果，一定离不开定时器，诸如 setTimeout、setInterval 之类，但是这次我不打算用他们，而是用 HTML5 中增加的 requestAnimationFrame，这是一个专门为浏览器实现动画而提供的 API。它虽然也是个定时器，但是相比于另外两个，他不需要传递时间，因为传递的回调函数里自带了参数 DOMHighResTimeStamp，这个参数表示回调函数被触发的时间。 除此之外，requestAnimationFrame 中的回调函数执行次数通常是每秒60次，即大概每 16.6 毫秒执行一次回调函数，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。好了，对于 requestAnimationFrame 的介绍就到这里，下面我们直接来说下动画实现滚动的核心原理： 每次滚动距离 = ( 滚动距离 / 动画持续时间 ) * 每次动画执行时间距离第一次执行时间的差值 + 当前滚动距离 直接来看完整的动画实现滚动的函数： 123456789101112131415161718192021// 滚动到目标位置function scrollToDest(destScrollTop) &#123; let startTime; let currScrollTop = window.pageYOffset; let duration = 200; function step(timestamp) &#123; if (!startTime) &#123; startTime = timestamp &#125; const elapsed = Math.round(timestamp - startTime) const distance = elapsed * ((Math.floor(destScrollTop) - currScrollTop) / duration) + currScrollTop document.documentElement.scrollTop = document.body.scrollTop = distance if (elapsed &lt; duration) &#123; window.requestAnimationFrame(step) &#125; &#125; window.requestAnimationFrame(step)&#125; 好了，现在有了动画函数，我们需要改写下子目录的点击事件，给滚动加上过渡效果，让人体验起来更加舒服： 123456789let catalogDd = document.querySelectorAll(&#x27;.arCatalog dd&#x27;);catalogDd.forEach((curr, index) =&gt; &#123; curr.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() let currTop = arContentAnchor[index].getBoundingClientRect().top scrollToDest(currTop + window.pageYOffset - DEFAULT.toTopDistance) &#125;, false)&#125;); 第一件事已经做好，接下来做第二件事，高亮当前点击某个子目录： 1234567891011121314// 给目录子项绑定事件let catalogDd = document.querySelectorAll(&#x27;.arCatalog dd&#x27;);catalogDd.forEach((curr, index) =&gt; &#123; curr.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() hasStopSetHighlight = true document.querySelector(&#x27;.arCatalog .on&#x27;).classList.remove(&#x27;on&#x27;) catalogDd[index].classList.add(&#x27;on&#x27;) lastOnIndex = index let currTop = arContentAnchor[index].getBoundingClientRect().top scrollToDest(currTop + window.pageYOffset - DEFAULT.toTopDistance) &#125;, false)&#125;); 如上即可，但是由于点击了某个子目录，页面会进行滚动，而页面滚动又会触发 setHighlight 函数对目录进行高亮，所以我这里的做法是用了一个全局变量 hasStopSetHighlight 用来控制当点击子目录的时候，不进行 setHighlight 设置高亮操作。 浏览器视口高度变了怎么办因为我们的滚动高度是根据浏览器视口高度计算出来的，如果浏览器视口高度变化了，那这个时候再去滚动页面，那肯定会出问题的。所以需要做的就是把和视口高度有关的逻辑抽离出来，统一放到一个函数里，当监听到视口高度变化的时候，再去执行这个函数。 先来写监听函数，同样用上了防抖函数处理： 123window.addEventListener(&#x27;resize&#x27;, function(e) &#123; debounce(initCatalog, DEFAULT.delay)()&#125;, false) 然后去把相关逻辑抽离出来： 1234567891011121314151617181920212223242526272829303132333435// 初始化function initCatalog() &#123; let tempHeight = window.innerHeight if (viewPortHeight !== tempHeight) &#123; viewPortHeight = tempHeight maxCatalogCount = Math.floor((viewPortHeight - DEFAULT.surplusHeight) / DEFAULT.lineHeight) generateCatalog() catalogLength = arContentAnchor.length lastSH = window.pageYOffset catalogBody = document.querySelector(&#x27;.arCatalog-body&#x27;) catalogDl = document.querySelector(&#x27;.arCatalog dl&#x27;) catalogDd = document.querySelectorAll(&#x27;.arCatalog dd&#x27;) bodyBCR = catalogBody.getBoundingClientRect() initBodyTop = bodyBCR.top initDlBottom = initDlBottom || catalogDl.getBoundingClientRect().bottom firstDdTop = firstDdTop || catalogDd[0].getBoundingClientRect().top, bodyMidBottom = initBodyTop + Math.ceil((maxCatalogCount / 2 )) * DEFAULT.lineHeight; // 给目录子项绑定事件 catalogDd.forEach((curr, index) =&gt; &#123; curr.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() hasStopSetHighlight = true document.querySelector(&#x27;.arCatalog .on&#x27;).classList.remove(&#x27;on&#x27;) catalogDd[index].classList.add(&#x27;on&#x27;) lastOnIndex = index let currTop = arContentAnchor[index].getBoundingClientRect().top scrollToDest(currTop + window.pageYOffset - DEFAULT.toTopDistance) &#125;, false) &#125;); &#125;&#125; 浏览器视口高度变化后，这里有个细节需要提一下，那就是滚动目录的 margin-top 以及高亮位置是希望变化的，所以我们需要使用全局变量进行提前保存起来，分别用到的全局变量是 marginTop 和 lastOnIndex。 组装上面的代码都是把不同的功能点提取到函数里进行操作，看起来比较散乱，所以我们需要看看一个完整的目录插件应该是什么样子？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * articleCatalog v2.0 * Copyright(c) 2016 by bulandent * Date: 2017-5-27 16:10:41 * Updated: 2020-10-10 17:40:04**/let articleCatalog = (function() &#123; if ( document.querySelectorAll(&#x27;.headerlink&#x27;).length === 0 || window.innerWidth &lt; 900 ) &#123; return function()&#123;&#125;; &#125; let DEFAULT = &#123; lineHeight: 28, // 每个菜单的行高是 28 moreHeight: 10, // 菜单左侧的线比菜单多出的高度 surplusHeight: 180, // 除了菜单高度+留白高度 delay: 200, // 防抖的延迟时间 duration: 200, // 滚动的动画持续时间 toTopDistance: 80, // 距离视口顶部多少高度之内时候触发高亮 selector: &#x27;.headerlink&#x27;, // 文章内容中标题标签的 selector &#125; return function(args) &#123; DEFAULT = Object.assign(DEFAULT, args) let arContentAnchor = document.querySelectorAll(DEFAULT.selector), catalogLength = arContentAnchor.length, maxCatalogCount = 0, // 视口内能容纳的最大目录个数 viewPortHeight = 0, // 当前视口的高度 marginTop = 0, // 菜单的初始滚动距离 defaultDirec = &#x27;bottom&#x27;, // 默认滚动方向 lastSH = 0, // 获取页面初始滚动距离 lastOnIndex = 0, // 上次高亮的目录索引 catalogBody = [], // .arCatalog-body catalogDl = null, // .arCatalog-body dl catalogDd = [], // .arCatalog-body dd initBodyTop = 0, // 目录可视区域的 top initDlBottom = 0, // 目录 dl 的 bottom firstDdTop = 0, // 第一个 dd 的 top bodyMidBottom = 0, // 目录可视区域的中间位置的 dd 的 bottom bodyBCR = null, // 目录可视区域的边界值 hasStopSetHighlight = false; // 在点击目录子项的时候直接高亮当前目录，而不通过 scroll 事件触发 setHighlight 函数 initCatalog() window.addEventListener(&#x27;scroll&#x27;, function() &#123; debounce(setHighlight, DEFAULT.delay)() &#125;, false) if (catalogLength &gt; maxCatalogCount) &#123; window.addEventListener(&#x27;scroll&#x27;, function() &#123; debounce(scrollCatalog, DEFAULT.delay)() &#125;, false) &#125; window.addEventListener(&#x27;resize&#x27;, function(e) &#123; debounce(initCatalog, DEFAULT.delay)() &#125;, false) // 此处声明初始化函数 initCatalog // 此处声明生成目录函数 generateCatalog // 此处声明设置高亮函数 setHighlight // 此处声明滚动目录函数 scrollCatalog // 此处声明动画实现滚动函数 scrollToDest // 此处声明防抖函数 debounce // 此处声明获取滚动方向函数 getScrollDirection function resetStatus() &#123; if (hasStopSetHighlight) &#123; hasStopSetHighlight = false &#125; &#125; &#125;&#125;()); 使用插件然后在实际页面里使用的时候，只需要引入 articleCatalog.js，然后直接用调用函数即可： 1articleCatalog() 当然调用的时候也支持传入一些参数，参数说明如下： 123456789articleCatalog(&#123; lineHeight: 28, &#x2F;&#x2F; 每个菜单的行高是 28 moreHeight: 10, &#x2F;&#x2F; 菜单左侧的线比菜单多出的高度 surplusHeight: 180, &#x2F;&#x2F; 除了菜单高度+留白高度 delay: 200, &#x2F;&#x2F; 防抖的延迟时间 duration: 200, &#x2F;&#x2F; 滚动的动画持续时间 toTopDistance: 80, &#x2F;&#x2F; 距离视口顶部多少高度之内时候触发高亮 selector: &#39;.headerlink&#39;, &#x2F;&#x2F; 文章内容中标题标签的 selector&#125;) 注意传入参数也是瞎传的，需要配合该插件的样式，否则容易程问题。比如明明页面中子目录的真实行高是 28px，你却传入 lineHeight: 24，那肯定是不行的。 使用这个插件是有前提的，那就是其文章页的 HTML 结构必须满足上面提到的那种结构才行，且只支持两级子目录。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"34条我能告诉你的Vue之实操篇","slug":"vue-operate","date":"2020-09-21T02:22:22.564Z","updated":"2020-10-23T08:12:11.394Z","comments":true,"path":"2020/09/21/vue-operate/","link":"","permalink":"https://bubuzou.com/2020/09/21/vue-operate/","excerpt":"这是我学习整理的关于 Vue.js 系列文章的第一篇，另外还有两篇分别是关于优化和原理的。希望读完这3篇文章，你能对 Vue 有个更深入的认识。 7种组件通信方式随你选组件通信是 Vue 的核心知识，掌握这几个知识点，面试开发一点问题都没有。 props/@on+$emit用于实现父子组件间通信。通过 props 可以把父组件的消息传递给子组件： 12&lt;!-- parent.vue --&gt;&lt;child :title=&quot;title&quot;&gt;&lt;/child&gt;","text":"这是我学习整理的关于 Vue.js 系列文章的第一篇，另外还有两篇分别是关于优化和原理的。希望读完这3篇文章，你能对 Vue 有个更深入的认识。 7种组件通信方式随你选组件通信是 Vue 的核心知识，掌握这几个知识点，面试开发一点问题都没有。 props/@on+$emit用于实现父子组件间通信。通过 props 可以把父组件的消息传递给子组件： 12&lt;!-- parent.vue --&gt;&lt;child :title=&quot;title&quot;&gt;&lt;/child&gt; 1234567// child.vueprops: &#123; title: &#123; type: String, default: &#x27;&#x27;, &#125;&#125; 这样一来 this.title 就直接拿到从父组件中传过来的 title 的值了。注意，你不应该在子组件内部直接改变 prop，这里就不多赘述，可以直接看官网介绍。 而通过 @on+$emit 组合可以实现子组件给父组件传递信息： 12&lt;!-- parent.vue --&gt;&lt;child @changeTitle=&quot;changeTitle&quot;&gt;&lt;/child&gt; 12// child.vuethis.$emit(&#x27;changeTitle&#x27;, &#x27;bubuzou.com&#x27;) $attrs和$listenersVue_2.4 中新增的 $attrs/$listeners 可以进行跨级的组件通信。$attrs 包含了父级作用域中不作为 prop 的属性绑定（class 和 style 除外），好像听起来有些不好理解？没事，看下代码就知道是什么意思了： 12&lt;!-- 父组件 index.vue --&gt;&lt;list class=&quot;list-box&quot; title=&quot;标题&quot; desc=&quot;描述&quot; :list=&quot;list&quot;&gt;&lt;/list&gt; 1234567// 子组件 list.vueprops: &#123; list: [],&#125;,mounted() &#123; console.log(this.$attrs) // &#123;title: &quot;标题&quot;, desc: &quot;描述&quot;&#125;&#125; 在上面的父组件 index.vue 中我们给子组件 list.vue 传递了4个参数，但是在子组件内部 props 里只定义了一个 list，那么此时 this.$attrs 的值是什么呢？首先要去除 props 中已经绑定了的，然后再去除 class 和 style，最后剩下 title 和 desc 结果和打印的是一致的。基于上面代码的基础上，我们在给 list.vue 中加一个子组件： 12&lt;!-- 子组件 list.vue --&gt;&lt;detail v-bind=&quot;$attrs&quot;&gt;&lt;/detial&gt; 12345// 孙子组件 detail.vue// 不定义props，直接打印 $attrsmounted() &#123; console.log(this.$attrs) // &#123;title: &quot;标题&quot;, desc: &quot;描述&quot;&#125;&#125; 在子组件中我们定义了一个 v-bind=&quot;$attrs&quot; 可以把父级传过来的参数，去除 props、class 和 style 之后剩下的继续往下级传递，这样就实现了跨级的组件通信。 $attrs 是可以进行跨级的参数传递，实现父到子的通信；同样的，通过 $listeners 用类似的操作方式可以进行跨级的事件传递，实现子到父的通信。$listeners 包含了父作用域中不含 .native 修饰的 v-on 事件监听器，通过 v-on=&quot;$listeners&quot; 传递到子组件内部。 12345&lt;!-- 父组件 index.vue --&gt;&lt;list @change=&quot;change&quot; @update.native=&quot;update&quot;&gt;&lt;/list&gt;&lt;!-- 子组件 list.vue --&gt;&lt;detail v-on=&quot;$listeners&quot;&gt;&lt;/detail&gt; 12345// 孙子组件 detail.vuemounted() &#123; this.$listeners.change() this.$listeners.update() // TypeError: this.$listeners.update is not a function&#125; provide/inject组合拳provide/inject 组合以允许一个祖先组件向其所有子孙后代注入一个依赖，可以注入属性和方法，从而实现跨级父子组件通信。在开发高阶组件和组件库的时候尤其好用。 123456789101112131415161718192021222324// 父组件 index.vuedata() &#123; return &#123; title: &#x27;bubuzou.com&#x27;, &#125;&#125;provide() &#123; return &#123; detail: &#123; title: this.title, change: (val) =&gt; &#123; console.log( val ) &#125; &#125; &#125;&#125;// 孙子组件 detail.vueinject: [&#x27;detail&#x27;],mounted() &#123; console.log(this.detail.title) // bubuzou.com this.detail.title = &#x27;hello world&#x27; // 虽然值被改变了，但是父组件中 title 并不会重新渲染 this.detail.change(&#x27;改变后的值&#x27;) // 执行这句后将打印：改变后的值 &#125; provide 和 inject 的绑定对于原始类型来说并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。这也就是为什么在孙子组件中改变了 title，但是父组件不会重新渲染的原因。 EventBus以上三种方式都是只能从父到子方向或者子到父方向进行组件的通信，而我就比较牛逼了😀，我还能进行兄弟组件之间的通信，甚至任意2个组件间通信。利用 Vue 实例实现一个 EventBus 进行信息的发布和订阅，可以实现在任意2个组件之间通信。有两种写法都可以初始化一个 eventBus 对象： 通过导出一个 Vue 实例，然后再需要的地方引入： 123// eventBus.jsimport Vue from &#x27;vue&#x27;export const EventBus = new Vue() 使用 EventBus 订阅和发布消息： 1234567import &#123;EventBus&#125; from &#x27;../utils/eventBus.js&#x27;// 订阅处EventBus.$on(&#x27;update&#x27;, val =&gt; &#123;&#125;)// 发布处EventBus.$emit(&#x27;update&#x27;, &#x27;更新信息&#x27;) 在 main.js 中初始化一个全局的事件总线： 12// main.jsVue.prototype.$eventBus = new Vue() 使用： 12345// 需要订阅的地方this.$eventBus.$on(&#x27;update&#x27;, val =&gt; &#123;&#125;)// 需要发布信息的地方this.$eventBus.$emit(&#x27;update&#x27;, &#x27;更新信息&#x27;) 如果想要移除事件监听，可以这样来： 1this.$eventBus.$off(&#x27;update&#x27;, &#123;&#125;) 上面介绍了两种写法，推荐使用第二种全局定义的方式，可以避免在多处导入 EventBus 对象。这种组件通信方式只要订阅和发布的顺序得当，且事件名称保持唯一性，理论上可以在任何 2 个组件之间进行通信，相当的强大。但是方法虽好，可不要滥用，建议只用于简单、少量业务的项目中，如果在一个大型繁杂的项目中无休止的使用该方法，将会导致项目难以维护。 Vuex进行全局的数据管理Vuex 是一个专门服务于 Vue.js 应用的状态管理工具。适用于中大型应用。Vuex 中有一些专有概念需要先了解下： State：用于数据的存储，是 store 中的唯一数据源； Getter：类似于计算属性，就是对 State 中的数据进行二次的处理，比如筛选和对多个数据进行求值等； Mutation：类似事件，是改变 Store 中数据的唯一途径，只能进行同步操作； Action：类似 Mutation，通过提交 Mutation 来改变数据，而不直接操作 State，可以进行异步操作； Module：当业务复杂的时候，可以把 store 分成多个模块，便于维护； 对于这几个概念有各种对应的 map 辅助函数用来简化操作，比如 mapState，如下三种写法其实是一个意思，都是为了从 state 中获取数据，并且通过计算属性返回给组件使用。 123456789computed: &#123; count() &#123; return this.$store.state.count &#125;, ...mapState(&#123; count: state =&gt; state.count &#125;), ...mapState([&#x27;count&#x27;]),&#125;, 又比如 mapMutations， 以下两种函数的定义方式要实现的功能是一样的，都是要提交一个 mutation 去改变 state 中的数据： 123456methods: &#123; increment() &#123; this.$store.commit(&#x27;increment&#x27;) &#125;, ...mapMutations([&#x27;increment&#x27;]),&#125; 接下来就用一个极简的例子来展示 Vuex 中任意2个组件间的状态管理。1、 新建 store.js 1234567891011121314151617import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125;, decrement(state) &#123; state.count-- &#125; &#125;,&#125;) 2、 创建一个带 store 的 Vue 实例 12345678910import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./utils/store&#x27;new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 3、 任意组件 A 实现点击递增 1234567891011121314&lt;template&gt; &lt;p @click=&quot;increment&quot;&gt;click to increment：&#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState, mapMutations&#125; from &#x27;vuex&#x27;export default &#123; computed: &#123; ...mapState([&#x27;count&#x27;]) &#125;, methods: &#123; ...mapMutations([&#x27;increment&#x27;]) &#125;,&#125;&lt;/script&gt; 4、 任意组件 B 实现点击递减 1234567891011121314&lt;template&gt; &lt;p @click=&quot;decrement&quot;&gt;click to decrement：&#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState, mapMutations&#125; from &#x27;vuex&#x27;export default &#123; computed: &#123; ...mapState([&#x27;count&#x27;]) &#125;, methods: &#123; ...mapMutations([&#x27;decrement&#x27;]) &#125;,&#125;&lt;/script&gt; 以上只是用最简单的 vuex 配置去实现组件通信，当然真实项目中的配置肯定会更复杂，比如需要对 State 数据进行二次筛选会用到 Getter，然后如果需要异步的提交那么需要使用 Action，再比如如果模块很多，可以将 store 分模块进行状态管理。对于 Vuex 更多复杂的操作还是建议去看Vuex 官方文档，然后多写例子。 Vue.observable实现mini vuex这是一个 Vue2.6 中新增的 API，用来让一个对象可以响应。我们可以利用这个特点来实现一个小型的状态管理器。 123456789101112131415// store.jsimport Vue from &#x27;vue&#x27;export const state = Vue.observable(&#123; count: 0,&#125;)export const mutations = &#123; increment() &#123; state.count++ &#125; decrement() &#123; state.count-- &#125;&#125; 1234567891011121314&lt;!-- parent.vue --&gt;&lt;template&gt; &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123; state &#125; from &#x27;../store&#x27;export default &#123; computed: &#123; count() &#123; return state.count &#125; &#125;&#125;&lt;/script&gt; 123456789// child.vueimport &#123; mutations &#125; from &#x27;../store&#x27;export default &#123; methods: &#123; handleClick() &#123; mutations.increment() &#125; &#125;&#125; $refs/$children/$parent/$root通过给子组件定义 ref 属性可以使用 $refs 来直接操作子组件的方法和属性。 1&lt;child ref=&quot;list&quot;&gt;&lt;/child&gt; 比如子组件有一个 getList 方法，可以通过如下方式进行调用，实现父到子的通信： 1this.$refs.list.getList() 除了 $refs 外，其他3个都是自 Vue 实例创建后就会自动包含的属性，使用和上面的类似。 6类可以掌握的修饰符表单修饰符表单类的修饰符都是和 v-model 搭配使用的，比如：v-model.lazy、v-model-trim 以及 v-model.number 等。 .lazy：对表单输入的结果进行延迟响应，通常和 v-model 搭配使用。正常情况下在 input 里输入内容会在 p 标签里实时的展示出来，但是加上 .lazy 后则需要在输入框失去焦点的时候才触发响应。 12&lt;input type=&quot;text&quot; v-model.lazy=&quot;name&quot; /&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt; .trim：过滤输入内容的首尾空格，这个和直接拿到字符串然后通过 str.trim() 去除字符串首尾空格是一个意思。 .number：如果输入的第一个字符是数字，那就只能输入数字，否则他输入的就是普通字符串。 事件修饰符Vue 的事件修饰符是专门为 v-on 设计的，可以这样使用： @click.stop=&quot;handleClick&quot;，还能串联使用：@click.stop.prevent=&quot;handleClick&quot;。 1234&lt;div @click=&quot;doDiv&quot;&gt; click div &lt;p @click=&quot;doP&quot;&gt;click p&lt;/p&gt;&lt;/div&gt; .stop：阻止事件冒泡，和原生 event.stopPropagation() 是一样的效果。如上代码，当点击 p 标签的时候，div 上的点击事件也会触发，加上 .stop 后事件就不会往父级传递，那父级的事件就不会触发了。 .prevent：阻止默认事件，和原生的 event.preventDefault() 是一样的效果。比如一个带有 href 的链接上添加了点击事件，那么事件触发的时候也会触发链接的跳转，但是加上 .prevent 后就不会触发链接跳转了。 .capture：默认的事件流是：捕获阶段-目标阶段-冒泡阶段，即事件从最具体目标元素开始触发，然后往上冒泡。而加上 .capture 后则是反过来，外层元素先触发事件，然后往深层传递。 .self：只触发自身的事件，不会传递到父级，和 .stop 的作用有点类似。 .once：只会触发一次该事件。 .passive：当页面滚动的时候就会一直触发 onScroll 事件，这个其实是存在性能问题的，尤其是在移动端，当给他加上 .passive 后触发的就不会那么频繁了。 .native：现在在组件上使用 v-on 只会监听自定义事件 (组件用 $emit 触发的事件)。如果要监听根元素的原生事件，可以使用 .native 修饰符，比如如下的 el-input，如果不加 .native 当回车的时候就不会触发 search 函数。 1&lt;el-input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.enter.native=&quot;search&quot;&gt;&lt;/el-input&gt; 串联使用事件修饰符的时候，需要注意其顺序，同样2个修饰符进行串联使用，顺序不同，结果大不一样。@click.prevent.self 会阻止所有的点击事件，而 @click.self.prevent 只会阻止对自身元素的点击。 鼠标按钮修饰符 .left：鼠标左键点击； .right：鼠标右键点击； .middle：鼠标中键点击； 键盘按键修饰符Vue 提供了一些常用的按键码： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 另外，你也可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符，比如可以通过如下的代码来查看具体按键的键名是什么： 1&lt;input @keyup=&quot;onKeyUp&quot;&gt; 123onKeyUp(event) &#123; console.log(event.key) // 比如键盘的方向键向下就是 ArrowDown&#125; .exact修饰符.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; .sync修饰符.sync 修饰符常被用于子组件更新父组件数据。直接看下面的代码： 12&lt;!-- parent.vue --&gt;&lt;child :title.sync=&quot;title&quot;&gt;&lt;/child&gt; 12// child.vuethis.$emit(&#x27;update:title&#x27;, &#x27;hello&#x27;) 子组件可以直接通过 update:title 的形式进行更新父组件中声明了 .sync 的 prop。上面父组件中的写法其实是下面这种写法的简写： 1&lt;child :title=&quot;title&quot; @update:title=&quot;title = $event&quot;&gt;&lt;/child&gt; 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 如果需要设置多个 prop，比如： 1&lt;child :name.sync=&quot;name&quot; :age.sync=&quot;age&quot; :sex.sync=&quot;sex&quot;&gt;&lt;/child&gt; 可以通过 v-bind.sync 简写成这样： 1&lt;child v-bind.sync=&quot;person&quot;&gt;&lt;/child&gt; 12345person: &#123; name: &#x27;bubuzou&#x27;, age: 21, sex: &#x27;male&#x27;,&#125; Vue 内部会自行进行解析把 person 对象里的每个属性都作为独立的 prop 传递进去，各自添加用于更新的 v-on 监听器。而从子组件进行更新的时候还是保持不变，比如： 1this.$emit(&#x27;update:name&#x27;, &#x27;hello&#x27;) 6种方式编写可复用模块今天需求评审了一个需求，需要实现一个详情页，这个详情页普通用户和管理员都能进去，但是展示的数据有稍有不同，但绝大部分是一样的；最主要的区别是详情对于普通用户是纯展示，而对于管理员要求能够编辑，然后管理员还有一些别的按钮权限等。需求看到这里，如果在排期的时候把用户的详情分给开发A做，而把管理员的详情分给B去做，那这样做的结果就是开发A写了一个详情页，开发B写了一个详情页，这在开发阶段、提测后的修改 bug 阶段以及后期迭代阶段，都需要同时维护这 2 个文件，浪费了时间浪费了人力，所以你可以从中意识到编写可复用模块的重要性。 而 Vue 作者尤大为了让开发者更好的编写可复用模块，提供了很多的手段，比如：组件、自定义指令、渲染函数、插件以及过滤器等。 组件组件是 Vue 中最精髓的地方，也是我们平时编写可复用模块最常用的手段，但是由于这块内容篇幅很多，所以不在这里展开，后续会写相关的内容进行详述。 使用混入mixins什么是混入呢？ 从代码结构上来看，混入其实就是半个组件，一个 Vue 组件可以包括 template、script 和 style 三部分，而混入其实就是 script 里面的内容。一个混入对象包含任意组件选项，比如 data、methods、computed、watch 、生命周期钩子函数、甚至是 mixins 自己等，混入被设计出来就是旨在提高代码的灵活性、可复用性。 什么时候应该使用混入呢？当可复用逻辑只是 JS 代码层面的，而无 template 的时候就可以考虑用混入了。比如需要记录用户在页面的停留的时间，那我们就可以把这段逻辑抽出来放在 mixins 里： 1234567891011121314// mixins.jsexport const statMixin = &#123; methods: &#123; enterPage() &#123;&#125;, leavePage() &#123;&#125;, &#125;, mounted() &#123; this.enterPage() &#125;, beforeDestroyed() &#123; this.leavePage() &#125;&#125; 然后在需要统计页面停留时间的地方加上： 1234import &#123; statMixin &#125; from &#x27;../common/mixins&#x27;export default &#123; mixins: [statMixin]&#125; 使用混入的时候要注意和组件选项的合并规则，可以分为如下三类： data 将进行递归合并，对于键名冲突的以组件数据为准： 1234567891011121314151617181920 // mixinA 的 data data() &#123; obj: &#123; name: &#x27;hello&#x27;, &#125;,&#125; // component A export default &#123; mixins: [mixinA], data()&#123; obj: &#123; name: &#x27;bubuzou&#x27;, age: 21 &#125;, &#125;, mounted() &#123; console.log( this.obj ) // &#123; name: &#x27;bubuzou&#x27;, &#x27;age&#x27;: 21 &#125; &#125; &#125; 对于生命周期钩子函数将会合并成一个数组，混入对象的钩子将先被执行： 12345678910111213141516171819202122// mixin Aconst mixinA = &#123; created() &#123; console.log( &#x27;第一个执行&#x27; ) &#125;&#125;// mixin Bconst mixinB = &#123; mixins: [mixinA] created() &#123; console.log( &#x27;第二个执行&#x27; ) &#125;&#125;// component Aexport default &#123; mixins: [mixinB] created() &#123; console.log( &#x27;最后一个执行&#x27; ) &#125;&#125; 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 自定义指令除了 Vue 内置的一些指令比如 v-model、v-if 等，Vue 还允许我们自定义指令。在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。比如我们可以通过自定义一个指令来控制按钮的权限。我们期望设计一个如下形式的指令来控制按钮权限： 1&lt;button v-auth=&quot;[&#x27;user&#x27;]&quot;&gt;提交&lt;/button&gt; 通过在按钮的指令里传入一组权限，如果该按钮只有 admin 权限才可以提交，而我们传入一个别的权限，比如 user，那这个按钮就不应该显示了。接下来我们去注册一个全局的指令： 123456789101112131415161718// auth.jsconst AUTH_LIST = [&#x27;admin&#x27;]function checkAuth(auths) &#123; return AUTH_LIST.some(item =&gt; auths.includes(item))&#125;function install(Vue, options = &#123;&#125;) &#123; Vue.directive(&#x27;auth&#x27;, &#123; inserted(el, binding) &#123; if (!checkAuth(binding.value)) &#123; el.parentNode &amp;&amp; el.parentNode.removeChild(el) &#125; &#125; &#125;)&#125;export default &#123; install &#125; 然后我们需要在 main.js 里通过安装插件的方式来启用这个指令： 12import Auth from &#x27;./utils/auth&#x27;Vue.use(Auth) 使用渲染函数这里将使用渲染函数实现上面介绍过的的权限按钮。使用方式如下，把需要控制权限的按钮包在权限组件 authority 里面，如果有该权限就显示，没有就不显示。 123&lt;authority :auth=&quot;[&#x27;admin&#x27;]&quot;&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/authority&gt; 然后我们用渲染函数去实现一个 authority 组件： 1234567891011121314151617181920&lt;script&gt;const AUTH_LIST = [&#x27;admin&#x27;, &#x27;user&#x27;, &#x27;org&#x27;]function checkAuth(auths) &#123; return AUTH_LIST.some(item =&gt; auths.includes(item))&#125;export default &#123; functional: true, props: &#123; auth: &#123; type: Array, required: true &#125; &#125;, render(h, context) &#123; const &#123; props, scopedSlots&#125; = context return checkAuth(props.auth) ? scopedSlots.default() : null &#125;&#125;&lt;/script&gt; 全局注册这个组件： 123// main.jsimport Authority from &#x27;./components/authority&#x27;Vue.component(&#x27;authority&#x27;, Authority) 使用过滤器Vue 提供了自定义过滤器的功能，主要应用场景是想要将数据以某种格式展示出来，而原始数据又不符合这种格式的时候。比如有一组关于人的数据，如下： 12345678910[&#123; name: &#x27;张茂&#x27;, population: &#x27;young&#x27;,&#125;, &#123; name: &#x27;王丽&#x27;, population: &#x27;middle&#x27;,&#125;, &#123; name: &#x27;郝鹏程&#x27;, population: &#x27;child&#x27;,&#125;] 其中有一项是关于按照年龄划分的群体类型 population，而它是用 code 进行标识的，我们希望在展示的时候能够显示成对应的中文意思，比如 young 显示成青年。那我们就可以定义一个如下的局部过滤器： 123456789export default &#123; filters: &#123; popuFilters(value) &#123; if (!value) &#123; return &#x27;未知&#x27; &#125; let index = [&#x27;child&#x27;, &#x27;lad&#x27;, &#x27;young&#x27;, &#x27;middle&#x27;, &#x27;wrinkly&#x27;].indexOf(value) return index &gt; 0 &amp;&amp; [&#x27;儿童&#x27;, &#x27;少年&#x27;, &#x27;青年&#x27;, &#x27;中年&#x27;, &#x27;老年&#x27;][index] || &#x27;未知&#x27; &#125; &#125;&#125; 使用过滤器的时候只要在 template 中这样使用即可： 1&lt;p&gt;&#123;&#123; item.population | popuFilters &#125;&#125;&lt;/p&gt; 自定义插件在某些情况下，我们封装的内容可能不需要使用者对其内部代码结构进行了解，其只需要熟悉我们提供出来的相应方法和 api 即可，这需要我们更系统性的将公用部分逻辑封装成插件，来为项目添加全局功能，比如常见的 loading 功能、弹框功能等。 开发 Vue 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象。可以通过如下4种方式来自定义插件： 123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或 property Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive(&#x27;my-directive&#x27;, &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; 然后需要在入口文件，比如 main.js 中注册插件： 12import MyPlugin from &#x27;./plugins/plugins.js&#x27;Vue.use(MyPlugin) 3种方式手写优雅代码平时写项目的时候我们都是在第一时间完成需求功能的开发、提测修改 bug 等，然后开开心心的等待着发布生产以为没啥事情了。其实回过头来细细的看我们平时写的代码，可能会发现很多地方都是值得优化的，比如对于很多重复性很强的代码，比如对于某些写得很繁杂的地方。优雅的代码可以化机械为自动、化繁为简，看人开了如沐春风，心情大好。这里列了几个在 Vue 中一定会遇到的问题，然后通过优雅的方式进行解决。 自动化导入模块在开发一个稍微大点的项目的时候，会习惯将路由按照模块来划分，然后就可能会出现如下这种代码： 12345678910111213141516171819// router.jsimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;// 导入了一大堆路由文件import mediator from &#x27;./mediator&#x27;import judges from &#x27;./judges&#x27;import disputeMediation from &#x27;./disputeMediation&#x27;import onlineMediation from &#x27;./onlineMediation&#x27;import useraction from &#x27;./useraction&#x27;import organcenter from &#x27;./organcenter&#x27;import admin from &#x27;./admin&#x27;let routeList = []routeList.push(mediator, judges, disputeMediation, onlineMediation, useraction, organcenter, admin)export default new Router(&#123; mode: &#x27;history&#x27;, routes: routeList,&#125;) 其实真实的远远不止这么点，就我本地项目而言就有20几个路由文件，写了一大堆的导入代码，显得很臃肿，更无奈的是每当需要新增一个路由模块，还得再次 import 再次 push，那么有没有什么办法可以解决这个问题呢？答案自然是有的。 利用 webpack 的 require.context 就可以很优雅的解决这个问题，使用语法如下： 123456require.context( directory, // 搜索的目录 useSubdirectories = true, // 是否搜索子目录 regExp = /^\\.\\/.*$/, // 匹配的目标文件格式 mode = &#x27;sync&#x27; // 同步还是异步) 有了这个语法，我们就能很容易的写出下面的代码： 123456789101112131415161718import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;let routeList = []let importAll = require.context(&#x27;@/publicResource/router&#x27;, false, /\\.js$/)importAll.keys().map(path =&gt; &#123; // 因为 index.js 也在 @/publicResource/router 目录下，所以需要排除 if (!path.includes(&#x27;index.js&#x27;)) &#123; //兼容处理：.default 获取 ES6 规范暴露的内容; 后者获取 commonJS 规范暴露的内容 let router = importAll(path).default || importAll(path) routeList(router) &#125;&#125;) export default new Router(&#123; mode: &#x27;history&#x27;, routes: routeList,&#125;) 其实不仅仅只是用在导入路由模块这里，对于项目里任何需要导入大量本地模块的地方都可以使用这种方式来解决。 模块化注册插件相信写 Vue 的同学们都知道 element-ui 这个组件库，在使用这个组件库的时候大部分都是只使用某些个别的组件，所以基本上都是按需引入需要的组件，然后就有如下一堆 Vue.use() 的代码： 123456789101112131415161718// main.jsimport Vue from &#x27;vue&#x27;import &#123; Input, Radio, RadioGroup, Checkbox, CheckboxGroup, Select // 还有很多组件&#125; from &#x27;element-ui&#x27;Vue.use(Input)Vue.use(Radio)Vue.use(RadioGroup)Vue.use(Checkbox)Vue.use(CheckboxGroup)Vue.use(Select) 这样写是没任何问题的，就是看着不够简洁舒服，那更优雅的做法是把这块逻辑抽到一个文件里，然后通过注册插件的方式来使用他们： 1234567891011121314151617181920212223// elementComponent.jsimport &#123; Input, Radio, RadioGroup, Checkbox, CheckboxGroup, Select // 还有很多组件&#125; from &#x27;element-ui&#x27;const components = &#123; Input, Radio, RadioGroup, Checkbox, CheckboxGroup, Select&#125;function install(Vue)&#123; Object.keys(components).forEach(key =&gt; Vue.use(components[key]))&#125;export default &#123; install &#125; 然后在 main.js 里使用这个插件： 1234// main.jsimport Vue from &#x27;vue&#x27;import elementComponent from &#x27;./config/elementComponent&#x27;Vue.use(elementComponent) 优雅导出请求接口不知道大伙是如何定义请求接口的，就我目前这个项目而言，是这么做的： 1234567891011121314151617// api.jsimport http from &#x27;./config/httpServer.js&#x27; /* 登入页面获取公钥 */export const getPublicKey = (data) =&gt; &#123; return http(&#123; url: &#x27;/userGateway/user/getPublicKey&#x27; &#125;, data)&#125;// 用户登录export const login = data =&gt; &#123; return http(&#123; url: &#x27;/userGateway/userSentry/login&#x27; &#125;, data)&#125;// 验证码登录export const loginByCode = data =&gt; &#123; return http(&#123; url: &#x27;/userGateway/userSentry/loginByCode&#x27; &#125;, data)&#125; 在组件中使用接口： 123456789101112&lt;script&gt;import &#123; getPublicKey &#125; from &#x27;./config/api.js&#x27;export default &#123; mounted() &#123; getPublicKey().then(res =&gt; &#123; // xxx &#125;).catch(err =&gt; &#123; // xxx &#125;) &#125;&#125;&lt;/script&gt; 这一切都很正常，但，我们这个项目总共有200多个接口，按照上面这种定义方式的话，一个接口定义加上空行需要占用 5 行，所以如果把全部接口都定义到这个 api.js 里需要占用 1000 行左右，看了实在让人心很慌呀。所以觉得应该这个地方应该可以优化一下。 1/userGateway/user/getPublicKey 上面这是一个后端给接口路径，斜杆把这个路径划分成 3 个子串，而最后一个子串必定是唯一的，所以我们可以从中做文章。于是乎就有了下面的代码： 12345678910111213141516// api.jsconst apiList = [ &#x27;/userGateway/user/getPublicKey&#x27;, // 登入页面获取公钥 &#x27;/userGateway/userSentry/login&#x27;, // 用户登录 &#x27;/userGateway/userSentry/loginByCode&#x27;, // 验证码登录]let apiName, API = &#123;&#125;apiList.forEach(path =&gt; &#123; // 使用正则取到接口路径的最后一个子串，比如: getPublicKey apiName = /(?&lt;=\\/)[^/]+$/.exec(path)[0] API[apiName] = (data) =&gt; &#123; return http(&#123;url: path&#125;, data) &#125;&#125;)export &#123; API &#125; 这样大概就把定义一个接口需要占用 5 行缩小到只需要 1 行了，大大减小了文件内容。在浏览这个文件的时候，我的鼠标滚轮也不会一直在滚滚滚了。 如果是这样定义接口的话，那在使用的时候还需要做点变化的： 123456789101112&lt;script&gt;import &#123; API &#125; from &#x27;./config/api.js&#x27;export default &#123; mounted() &#123; API.getPublicKey().then(res =&gt; &#123; // xxx &#125;).catch(err =&gt; &#123; // xxx &#125;) &#125;&#125;&lt;/script&gt; 4种$event传参方式在进行实际项目开发的时候经常会需要通过事件传递参数，这里总结了4种应用场景。 用于组件通信比如子组件通过 $emit 来调用父组件方法的时候，可以在父组件中用 $event 接收到从子组件传递过来的参数： 12&lt;!-- 子组件 --&gt;&lt;button @click=&quot;$emit(&#x27;changeText&#x27;, &#x27;18px&#x27;)&quot;&gt;点击加大字号&lt;/button&gt; 12&lt;!-- 父组件 --&gt;&lt;blog-post @changeText=&quot;changeText(&#x27;article&#x27;, $event)&quot;&gt;&lt;/blog-post&gt; 123changeText(type, value) &#123; console.log(type, value) // &#x27;article&#x27; &#x27;18px&#x27;&#125; 如果子组件传递过来的参数有多个，这个时候用 $event 就不太行了，此时可以用 arguments 代替： 12&lt;!-- 子组件 --&gt;&lt;button @click=&quot;$emit(&#x27;changeText&#x27;, &#x27;red&#x27;, &#x27;18px&#x27;)&quot;&gt;点击改变样式&lt;/button&gt; 12&lt;!-- 父组件 --&gt;&lt;blog-post @changeText=&quot;changeText(...arguments, &#x27;article&#x27;)&quot;&gt;&lt;/blog-post&gt; 123changeText(...value) &#123; console.log( value ) // [&#x27;red&#x27;, &#x27;18px&#x27;, &#x27;article&#x27;]&#125; 传递原生DOM事件对象比如我们需要获取到当前的点击元素，就可以通过给点击事件传递 $event 参数： 1&lt;button @click=&quot;submit(&#x27;first&#x27;, $event)&quot;&gt;提交&lt;/button&gt; 123submit(type, event) &#123; const target = event.target.tagName&#125; 用于第三方类库事件回调比如有一个组件里使用了好几个 element-ui 的分页组件，每个分页都有一个 current-change 事件，用来处理当分页改变之后的事情，这样的话我们就需要写多个回调函数，但是如果用以下方式，我们就也可以只写一个函数，通过 type 来判断是哪个分页的回调，而 $event 则用来传递 current-change 回调默认的参数： 1234567891011121314&lt;!-- 页面列表的分页 --&gt;&lt;el-pagination @current-change=&quot;changePage(&#x27;main&#x27;, $event)&quot;&gt;&lt;/el-pagination&gt;&lt;!-- 弹窗A列表的分页 --&gt;&lt;el-pagination @current-change=&quot;changePage(&#x27;modalA&#x27;, $event)&quot;&gt;&lt;/el-pagination&gt;&lt;!-- 弹窗B列表的分页 --&gt;&lt;el-pagination @current-change=&quot;changePage(&#x27;modalB&#x27;, $event)&quot;&gt;&lt;/el-pagination&gt; 1234changePage(type, page) &#123; const types = [&#x27;main&#x27;, &#x27;modalA&#x27;, &#x27;modalB&#x27;] types[type] &amp;&amp; (this[types[type]].pageIndex = page) &amp;&amp; this.getList(type)&#125; 使用箭头函数处理对于第三种场景，使用第三方类库组件的时候，需要给事件回调增加额外的参数，如果默认的回调参数只有1个那么我们就可以使用上面的那种方式，但是如果回调参数有多个的话，用 $event 就不好处理了，可以使用箭头函数。比如文件上传的时候，有个 on-change 属性，当文件变化的时候就会触发回调，正常情况下我们这样写是没问题的： 123&lt;el-upload :on-change=&quot;changeFile&quot;&gt; &lt;el-button&gt;上传&lt;/el-button&gt;&lt;/el-upload&gt; 1changeFile(file, fileList) &#123;&#125; 但是如果一个组件里有多个文件上传，而我们又不想写多个 changeFile，那就需要传递额外的参数 type 了 ： 123&lt;el-upload :on-change=&quot;(file, fileList) =&gt; changeFile(&#x27;org&#x27;, file, fileList)&quot;&gt; &lt;el-button&gt;上传&lt;/el-button&gt;&lt;/el-upload&gt; 1changeFile(type, file, fileList) &#123;&#125; 3种深入watch的用法立即执行watch 是 Vue 中的侦听器，可以侦听一个 Vue 实例上的数据，当数据变动的时候，就会触发该侦听器。所以他的应用场景就是：当某个数据变动后需要做什么的时候就可以使用 watch 啦。对于 watch，平常我们写得最多的估计是如下这种写法： 12345watch: &#123; list: function(val) &#123; this.getMsg() &#125;&#125; 如果我们希望组件初始化的时候就执行一次 getMsg 方法，可以直接在 mounted 里调用： 123mounted() &#123; this.getMsg()&#125; 其实，还有一种更加简便的写法，通过给 watch 设置 immediate: true ，即可： 12345678watch: &#123; list: &#123; handler(val) &#123; // 注意别写错成 handle this.getMsg() &#125;, immediate: true &#125;&#125; 深度监听侦听器对于属性变更后会自动调用一次，但是仅限于该属性本身，如果变更的是属性的属性，则不会触发侦听回调，如果想要实现这个功能可以给 watch 加上 ‘deep: true’ 即可： 123456789watch: &#123; obj: &#123; handler(val) &#123; // do something &#125;, deep: true &#125;&#125;,mounted() &#123; this.obj.name = &#x27;bubuzou&#x27; // 将触发 handler&#125; 多个handlers实际上，watch 可以设置为数组，支持类型为 String、Object 和 Function。触发后，多个处理函数都将被调用。 1234567891011121314151617watch: &#123; obj: [ &#x27;print&#x27;, &#123; handler: &#x27;print&#x27;, deep: true &#125;, function(val, oldValue) &#123; console.log(val) &#125; ]&#125;,methods: &#123; print() &#123; console.log(this.obj) &#125;&#125; 5个其他开发小技巧掌握 Vue 的开发小技巧，在一些特定的场景下真的很管用，这里列了一些常用的小技巧。 函数式组件实现零时变量我们在使用插槽的时候，知道有一个叫做插槽 prop 的知识，今天我们用他和函数式组件结合在一块，实现一个零时变量的组件： 12345678910// tempvar.vue&lt;script&gt;export default &#123; functional: true, render(h, context) &#123; const &#123; props, scopedSlots&#125; = context return scopedSlots.default &amp;&amp; scopedSlots.default(props || &#123;&#125;) &#125;&#125;&lt;/script&gt; 定义好了函数式组件，我们就可以在需要的地方引入且使用他： 1234567891011121314151617181920212223242526&lt;template&gt;&lt;tempvar :var1=&quot;`hello $&#123;user.name&#125;`&quot; :var2=&quot;user.age ? user.age : &#x27;18&#x27;&quot;&gt; &lt;template v-slot=&quot;&#123;var1, var2&#125;&quot;&gt; 姓名： &#123;&#123; var1 &#125;&#125; 年龄：&#123;&#123; var2 &#125;&#125; &lt;/template&gt;&lt;/tempvar&gt;&lt;/template&gt;&lt;script&gt; import tempvar from &#x27;@/components/tempvar.vue&#x27; export default &#123; data() &#123; return &#123; user: &#123; name: &#x27;bubuzou&#x27;, age: 12, &#125;, &#125; &#125; components: &#123; tempvar &#125; &#125;&lt;/script&gt; 可能细心的小伙伴发现了，要把名字前加个 hello、默认年龄设置为 18 用计算属性就可以了呀？为啥还要搞那么复杂，专门用一个函数式组件去实现呢？其实这个小技巧还是很有必要存在的，当许多组件都有这种数据的重新计算的时候，如果没有使用这个技巧，那么就需要写很多很多的计算属性，而有了函数式组件 tempvar 后，只需要在组件里引入他，然后写插槽就好了。就相当于把写计算属性的功夫花在了写插槽上了。总而言之，两种方式都可以实现类似的属性计算功能，该怎么选，随你喜欢啦。 调试template（不推荐）在开发调试的时候经常会需要通过 console.log 来打印出某个数据对象来查看其内部的结构或者字段值，但是这样做肯定不必在 template 里将其输出更直接。比如有这样一个数据： 1234obj: &#123; name: &#x27;bubuzou&#x27;, age: 21,&#125; 在模板中展示： 1&lt;p&gt;&#123;&#123; obj &#125;&#125;&lt;/p&gt; 页面渲染完成后会看到： 1&#123; &quot;name&quot;: &quot;bubuzou&quot;, &quot;age&quot;: 21 &#125; 对于这样的渲染结果虽然没什么问题，但是如果这个 obj 是层级很深且字段很多的数据，显示出来就会一堆数据砸在一块，丝毫没有阅读体验。 因此基于这个背景，我们可以将 console.log 挂载在 Vue 的实例原型上： 12// main.jsVue.prototype.$log = window.console.log 然后就可以开开心心在模板中使用他了： 1&lt;p&gt;&#123;&#123; $log( obj ) &#125;&#125;&lt;/p&gt; 这样会在浏览器控制台输出当前的数据对象，在显示效果上和 console.log 直接打印别无二致。 但说了这么多，使用 Vue 进行开发调试还是强烈推荐官方的vue-devtools 工具，谁用谁知道。 监听子组件的钩子函数通常如果我们想在子组件钩子函数触发的时候通知父组件，我们可以这样做： 12&lt;!-- parent.vue --&gt;&lt;child @mounted=&quot;doSomething&quot;&gt;&lt;/child&gt; 12// child.vuethis.$emit(&#x27;mounted&#x27;) 其实还有一种更加简单的写法，那就是使用 hookEvent： 1&lt;child @hook:mounted=&quot;doSomething&quot;&gt;&lt;/child&gt; 钩子函数除了以上用法，还可以通过动态注册做一些别的事情，比如组件销毁前进行资源的释放： 12345678910mounted() &#123; let setIntervalId = setInterval(() =&gt; &#123; console.log(888); &#125;, 1000) this.$once(&quot;hook:beforeDestroy&quot;, () =&gt; &#123; clearInterval(setIntervalId) setIntervalId = null &#125;)&#125; 路由参数解耦参数解耦，啥意思呢？别着急，我们先来看比如对于这么一串路由： 12345const router = [&#123; path: &#x27;/home/:type/:id&#x27;, name: &#x27;Home&#x27;, component: Home,&#125;] 当前页面的路径是 http://xxx/detail/preview/21?sex=male，平时我们写代码的时候或多或少的会写出这种代码，在组件里使用 $route 给组件传参数： 123456789mounted() &#123; if (this.$route.params.type === &#x27;preview&#x27;) &#123; this.isPreview = true &#125; else &#123; this.isPreview = false &#125; this.id = this.$route.params.id this.sex = this.$route.query.sex&#125; 这样子写本身没什么问题，就是会使得组件和路由高度耦合，让组件只能在含有特定 URL 的页面中使用，限制了组件的通用性。其实，我们可以通过 props 传参，来解耦路由参数，将上面的路由配置改成如下： 12345678910const router = [&#123; path: &#x27;/home/:type/:id&#x27;, name: &#x27;Home&#x27;, component: Home, props: (route) =&gt; (&#123; type: route.params.type, id: route.params.id, sex: route.query.sex, &#125;)&#125;] 然后在组件 props 加上参数： 1props: [&#x27;type&#x27;, &#x27;id&#x27;, &#x27;sex&#x27;] 组件里使用参数的时候就不需要用 this.$route，而是可以直接 this.type 即可。这样一来，这个组件就可以在任何地方使用了。 深度作用选择器当给 style 加上 scoped，页面渲染完成后会给 html 和 css 选择器加上哈希值用于表示唯一性： 123&lt;div class=&quot;home&quot; data-v-fae5bece&gt; &lt;button data-v-fae5bece class=&quot;el-button el-button-primary&quot;&gt;提交&lt;/button&gt;&lt;/div&gt; 123.home .el-button[data-v-fae5bece] &#123; font-size: 20px;&#125; 对于在 style 中被加了 scoped 的组件，其样式将只能作用于组件内部，不会对其子组件造成影响。比如有这样一个组件： 1234567891011&lt;!-- 父组件 --&gt;&lt;div class=&quot;home&quot;&gt; &lt;el-button type=&quot;primary&quot;&gt;父按钮&lt;/button&gt; &lt;child&gt;&lt;/child&gt;&lt;/div&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.home .el-button &#123; font-size: 20px;&#125;&lt;/style&gt; 1234&lt;!-- 子组件 --&gt;&lt;div class=&quot;child&quot;&gt; &lt;el-button type=&quot;primary&quot;&gt;子按钮&lt;/button&gt;&lt;/div&gt; 当页面渲染出来后，会是如下结果： 123456&lt;div class=&quot;home&quot; data-v-fae5bece&gt; &lt;button data-v-fae5bece class=&quot;el-button el-button-primary&quot;&gt;父按钮&lt;/button&gt; &lt;div class=&quot;child&quot; data-v-fae5bece&gt; &lt;button class=&quot;el-button el-button-primary&quot;&gt;子按钮&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 根据上面的 html，我们可以看到 .home .el-button[data-v-fae5bece] 这个选择器作用不到子按钮这个 button。 在实际项目中，我们有时候需要让父组件的样式能作用到子组件，即使父组件的 style 上加了 scoped，那这个时候就需要用到深度作用选择器 &gt;&gt;&gt;，比如在刚刚的例子上可以给父组件样式加上深度作用选择器。 深度作用选择器会被 Vue Loader 处理，且只能在有预处理器的地方使用。由于某些预处理器比如 Sass 不能正确解析 &gt;&gt;&gt;，所以我们可以使用它的别名：/deep/ 或 ::v-deep 来替代。 1234567&lt;style lang=&quot;scss&quot; scoped&gt;.home &#123; /deep/ .el-button &#123; font-size: 20px; &#125;&#125;&lt;/style&gt; 加上深度作用选择器后，选择器会由原来的： 1.home .el-button[data-v-fae5bece] &#123;&#125; 变成如下的： 1.home[data-v-fae5bece] .el-button &#123;&#125; 参考文章 vue篇之事件总线（EventBus） 《Vue开发实战》 感谢阅读如果本文对你有帮助的话，给本文点个在看吧","categories":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/tags/vue/"}]},{"title":"小程序升级WePY2踩坑记","slug":"wepy2","date":"2020-08-06T13:39:57.000Z","updated":"2020-08-27T15:50:01.384Z","comments":true,"path":"2020/08/06/wepy2/","link":"","permalink":"https://bubuzou.com/2020/08/06/wepy2/","excerpt":"最近有个小程序项目需要迭代，但是迭代任务不多，时间比较充裕。而这个小程序最早是在18年的时候开发的，用的开发框架是 WePY 的 1.7.2 版本，去年也就是 19 年的时候 WePY 框架进行了升级，到了 2.0 版本。升级之后的 WePY，用 WePY 官方文档的话来说：通过优化细节，引入 Promise、Async Functions 等让开发小程序项目变得更加简单，高效。基于这些背景，我和小伙伴一拍即合，决定对我们的项目进行框架升级，体验下到底 WePY2 能给我们带来什么。 本文将以项目改动为出发点，基于当前这个项目的结构和编码方式来考虑到底升级 WePY2 后，哪里需要改，怎么改以及有哪些需要注意的地方，通过对比 2 个版本的写法差异这个思路来写，不会去太较真 WePY2 相对于 WePY1 实现或原理上的区别。下面我将一条一条的列出来需要改动的点。 本篇文章记录的是我和小伙伴这次升级框架遇到的需要改动的地方和坑，所使用的是 wepy 的 2.1.0 版本，后续如果版本升级后，本篇记录到的坑如果已经被修复了，请自行忽略本文所述的问题。另外下文中所说到的 2.x 版本都是指 wepy_v2.1.0。","text":"最近有个小程序项目需要迭代，但是迭代任务不多，时间比较充裕。而这个小程序最早是在18年的时候开发的，用的开发框架是 WePY 的 1.7.2 版本，去年也就是 19 年的时候 WePY 框架进行了升级，到了 2.0 版本。升级之后的 WePY，用 WePY 官方文档的话来说：通过优化细节，引入 Promise、Async Functions 等让开发小程序项目变得更加简单，高效。基于这些背景，我和小伙伴一拍即合，决定对我们的项目进行框架升级，体验下到底 WePY2 能给我们带来什么。 本文将以项目改动为出发点，基于当前这个项目的结构和编码方式来考虑到底升级 WePY2 后，哪里需要改，怎么改以及有哪些需要注意的地方，通过对比 2 个版本的写法差异这个思路来写，不会去太较真 WePY2 相对于 WePY1 实现或原理上的区别。下面我将一条一条的列出来需要改动的点。 本篇文章记录的是我和小伙伴这次升级框架遇到的需要改动的地方和坑，所使用的是 wepy 的 2.1.0 版本，后续如果版本升级后，本篇记录到的坑如果已经被修复了，请自行忽略本文所述的问题。另外下文中所说到的 2.x 版本都是指 wepy_v2.1.0。 初始化一个WePY2的demo由于本地还有其他项目用的是 WePY_v1.7.2，所以我们不能把 WePY2 的 CLI 工具安装在全局环境中，只能安装在当前项目中。官方推荐是直接用 1.7.x 的 CLI 去初始化 2.0.x 的项目: 1wepy init standard#2.0.x zzodr 这样就能够在本地初始化一个 wepy2 的项目模板，但是 @wepy/core 是 2.0.0-alpha.16 版本的，将它更新到最新的 2.1.0 版本，这里也一起更新下整个旧项目和新模板所用到的依赖，下面直接贴出来： 123456789101112131415161718192021222324252627&#123; &quot;dependencies&quot;: &#123; &quot;@wepy/core&quot;: &quot;^v2.1.0&quot;, &quot;@wepy/use-intercept&quot;: &quot;^2.1.0&quot;, &quot;@wepy/use-promisify&quot;: &quot;^2.1.0&quot;, &quot;@wepy/x&quot;: &quot;^2.0.2&quot;, &quot;miniprogram-slide-view&quot;: &quot;0.0.3&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.1.0&quot;, &quot;@babel/preset-env&quot;: &quot;^7.1.0&quot;, &quot;@wepy/babel-plugin-import-regenerator&quot;: &quot;0.0.2&quot;, &quot;@wepy/cli&quot;: &quot;^2.1.0&quot;, &quot;@wepy/compiler-babel&quot;: &quot;^2.0.1&quot;, &quot;@wepy/compiler-sass&quot;: &quot;^2.1.0&quot;, &quot;@wepy/plugin-define&quot;: &quot;^2.1.0&quot;, &quot;babel-eslint&quot;: &quot;^7.2.1&quot;, &quot;cross-env&quot;: &quot;^5.1.3&quot;, &quot;eslint&quot;: &quot;^3.18.0&quot;, &quot;eslint-config-standard&quot;: &quot;^7.1.0&quot;, &quot;eslint-friendly-formatter&quot;: &quot;^2.0.7&quot;, &quot;eslint-plugin-html&quot;: &quot;^2.0.1&quot;, &quot;eslint-plugin-promise&quot;: &quot;^3.5.0&quot;, &quot;eslint-plugin-standard&quot;: &quot;^2.0.1&quot;, &quot;wepy-eslint&quot;: &quot;^1.5.3&quot; &#125;&#125; 接下来操作主要是删除模板里的代码，然后把项目的结构和代码搬过去。 wpy文件代码结构调整WePy 单文件组件主要由 &lt;script&gt;、&lt;template&gt;、&lt;style&gt;、&lt;config&gt; 四部分组成（也包括小程序 &lt;wxs&gt; 标签）。所以需要把 WePY 1.7.2 中定义在 &lt;script&gt; 中的 config 配置需要独立到外层的 &lt;config&gt; 中。1.7.2 写法： 123456789&lt;template&gt;&lt;/template&gt;&lt;script&gt; export default class Home extends wepy.page &#123; config = &#123; navigationBarTitleText: &#x27;首页&#x27; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 2.x 写法： 12345678&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;config&gt;&#123; navigationBarTitleText: &#x27;首页&#x27;&#125;&lt;/config&gt;&lt;style&gt;&lt;/style&gt; 程序/页面/组件注册方式调整注册方式将不再使用继承的方式，而是改成直接调用对应的实例方法。1.7.2 写法： 123export default class APP extends wepy.app &#123;&#125; // 注册程序export default class HOME extends wepy.page &#123;&#125; // 注册页面export default class LIST extends wepy.component &#123;&#125; // 注册组件 2.x 写法： 123wepy.app(&#123;&#125;) // 注册程序wepy.page(&#123;&#125;) // 注册页面wepy.component(&#123;&#125;) // 注册组件 代码结构由类结构变成对象结构由于注册方式的改变，那么自然的代码结构也要有所调整。1.7.2 写法： 123456export default class HOME extends wepy.page &#123; data = &#123;&#125; methods = &#123;&#125; onLoad() &#123;&#125; onShow() &#123;&#125;&#125; 2.x 写法： 123456wepy.page(&#123; data: &#123;&#125;, methods: &#123;&#125;, onLoad() &#123;&#125;, onShow() &#123;&#125;,&#125;) 上面仅仅只是以页面做为例子，wepy.app() 和 wepy.component() 也要对应调整。 自定义方法和组件事件处理函数需要移到 methods 里在 WePY 1.7.2 中注册的页面或者组件函数有这么几种类型： 生命周期函数，比如 onLoad、onShow 等； wxml 事件处理函数，即在 wxml 中绑定的事件，这类函数需要定义在 methods，比如：bindtap、bindchange 等； 组件间事件处理函数，响应组件之间通过 $broadcast、$emit、$invoke 所传递的事件函数，这类函数需要定义在 events 对象里； 自定义函数，即用于被其他函数直接调用的函数，需要定义在和 methods 同级的位置。 而在 WePY 2 中需要将组件处理函数和自定义函数都放到 methods 里。下面假设 HOME 页面有一个子组件 child，且子组件里会执行这句 this.$emit(&#39;updateList)，基于这个背景看下 2 个版本下的写法差异： 1.7.2 写法： 123456789101112131415161718192021&lt;template&gt; &lt;view&gt; &lt;view bindtap=&quot;tapBox&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default class HOME extends wepy.page &#123; data = &#123;&#125; onLoad() &#123;&#125; // 生命周期函数 onShow() &#123;&#125; // 生命周期函数 events = &#123; updateList:() =&gt; &#123;&#125; // 组件间事件处理函数 &#125; methods = &#123; tapBox() &#123; // wxml事件处理函数 this.getMsg() &#125; &#125; getMsg() &#123;&#125; // 自定义函数&#125;&lt;/script&gt; 2.x 写法： 12345678910111213141516171819&lt;template&gt; &lt;view&gt; &lt;view @tap=&quot;tapBox&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;wepy.page(&#123; data: &#123;&#125;, onLoad() &#123;&#125;, // 生命周期函数 onShow() &#123;&#125;, // 生命周期函数 methods: &#123; tapBox() &#123; // wxml事件处理函数 this.getMsg() &#125;, updateList() &#123;&#125;, // 组件间事件处理函数 getMsg() &#123;&#125;, // 自定义函数 &#125;,&#125;)&lt;/script&gt; 组件引入方式变更在 2.x 版本中组件引入不再通过 import 进行导入，而是直接定义在页面的配置 &lt;config&gt; 中。1.7.2 写法： 12345678910111213&lt;template&gt; &lt;view&gt; &lt;child&gt;&lt;/child&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import Child from &#x27;./components/child.wpy&#x27;;export default class HOME extends wepy.page &#123; components = &#123; child: Child &#125;&#125;&lt;/script&gt; 2.x 写法： 123456789101112131415&lt;template&gt; &lt;view&gt; &lt;child&gt;&lt;/child&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;wepy.page(&#123;&#125;)&lt;/script&gt;&lt;config&gt;&#123; usingComponents: &#123; &#x27;child&#x27;: &#x27;./components/child.wpy&#x27;, &#125;&#125;&lt;/config&gt; 另外，2.x 中已经再不支持在 app.wpy 里定义全局组件，而 1.7.2 中是可以的。 生命周期函数调整在 2.x 中生命周期函数基本和原生保持一致，和 1.7.2 相比，只是需要把组件中的 onLoad 改成了 ready 即可，其他无需变动。 级别 1.7.2 2.x app onLaunch onLaunch app onShow onShow page onLoad onLoad page onShow onShow page onReady onReady component - created component - attached component onLoad ready 2.x 生命周期执行顺序： app onLaunch -&gt; app onShow -&gt; component created -&gt; component attached -&gt; page onLoad -&gt; page onShow -&gt; component ready -&gt; page onReady -&gt; page onUnload -&gt; component detached page onHide 在当前页面通过 wx.navigateTo 打开新页面的时候会执行，而如果是在当前页面点击返回上一个页面或者 wx.redirectTo 并不会执行。 不再支持请求拦截器（坑）在 1.7.2 中可以在 wepy.app 的构造函数里通过配置拦截器可以对请求进行拦截，请求被拦截后可以加上更多的请求参数以及请求响应后可以进行统一的错误处理，功能还是挺好用的。但是在 2.x 中这个功能至少从文档上是没看到，虽然源码里提供了一个 use-intercept拦截器的包，但是经过我几番尝试之后还是报错，所以就打算弃用拦截器了，直接在请求里进行参数增加和错误处理。request.js 这里贴一份大概的代码： 1234567891011121314151617181920import wepy from &quot;@wepy/core&quot;;import &#123; HOST &#125; from &quot;./constants&quot;;export default function(url, data, handler = toast, header = &#123;&#125;) &#123; // 头参数添加 header[&quot;Content-Type&quot;] = &quot;application/json&quot;; header[&quot;cType&quot;] = &quot;WECHAT&quot;; return wepy.wx.request(&#123; // 这里 wepy.wx.request 这种写法，需要在app.wpy里配置promisify， method: &quot;POST&quot;, data: data || &#123;&#125;, header, url: `$&#123;HOST&#125;$&#123;url&#125;`, &#125;).then(data =&gt; &#123; // 请求成功处理代码放这儿 return Promise.reject(data) &#125;).catch(err =&gt; &#123; // 错误处理代码放这儿 return Promise.reject(err); &#125;);&#125; 其中 wepy.wx.request 这种写法需要在 app.wpy 里配置 promisify，可以参考这里 use-promisify 标签属性的值必须被双引号包裹在 1.7.2 中对单引号和双引号没有强制要求，但是在 2.x 中必须是双引号，不然编译会报错。1.7.2 写法： 12345&lt;template&gt; &lt;view&gt; &lt;view class=&quot;title&quot; bindtap=&#x27;change&#x27;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 2.x 写法： 12345&lt;template&gt; &lt;view&gt; &lt;view class&#x3D;&quot;title&quot; bindtap&#x3D;&quot;change&quot;&gt;&lt;&#x2F;view&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt; 调用原生事件需要传入参数$wx小程序原生事件会传递一个 event 参数。而 WePY 的事件分发器在处理事件时会有一个 $event 参数。 $event 参数是对 event 进行了一层包装，目地是为了无侵入地对齐 Web Event 标准属性。而其中 $event.$wx === event。 因此，WePY 中响应事件获得的事件参数均是指 $event。如果想拿到原生事件参数，请使用 $event.$wx。1.7.2 写法： 123456789101112131415&lt;template&gt; &lt;view&gt;&lt;input bindinput=&quot;setInput&quot; value=&quot;&#123;&#123;name&#125;&#125;&quot; /&gt;&lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default class HOME extends wepy.page &#123; data = &#123; name: &#x27;&#x27;, &#125; methods = &#123; setInput(e) &#123; this.name = e.detail.value &#125; &#125;&#125;&lt;/script&gt; 2.x 写法，只需要将 bindinput=&quot;setInput&quot; 改成 @input=&quot;setInput($wx)&quot; 即可。 模板语法修改2.x 的模板语法继承了 WXML 的基本模板语法，并支持大部分 Vue 模板语法。对于标签：2.x 支持绝大部分的 HTML 标签，经过编译后会转成标准的 WXML 模板语法。但是对于 1.7.2 中的有一个标签 &lt;repeat&gt; 不再支持，需要将其替换成 &lt;view&gt; 并且用 v-for 进行循环渲染。 下面是一些常用的模板语法对于 2 个版本之间写法的对比：1.7.2 写法 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;view&gt; &lt;!-- 属性绑定 --&gt; &lt;view id=&quot;&#123;&#123; id &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;!-- 数据绑定 --&gt; &lt;view&gt;&#123;&#123; name &#125;&#125;&lt;/view&gt; &lt;!-- 事件绑定 --&gt; &lt;view bindtap=&quot;change(&#123;&#123; index &#125;&#125;)&quot;&gt;&lt;/view&gt; &lt;!-- class绑定 --&gt; &lt;view class=&quot;change &#123;&#123;hasData ? &#x27;has-data&#x27; : &#x27;&#x27; &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;!-- style绑定 --&gt; &lt;view style=&quot;&#123;&#123; &#x27;color:&#x27; + color + &#x27;;&#x27; + &#x27;font-size:&#x27; + fontSize + &#x27;;&#x27; &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;!-- 条件判断 --&gt; &lt;view wx:if=&quot;&#123;&#123; flag1 &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;view wx:elif=&quot;&#123;&#123; flag2 &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;view wx:else&gt;&lt;/view&gt; &lt;!-- 显示判断 --&gt; &lt;view hidden=&quot;&#123;&#123; !isShow &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;!-- 列表渲染，默认是：item、index --&gt; &lt;view wx:for=&quot;&#123;&#123; array &#125;&#125;&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 2.x 写法： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;view&gt; &lt;!-- 属性绑定 --&gt; &lt;view :id=&quot;id&quot;&gt;&lt;/view&gt; &lt;!-- 数据绑定 --&gt; &lt;view&gt;&#123;&#123; name &#125;&#125;&lt;/view&gt; &lt;!-- 事件绑定 --&gt; &lt;view @tap=&quot;change( index )&quot;&gt;&lt;/view&gt; &lt;!-- class绑定 --&gt; &lt;view class=&quot;change&quot; :class=&quot;&#123; &#x27;has-data&#x27;: hasData &#125;&quot;&gt;&lt;/view&gt; &lt;!-- style绑定 --&gt; &lt;view :style=&quot;&#123;&#x27;color&#x27;: color, &#x27;font-size&#x27;: fontSize &#125;&quot;&gt;&lt;/view&gt; &lt;!-- 条件判断 --&gt; &lt;view v-if=&quot;flag1&quot;&gt;&lt;/view&gt; &lt;view v-else-if=&quot;flag2&quot;&gt;&lt;/view&gt; &lt;view v-else&gt;&lt;/view&gt; &lt;!-- 显示判断 --&gt; &lt;view v-show=&quot;isShow&quot;&gt;&lt;/view&gt; &lt;!-- 列表渲染，默认是：item、index --&gt; &lt;view v-for=&quot;(item, index) in array&quot; :key=&quot;index&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 对于 v-for 循环列表的时候这里有一个（坑）不得不提一下，github issues直接看下面的代码： 1234&lt;view v-for=&quot;item in array&quot;&gt; &lt;view&gt;&#123;&#123; index &#125;&#125;&lt;/view&gt; &lt;view @tap=&quot;tapItem(index)&quot;&gt;&lt;/view&gt;&lt;/view&gt; 对于上面的代码，&lt;view&gt;&#123;&#123; index &#125;&#125;&lt;/view&gt; 可以正常显示索引值 index，但是 tapItem 传的参数却是 undefined，这所以我们需要显示的声明索引 v-for=&quot;(item, index) in array&quot; 即可。 表单双向绑定调整2.x 中直接用 v-model 进行表单绑定，而不需要再定义一个函数对其进行赋值操作。1.7.2 写法： 1234567891011121314&lt;template&gt; &lt;input value=&quot;&#123;&#123; name &#125;&#125;&quot; bindtap=&quot;setInput&quot; /&gt;&lt;/template&gt;&lt;script&gt;export default class HOME extends wepy.page &#123; data = &#123; name: &#x27;&#x27;, &#125; methods = &#123; bindtap(e) &#123; this.name = e.detail.value &#125; &#125;&#125; 2.x 写法： 123456789&lt;template&gt; &lt;input v-model=&quot;name&quot; /&gt;&lt;/template&gt;&lt;script&gt;wepy.page(&#123; data: &#123; name: &#x27;&#x27;, &#125;&#125;) 全局数据属性获取方式调整我们有时候需要在 app.wpy 里定义全局数据属性 globalData： 12345export default class APP extends wepy.app &#123; globalData = &#123; isBack: false &#125;&#125; 在 2.x 中定义方式没变，但是获取方式有所调整： 12345// 1.7.2 获取方式console.log(this.$parent.globalData.isBack)// 2.x 获取方式console.log(this.$app.$options.globalData.isBack) 全局样式对组件无效2.x 中对组件的实现方式保留了很多原生小程序的特性，比如这一条，组件样式 中明确说明：除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项），虽然可以通过更改组件样式隔离选项使得组件可以被全局样式作用到，但有时候也会带来弊端，比如在标签的属性 class 前面加上 ~，可以使组件获取全局样式，但是这样一来也带来一个问题，就是定义在组件里的该 class 样式会失效😭。这样的升级真的让写样式很难受，所以为了让样式写得尽量方便简单，我还是老老实实的把组件的样式就定义在组件里，不从全局拿样式了。 组件通信不再支持$broadcast父组件给子组件传递数据可以通过设置静态或者动态的 prop 属性或者通过广播 $broadcast 来让所有子组件都收到父组件的信息，而子组件给父组件通信可以通过在父级自定义事件，在子组件中通过 $emit 来通信。但是在 2.x 中不再支持父级给子组件进行事件广播了，而是可以通过给子组件加上 ref 属性后，通过 this.$refs 来直接操作子组件函数来达成通信的目的，如下代码：parent.wpy: 12345678910&lt;template&gt; &lt;child ref=&quot;child&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;wepy.page(&#123; onLoad() &#123; this.$refs.child.getList() &#125;&#125;)&lt;/script&gt; child.wpy： 1234567&lt;script&gt;wepy.component(&#123; methods: &#123; getList() &#123;&#125; &#125;&#125;)&lt;/script&gt; 组件prop不再支持双向绑定在 1.7.2 中可以通过可以通过设置 prop 给子组件传参，如果设置的时候加上 .sync 那么当父组件参数更新的时候，传递给子组件的也会自动更新，而如果在子组件的 prop 里加上 twoWay: true 则子组件数据可以绑定到父组件。从而实现组件数据的双向绑定。功能还是挺好用的，但遗憾的是在 2.x 中已经不再支持通过 twoWay: true 的方式从子组件绑定数据到父组件，父到子是可以的，但是不再需要设置 sync。那子组件需要更新父组件的数据，只能通过自定义事件，然后在子组件通过 $emit 进行更新数据了。1.7.2 写法：父页面： 123&lt;template&gt; &lt;child :title.sync=&quot;title&quot;&gt;&lt;/child&gt;&lt;/tempalte&gt; 子组件： 123456789export default class CHILD extends wepy.component &#123; props = &#123; title: &#123; type: String, default: &#x27;&#x27;, twoWay: true &#125; &#125;&#125; 2.x 写法：父页面： 123456789101112131415&lt;template&gt; &lt;child :title=&quot;title&quot; @changeTitle=&quot;changeTitle&quot;&gt;&lt;/child&gt;&lt;/tempalte&gt;&lt;script&gt; export default class HOME extends wepy.page &#123; data = &#123; title: &#x27;最开始的标题&#x27;, &#125; events = &#123; changeTitle(val) &#123; this.title = val &#125; &#125; &#125;&lt;/script&gt; 子组件： 1234567891011wepy.page(&#123; props: &#123; title: &#123; type: String, default: &#x27;&#x27;, &#125; &#125;, onLoad()&#123; this.$emit(&#x27;changeTitle&#x27;, &#x27;改变之后的标题&#x27;) &#125;&#125;) 组件插槽slot代码插入后层级错乱问题（坑）这个问题已经提到 github issues 中，且已经被作者标记为 bug。原始代码：parent.wpy 父页面： 123456&lt;template&gt; &lt;view&gt;parent&lt;/view&gt; &lt;child&gt; &lt;view&gt;child view&lt;/view&gt; &lt;/child&gt;&lt;/template&gt; child.wpy 子组件： 123456&lt;template&gt; &lt;view&gt; &lt;view&gt;child&lt;/view&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/view&gt;&lt;/template&gt; 期望的编译后（正确）的 template 是： 1234567&lt;template&gt; &lt;view&gt;parent&lt;/view&gt; &lt;view&gt; &lt;view&gt;child&lt;/view&gt; &lt;view&gt;child view&lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 而实际 2.x 编译后的 template 是会将对应的内容插入到子组件与根元素并列那级： 1234567&lt;template&gt; &lt;view&gt;parent&lt;/view&gt; &lt;view&gt; &lt;view&gt;child&lt;/view&gt; &lt;/view&gt; &lt;view&gt;child view&lt;/view&gt;&lt;/template&gt; 针对老项目里用到 slot 的地方，我只能改写代码来避开这个坑了。 资源引入调整资源引入方式调整主要是介绍组件引入和图片引入两种。首先来看组件引入： 12345678910&lt;config&gt;&#123; usingComponents: &#123; &#x27;load-more&#x27;: &#x27;/components/loadMore&#x27;, // 绝对路径 &#x27;btn&#x27;: &#x27;../btn&#x27;, // 相对路径 &#x27;list&#x27;: &#x27;~@/components/list&#x27;, // 通过wepy.config.js配置别名@指向src，实际上也是绝对路径 &#x27;van-icon&#x27;: &#x27;module:van-icon&#x27;, // 模块引入 &#125;&#125;&lt;/config&gt; 对于图片引入，存在两种方式：一种是静态的，程序在编译的时候就知道需要把哪些图片加载出来，另一种是动态的，只有在程序执行的时候才知道要加载哪些图片。对于第一种方式，通过相对路径、绝对路径或者 @ 都可以引入到图片： 1234567&lt;template&gt; &lt;view&gt; &lt;image src=&quot;../bg.png&quot;&gt;&lt;/image&gt; &lt;image src=&quot;/images/icon.png&quot;&gt;&lt;/image&gt; &lt;image src=&quot;@/images/nodata.png&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/template&gt; 对于第二种方式，需要将动态的图片放置在某个固定的位置，比如 /src/images/static，然后再 wepy.config.js 里配置 static: [&#39;/src/images/static&#39;] 这样在编译的时候就会把这个路径下的文件都拷贝到输出后的目录，从而能够准确引用这些动态图片。wepy.config.js 配置： 123module.exports = &#123; static: [&#x27;src/images/static&#x27;],&#125; 页面： 12345678910111213141516&lt;template&gt; &lt;view&gt; &lt;image :src=&quot;&#x27;../images/static/&#x27; + fileType + &#x27;.png&#x27;&quot;&gt;&lt;/image&gt; &lt;image :src=&quot;imgSrc&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; wepy.page(&#123; data: &#123; imgSrc: &#x27;&#x27;, &#125;, onLoad() &#123; this.imgSrc = &#x27;/images/static/icon.png&#x27; &#125; &#125;)&lt;/script&gt; 静态图片特殊处理：单独放到一个目录里，然后再WePY.config.js里配置static scss里如果引入.wxss文件会直接终止编译进程下面的代码是一个页面的 scss 样式里，引入了 wxss 文件，最终会导致编译进程终止。 1234&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt; @import &quot;./btn.scss&quot;; @import &quot;./styles/common.wxss&quot;;&lt;/style&gt; 解决办法： 123456&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt; @import &quot;./btn.scss&quot;;&lt;/style&gt;&lt;style lang=&quot;wxss&quot; type=&quot;text/wxss&quot;&gt; @import &quot;./styles/common.wxss&quot;;&lt;/style&gt; scss样式里存在特殊字符会导致编译报错（坑）这里的特殊字符其实也是正常的需求，比如引入了字体图标，那可能会有这种样式 content: &#39;\\6499&#39;, 然后因为有反斜杠会直接导致报错编译错误。解决思路是把这种带有特殊字符的样式放到 wxss 里，然后通过另外一个 style 引入进来，编译器进行编译的时候会对 scss 样式进行编译处理，但是对于 wxss 会直接拷贝到输入目录，而不进行编译处理，所以能绕过这个坑。 123456789&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt; @import &quot;./btn.scss&quot;;&lt;/style&gt;&lt;style lang=&quot;wxss&quot; type=&quot;text/wxss&quot;&gt; .icon-success::after &#123; content: &#x27;\\e8921&#x27;; color: green; &#125;&lt;/style&gt; 数据绑定机制调整1.7.2 中用脏检查进行数据绑定，通过 $apply() 方法使得数据能够及时更新，页面重新渲染。在 2.x 中使用了 Vue Observer 实现数据绑定，告别 $apply()，但是遇到一个问题，某个数组项的某个属性更新后，数组虽然是更新了，但是不能够触发页面进行重新渲染，即使使用 splice 也不行。不过可以通过浅拷贝一个引用类型，重新赋值，从而触发页面重新渲染。 123456789101112131415161718192021wepy.page(&#123; data: &#123; list: [&#123; name: &#x27;aaa&#x27;, hasBorder: true, &#125;, &#123; name: &#x27;bbb&#x27;, hasBorder: false, &#125;] &#125;, methods: &#123; handleClick() &#123; this.list[1].hasBorder = true // 不会重新渲染页面 this.list.splice(1, 1, &#123; // 也不会重新渲染页面 name: &#x27;bbb&#x27;, hasBorder: true, &#125;) this.list = [...this.list] // 浅拷贝，使得this.list的引用地址变化了，使得页面重新渲染 &#125; &#125;&#125;)","categories":[{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序、wepy","slug":"小程序、wepy","permalink":"https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%81wepy/"}]},{"title":"JavaScript中的数据类型","slug":"js-datatype","date":"2020-07-29T06:11:02.000Z","updated":"2020-07-29T08:14:17.456Z","comments":true,"path":"2020/07/29/js-datatype/","link":"","permalink":"https://bubuzou.com/2020/07/29/js-datatype/","excerpt":"JavaScript中有哪些数据类型？计算机世界中定义的数据类型其实就是为了描述现实世界中存在的事实而定义的。比如我们用人来举例： 有没有人在房间里？这里的有和没有就是是或者非的概念，在 JS 中对应 Boolean 类型，true 表示是，false 表示非； 有几个人在房间里？这里的几个表示的是一个量级概念，在 JS 中对应 Number 类型，包含整数和浮点数，还有一些特殊的值，比如：-Infinity 表示负无穷大、+Infinity 表示正无穷大、NaN 表示不是一个数字； 房间里的这些人都是我的朋友。这是一句陈述语句，这种文本类的信息将会以字符串形式进行存储，在 JS 中对应 String 类型； 房间里没有人。这里的没有代表无和空的概念，在 JS 中 null 和 undefined 都可以表示这个意思； 现实世界中所有人都是独一无二的，这在 JS 中对应 Symbol 类型，表示唯一且不可改变； Number 所表示的整数是有范围的，超出范围的数据就没法用 Number 表示了，于是 ES10 中提出了一种新的数据类型 BigInt，能表示任何位数的整数； 以上提到的 Boolean、Number、String、null、undefined、Symbol 和 BigInt 等7种类型都是 JavaScript 中的原始类型，还有一种是非原始类型叫做对象类型；比如：一个人是对象，这个人有名字、性别、年龄等； 12345let person = &#123; name: &#x27;bubuzou&#x27;, sex: &#x27;male&#x27;, age: 26,&#125;","text":"JavaScript中有哪些数据类型？计算机世界中定义的数据类型其实就是为了描述现实世界中存在的事实而定义的。比如我们用人来举例： 有没有人在房间里？这里的有和没有就是是或者非的概念，在 JS 中对应 Boolean 类型，true 表示是，false 表示非； 有几个人在房间里？这里的几个表示的是一个量级概念，在 JS 中对应 Number 类型，包含整数和浮点数，还有一些特殊的值，比如：-Infinity 表示负无穷大、+Infinity 表示正无穷大、NaN 表示不是一个数字； 房间里的这些人都是我的朋友。这是一句陈述语句，这种文本类的信息将会以字符串形式进行存储，在 JS 中对应 String 类型； 房间里没有人。这里的没有代表无和空的概念，在 JS 中 null 和 undefined 都可以表示这个意思； 现实世界中所有人都是独一无二的，这在 JS 中对应 Symbol 类型，表示唯一且不可改变； Number 所表示的整数是有范围的，超出范围的数据就没法用 Number 表示了，于是 ES10 中提出了一种新的数据类型 BigInt，能表示任何位数的整数； 以上提到的 Boolean、Number、String、null、undefined、Symbol 和 BigInt 等7种类型都是 JavaScript 中的原始类型，还有一种是非原始类型叫做对象类型；比如：一个人是对象，这个人有名字、性别、年龄等； 12345let person = &#123; name: &#x27;bubuzou&#x27;, sex: &#x27;male&#x27;, age: 26,&#125; 为什么要区分原始类型和对象类型？他们之间有什么区别？原始类型的不可变性在回答这个问题之前，我们先看一下变量在内存中是如何存储的： 123let name1 = &#x27;bubuzou&#x27;let name2 = name1.concat(&#x27;.com&#x27;)console.log(name1) // &#x27;bubuzou&#x27; 执行完上面这段代码，我们发现变量 name1 的值还是不变，依然是 bubuzou。这就说明了字符串的不可变性。但是你看了下面的这段代码，你就会产生疑问了： 123let name1 = &#x27;bubuzou&#x27;name1 += &#x27;.com&#x27;console.log(name1) // &#x27;bubuzou.com&#x27; 你说字符串是不可变的，那现在不是变了嘛？其实这只是变量的值变了，但是存在内存中的字符串依然不变。这就涉及到变量在内存中的存储了。在 JavaScript 中，变量在内存中有2种存储方式：存在栈中和存在堆中。那么栈内存和堆内存有啥区别呢？ 栈内存： 顺序存储结构，特点是先进后出。就像一个兵乒球盒子一样，兵乒球从外面一个个的放入盒子里，最先取出来的一定是最后放入盒子的那个。 存储空间固定 可以直接操作其保存的值，执行效率高 堆内存： 无序的存储结构 存储空间可以动态变化 无法直接操作其内部的存储，需要通过引用地址操作 了解完变量在内存中的存储方式有2种，那我们继续以上面那串代码为例，画出变量的存储结构图：然后我们可以描述下当计算机执行这段代码时候的发生了什么？首先定义了一个变量 name1 并且给其赋值 bubuzou 这个时候就会在内存中开辟一块空间用来存储字符串 bubuzou，然后变量指向了这个内存空间。然后再执行第二行代码 let name2 = name1.concat(&#39;.com&#39;) 这里的拼接操作其实是产生了一个新字符串 bubuzou.com，所以又会为这个新字符串创建一块新内存，并且把定义的变量 name2 指向这个内存地址。 所以我们看到其实整个操作 bubuzou 这个字符串所在的内存其实是没有变化的，即使在第二段代码中执行了 name1 += &#39;.com&#39; 操作，其实也只是变量 name1 指向了新的字符串 bubuzou.com 而已，旧的字符串 bubuzou 依然存在内存中，不过一段时间后由于该字符串没有被变量所引用，所以会被当成垃圾进行回收，从而释放掉该块内存空间。 从而我们得出结论：原始类型的值都是固定的，而对象类型则是由原始类型的键值对组合成一个复杂的对象；他们在内存中的存储方式是不一样的，原始类型的值直接存在栈内存中，而对象类型的实际值是存在堆内存中的，在栈内存中保存了一份引用地址，这个地址指向堆内存中的实际值，所以对象类型又习惯被叫做引用类型。 想一个问题为什么引用类型的值要存储到堆内存中？能不能存到栈内存中呢？答案一：因为引用类型大小不固定，而栈的大小是固定的，堆空间的大小是可以动态变化的，所以引用类型的值适合存在堆中；答案二：在代码执行过程中需要频繁的切换执行上下文的时候，如果把引用类型的值存到栈中，将会造成非常大的内存开销。 比较当我们对两个变量进行比较的时候，不同类型的变量是有不同表现的： 1234567891011let str1 = &#x27;hello&#x27;let str2 = &#x27;hello&#x27;console.log( str1 === str2 ) // truelet person1 = &#123; name: &#x27;bubuzou&#x27;&#125;let person2 = &#123; name: &#x27;bubuzou&#x27;&#125;console.log( person1 === person2 ) // false 我们定义了2个字符串变量和2个对象变量，他们都长一模一样，但是字符串变量会相等，对象变量却不相等。这是因为在 JavaScript 中，原型类型进行比较的时候比较的是存在栈中的值是否相等；而引用类型进行比较的时候，是比较栈内存中的引用地址是否相等。如上几个变量在内存中的存储模型如图所示： 复制变量进行复制的时候，原始类型和引用类型变量也是有区别的，来看下面的代码： 1234let str1 = &#x27;hello&#x27;let str2 = str1str2 = &#x27;world&#x27;console.log( str1 ) // &#x27;hello&#x27; let str1 = &#39;hello&#39;: 复制前，定义了一个变量 str1，并且给其赋值 hello，这个时候 hello 这个字符串就会在栈内存中被分配一块空间进行存储，然后变量 str1 会指向这个内存地址； let str2 = str1：复制后，把 str1 的值赋值给 str2，这个时候会在栈中新开辟一块空间用来存储 str2 的值； str2 = &#39;world&#39;：给 str2 赋值了一个新的字符串 world，那么将新建一块内存用来存储 world，同时 str2 原来的值 hello 的内存空间因为没有变量所引用，所以一段时间后建被当成垃圾回收； console.log( str1 )：因为 str1 和 str2 的栈内存地址是不一样的，所以即使 str2 的值被改变，也不会影响到 str1。 然后我们继续往下，看下引用类型的复制： 1234567let person1 &#x3D; &#123; name: &#39;bubuzou&#39;, age: 20&#125;let person2 &#x3D; person1person2.name &#x3D; &#39;bubuzou.com&#39;console.log( person1.name) &#x2F;&#x2F; &#39;bubuzou.com&#39; 原始类型进行复制的时候是变量的值进行重新赋值，而如上图所示：引用类型进行复制的时候是把变量所指向的引用地址进行赋值给新的变量，所以复制后 person1 和 person2 都指向堆内存中的同一个值，所以当改变 person2.name 的时候， person1.name 也会被改变就是这个原因。 值传递和引用传递先说一下结论，在 JavaScript 中，所有函数的参数传递都是按值进行传递的。看如下代码： 123456let name = &#x27;bubuzou&#x27;function changeName(name) &#123; name = &#x27;bubuzou.com&#x27;&#125;changeName(name)console.log( name ) // &#x27;bubuzou&#x27; 定义了一个变量 name，并赋值为 bubuzou，函数调用的时候传入 name，这个时候会在函数内部创建一个局部变量 name 并且把全局变量的值 bubuzou 传递给他，这个操作其实是在内存里新建了一块空间用来存放局部变量的值，然后又把局部变量的值改成了 bubuzou.com，这个时候其实内存中会有3块地址空间分别用来存放全局变量的值 bubuzou、局部变量原来的值 bubuzou、和局部变量新的值 bubuzou.com；一旦函数调用结束，局部变量将被销毁，一段时间后由于局部变量新旧值没有变量引用，那这两块空间将被回收释放；所以这个时候全局 name 的值依然是 bubuzou。 再来看看引用类型的传参，会不会有所不同呢？ 12345678let person = &#123; name: &#x27;bubuzou&#x27;&#125;function changePerosn(person) &#123; person.name = &#x27;bubuzou.com&#x27;&#125;changePerosn( person )console.log( person.name ) // &#x27;bubuzou.com&#x27; 引用类型进行函数传参的时候，会把引用地址复制给局部变量，所以全局的 person 和函数内部的局部变量 person 是指向同一个堆地址的，所以一旦一方改变，另一方也将被改变，所以至此我们是不是可以下结论说：当函数进行传参的时候如果参数是引用类型那么就是引用传递嘛？ 将上面的例子改造下： 1234567891011let person = &#123; name: &#x27;bubuzou&#x27;&#125;function changePerosn(person) &#123; person.name = &#x27;bubuzou.com&#x27; person = &#123; name: &#x27;hello world&#x27; &#125;&#125;changePerosn( person ) console.log( person.name ) // &#x27;bubuzou.com&#x27; 如果 person 是引用传递的话，那就会自动指向值被改为 hello world 的新对象；事实上全局变量 person 的引用地址自始至终都没有改变，倒是局部变量 person 的引用地址发生了改变。 null 和 undefined 傻傻分不清？null 在 JavaScript 中自成一种原始类型，只有一个值 null，表示无、空、值未知等特殊值。可以直接给一个变量赋值为 null： 1let s = null undefined 和 null 一样也是自成一种原始类型，表示定义了一个变量，但是没有赋值，则这个变量的值就是 undefined: 12let sconsole.log( s) // undefined 虽然可以给变量直接赋值为 undefined 也不会报错，但是原则上如果一个变量值未定，或者表示空，则直接赋值为 null 比较合适，不建议给变量赋值 undefined。null 和 undefined 在进行逻辑判断的时候都是会返回 false 的： 12let a = null, bconsole.log( a ? &#x27;a&#x27; : b ? &#x27;b&#x27; : &#x27;c&#x27;) // &#x27;c&#x27; null 在转成数字类型的时候会变成 0，而 undefined 会变成 NaN: 123let a = null, bconsole.log( +null ) // 0console.log( + b ) // NaN 认识新的原始类型 SymbolSymbol 值表示唯一标识符，是 ES6 中新引进的一种原始类型。可以通过 Symbol() 来创建一个重要的值，也可以传入描述值；其唯一性体现在即使是传入一样的描述，他们两者之间也是不会相等的： 123let a = Symbol(&#x27;bubuzou&#x27;)let b = Symbol(&#x27;bubuzou&#x27;)console.log( a === b ) // false 全局的 Symbol那还是不是任意2个描述一样的 Symbol 都是不相等的呢？答案是否定的。可以通过 Symbol.for() 来查找或新建一个 Symbol： 123let a = Symbol.for(&#x27;bubuzou&#x27;)let b = Symbol.for(&#x27;bubuzou&#x27;)console.log( a === b ) // true 使用 Symbol.for() 可以在根据传入的描述在全局范围内进行查找，如果没找到则新建一个 Symbol，并且返回；所以当执行第二行代码 Symbol.for(&#39;bubuzou&#39;) 的时候，就会找到全局的那个描述为 bubuzou 的 Symbol，所以这里 a 和 b 是会绝对相等的。 居然可以通过描述找到 Symbol， 那是否可以通过 Symbol 来找到描述呢？答案是肯定的，但是必须是全局的 Symbol，如果没找到则会返回 undefined: 123let a = Symbol.for(&#x27;bubuzou&#x27;)let desc = Symbol.keyFor( a )console.log( desc ) // &#x27;bubuzou&#x27; 但是对于任何一个 Symbol 都有一个属性 description，表示这个 Symbol 的描述： 12let a = Symbol(&#x27;bubuzou&#x27;)console.log( a.description ) // &#x27;bubuzou&#x27; Symbol 作为对象属性我们知道对象的属性键可以是字符串，但是不能是 Number 或者 Boolean；Symbol 被设计出来其实最大的初衷就是用于对象的属性键： 12345let age = Symbol(&#x27;20&#x27;)let person = &#123; name: &#x27;bubuzou&#x27;, [age]: &#x27;20&#x27;, // 在对象字面量中使用 `Symbol` 的时候需要使用中括号包起来&#125; 这里给 person 定义了一个 Symbol 作为属性键的属性，这个相比于用字符串作为属性键有啥好处呢？最明显的好处就是如果这个 person 对象是多个开发者进行开发维护，那么很容易再给 person 添加属性的时候出现同名的，如果是用字符串作为属性键那肯定是冲突了，但是如果用 Symbol 作为属性键，就不会存在这个问题了，因为它是唯一标识符，所以可以使对象的属性受到保护，不会被意外的访问或者重写。 注意一点，如果用 Symbol 作为对象的属性键的时候，for in 、Object.getOwnPropertyNames、或 Object.keys() 这里循环是无法获取 Symbol 属性键的，但是可以通过 Object.getOwnPropertySymbols() 来获取；在上面的代码基础上： 123456for (let o in person) &#123; console.log( o ) // &#x27;name&#x27;&#125;console.log (Object.keys( person )) // [&#x27;name&#x27;]console.log(Object.getOwnPropertyNames( person )) // [&#x27;name&#x27;]console.log(Object.getOwnPropertySymbols( person )) // [Symbol(20)] 你可能不知道的 Number 类型JavaScript 中的数字涉及到了两种类型：一种是 Number 类型，以 64 位的格式 IEEE-754 存储，也被称为双精度浮点数，就是我们平常使用的数字，其范围是 $2^{52}$ 到 -$2^{52}$；第二种类型是 BigInt，能够表示任意长度的整数，包括超出 $2^{52}$ 到 -$2^{52}$ 这个范围外的数。这里我们只介绍 Number 数字。 常规数字和特殊数字对于一个常规的数字，我们直接写即可，比如: 1let age = 20 但是还有一种位数特别多的数字我们习惯用科学计数法的表示方法来写： 12let billion = 1000000000;let b = 1e9 以上两种写法是一个意思， 1e9 表示 1 x $10^9$；如果是 1e-3 表示 1 / $10^3$ = 0.001。在 JavaScript 中也可以用数字表示不同的进制，比如：十进制中的 10 在 二、八和十六进制中可以分别表示成 0b1010、0o12 和 0xa；其中的 0b 是二进制前缀，0o 是八进制前缀，而 ox 是十六进制的前缀。 我们也可以通过 toString(base) 方法来进行进制之间的转换， base 是进制的基数，表示几进制，默认是 10 进制的，会返回一个转换数值的字符串表示。比如： 1234let num = 10console.log( num.toString( 2 )) // &#x27;1010&#x27;console.log( num.toString( 8 )) // &#x27;12&#x27;console.log( num.toString( 16 )) // &#x27;a&#x27; 数字也可以直接调用方法，10..toString( 2 ) 这里的 2个 . 号不是写错了，而是必须是2个，否则会报 SyntaxError 错误。第一个点表示小数点，第二个才是调用方法。点符号首先会被认为是数字常量的一部分，其次再被认为是属性访问符，如果只写一个点的话，计算机无法知道这个是表示一个小数呢还是去调用函数。数字直接调用函数还可以有以下几种写法： 123(10).toString(2) // 将10用括号包起来10.0.toString(2) // 将10写成10.0的形式10 .toString(2) // 空格加上点符号调用 Number 类型除了常规数字之外，还包含了一些特殊的数字： NaN：表示不是一个数字，通常是由不合理的计算导致的结果，比如数字除以字符串 1 / &#39;a&#39;;NaN 和任何数进行比较都是返回 false，包括他自己： NaN == NaN 会返回 false;如何判断一个数是不是 NaN 呢？有四种方法： 方法一：通过 isNaN() 函数，这个方法会对传入的字符串也返回 true，所以判断不准确，不推荐使用： 12isNaN( 1 / &#x27;a&#x27;)` // trueisNaN( &#x27;a&#x27; ) // true 方法二：通过 Number.isNaN()，推荐使用： 12Number.isNaN( 1 / &#x27;a&#x27;)` // trueNumber.isNaN( &#x27;a&#x27; ) // false 方法三：通过 Object.is(a, isNaN): 12Object.is( 0/&#x27;a&#x27;, NaN) // trueObject.is( &#x27;a&#x27;, NaN) // false 方法四：通过判断 n !== n，返回 true， 则 n 是 NaN : 12let s = 1/&#x27;a&#x27;console.log( s !== s ) // true +Infinity：表示正无穷大，比如 1/0 计算的结果, -Infinity 表示负无穷大，比如 -1/0 的结果。 +0 和 -0，JavaScript 中的数字都有正负之分，包括零也是这样，他们会绝对相等： 1console.log( +0 === -0 ) // true 为什么 0.1 + 0.2 不等于 0.31console.log( 0.1 + 0.2 == 0.3 ) // false 有没有想过为什么上面的会不相等？因为数字在 JavaScript 内部是用二进制进行存储的，其遵循 IEEE 754 标准的，用 64 位来存储一个数字，64 位又被分隔成 1、11 和 52 位来分别表示符号位、指数位和尾数位。比如十进制的 0.1 转成二进制后是多少？我们手动计算一下，十进制小数转二进制小数的规则是“乘2取整，顺序排列”，具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。 123456780.1 * 2 &#x3D; 0.2 &#x2F;&#x2F; 第1步：整数为0，小数0.20.2 * 2 &#x3D; 0.4 &#x2F;&#x2F; 第2步：整数为0，小数0.40.4 * 2 &#x3D; 0.8 &#x2F;&#x2F; 第3步：整数为0，小数0.80.8 * 2 &#x3D; 1.6 &#x2F;&#x2F; 第4步：整数为1，小数0.60.6 * 2 &#x3D; 1.2 &#x2F;&#x2F; 第5步：整数为1，小数0.20.2 * 2 &#x3D; 0.4 &#x2F;&#x2F; 第6步：整数为0，小数0.40.4 * 2 &#x3D; 0.8 &#x2F;&#x2F; 第7步：整数为0，小数0.8... 我们这样依次计算下去之后发现得到整数的顺序排列是 0001100110011001100.... 无限循环，所以理论上十进制的 0.1 转成二进制后会是一个无限小数 0.0001100110011001100...，用科学计数法表示后将是 1.100110011001100... x $2^{-4}$ ，但是由于 IEEE 754 标准规定了一个数字的存储位数只能是 64 位，有效位数是 52 位，所以将会对 1100110011001100.... 这个无限数字进行舍入总共 52 位作为有效位，然后二进制的末尾取舍规则是看后一位数如果是 1 则进位，如果是 0 则直接舍去。那么由于 1100110011001100.... 这串数字的第 53 位刚好是 1 ，所以最终的会得到的数字是 1100110011001100110011001100110011001100110011001101，即1.100110011001100110011001100110011001100110011001101 x $2^{-4}$。十进制转二进制也可以用 toString 来进行转化: 1console.log( 0.1.toString(2) ) // &#x27;0.0001100110011001100110011001100110011001100110011001101&#x27; 我们发现十进制的 0.1 在转化成二进制小数的时候发生了精度的丢失，由于进位，它比真实的值更大了。而 0.2 其实也有这样的问题，也会发生精度的丢失，所以实际上 0.1 + 0.2 不会等于 0.3: 1console.log( 0.1 + 0.2 ) // 0.30000000000000004 那是不是没办法判断两个小数是否相等了呢？答案肯定是否定的，想要判断2个小数 n1 和 n2 是否相等可以如下操作： 方法一：两小数之差的绝对值如果比 Number.EPSILON 还小，那么说明两数是相等的。 Number.EPSILON 是 ES6 中的误差精度，实际值可以认为等于 $2^{-52}$。 123if ( Math.abs( n1 - n2 ) &lt; Number.EPSILON ) &#123; console.log( &#x27;n1 和 n2 相等&#x27; )&#125; 方法二：通过 toFixed(n) 对结果进行舍入，toFixed() 将会返回字符串，我们可以用 一元加 + 将其转成数字： 12let sum = 0.1 + 0.2console.log( +sum.toFixed(2) === 0.3 ) // true 数值的转化对数字进行操作的时候将常常遇到数值的舍入和字符串转数字的问题，这里我们巩固下基础。先来看舍入的： Math.floor()，向下舍入，得到一个整数: 12Math.floor(2.2) // 2Math.floor(2.8) // 2 Math.ceil()，向上舍入，得到一个整数： 12Math.ceil(2.2) // 3Math.ceil(2.8) // 3 Math.round()，对第一位小数进行四舍五入： 123Math.round(2.26) // 2Math.round(2.46) // 2Math.round(2.50) // 3 Number.prototype.toFixed(n)，和 Math.round() 一样会进行四舍五入，将数字舍入到小数点后 n 位，并且以字符串的形式返回： 12312..toFixed(2) // &#x27;12.00&#x27;12.14.toFixed(1) // &#x27;12.1&#x27;12.15.toFixed(1) // &#x27;12.2&#x27; 为什么 6.35.toFixed(1) 会等于 6.3 ？因为 6.35 其实是一个无限小数： 16.35.toFixed(20) // &quot;6.34999999999999964473&quot; 所以在 6.35.toFixed(1) 求值的时候会得到 6.3。 再来看看字符串转数字的情况： Number(n) 或 +n，直接将 n 进行严格转化： 123456Number(&#x27; &#x27;) // 0console.log( +&#x27;&#x27;) // 0Number(&#x27;010&#x27;) // 10console.log( +&#x27;010&#x27; ) // 10Number(&#x27;12a&#x27;) // NaNconsole.log( +&#x27;12a&#x27; ) // NaN parseInt()，非严格转化，从左到右解析字符串，遇到非数字就停止解析，并且把解析的数字返回： 1234parseInt(&#x27;12a&#x27;) // 12parseInt(&#x27;a12&#x27;) // NaNparseInt(&#x27;&#x27;) // NaNparseInt(&#x27;0xA&#x27;) // 10，0x开头的将会被当成十六进制数 parseInt() 默认是用十进制去解析字符串的，其实他是支持传入第二个参数的，表示要以多少进制的 基数去解析第一个参数： 12parseInt(&#x27;1010&#x27;, 2) // 10parseInt(&#x27;ff&#x27;, 16) // 255 如何判断一个数是不是整数？介绍两种方法： 方法一：通过 Number.isInteger(): 12Number.isInteger(12.0) // trueNumber.isInteger(12.2) // false 方法二：typeof num == &#39;number&#39; &amp;&amp; num % 1 == 0 123function isInteger(num) &#123; return typeof num == &#x27;number&#x27; &amp;&amp; num % 1 == 0&#125; 引用类型除了原始类型外，还有一个特别重要的类型：引用类型。高程里这样描述他：引用类型是一种数据结构， 用于将数据和功能组织在一起。到目前为止，我们看到最多的引用类型就是 Object，创建一个 Object 有两种方式： 方式一：通过 new 操作符： 123let person = new Object()person.name = &#x27;bubuzou&#x27;person.age = 20 方式二：通过对象字面量，这是我们最喜欢用的方式： 1234let person = &#123; name: &#x27;bubuzou&#x27;, age: 20&#125; 内置的引用类型除了 Object 外，在 JavaScript 中还有别的内置的引用类型，比如： Array 数组 Date 日期 RegExp 正则表达式 Function 函数 他们的原型链的顶端都会指向 Object: 12let d = new Date()console.log( d.__proto__.__proto__.constructor ) // ƒ Object() &#123; [native code] &#125; 包装类型先来看一个问题，为什么原始类型的变量没有属性和方法，但是却能够调用方法呢？ 12let str = &#x27;bubuzou&#x27;str.substring(0, 3) // &#x27;bub&#x27; 因为 JavaScript 为了更好地操作原始类型，设计出了几个对应的包装类型，他们分别是： Boolean Number String 上面那串代码的执行过程其实是这样的： 创建 String 类型的一个实例; 在实例上调用指定的方法; 销毁这个实例 用代码体现一下： 123let str = new String(&#x27;bubuzou&#x27;)str.substring(0, 3)str = null 原始类型调用函数其实就是自动进行了装箱操作，将原始类型转成了包装类型，然后其实原始类型和包装类型是有本质区别的，原始类型是原始值，而包装类型是对象实例： 12345let str1 = &#x27;bubuzou&#x27;let str2 = new String(&#x27;bubuzou&#x27;)console.log( str1 === str2 ) // fasleconsole.log( typeof str1 ) // &#x27;string&#x27;console.log( typeof str2 ) // &#x27;object&#x27; 居然有装箱操作，那肯定也有拆箱操作，所谓的拆箱就是包装类型转成原始类型的过程，又叫 ToPromitive，来看下面的例子： 123456let obj = &#123; toString: () =&gt; &#123; return &#x27;bubuzou&#x27; &#125;, valueOf: () =&gt; &#123; return 20 &#125;,&#125;console.log( +obj ) // 20console.log( `$&#123;obj&#125;` ) // &#x27;bubuzou&#x27; 在拆箱操作的时候，默认会尝试调用包装类型的 toString() 和 valueOf() 方法，对于不同的 hint 调用顺序会有所区别，如果 hint 是 string 则优先调用 toString()，否则的话，则优先调用 valueOf()。默认情况下，一个 Object 对象具有 toString() 和 valueOf() 方法： 123let obj = &#123;&#125;console.log( obj.toString() ) // &#x27;[object Object]&#x27;console.log( obj.valueOf() ) // &#123;&#125;，valueOf会返回对象本身 类型装换Javascript 是弱类型的语音，所以对变量进行操作的时候经常会发生类型的转换，尤其是隐式类型转换，可能会让代码执行结果出乎意料之外，比如如下的代码你能理解其执行结果嘛？ 12[] + &#123;&#125; // &#x27;[object Object]&#x27;&#123;&#125; + [] // 0 类型转换规则所以我们需要知道类型转换的规则，以下整理出一个表格，列出了常见值和类型以及转换之后的结果，仅供参考。 转换前的值 转换前类型 toBoolean toNumber toString true Boolean - 1 “true” false Boolean - 0 “false” null Null false 0 “null” undefined Undefined false NaN “undefined” 123 Number true - “123” Infinity Number true - “Infinity” 0 Number false - “0” NaN Number false - “NaN” “” String false 0 - “ “ String true 0 - “0” String true 0 - “123” String true 123 - “123abc” String true NaN - Symbol() Symbol true TypeError TypeError {} Object true NaN “[object Object]” [] Object true 0 “” [“0”] Object true 0 “0” [“0”, “a”] Object true NaN “0,a” [“0”, undefined, “a”] Object true Nan “0,,a” 显示类型转换我们平时写代码的时候应该尽量让写出来的代码通俗易懂，让别人能阅读后知道你是要做什么，所以在对类型进行判断的时候应该尽量显示的处理。比如将字符串转成数字，可以这样： 123Number( &#x27;21&#x27; ) // 21Number( &#x27;21.8&#x27; ) // 21.8+&#x27;21&#x27; // 21 将数字显示转成字符串可以这样： 12String(21) // &#x27;21&#x27;21..toString() // &#x27;21&#x27; 显示转成布尔类型可以这样： 1234Boolean(&#x27;21&#x27;) // trueBoolean( undefined ) // false!!NaN // false!!&#x27;21&#x27; // true 除了以上之外，还有一些关于类型转换的冷门操作，有时候也挺管用的：直接用一元加操作符获取当前时间的毫秒数： 1+new Date() // 1595517982686 用 ~ 配合 indexOf() 将操作结果直接转成布尔类型： 1234let str = &#x27;bubuzou.com&#x27;if (~str.indexOf(&#x27;.com&#x27;)) &#123; console.log( &#x27;str如果包含了.com字符串，则会打印这句话&#x27; )&#125; 使用 ~~ 对字符或数字截取整数，和 Math.floor() 有稍许不同： 12345~~21.1 // 21~~-21.9 // -21~~&#x27;1.2a&#x27; // 0Math.floor( 21.1 ) // 21Math.floor( -21.9 ) // -22 隐式类型转换隐式类型转换发生在 JavaScript 的运行时，通常是由某些操作符或语句引起的，有下面这几种情况： 隐式转成布尔类型： if (..)语句中的条件判断表达式。 for ( .. ; .. ; .. )语句中的条件判断表达式(第二个)。 while (..) 和 do..while(..) 循环中的条件判断表达式。 ? :中的条件判断表达式。 逻辑运算符 || (逻辑或)和 &amp;&amp; (逻辑与)左边的操作数(作为条件判断表达式) 1234567if (42) &#123; console.log(42)&#125;while (&#x27;bubuzou&#x27;) &#123; console.log(&#x27;bubuzou&#x27;)&#125;const c = null ? &#x27;存在&#x27; : &#x27;不存在&#x27; // &#x27;不存在&#x27; 上例中的非布尔值会被隐式强制类型转换为布尔值以便执行条件判断。需要特别注意的是 || 和 &amp;&amp; 操作符。|| 的操作过程是只有当左边的值返回 false 的时候才会对右边进行求值且将它作为最后结果返回，类似 a ? a : b 这种效果: 12const a = &#x27;a&#x27; || &#x27;b&#x27; // &#x27;a&#x27;const b = &#x27;&#x27; || &#x27;c&#x27; // &#x27;c&#x27; 而 &amp;&amp; 的操作过程是只有当左边的值返回 true 的时候才对右边进行求值且将右边的值作为结果返回，类似 a ? b : a 这种效果： 12const a = &#x27;a&#x27; &amp;&amp; &#x27;b&#x27; // &#x27;b&#x27;const b = &#x27;&#x27; &amp;&amp; &#x27;c&#x27; // &#x27;&#x27; 数学操作符 - * / 会对非数字类型的会优先转成数字类型，但是对 + 操作符会比较特殊： 当一侧为 String 类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。 当一侧为 Number 类型，另一侧为原始类型，则将原始类型转换为 Number 类型。 当一侧为 Number 类型，另一侧为引用类型，将引用类型和 Number 类型转换成字符串后拼接。1234542 + &#x27;bubuzou&#x27; // &#x27;42bubuzou&#x27;42 + null // 4242 + true // 4342 + [] // &#x27;42&#x27;42 + &#123;&#125; // &#x27;42[object Object]&#x27; 宽松相等和严格相等 宽松相等（==）和严格相等（===）在面试的时候经常会被问到，而回答一般是 == 是判断值是否相等，而 === 除了判断值会不会相等之外还会判断类型是否相等，这个答案不完全正确，更好的回答是：== 在比较过程中允许发生隐式类型转换，而 === 不会。 那 == 是怎么进行类型转换的呢？ 数字和字符串比，字符串将转成数字进行比较： 1220 == &#x27;20&#x27; // true20 === &#x27;20&#x27; // false 别的类型和布尔类型比较，布尔类型将首先转成数字进行比较，true 转成数字 1, false 转成数字 0，注意这个是非常容易出错的一个点： 123456&#x27;bubuzou&#x27; == true // false&#x27;0&#x27; == false // truenull == false // false,undefined == false // false[] == true // false[&#x27;1&#x27;] == true // true 所以写代码进行判断的时候一定不要写成 x == true 或 x == false 这种，而应该直接 if (x) 判断。 null 和 undefined: null == undefined 比较结果是 true，除此之外，null、undefined 和其他任何结果的比较值都为 false。可以认为在 == 的情况下，null 和 undefined 可以相互的进行隐式类型转换。 1234567null == undefined // truenull == &#x27;&#x27; // falsenull == 0 // falsenull == false // falseundefined == &#x27;&#x27; // falseundefined == 0 // falseundefined == false // false 原始类型和引用类型比较，引用类型会首先进行 ToPromitive 转成原始类型然后进行比较，规则参考上面介绍的拆箱操作： 1234&#x27;42&#x27; == [42] // true&#x27;1,2,3&#x27; == [1, 2, 3] // true&#x27;[object Object]&#x27; == &#123;&#125; // true0 == [undefined] // true 特殊的值 12345NaN == NaN // false+0 == -0 // true[] == ![] // true，![]的优先级比==高，所以![]先转成布尔值变成false；即变成[] == false，false再转成数字0，[]转成数字0，所以[] == ![]0 == &#x27;\\n&#x27; // true 类型检测用typeof检测原始类型JavaScript 中有 null、undefined、boolean、number、string、Symbol 等六种原始类型，我们可以用 typeof 来判断值是什么原始类型的，会返回类型的字符串表示： 12345typeof undefined // &#x27;undefined&#x27;typeof true // &#x27;boolean&#x27;typeof 42 // &#x27;number&#x27;typeof &quot;42&quot; // &#x27;string&#x27;typeof Symbol() // &#x27;symbol&#x27; 但是原始类型中有一个例外，typeof null 会得到 ‘object’，所以我们用 typeof 对原始值进行类型判断的时候不能得到一个准确的答案，那如何判断一个值是不是 null 类型的呢？ 12let o = null!o &amp;&amp; typeof o === &#x27;object&#x27; // 用于判断 o 是否是 null 类型 undefined 和 undeclared 有什么区别？前者是表示在作用域中定义了但是没有赋值的变量，而后者是表示在作用域中没有定义的变量；分别表示 undefined 未定义、undeclared 未声明。 typeof 能够对原始类型进行判断，那是否也能判断引用类型呢？ 12345typeof [] // &#x27;object&#x27;typeof &#123;&#125; // &#x27;object&#x27;typeof new Date() // &#x27;object&#x27;typeof new RegExp() // &#x27;object&#x27;typeof new Function() // &#x27;function&#x27; 从上面的结果我们可以得到这样一个结论： typeof 对引用类型判断的时候只有 function 类型可以正确判断，其他都无法正确判断具体是什么引用类型。 用instanceof检测引用类型我们知道 typeof 只能对部分原始类型进行检测，对引用类型毫无办法。JavaScript 提供了一个操作符 instanceof，我们来看下他是否能检测引用类型： 12[] instanceof Array // true[] instanceof Object // true 我们发现数组即是 Array 的实例，也是 Object 的实例，因为所以引用类型原型链的终点都是 Object，所以 Array 自然是 Object 的实例。那么我们得出结论：instanceof 用于检测引用类型好像也不是很靠谱的选择。 用toString进行类型检测我们可以使用 Object.prototype.toString.call() 来检测任何变量值的类型： 1234567891011121314Object.prototype.toString.call(true) // &#x27;[object Boolean]&#x27;Object.prototype.toString.call(undefined) // &#x27;[object Undefined]&#x27;Object.prototype.toString.call(null) // &#x27;[object Null]&#x27;Object.prototype.toString.call(20) // &#x27;[object Number]&#x27;Object.prototype.toString.call(&#x27;bubuzou&#x27;) // &#x27;[object String]&#x27;Object.prototype.toString.call(Symbol()) // &#x27;[object Symbol]&#x27;Object.prototype.toString.call([]) // &#x27;[object Array]&#x27;Object.prototype.toString.call(&#123;&#125;) // &#x27;[object Object]&#x27;Object.prototype.toString.call(function()&#123;&#125;) // &#x27;[object Function]&#x27;Object.prototype.toString.call(new Date()) // &#x27;[object Date]&#x27;Object.prototype.toString.call(new RegExp()) // &#x27;[object RegExp]&#x27;Object.prototype.toString.call(JSON) // &#x27;[object JSON]&#x27;Object.prototype.toString.call(MATH) // &#x27;[object MATH]&#x27;Object.prototype.toString.call(window) // &#x27;[object RegExp]&#x27; 参考文章 【JS 进阶】你真的掌握变量和类型了吗 你不知道的JS中卷-第四章 JS中的栈内存堆内存 IEEE 754","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"使用nvm来管理Node版本","slug":"nvm","date":"2020-03-26T13:11:58.000Z","updated":"2020-08-12T09:46:13.360Z","comments":true,"path":"2020/03/26/nvm/","link":"","permalink":"https://bubuzou.com/2020/03/26/nvm/","excerpt":"使用nvm来管理Node版本nvm 是 Node.js 的版本管理工具，可以创建不同版本 Node 的隔离环境，从而避免不同版本包之间的干扰。官方 github 卸载全局安装的Node最近在做项目的时候，发现编译速度特别慢，而升级 Node 版本之后速度会明显提升。所以这才有使用 nvm 来管理 Node 的故事。 目前本地全局安装的 Node 版本是 9.11.1， 这个版本还是18年4月左右更新的，是相当的跟不上节奏了。这里可以查看 Node 历史版本。 安装 nvm 之前最好是将现有的全局 Node 进行卸载，否则会发生冲突。","text":"使用nvm来管理Node版本nvm 是 Node.js 的版本管理工具，可以创建不同版本 Node 的隔离环境，从而避免不同版本包之间的干扰。官方 github 卸载全局安装的Node最近在做项目的时候，发现编译速度特别慢，而升级 Node 版本之后速度会明显提升。所以这才有使用 nvm 来管理 Node 的故事。 目前本地全局安装的 Node 版本是 9.11.1， 这个版本还是18年4月左右更新的，是相当的跟不上节奏了。这里可以查看 Node 历史版本。 安装 nvm 之前最好是将现有的全局 Node 进行卸载，否则会发生冲突。 终端下查看 Node 的全局安装目录： 12ccp:~ ccp$ which node&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node Mac 环境下全局的 Node 会被安装在 /usr/local/bin/ 目录下，接下来我们要打开这个目录； 打开访达，然后按下快捷键 ⇧ + ⌘ + G，输入上面的目录，即可打开对应的目录； 接下来依次检查并且删除这些目录下的 node 和 node_modules 相关文件和文件夹： /usr/local/lib /usr/local/include 打开 /usr/local/bin 并删除 node 可执行文件; 如果你是使用的 brew install node 安装的 Node，那么你还需要在终端中执行 brew uninstall node 命令来卸载。 过程中，你可能还需要在终端中执行一些指令： 12345678sudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npmsudo rm &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1&#x2F;node.1sudo rm &#x2F;usr&#x2F;local&#x2F;lib&#x2F;dtrace&#x2F;node.dsudo rm -rf ~&#x2F;.npmsudo rm -rf ~&#x2F;.node-gypsudo rm &#x2F;opt&#x2F;local&#x2F;bin&#x2F;nodesudo rm &#x2F;opt&#x2F;local&#x2F;include&#x2F;nodesudo rm -rf &#x2F;opt&#x2F;local&#x2F;lib&#x2F;node_modules 至此，全局安装的 Node 才算卸载干净。 安装nvm 在终端里执行如下脚本： 1curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.35.3&#x2F;install.sh | bash 然后在终端输入命令 command -v nvm，如果显示 nvm 则表示安装成功；否则如果显示 nvm: command not found，则需要做如下操作： 在 .nvm 同级目录下创建 .bash_profile 文件，终端键入如下命令： 1touch ~&#x2F;.bash_profile 把以下代码贴到上面的文件中： 12export NVM_DIR&#x3D;~&#x2F;.nvmsource ~&#x2F;.nvm&#x2F;nvm.sh nvm 安装后，可以用 nvm ls 来查看，如果会显示安装的 Node 版本列表，则显示安装成功。有了 nvm 后，在用 npm install xxx -g 进行全局安装的时候会把包安装对应版本的 Node 下，如果是 Mac 则目录 user/.nvm/versions/node/v12.16.1/bin 下可以看到对应的全局命令。 nvm常用命令 nvm ls-remote 查看 Node 远程版本库 nvm install node 将安装最新版本的 Node nvm install v12.7.0 将安装 12.7.0 版本的 Node nvm uninstall v12.7.0 卸载 12.7.0 版本的 Node nvm ls 查看已经安装的 Node 版本 nvm use v12.7.0 切换 12.7.0 为当前使用的版本 nvm alias default v12.7.0 将 12.7.0 设置为 Node 的默认版本 nvm which v12.7.0 查看 12.7.0 版本的 Node 的安装目录，比如：/Users/ccp/.nvm/versions/node/v12.7.0/bin/node nvm --help 查看更多命令用法 其他相关命令 command -v nvm 查看 nvm 是否安装成功 node -v 查看当前使用的 Node 版本 which node 查看当前 Node 的安装目录 其他问题 由于 Node 版本的升级，所以当编译项目的时候可能会报依赖包的错误，这个时候就需要升级依赖包，将项目的 node_modules 目录删了，重新执行 npm install。 升级 Node 后，由于内存 2048M 的限制，编译项目的时候很有可能会报 JS stack trace 内存溢出的错误，这个时候可以用 increase-memory-limit 来解决。","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"node","slug":"node","permalink":"https://bubuzou.com/tags/node/"}]},{"title":"Vue-Test-Utils + Jest 单元测试入门与实践","slug":"Vue-Test-Utils+Jest","date":"2019-10-23T17:41:11.000Z","updated":"2020-10-23T08:49:26.347Z","comments":true,"path":"2019/10/24/Vue-Test-Utils+Jest/","link":"","permalink":"https://bubuzou.com/2019/10/24/Vue-Test-Utils+Jest/","excerpt":"介绍Vue-Test-Utils 是 Vue.js 官方的单元测试实用工具库，它提供了一系列的 API 来使得我们可以很便捷的去写 Vue 应用中的单元测试。 主流的单元测试运行器有很多，比如 Jest、Mocha 和 Karma 等，这几个在 Vue-Test-Utils 文档里都有对应的教程，这里我们只介绍 Vue-Test-Utils + Jest 结合的示例。 Jest 是一个由 Facebook 开发的测试框架。Vue 对其进行描述：是功能最全的测试运行器。它所需的配置是最少的，默认安装了 JSDOM，内置断言且命令行的用户体验非常好。不过你需要一个能够将单文件组件导入到测试中的预处理器。我们已经创建了 vue-jest 预处理器来处理最常见的单文件组件特性，但仍不是 vue-loader 100% 的功能。","text":"介绍Vue-Test-Utils 是 Vue.js 官方的单元测试实用工具库，它提供了一系列的 API 来使得我们可以很便捷的去写 Vue 应用中的单元测试。 主流的单元测试运行器有很多，比如 Jest、Mocha 和 Karma 等，这几个在 Vue-Test-Utils 文档里都有对应的教程，这里我们只介绍 Vue-Test-Utils + Jest 结合的示例。 Jest 是一个由 Facebook 开发的测试框架。Vue 对其进行描述：是功能最全的测试运行器。它所需的配置是最少的，默认安装了 JSDOM，内置断言且命令行的用户体验非常好。不过你需要一个能够将单文件组件导入到测试中的预处理器。我们已经创建了 vue-jest 预处理器来处理最常见的单文件组件特性，但仍不是 vue-loader 100% 的功能。 环境配置通过脚手架 vue-cli 来新建项目的时候，如果选择了 Unit Testing 单元测试且选择的是 Jest 作为测试运行器，那么在项目创建好后，就会自动配置好单元测试需要的环境，直接能用 Vue-Test-Utils 和 Jest 的 API 来写测试用例了。 但是新建项目之初没有选择单元测试功能，需要后面去添加的话，有两种方案： 第一种配置： 直接在项目中添加一个 unit-jest 插件，会自动将需要的依赖安装配置好。 1vue add @vue&#x2F;unit-jest 第二种配置： 这种配置会麻烦一点，下面是具体的操作步骤。 安装依赖 安装 Jest 和 Vue Test Utils 1npm install --save-dev jest @vue&#x2F;test-utils 安装 babel-jest 、 vue-jest 和 7.0.0-bridge.0 版本的 babel-core 1npm install --save-dev babel-jest vue-jest babel-core@7.0.0-bridge.0 安装 jest-serializer-vue 1npm install --save-dev jest-serializer-vue 配置 JestJest 的配置可以在 package.json 里配置；也可以新建一个文件 jest.config.js， 放在项目根目录即可。这里我选择的是配置在 jest.config.js 中： 123456789101112131415161718module.exports = &#123; moduleFileExtensions: [ &#x27;js&#x27;, &#x27;vue&#x27; ], transform: &#123; &#x27;^.+\\\\.vue$&#x27;: &#x27;&lt;rootDir&gt;/node_modules/vue-jest&#x27;, &#x27;^.+\\\\.js$&#x27;: &#x27;&lt;rootDir&gt;/node_modules/babel-jest&#x27; &#125;, moduleNameMapper: &#123; &#x27;^@/(.*)$&#x27;: &#x27;&lt;rootDir&gt;/src/$1&#x27; &#125;, snapshotSerializers: [ &#x27;jest-serializer-vue&#x27; ], testMatch: [&#x27;**/__tests__/**/*.spec.js&#x27;], transformIgnorePatterns: [&#x27;&lt;rootDir&gt;/node_modules/&#x27;]&#125; 各配置项说明： moduleFileExtensions 告诉 Jest 需要匹配的文件后缀 transform 匹配到 .vue 文件的时候用 vue-jest 处理， 匹配到 .js 文件的时候用 babel-jest 处理 moduleNameMapper 处理 webpack 的别名，比如：将 @ 表示 /src 目录 snapshotSerializers 将保存的快照测试结果进行序列化，使得其更美观 testMatch 匹配哪些文件进行测试 transformIgnorePatterns 不进行匹配的目录 配置 package.json写一个执行测试的命令脚本： 12345&#123; &quot;script&quot;: &#123; &quot;test&quot;: &quot;jest&quot; &#125;&#125; 第一个测试用例为了保证环境的一致性，我们从创建项目开始一步一步演示操作步骤。 用 vue-cli 创建一个项目当前我用到的是 3.10.0 版本的 vue-cli。开始创建项目： 1vue create first-vue-jest 选择 Manually select features 进行手动选择功能配置： 12345678Vue CLI v3.10.0┌───────────────────────────┐│ Update available: 4.0.4 │└───────────────────────────┘? Please pick a preset: VUE-CLI3 (vue-router, node-sass, babel, eslint) default (babel, eslint)❯ Manually select features 勾选 Babel、Unit Testing： 12345678910? Check the features needed for your project: ◉ Babel ◯ TypeScript ◯ Progressive Web App (PWA) Support ◯ Router ◯ Vuex ◯ CSS Pre-processors ◯ Linter &#x2F; Formatter ◉ Unit Testing ◯ E2E Testing 选择 Jest: 123? Pick a unit testing solution: Mocha + Chai❯ Jest 选择 In dedicated config files 将各配置信息配置在对应的 config 文件里： 123? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)❯ In dedicated config files In package.json 输入n，不保存预设： 1? Save this as a preset for future projects? (y&#x2F;N) n 项目创建完成后，部分文件的配置信息如下： babel.config.js: 123456module.exports = &#123; presets: [ &#x27;@vue/cli-plugin-babel/preset&#x27; ]&#125; jest.config.js， 这个文件的配置默认是预设插件的，可以按实际需求改成上面提到的配置 Jest 里的配置一样。 123module.exports = &#123; preset: &#x27;@vue/cli-plugin-unit-jest&#x27;&#125; package.json: 123456789101112131415161718192021&#123; &quot;name&quot;: &quot;first-vue-jest&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;test:unit&quot;: &quot;vue-cli-service test:unit&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;core-js&quot;: &quot;^3.1.2&quot;, &quot;vue&quot;: &quot;^2.6.10&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;^4.0.0&quot;, &quot;@vue/cli-plugin-unit-jest&quot;: &quot;^4.0.0&quot;, &quot;@vue/cli-service&quot;: &quot;^4.0.0&quot;, &quot;@vue/test-utils&quot;: &quot;1.0.0-beta.29&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot; &#125;&#125; 执行测试命令用上面的步骤创建的项目完成项目后，我们可以在 package.json 的 scripts 项中看到有个 test:unit ，执行它： 12cd first-vue-jestnpm run test:unit 然后终端里会看到输出结果，PASS 表示测试用例通过了，这个是官方提供单元测试例子。下面我们来写点自己的东西。 实现一个ToDoList 看上面的原型图，有这么几点明确的需求： 在头部右侧输入框输入要做的事情，敲回车后，内容跑到待完成列表里，同时清空输入框 输入框为空的时候敲回车，不做任何变化 待完成列表支持编辑功能，已完成列表不能进行编辑 每个列表项的右侧都有删除按钮，用 - 号表示，点击后删除该项 待完成列表有标记为已完成的按钮，用 √ 号表示，点击后当前项移动到已完成列表 已完成列表有标记为未完成的按钮，用 x 号表示，点击后当前项移动到未完成列表 列表序号从1开始递增 当待完成列表为空的时候，不显示待完成字样 当已完成列表为空的时候，不显示已完成字样 先把上面的页面写好写页面之前先把创建项目的时候生成的 HelloWorld.vue 和对应的测试文件 example.spec.js 删除；同时修改 App.vue 文件，引入 ToDoList 组件： 123456789101112131415&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;ToDoList&gt;&lt;/ToDoList&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ToDoList from &#x27;./components/ToDoList&#x27;export default &#123; components: &#123; ToDoList &#125;&#125;&lt;/script&gt; 在 src/compoents 下新建一个文件 ToDoList.vue，样式较多就不贴出来了，具体可以去看本项目源码： 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;todolist&quot;&gt; &lt;header&gt; &lt;h5&gt;ToDoList&lt;/h5&gt; &lt;input class=&quot;to-do-text&quot; v-model=&quot;toDoText&quot; @keyup.enter=&quot;enterText&quot; placeholder=&quot;输入计划要做的事情&quot;/&gt; &lt;/header&gt; &lt;h4 v-show=&quot;toDoList.length &gt; 0&quot;&gt;待完成&lt;/h4&gt; &lt;ul class=&quot;wait-to-do&quot;&gt; &lt;li v-for=&quot;(item, index) in toDoList&quot; :keys=&quot;item&quot;&gt; &lt;p&gt; &lt;i&gt;&#123;&#123;index + 1&#125;&#125;&lt;/i&gt; &lt;input :value=&quot;item&quot; @blur=&quot;setValue(index, $event)&quot; type=&quot;text&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;span class=&quot;move&quot; @click=&quot;removeToComplete(item, index)&quot;&gt;√&lt;/span&gt; &lt;span class=&quot;del&quot; @click=&quot;deleteWait(index)&quot;&gt;-&lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h4 v-show=&quot;completedList.length &gt; 0&quot;&gt;已完成&lt;/h4&gt; &lt;ul class=&quot;has-completed&quot;&gt; &lt;li v-for=&quot;(item, index) in completedList&quot; :keys=&quot;item&quot;&gt; &lt;p&gt; &lt;i&gt;&#123;&#123;index + 1&#125;&#125;&lt;/i&gt; &lt;input :value=&quot;item&quot; disabled=&quot;true&quot; type=&quot;text&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;span class=&quot;move&quot; @click=&quot;removeToWait(item, index)&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;del&quot; @click=&quot;deleteComplete(index)&quot;&gt;-&lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;export default &#123; data() &#123; return &#123; toDoText: &#x27;&#x27;, toDoList: [], completedList: [] &#125; &#125;, methods: &#123; setValue(index, e) &#123; this.toDoList.splice(index, 1, e.target.value) &#125;, removeToComplete(item, index) &#123; this.completedList.splice(this.completedList.length, 0, item) this.toDoList.splice(index, 1) &#125;, removeToWait(item, index) &#123; this.toDoList.splice(this.toDoList.length, 0, item) this.completedList.splice(index, 1) &#125;, enterText() &#123; if (this.toDoText.trim().length &gt; 0) &#123; this.toDoList.splice(this.toDoList.length, 0, this.toDoText) this.toDoText = &#x27;&#x27; &#125; &#125;, deleteWait(index) &#123; this.toDoList.splice(index, 1) &#125;, deleteComplete(index) &#123; this.completedList.splice(index, 1) &#125; &#125;&#125;;&lt;/script&gt; 页面写完，原型上的需求也大概开发完成，页面大概长如下样子： 修改目录配置接下来就是开始编写单元测试文件了，写之前我们先把测试文件目录修改下为 __tests__，同时修改 jest.config.js 为如下配置，注意其中的 testMatch 已经修改为匹配 __tests__ 目录下的所有 .js 文件了。 123456789101112131415161718module.exports = &#123; moduleFileExtensions: [ &#x27;js&#x27;, &#x27;vue&#x27; ], transform: &#123; &#x27;^.+\\\\.vue$&#x27;: &#x27;&lt;rootDir&gt;/node_modules/vue-jest&#x27;, &#x27;^.+\\\\.js$&#x27;: &#x27;&lt;rootDir&gt;/node_modules/babel-jest&#x27; &#125;, moduleNameMapper: &#123; &#x27;^@/(.*)$&#x27;: &#x27;&lt;rootDir&gt;/src/$1&#x27; &#125;, snapshotSerializers: [ &#x27;jest-serializer-vue&#x27; ], testMatch: [&#x27;**/__tests__/**/*.spec.js&#x27;], transformIgnorePatterns: [&#x27;&lt;rootDir&gt;/node_modules/&#x27;]&#125; 编写测试文件在 __tests__/unit/ 目录下新建文件 todolist.spec.js，我们约定测试某个 vue 文件，那么它的单元测试文件习惯命名成 *.spec.js 或 *.test.js。 123456789import &#123; shallowMount &#125; from &#x27;@vue/test-utils&#x27;import ToDoList from &#x27;@/components/ToDoList&#x27;describe(&#x27;test ToDoList&#x27;, () =&gt; &#123; it(&#x27;输入框初始值为空字符串&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) expect(wrapper.vm.toDoText).toBe(&#x27;&#x27;) &#125;)&#125;) 上面这个测试文件简要说明： shallowMount 将会创建一个包含被挂载和渲染的 Vue 组件的 Wrapper，只存根当前组件，不包含子组件。 describe(name, fn) 这边是定义一个测试套件，test ToDoList 是测试套件的名字，fn 是具体的可执行的函数 it(name, fn) 是一个测试用例，输入框初始值为空字符串 是测试用例的名字，fn 是具体的可执行函数；一个测试套件里可以保护多个测试用例。 expect 是 Jest 内置的断言风格，业界还存在别的断言风格比如 Should、Assert 等。 toBe 是 Jest 提供的断言方法， 更多的可以到Jest Expect 查看具体用法。 123456789it(&#x27;待完成列表初始值应该为空数组&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) expect(wrapper.vm.toDoList.length).toBe(0)&#125;)it(&#x27;已完成列表初始值应该为空数组&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) expect(wrapper.vm.completedList).toEqual([])&#125;) 待完成和已完成列表，居然是列表，所以存放数据的字段必须是 Array 类型，空列表就是空数组。如果第二个测试用例改成： 1expect(wrapper.vm.completedList).toBe([]) 将会报错，因为 toBe 方法内部是调用 Object.is(value1, value2) 来比较2个值是否相等的，和 == 或 === 的判断逻辑不一样。显然 Object.is([], []) 会返回 false。 12345678910111213141516171819202122it(&#x27;输入框值变化的时候，toDoText应该跟着变化&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.find(&#x27;.to-do-text&#x27;).setValue(&#x27;晚上要陪妈妈逛超市&#x27;) expect(wrapper.vm.toDoText).toBe(&#x27;晚上要陪妈妈逛超市&#x27;)&#125;)it(&#x27;输入框没有值，敲入回车的时候，无变化&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) const length = wrapper.vm.toDoList.length const input = wrapper.find(&#x27;.to-do-text&#x27;) input.setValue(&#x27;&#x27;) input.trigger(&#x27;keyup.enter&#x27;) expect(wrapper.vm.toDoList.length).toBe(length)&#125;)it(&#x27;输入框有值，敲入回车的时候，待完成列表将新增一条数据，同时清空输入框&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) const length = wrapper.vm.toDoList.length const input = wrapper.find(&#x27;.to-do-text&#x27;) input.setValue(&#x27;晚上去吃大餐&#x27;) input.trigger(&#x27;keyup.enter&#x27;) expect(wrapper.vm.toDoList.length).toBe(length + 1) expect(wrapper.vm.toDoText).toBe(&#x27;&#x27;)&#125;) setValue 可以设置一个文本控件的值并更新 v-model 绑定的数据。 .to-do-text 是一个 CSS 选择器；Vue-Test-Utils 提供了 find 方法来通过查找选择器，来返回一个 Wrapper；选择器可以是 CSS 选择器、可以是 Vue 组件也可以是一个对象，这个对象包含了组件的 name 或 ref 属性，比如可以这样用：wrapper.find(&#123; name: &#39;my-button&#39; &#125;) wrapper.vm 是一个 Vue 实例，只有 Vue 组件的包裹器才有 vm 这个属性；通过 wrapper.vm 可以访问所有 Vue 实例的属性和方法。比如：wrapper.vm.$data、wrapper.vm.$nextTick()。 trigger 方法可以用来触发一个 DOM 事件，这里触发的事件都是同步的，所以不必将断言放到 $nextTick() 里去执行；同时支持传入一个对象，当捕获到事件的时候，可以获取到传入对象的属性。可以这样写：wrapper.trigger(&#39;click&#39;, &#123;name: &quot;bubuzou.com&quot;&#125;) 1234567it(&#x27;待完成列表支持编辑功能，编辑后更新toDoList数组&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;toDoList: [&#x27;跑步半小时&#x27;]&#125;) wrapper.find(&#x27;.wait-to-do li&#x27;).find(&#x27;input&#x27;).setValue(&#x27;绕着公园跑3圈&#x27;) wrapper.find(&#x27;.wait-to-do li&#x27;).find(&#x27;input&#x27;).trigger(&#x27;blur&#x27;) expect(wrapper.vm.toDoList[0]).toBe(&#x27;绕着公园跑3圈&#x27;)&#125;) 先用 setData 给 toDoList 设置一个初始值，使其渲染出一个列表项；然后找到这个列表项，用 setValue 给其设置值，模拟了编辑；列表项的输入框是用 :value=&quot;item&quot; 绑定的 value, 所以 setValue 无法触发更新；只能通过 trigger 来触发更新 toDoList 的值。 123456789101112131415161718192021222324252627282930313233343536373839it(&#x27;待完成列表点击删除，同时更新toDoList数组&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;toDoList: [&#x27;睡前看一小时书&#x27;]&#125;) expect(wrapper.vm.toDoList.length).toBe(1) wrapper.find(&#x27;.wait-to-do li&#x27;).find(&#x27;.del&#x27;).trigger(&#x27;click&#x27;) expect(wrapper.vm.toDoList.length).toBe(0)&#125;)it(&#x27;点击待完成列表中某项的已完成按钮，数据对应更新&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;toDoList: [&#x27;中午饭后吃一个苹果&#x27;]&#125;) expect(wrapper.vm.toDoList.length).toBe(1) expect(wrapper.vm.completedList.length).toBe(0) wrapper.find(&#x27;.wait-to-do li&#x27;).find(&#x27;.move&#x27;).trigger(&#x27;click&#x27;) expect(wrapper.vm.toDoList.length).toBe(0) expect(wrapper.vm.completedList.length).toBe(1)&#125;)it(&#x27;点击已完成列表中某项的未完成按钮，数据对应更新&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;completedList: [&#x27;唱了一首歌&#x27;]&#125;) expect(wrapper.vm.toDoList.length).toBe(0) expect(wrapper.vm.completedList.length).toBe(1) wrapper.find(&#x27;.has-completed li&#x27;).find(&#x27;.move&#x27;).trigger(&#x27;click&#x27;) expect(wrapper.vm.toDoList.length).toBe(1) expect(wrapper.vm.completedList.length).toBe(0)&#125;)it(&#x27;列表序号从1开始递增&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;toDoList: [&#x27;早上做作业&#x27;, &#x27;下午去逛街&#x27;]&#125;) expect(wrapper.vm.toDoList.length).toBe(2) expect(wrapper.find(&#x27;.wait-to-do&#x27;).html()).toMatch(&#x27;&lt;i&gt;1&lt;/i&gt;&#x27;) expect(wrapper.find(&#x27;.wait-to-do&#x27;).html()).toMatch(&#x27;&lt;i&gt;2&lt;/i&gt;&#x27;)&#125;)it(&#x27;当待完成列表为空的时候，不显示待完成字样&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;toDoList: []&#125;) expect(wrapper.find(&#x27;h4&#x27;).isVisible()).toBeFalsy() wrapper.setData(&#123;toDoList: [&#x27;明天去爬北山&#x27;]&#125;) expect(wrapper.find(&#x27;h4&#x27;).isVisible()).toBeTruthy()&#125;) 一个测试用例中可以写多个 expect 以保证断言的准确性。 异步测试最后我们为了模拟异步测试，所以加一个需求，即页面加载的时候会去请求远程待完成列表的数据。在项目根目录新建 __mocks__ 目录，同时新建 axios.js: 12345678910111213141516const toToList = &#123; success: true, data: [&#x27;上午去图书馆看书&#x27;, &#x27;下去出去逛街&#x27;]&#125;export const get = (url) =&gt; &#123; if (url === &#x27;toToList.json&#x27;) &#123; return new Promise((resolve, reject) =&gt; &#123; if (toToList.success) &#123; resolve(toToList) &#125; else &#123; reject(new Error()) &#125; &#125;) &#125;&#125; 修改 ToDoList.vue，导入 axios 和增加 mounted： 12345678910111213&lt;script&gt;import * as axios from &#x27;../../__mocks__/axios&#x27;export default &#123; mounted () &#123; axios.get(&#x27;toToList.json&#x27;).then(res =&gt; &#123; this.toDoList = res.data &#125;).catch(err =&gt; &#123; &#125;) &#125;,&#125;;&lt;/script&gt; 测试用例编写为： 123456it(&#x27;当页面挂载的时候去请求数据，请求成功后应该会返回2条数据&#x27;, (done) =&gt; &#123; wrapper.vm.$nextTick(() =&gt; &#123; expect(wrapper.vm.toDoList.length).toBe(2) done() &#125;)&#125;) 对于异步的代码，写断言的时候需要放在 wrapper.vm.$nextTick() 里，且手动调用 done()。 配置测试覆盖率测试用例写了部分，如果我们看下覆盖率如何，就需要要配置测试覆盖率。在 jest.config.js 里新增配置： 12collectCoverage: true,collectCoverageFrom: [&quot;**/*.&#123;js,vue&#125;&quot;, &quot;!**/node_modules/**&quot;], 在 package.json 的 scripts 中新增一条配置: 1&quot;test:cov&quot;: &quot;vue-cli-service test:unit --coverage&quot; 然后我们在终端运行： npm run test:cov，结果如下： 运行测试覆盖率命名后会在项目根目录生成 coverage 目录，浏览器打开里面的 index.html ：","categories":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"}],"tags":[{"name":"jest","slug":"jest","permalink":"https://bubuzou.com/tags/jest/"},{"name":"vue-test-utils","slug":"vue-test-utils","permalink":"https://bubuzou.com/tags/vue-test-utils/"},{"name":"单元测试","slug":"单元测试","permalink":"https://bubuzou.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"Git常用操作，一文打尽","slug":"git-all-actions","date":"2019-09-24T08:29:10.000Z","updated":"2019-09-24T10:32:10.699Z","comments":true,"path":"2019/09/24/git-all-actions/","link":"","permalink":"https://bubuzou.com/2019/09/24/git-all-actions/","excerpt":"创建版本库 git clone url 克隆远程版本库 git init 初始化本地版本库","text":"创建版本库 git clone url 克隆远程版本库 git init 初始化本地版本库 配置 git config --global user.name &#39;chengcp&#39; 配置global级别的用户名 git config --global user.email &#39;1326895569@qq.com&#39; 配置global级别的邮箱 git config --global -l 查看global级别的配置列表 git config --global --unset user.name 删除用户名 git config --global alias.last &#39;log -1 HEAD&#39; 配置last别名，使用git last将显示最近的一次提交记录 添加和删除文件 git add file1 file2 添加指定文件到暂存区 git add dir 添加指定目录到暂存区 git add . 添加当前目录的所有文件到暂存区 git mv oldname newname 对一个已经追踪过的文件进行改名，同时加入暂存区 git rm file1 file2 删除工作区文件，同时将这次删除放入暂存区 git rm --cached file 停止追踪指定文件，但该文件会保留在工作区；tracked变成untracked 提交 git commit file1 file 2 -m message 提交暂存区指定文件到本地仓库 git commit -m message 提交暂存区所有文件到本地仓库 git commit -a -m message 自动暂存所有已经追踪过的文件，且提交到本地仓库 git commit --amend -m message 使用一次新的提交，替代上次提交 分支 git branch 查看所有本地分支 git branch –r 查看所有远程分支 git branch –a 查看所有远程和本地分支 git branch –v 查看本地所有分支最新一次提交信息 git branch [branch] 新建分支 git checkout –b [branch] 新建一个分支，并且切换过去 git branch [branch] [commit] 基于某次提交，建立一个分支 git branch --track [branch] [remote-branch] 建立一个分支，并且与远程分支建立追踪关系 git branch --set-upstream [branch] [remote-branch] 在现有的本地分支和远程分支之间建立追踪关系 git branch –m [old-branch] [new-branch] 重命名分支 git merge [branch] 把指定分支合并到当前分支 git chery-pick [commit] [commit] 选择提交，合并进当前分支 git branch –d [branch] 删除本地分支 git push origin –d [branch] 删除远程分支 git checkout [branch] 切换分支 git checkout - 切换到上一个最近使用过的分支 标签 git tag 列出所有标签 git show [tag] 查看指定标签信息 git tag [tag] 给最近一次提交打一个标签 git tag [tag] [commit] 在某次提交上打一个标签 git tag –d [tag] 删除本地指定标签 git push origin –d tag [tag] 删除远程的标签 git push origin [tag] 推送指定标签 git push origin --tags 推送所有标签 查看信息 git status 查看文件状态 git help [command] 获取帮助文档 git [command] --help 获取帮助文档 git log 查看当前分支的提交记录 git log –all 查看所有分支的提交记录 git log -5 --oneline --graph 查看最近5次提交记录，以单行、树状图形式显示 git reflog 查看本地所有变更记录 git diff 查看工作区和暂存区的差异 git diff -- file 某个文件在工作区和暂存区的差异 git diff HEAD 工作区和最新一次提交的差异 git diff --cached 暂存区和HEAD的差异 git diff branch_a branch_b – file 某文件在两个分支间的差异 远程操作 git remote -v 查看所有远程仓库 git ls-remote origin 查看远程仓库引用列表 git remote show origin 查看远程仓库信息 git fetch origin 拉取远程仓库最新提交 git pull origin master 拉取远程master，并且合并到本地当前分支 git remote add upstream url 添加一个新的远程仓库，命名为upstream git push origin master 推送到远程origin的master分支 git push origin --all 推送所有分支到远程仓库 git remote prune origin 删除远程仓库中不存在的分支 撤销 git reset --soft HEAD 回滚到指定版本，保留工作区和暂存区 git reset --mixed HEAD 回滚到指定版本，保留工作区，清空暂存区；--mixed是默认参数，即等同于git reset HEAD git reset --hard HEAD 回滚到指定版本，清空工作区和暂存区 git reset HEAD -- file 清空暂存区中某个文件的修改 git checkout -- file 检出暂存区的文件到工作目录 git checkout . 检出暂存区的所有文件到工作目录 git revert HEAD~ 2 回滚到2个祖先提交的版本，同时产生新的提交记录 git revert --continue 冲突解决，且把修改提交到暂存区后执行回滚，生成一个新的提交 git revert –abort 取消回滚，回到之前的状态 储藏 git stash 将工作区和暂存区的变更保存到储藏堆栈中，同时工作区和暂存区恢复到HEAD一样 git stash list 查看储藏列表 git stash pop 应用最近的一次储藏，并且从储藏栈中移除该条记录 git stash apply stash@&#123;0&#125; 应用最近的一次储藏，不移除记录；等同于 git stash apply git stash pop --index 应用最近一次储藏，--index表示暂存区的变更也会更新，否则只更新工作区变更 git stash drop stash@&#123;0&#125; 移除储藏记录","categories":[{"name":"git","slug":"git","permalink":"https://bubuzou.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://bubuzou.com/tags/git/"}]},{"title":"vue-quill-editor插入图片路径太长问题解决","slug":"vue-quill-editor","date":"2019-07-26T02:49:08.000Z","updated":"2020-10-23T08:12:27.542Z","comments":true,"path":"2019/07/26/vue-quill-editor/","link":"","permalink":"https://bubuzou.com/2019/07/26/vue-quill-editor/","excerpt":"最近做项目的时候有一个发布新闻的需求，新闻编辑的时候要求能发布带格式的文本内容和能展示支持图片。由于项目是用vue开发的，所以找编辑器的时候选了 vue-quill-editor 。编辑器长如下的样子：","text":"最近做项目的时候有一个发布新闻的需求，新闻编辑的时候要求能发布带格式的文本内容和能展示支持图片。由于项目是用vue开发的，所以找编辑器的时候选了 vue-quill-editor 。编辑器长如下的样子： 现在的问题但是这个编辑器会把插入的图片会转成 base64 位的编码，使得编辑器内容保存进数据库的时候会超出限制长度，从而报错。 从问题来源着手首先要明白导致这个问题的原因是 vue-quill-editor 编辑器默认把上传的图片给转成 base64 编码，那是不是有这么一个配置参数可以设置上传后图片的格式呢？经过一番文档的查找，貌似是没有。但是提供了一个 handlers 可以自定义图片上传的方式，那就从这里下文章。大概意思是点击这个图片按钮的时候，会出发一个回调，可以在回调里触发自己的文件上传开关。这里我用的文件上传是 element-ui 的 el-upload。 安装vue-quill-editor1npm install vue-quill-editor --save 配置vue-quill-editor配置 html 123456789&lt;quill-editor v-model=&quot;ruleForm.content&quot; ref=&quot;myQuillEditor&quot; :options=&quot;editorOption&quot; class=&quot;ql-editor&quot; :class=&quot;operationType.includes(&#x27;check&#x27;) ? &#x27;disabled&#x27; : &#x27;&#x27;&quot; :disabled=&quot;operationType.includes(&#x27;check&#x27;)&quot; &gt;&lt;/quill-editor&gt; 导入vue-quill-editor 且设置components： 123456import &#123; quillEditor &#125; from &#x27;vue-quill-editor&#x27;export default &#123; components: &#123; quillEditor &#125;&#125; 设置options: 123456789101112131415161718192021222324252627282930editorOption:&#123; modules: &#123; toolbar: &#123; container: [ [&#x27;bold&#x27;, &#x27;italic&#x27;, &#x27;underline&#x27;, &#x27;strike&#x27;], [&#x27;blockquote&#x27;, &#x27;code-block&#x27;], [&#123; &#x27;list&#x27;: &#x27;ordered&#x27; &#125;, &#123; &#x27;list&#x27;: &#x27;bullet&#x27; &#125;], [&#123; &#x27;script&#x27;: &#x27;sub&#x27; &#125;, &#123; &#x27;script&#x27;: &#x27;super&#x27; &#125;], [&#123; &#x27;indent&#x27;: &#x27;-1&#x27; &#125;, &#123; &#x27;indent&#x27;: &#x27;+1&#x27; &#125;], [&#123; &#x27;size&#x27;: [&#x27;small&#x27;, false, &#x27;large&#x27;, &#x27;huge&#x27;] &#125;], [&#123; &#x27;header&#x27;: [1, 2, 3, 4, 5, 6, false] &#125;], [&#123; &#x27;color&#x27;: [] &#125;, &#123; &#x27;background&#x27;: [] &#125;], [&#123; &#x27;align&#x27;: [] &#125;], [&#x27;clean&#x27;], [&#x27;link&#x27;, &#x27;image&#x27;] ], handlers: &#123; image: function(value) &#123; if (value) &#123; // 触发element-ui的文件上传 document.querySelector(&quot;.avatar-uploader input&quot;).click(); &#125; else &#123; this.quill.format(&quot;image&quot;, false); &#125; &#125;, &#125; &#125; &#125;, placeholder: &#x27;请输入&#x27;,&#125;, 引入相关style： 12345&lt;style lang=&quot;scss&quot;&gt; @import &#x27;~quill/dist/quill.core.css&#x27;; @import &#x27;~quill/dist/quill.snow.css&#x27;; @import &#x27;~quill/dist/quill.bubble.css&#x27;;&lt;/style&gt; 配置el-uploadtemplate： 123456789101112&lt;el-upload ref=&quot;quillUploader&quot; class=&quot;avatar-uploader&quot; :action=&quot;serverUrl&quot; :show-file-list=&quot;false&quot; :auto-upload=&quot;false&quot; :on-change=&quot;onChangeQuill&quot; :before-upload=&quot;beforeUpload&quot; :limit=&quot;20&quot; :multiple=&quot;true&quot; :accept=&quot;acceptFile&quot;&gt;&lt;/el-upload&gt; onChange的时候执行文件上传，这里的文件上传用的是腾讯的对象存储服务，cosUtils封装了一些对象存储的一些工具方法，你们可以自行替换成自己后端的上传接口。下面这段代码的大概意思是文件上传到对象存储服务器成功之后，拿到具体的图片地址，插入到编辑器光标所在的位置，这个时候图片就显示出来了。 123456789101112131415onChangeQuill(file, fileList) &#123; let fileName = file.uid + file.name cosUtils.putObject(fileName, file.raw, &#x27;operate/&#x27;, (err, data) =&gt; &#123; // 新闻图片存到operate/目录下 console.log(err || data) if (!err) &#123; let quill = this.$refs.myQuillEditor.quill let length = quill.getSelection().index // 图片上传到对象存储后的具体地址 let imgSrc = `https://huzhouhuanzi-xxxxxxx.cos.ap-shanghai.myqcloud.com/operate/$&#123;fileName&#125;` quill.insertEmbed(length, &quot;image&quot;, imgSrc) // 调整光标到最后 quill.setSelection(length + 1) &#125; &#125;)&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"}],"tags":[{"name":"图像","slug":"图像","permalink":"https://bubuzou.com/tags/%E5%9B%BE%E5%83%8F/"},{"name":"upload","slug":"upload","permalink":"https://bubuzou.com/tags/upload/"},{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/tags/vue/"}]},{"title":"小程序根据打包命令区分不同环境的API","slug":"wepy-plugins-preprocess","date":"2019-06-26T23:52:40.000Z","updated":"2019-06-27T04:23:15.051Z","comments":true,"path":"2019/06/27/wepy-plugins-preprocess/","link":"","permalink":"https://bubuzou.com/2019/06/27/wepy-plugins-preprocess/","excerpt":"一般来讲项目都会有开发版、测试版和生产版这三个版本，不同版本对应不同的API域名，比如可能会是这样子： 123const HOST_DEV = &#x27;https://dev-bubuzouapi.com/&#x27; // 开发环境APIconst HOST_TEST = &#x27;https://test-bubuzouapi.com/&#x27; // 测试环境APIconst HOST = &#x27;https://bubuzouapi.com/&#x27; // 生产环境API 前端项目里要如何区分用什么时候用哪个API呢？比较笨的方法是，比如这次我要打一个测试环境给测试用，那我必须手动的把 HOST_TEST 这个变量的值设置到请求的 url 里。如果下次需要打其他环境的包，那我就需要再次手动更改 url 为别的值，这样显得很不方便。","text":"一般来讲项目都会有开发版、测试版和生产版这三个版本，不同版本对应不同的API域名，比如可能会是这样子： 123const HOST_DEV = &#x27;https://dev-bubuzouapi.com/&#x27; // 开发环境APIconst HOST_TEST = &#x27;https://test-bubuzouapi.com/&#x27; // 测试环境APIconst HOST = &#x27;https://bubuzouapi.com/&#x27; // 生产环境API 前端项目里要如何区分用什么时候用哪个API呢？比较笨的方法是，比如这次我要打一个测试环境给测试用，那我必须手动的把 HOST_TEST 这个变量的值设置到请求的 url 里。如果下次需要打其他环境的包，那我就需要再次手动更改 url 为别的值，这样显得很不方便。 wepy-plugin-preprocess如果你的小程序用的是 wepy 框架来构建的话，你可以用 wepy-plugin-preprocess 这个插件来对 js 进行一个预处理，可以使得每次设置到请求里的 url 的值是根据打包命令来的。 wepy-plugin-preprocess 是依赖于 preprocess 这个包的，这个包里定义了一些用于预处理的指令，比如 @if VAR=&#39;value&#39;、@ifdef VAR、@include 这种，想要了解更多用法，请点击这里。 安装插件： 1npm install wepy-plugin-preprocess --save-dev 配置wepy.config.js文件123456789let ENV = process.env.NODE_ENVmodule.exports = &#123; plugins: &#123; preprocess: &#123; filter: /\\.js$/, context: &#123; ENV &#125; &#125; &#125;,&#125; 设置package.json文件想要区分不同的环境，就需要配置几个不同环境的打包命令。 1234567&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;cross-env NODE_ENV=dev wepy build --watch&quot;, &quot;test&quot;: &quot;cross-env NODE_ENV=test wepy build --no-cache&quot;, &quot;prod&quot;: &quot;cross-env NODE_ENV=prod wepy build --no-cache&quot;, &#125;&#125; 定义常量文件常量文件里可以定义一些项目里用到的常量，比如这里会定义 API 域名。然后把常量导出去，需要用的地方再导入即可使用这些常量。 1234567891011121314/* @if ENV=&#x27;dev&#x27; **const HOST = exports.HOST = &#x27;https://dev-bubuzouapi.com/&#x27; // 开发环境APIconst HOST_SOCKET = exports.HOST_SOCKET = &#x27;wss://dev-bubuzouapi.com/&#x27; // 开发环境socket/* @endif *//* @if ENV=&#x27;test&#x27; **const HOST = exports.HOST = &#x27;https://test-bubuzouapi.com/&#x27; // 测试环境APIconst HOST_SOCKET = exports.HOST_SOCKET = &#x27;wss://test-bubuzouapi.com/&#x27; // 测试环境socket/* @endif *//* @if ENV=&#x27;prod&#x27; **const HOST = exports.HOST = &#x27;https://bubuzouapi.com/&#x27; // 生产环境APIconst HOST_SOCKET = exports.HOST_SOCKET = &#x27;wss://bubuzouapi.com/&#x27; // 生产环境socket/* @endif */ 通过命令切换api域名切换成开发环境： 1npm run dev // 编译完成后请求的域名就是&#x27;https://dev-bubuzouapi.com/&#x27; 切换成测试环境： 1npm run test 切换成生产环境： 1npm run prod","categories":[{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"element-ui文件上传一次请求上传多个文件","slug":"once-request-to-upload-multiple-files","date":"2019-03-26T08:48:21.000Z","updated":"2020-10-23T08:12:00.785Z","comments":true,"path":"2019/03/26/once-request-to-upload-multiple-files/","link":"","permalink":"https://bubuzou.com/2019/03/26/once-request-to-upload-multiple-files/","excerpt":"最近在做项目的时候有一个需求，需要导入word文档，并且需要支持多选。element-ui 的 upload 组件支持多选文件，只需要配置参数 multiple 为 true 即可。但是这个组件默认会将多选的文件分多次进行上传，于是就会存在多次的上传请求，由于后台的接口要求是一次请求能够上传多个文件，且我们也知道请求多了会对服务器造成更大的压力，因而基于多种原因，这个 upload 的上传行为得进行改造一番。","text":"最近在做项目的时候有一个需求，需要导入word文档，并且需要支持多选。element-ui 的 upload 组件支持多选文件，只需要配置参数 multiple 为 true 即可。但是这个组件默认会将多选的文件分多次进行上传，于是就会存在多次的上传请求，由于后台的接口要求是一次请求能够上传多个文件，且我们也知道请求多了会对服务器造成更大的压力，因而基于多种原因，这个 upload 的上传行为得进行改造一番。 先来看下改造前后的结果改造前的结果：同时上传2个文件，会发出2次对接口的请求，每次请求里包含了一个文件。 改造后的结果：同时上传2个文件，会发出一次接口请求，接口入参里包含2个文件。 方法一：通过配置file-list（推荐使用）html部分： 12345678910111213&lt;el-upload class=&quot;upload-demo list-uploadbtn&quot; ref=&quot;upload&quot; :action=&quot;curBastUrl&quot; :auto-upload=&quot;false&quot; :on-remove=&quot;updataRemove&quot; :before-upload=&quot;beforeUpload&quot; :on-change=&quot;updatachange&quot; :file-list=&quot;fileList&quot; :multiple=&quot;true&quot;&gt; &lt;el-button size=&quot;small&quot;&gt;点击上传&lt;/el-button&gt;&lt;/el-upload&gt;&lt;el-button type=&quot;primary&quot; @click=&quot;submitUpload&quot;&gt;确 定&lt;/el-button&gt; js部分： 12345678910111213141516submitUpload() &#123; // 导入 let formData = new FormData(); // 用FormData存放上传文件 this.fileList.forEach(file =&gt; &#123; formData.append(&#x27;file&#x27;, file.raw) &#125;) formData.append(&#x27;categoryDirectory&#x27;, this.filedata.categoryDirectory) // importCase是上传接口 importCase(formData).then((res) =&gt; &#123; //手动上传无法触发成功或失败的钩子函数，因此这里手动调用 this.updataSuccess(res.data) &#125;, (err) =&gt; &#123; &#125;)&#125; 关键代码说明： auto-upload 设置为 false 用于关闭组件的自动上传； file-list 配置一个数组用于接收上传的文件列表； multiple 设置为 true 表示支持多选文件； action 配置为完整的上传接口url，不配置会报错 不用配置 data、on-success、on-error等参数，因为手动上传不会用到这些配置信息； 最后通过点击按钮手动调用上传函数 submitUpload ，创建一个 FormData 把 fileList 的文件存进去。 方法二：通过配置http-requesthtml部分： 12345678910111213&lt;el-upload class=&quot;upload-demo list-uploadbtn&quot; ref=&quot;upload&quot; :action=&quot;curBastUrl&quot; :auto-upload=&quot;false&quot; :http-request=&quot;uploadFile&quot; :on-remove=&quot;updataRemove&quot; :before-upload=&quot;beforeUpload&quot; :on-change=&quot;updatachange&quot; :multiple=&quot;true&quot;&gt; &lt;el-button size=&quot;small&quot;&gt;点击上传&lt;/el-button&gt;&lt;/el-upload&gt;&lt;el-button type=&quot;primary&quot; @click=&quot;submitUpload&quot;&gt;确 定&lt;/el-button&gt; js部分： 123456789101112131415161718submitUpload() &#123; // 导入 let tempData = this.filedata this.filedata = new FormData() // 用FormData存放上传文件 this.$refs.upload.submit() // 会循环调用uploadFile方法，多个文件调用多次 this.filedata.append(&#x27;categoryDirectory&#x27;, tempData.categoryDirectory) // importCase是上传接口 importCase(this.filedata).then((res) =&gt; &#123; //手动上传无法触发成功或失败的钩子函数，因此这里手动调用 this.updataSuccess(res.data) &#125;, (err) =&gt; &#123; &#125;)&#125;uploadFile(file) &#123; this.filedata.append(&#x27;file&#x27;, file.file)&#125; 关键代码说明： http-request 自定义上传方法； 最后通过点击按钮手动调用上传函数 submitUpload ，创建一个 FormData, 调用 upload 组件的 submit 方法的时候会循环调用 http-request 配置的方法，从而往 FormData 里存放文件。","categories":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"}],"tags":[{"name":"upload","slug":"upload","permalink":"https://bubuzou.com/tags/upload/"},{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/tags/vue/"},{"name":"element-ui","slug":"element-ui","permalink":"https://bubuzou.com/tags/element-ui/"}]},{"title":"JS中类数组的遍历以及性能探究","slug":"traverse-of-array-like","date":"2017-08-28T04:08:21.000Z","updated":"2019-07-26T08:05:11.771Z","comments":true,"path":"2017/08/28/traverse-of-array-like/","link":"","permalink":"https://bubuzou.com/2017/08/28/traverse-of-array-like/","excerpt":"类数组在 JS 中我们都知道有一种数据类型叫数组，平常也用得很多，这里看到数组的介绍。但什么是类数组呢？在 JS 中存在一些对象，它们都带有 length 属性，却又不具备数组的那些方法，这些对象我们它叫做类数组。那么类数组有哪些呢？ jQuery对象 12var aList = $(&#x27;.tagcloud&#x27;).find(&#x27;a&#x27;);console.log( aList.length ); // &gt;= 0 如上通过jQuery获取的元素集合就是一个典型的类数组。","text":"类数组在 JS 中我们都知道有一种数据类型叫数组，平常也用得很多，这里看到数组的介绍。但什么是类数组呢？在 JS 中存在一些对象，它们都带有 length 属性，却又不具备数组的那些方法，这些对象我们它叫做类数组。那么类数组有哪些呢？ jQuery对象 12var aList = $(&#x27;.tagcloud&#x27;).find(&#x27;a&#x27;);console.log( aList.length ); // &gt;= 0 如上通过jQuery获取的元素集合就是一个典型的类数组。 NodeList 12var h2s = document.querySelectorAll(&#x27;h2&#x27;);console.log( h2s.constructor ); // ƒ NodeList() &#123; [native code] &#125; NodeList是节点集合，既包括了元素节点也包含了文本节点，比如node.childNodes也是一个 NodeList. HTMLCollection 12var h4s = document.getElementsByTagName(&#x27;h4&#x27;);console.log( h4s instanceof HTMLCollection ); // true HTMLCollection 是元素集合，更多详细信息可以看这里 类数组虽然没有数组的那些方法，但是可以通过 call 方法将其转成数组： 1234var h2s = document.querySelectorAll(&#x27;h2&#x27;);console.log( h2s.constructor ); // ƒ NodeList() &#123; [native code] &#125;var temp = Array.prototype.slice.call(h2s, null);console.log( temp instanceof Array ); // true 遍历类数组数组或者类数组的遍历方式很多，下面我们一一来介绍。 普通 for 循环 123for ( var i = 0; i &lt; arr.length; i++ ) &#123; &#125; 最普通也是最经典的 for 循环，大多数开发都喜欢用的方式。 优化版 for 循环 123for ( var i = 0, l = arr.length; i &lt; l; i++ ) &#123; &#125; 优化后的for循环，把数组长度的取值放到了定义变量的时候，避免了每次判断都要去取数组长度，从而节约了一定时间。 弱化版for循环 123for ( var i = 0; arr[i] != null; i++ ) &#123; &#125; 这种循环方式和上面两种都差不了多少，只不过是没有使用length判断，而使用变量本身判断。 forEach循环 123arr.forEach(function( item ) &#123; &#125;); JS数组自带的遍历方法。 新版forEach 123Array.prototype.forEach.call(arr, function( ele ) &#123; &#125;); 借用了原型的call方法来遍历类数组。 for in循环 123for ( var temp in arr ) &#123; &#125; for of循环 123for ( let v of arr ) &#123; &#125; ES6中新提出的一种循环方式。 map循环 123arr.map(function(e, i) &#123; &#125;); while循环 1234var flag = 0;while ( flag++ &lt; arr.length ) &#123; &#125; 性能测试这里测试里主要是通过控制外循环次数、数组的长度和循环体的复杂度来达到模拟性能测试的目的。 12345678// 核心代码var t4 = new Date().getTime();for ( var j = 0; j &lt; count; j++ ) &#123; // 外循环 arr.forEach(function( cha ) &#123; // 内循环 contextFn( cha ); // 循环体 &#125;);&#125;console.log( new Date().getTime() - t4) ); 内循环里是分别替换到不同的遍历方式，通过设置循环次数和数组长度来测试了一些数据，也可以来这里看demo 从上面的测试结果大致可以看出速度最快的遍历方式应该是优化后的 for 循环了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://bubuzou.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"良好的CSS编码习惯","slug":"css-coding-standards","date":"2017-07-18T07:28:21.000Z","updated":"2019-07-26T07:36:11.756Z","comments":true,"path":"2017/07/18/css-coding-standards/","link":"","permalink":"https://bubuzou.com/2017/07/18/css-coding-standards/","excerpt":"一个 css 文件的核心内容是由许许多多的 css 规则组成的，而每个规则又包含了两部分：选择器和声明；声明块里可能又包含多个声明，每个声明又是由属性和值组成的。这个大概就是 css 的代码结构。 这么多的规则就像一个小镇上的房子一样，如果房子建造之初，毫无规划胡乱建造，那等房子建造起来的时候，从远远望去就会非常地错杂不堪，难以入目，给人的心里埋下了非常糟糕的印象；又可能后期，由于发展的需要，要给小镇加修道路或者新建个学校，由于房子与房子之间连接得很混乱，所以这给后期重建镇子的人带来了很大的困难。 同样，在 css 的世界里，代码的排列布局也是非常重要的。良好的代码书写习惯能够让代码看起来更加干净简洁，给阅读者一种赏心悦目的感觉；好的代码便于开发发现错误，提高工作效率。所以作为一名好前端，很有必要养成一个良好的 css 编码习惯。","text":"一个 css 文件的核心内容是由许许多多的 css 规则组成的，而每个规则又包含了两部分：选择器和声明；声明块里可能又包含多个声明，每个声明又是由属性和值组成的。这个大概就是 css 的代码结构。 这么多的规则就像一个小镇上的房子一样，如果房子建造之初，毫无规划胡乱建造，那等房子建造起来的时候，从远远望去就会非常地错杂不堪，难以入目，给人的心里埋下了非常糟糕的印象；又可能后期，由于发展的需要，要给小镇加修道路或者新建个学校，由于房子与房子之间连接得很混乱，所以这给后期重建镇子的人带来了很大的困难。 同样，在 css 的世界里，代码的排列布局也是非常重要的。良好的代码书写习惯能够让代码看起来更加干净简洁，给阅读者一种赏心悦目的感觉；好的代码便于开发发现错误，提高工作效率。所以作为一名好前端，很有必要养成一个良好的 css 编码习惯。 文件命名web 项目中的所有资源文件名称应遵循相同的命名约定。css 文件也不例外，来看下面的例子： 12345678910111213&#x2F;* Not recommended *&#x2F;MyScript.jsmyCamelCaseName.cssi_love_underscores.html1001-scripts.jsmy-file-min.css &#x2F;* Recommended *&#x2F;my-script.jsmy-camel-case-name.cssi-love-underscores.htmlthousand-and-one-scripts.jsmy-file.min.css 一般来说资源文件的名字习惯如下命名： 以字母开头，避免数字开头 全部用小写，这样的话不容易在引用的时候因为大小写而出错 用-来分隔单词，而不是下划线 对于压缩过的文件，比如 css 或者 js 文件，使用 .min 代替 -min 设置编码在 css 文件的最顶部设置编码格式为 utf-8 ，否则有可能使得 css 文件出现乱码。 1@charset &quot;utf-8&quot;; 格式化css 文件里包含了许许多多的 css 规则，而每条 css 规则又由两部分组成，分别是选择器和声明块；声明块里包含了多个声明，而声明又是属性和值组成的。格式化里将要介绍的就是它们的结构和摆放位置，包括缩进、空格、换行以及个别声明的书写习惯等。 缩进css 代码的缩进让代码结构更加清晰，css 代码缩进需要遵循以下几点： 一个制表符( Tab 键)相当于4个空格(空格键)，css 的缩进占位一般是一个制表符的宽度。 缩进占位里不要混杂着制表符和空格，建议设置好编辑器的一个制表符等于4个空格宽度。 声明需要缩进；在 media query 里的所有 css 规则也需要缩进。 12345@media screen and (max-width: 640px) &#123; body &#123; background-color: #f8f8f8; &#125;&#125; 空格在 css 的世界里为了让代码看起来不那么拥挤，所以需要在适当的地方使用空格： 选择器和声明块的左大括号{之间。 声明中属性的冒号之后，属性值之前。 对于只有一条声明的声明块，声明的左右两边与左右大括号之间。 对于一个属性中有多个属性值，且放在同一行的时候，用来分隔各个属性值的逗号的后面。 对于一些特别的属性值里存在逗号分隔的情况，比如 rgba(248, 248, 248, .5)，需要在每个逗号后加上空格 123456.heavy &#123; font-weight: 700; &#125; body &#123; font-family: Georgia, serif; background-color: rgba(248, 248, 248, .5);&#125; 换行和空行换行和空行的目的也是为了 css 代码的美观性和结构更加清晰： 每个 css 规则之间需要一个空行。 单行注释的前面需要一个空行。 一个规则里存在多个选择器的时候，每个选择器的逗号后换行。 一个声明块里有多个声明的时候，每条声明后都需要换行；只有一条声明的时候，声明和选择器同行。 对于逗号分隔且非常长的属性值，可以考虑换行并且缩进一个制表符。 media query 声明的第一行空行，这样就不会和第一条声明杂在一起，显得拥挤。 123456789101112131415161718192021.modal &#123; width: 500px; margin: 0 auto;&#125; .modal a,.modal span &#123; color: #41b883; &#125; /* common */.shadow &#123; box-shadow: 1px 1px 1px #000, 2px 2px 1px 1px #ccc inset;&#125; @media screen and (max-width: 640px) &#123; .modal .modal-con a &#123; font-size: 12px; &#125;&#125; 选择器选择器这块主要是介绍命名、书写习惯以及为了更高的匹配效率而建议的写法等。 ID和Class的命名规范ID 和 Class 的主要习惯于如下命名方式： 全部字母用小写，避免使用驼峰命名法。 使用短横线-来作为连接单词之间的字符，避免使用下划线_。 1234.post-title &#123; font-size: 20px; color: #41b883;&#125; 命名尽可能语义化，让人一目了然。 123456789/* Not recommended */.fw-800 &#123; font-weight: 800; &#125; .red &#123; color: red; &#125; /* Recommended */ .heavy &#123; font-weight: 800; &#125; .important &#123; color: red; &#125; 尽可能避免使用ID选择器在 css 的世界里不太欢迎 ID 选择器，因为 ID 是作为某个元素的唯一标识而设定的，但是元素的样式是可以被重复定义，层层覆盖的。所以建议不要使用 ID 选择器，取而代之的是多用类选择器。 12345/* Not recommended */#article p &#123; line-height: 28px; &#125; /* Recommended */.article p &#123; line-height: 28px; &#125; 避免使用标签进行双重限定这是什么意思呢？看了下面的例子你就知道了。 12345/* Not recommended */p.desc &#123; color: #666; &#125; /* Recommended */.desc &#123; color: #666; &#125; 尽可能的精确，但是最好不要超过3级css 的选择判定也存在效率问题，所以书写的时候尽量要精确；选择器的嵌套层级最好不要超过3级，否则显得很冗长，效率上也未必更高。 12345/* Not recommended */.content .title &#123; font-size: 2rem; &#125; /* Recommended */.content &gt; .content-body &gt; .title &#123; font-size: 2rem; &#125; 属性选择器记得使用双引号属性选择器记得使用双引号，避免单引号和不用引号 12345/* Not recommended */input[type=text] &#123; line-height: 1.2; &#125; /* Recommended */input[type=&quot;text&quot;] &#123; line-height: 1.2; &#125; 声明块作为 css 规则中的第二部分，声明块中自然也有许多需要注意的地方。比如声明的顺序、属性和值的写法以及一些个例等。 声明的顺序在 css 中存在好几百个属性，如果需要一个 css 规则里几乎可以写满这些属性。如果这些声明毫无顺序章法可言，那么在需要修改的时候就会非常的头痛了，一大块声明杂在一个规则里，你就需要慢慢地找慢慢地看了。但是如果你的声明都是按照一定的逻辑顺序来书写，那么声明的层次就非常清晰。声明的时候一般比较重要的属性会优先书写。 如果包含了 content属性，则应该最优先书写，即写到声明块的最上面。 定位相关的属性，比如position、top、left、z-index、display、float、visibility和overflow、flex等。 布局相关的属性，比如display、float、visibility、overflow、flex和clear等。 盒模型相关的属性，比如width、height、margin、padding、border以及box-sizing等。 文本排版印刷相关的属性，比如font、line-height、vertical-align、text-align和white-space、text-decoration等。 视觉感官上相关的属性，比如color、background、list-style、transform、transition和animation等。 12345678910111213141516171819202122232425262728.box &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Layout */ display: block; float: right; /* Box-model */ width: 100px; height: 100px; border: 1px solid #e5e5e5; border-radius: 3px; /* Typography */ font: normal 13px &quot;Helvetica Neue&quot;, sans-serif; line-height: 1.5; text-align: center; /* Visual */ color: #333; background-color: #f5f5f5;&#125; 尽可能的使用简写属性在 css 中存在一些属性是可以拆分成其他独立属性的，比如background、border、font、list-style、margin 和 padding 等。这些属性在 css 里被称为复合属性，又因为一个属性包含了多个独立属性，所以在书写的时候使得代码更加简洁，所以又喜欢称其为简写属性，这里的简写也可以理解为动词。 12345678/* Not recommended */.box &#123; margin: 0; margin-top: 10px;&#125; /* Recommended */.box &#123; margin: 10px 0 0; &#125; 每条声明都以分号结尾在 css 里，如果声明不以分号结尾是会出问题的，但是也有一个例外，那就是声明块的最后一个声明是可以不用分号结尾的。但是如果改变了声明的顺序或者新增了声明，那原来的那条没有带分号的声明就有可能不是最后一条声明了，肯定就出问题了，所以为了避免这种不必要的错误发生，我们要习惯给每个声明都加上分号。 12345678910111213/* Not recommended */.post-content h6 &#123; position: relative; margin: 1em 0; color: #4e4a4a&#125; /* Recommended */.post-content h6 &#123; position: relative; margin: 1em 0; color: #4e4a4a;&#125; 双引号在 css 的世界里很多地方是很有必要用引号的，为了避免混淆，建议需要引号的地方都使用双引号，而不用单引号。 对于 font-family 属性，如果属性值是带空格的英文比如 Helvetica Neue 或者是中文，那么建议加上双引号，比如content 属性。对于 URI 资源的引用，有使用到url()引入资源的时候，不用带引号。比如引入背景图片、字体定义的时候引入字体包等。 12345.tip:before &#123; content: &quot;!&quot;; font-family: Dosis, &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; background: url(../img/tip.png) no-repeat center;&#125; 尽量不要使用 !importantcss规则的定义顺序很重要，同层级的声明，定义文件后面的会覆盖定义在前面的，但是如果使用了 !important 来限定声明，则可以将优先级提升到最高，这是非常霸道的规则。有时候因为使用了 !important，使得脚本程序改变不了样式渲染的结果，非常可恶。所以建议不要使用这个属性，取而代之的是，如果真的需要提高某个选择器的优先级，可以通过增加样式的层级来达到这个目的。 123456/* Not recommended */.heavy &#123; font-weight: 700 !important; &#125; /* Recommended */.heavy p,.heavy a &#123; font-weight: 700; &#125; 值和单位 所有属性和值尽量都用小写。 属性值为0的时候，不要带单位。 12345/* Not recommended */.info-item &#123; padding: 0px 10px; &#125; /* Recommended */.info-item &#123; padding: 0 10px; &#125; 当可能的时候尽量使用三位的十六进制计数法，比如表示颜色的时候。 12345/* Not recommended */.pink-color &#123; color: #ff33aa; &#125; /* Recommended */.pink-color &#123; color: #f3a; &#125; font-weight使用数值化表示方法，用400代替 normal、700代替 bold。 12345/* Not recommended */.heavy &#123; font-weight: bold; &#125; /* Recommended */.heavy &#123; font-weight: 700; &#125; line-height尽量不要带单位，除非必须用px来标定。 12345/* Not recommended */.content p &#123; line-height: 1.2em; &#125; /* Recommended */.content p &#123; line-height: 1.2; &#125; 当属性值是介于0到1之间的小数时，可以直接把0省略。 12345/* Not recommended */.pannel &#123; opacity: 0.8; &#125; /* Recommended */.pannel &#123; opacity: .8; &#125; 注释文件或模块注释文件顶部（@charset之后）最好是需要一块注释，大概介绍的是这个文件是关于什么内容的，作者是谁，最后更新时间等。当然如果一个 css 文件非常大，涉及到很多组件模块相关的代码，那可能每个模块都需要一个注释。 123456/** * @name: bubuzou.css * @description: hexo-theme-bubuzou的主题样式 * @author: typeR(zgrlbq@126.com) * @update: 2017-7-21 16:21:02 */ 单行注释星号与内容之间必须保留一个空格。如果是单条声明需要注释，则写到声明的分号后分隔一个空格开始注释。 12345/* This is a comment about this selector */.another-selector &#123; position: absolute; top: 0; /* I should explain why this is so important */&#125; 多行注释星号要一列对齐，星号与内容之间必须保留一个空格。多行的注释和规则之间最好加一个空格，才不会显得那么拥挤。 12345/** * Description of left, whether or not it has media queries, etc. */ .left &#123; float: left; &#125; 参考文章 Web Styleguide - Style guide to harmonize HTML, Javascript and CSS / Sass coding style CSS Coding Standards css-syntax CSS样式书写规范","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"jpg、gif、png和svg用于web上，我们该如何选择最合适的图像格式？","slug":"jpeg-gif-png-svg-on-web","date":"2017-06-29T03:19:21.000Z","updated":"2019-07-26T07:38:17.503Z","comments":true,"path":"2017/06/29/jpeg-gif-png-svg-on-web/","link":"","permalink":"https://bubuzou.com/2017/06/29/jpeg-gif-png-svg-on-web/","excerpt":"要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：jpg、gif、png和svg。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？logo应该是选择 svg 还是 png ？而截图是选 jpg 还是 png 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。 在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。 先来看几个概念 有损(Lossless)和无损(Lossy)：一般我们聊到图片的时候经常会听到别人提到有损或者无损的字眼，那么什么是有损和无损呢？无损就是图片在压缩保存后虽然占用的存储更小了，但是图像的呈现质量依然如旧；而有损则是相反，图像随着一次又一次的压缩后，质量会变得越来越差。 索引色(Indexed color)和直接色(Direct color)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过256种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。 光栅格式(raster)和矢量格式(vector)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 Photoshop 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。","text":"要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：jpg、gif、png和svg。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？logo应该是选择 svg 还是 png ？而截图是选 jpg 还是 png 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。 在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。 先来看几个概念 有损(Lossless)和无损(Lossy)：一般我们聊到图片的时候经常会听到别人提到有损或者无损的字眼，那么什么是有损和无损呢？无损就是图片在压缩保存后虽然占用的存储更小了，但是图像的呈现质量依然如旧；而有损则是相反，图像随着一次又一次的压缩后，质量会变得越来越差。 索引色(Indexed color)和直接色(Direct color)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过256种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。 光栅格式(raster)和矢量格式(vector)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 Photoshop 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。 JPEGJEPG由联合图像专家小组（Joint Photographic Experts Group）于1992年创建，并以创建者命名。JPEG是一种有损光栅图像格式，这意味着每次压缩保存JPEG时，一些信息将发生不可逆转地丢失；且存储的颜色无限制，这就对存储照片这种颜色非常丰富复杂的图像就很友好了。 因为 JPEG 压缩在亮度和色彩上面的优越性，所以 JPEG 非常适合用于照片、色彩梯度明显的图像比如渐变和阴影这些地方。 JPEG 的压缩可以用 Photoshop 里存储为 web 格式的时候可以直接选择压缩品质，一般用于 web 的 JPG 图片选择 50%-60% 质量的即可，因为它兼顾不错的图像质量和较小的文件尺寸。另外也可以用在线压缩工具 TinyJPG。 下面这个图，我用的是 50%的品质压缩出来的 JPG，很明显质量要比 GIF 的要好很多，而且文件尺寸也小不少。 JPEG 和 JPG 的区别：JPEG 更多的指的是 .jpg 图像格式的一种压缩算法，而 JPG 就是一种图像存储的格式。 PNG可移植网络图形（Portable Network Graphics）也是一种自1995年以来就一直存在的光栅图像格式。它与 JPEG 不同，因为它是一种无损格式，并且是目前网络上最常见的无损格式。这意味着由于它的压缩算法，当文件被保存和压缩时，不会丢失任何信息。 PNG格式PNG其实可以细分为好几个格式的，有PNG 8、PNG 24和PNG 32。那么怎么区分一个 PNG 图片是什么格式的呢？ 打开上面这张图片的属性面板，从详细信息里看到有一个属性叫做位深度，它的值是24，那么就表示他是 PNG 24 格式的图片。同样，PNG 8 和 PNG 32 的位深度分别是8和32。 位深度表示图像能够存储颜色的最大数值。8位就是2的8次方（2^8=256）种颜色，所以 PNG 8 最多只能存储256种颜色。PNG 24 和 PNG 32又叫真彩色，最多存储2的24次方种颜色，可以达到人眼分辨的极限了；PNG 32中剩余的8位存储的是Alpha 通道的透明色。 然后如何生成这些不同格式的图片呢？自然是用专业的图像处理软件啦，比如可以用 Photoshop 或者 Fireworks。这里以 Photoshop 为例子，文件-&gt;存储为 Web 所用格式， 可以看到下拉这里只有 PNG-8 和 PNG-24，而没有 PNG-32 呢？是因为 Photoshop不支持这个格式嘛？并不是。 在 Photoshop 里导出 PNG-32 格式的图片是通过选择 PNG-24格式，并且勾选下面的透明度，这样生成的图片位数才是32位的，如果不勾选透明度的话就是 PNG-24 格式。由此看来 PNG-24 是不支持透明的，PNG-32 是支持透明的。 PNG透明度从 Fireworks 8的优化面板里可以看到 PNG 格式存在三种透明格式：不透明、索引透明和 Alpha透明。 PNG 8透明度 从上面那个图里可以看出 PNG 8 是支持这三种不透明格式的。但是 Photoshop 只支持导出不透明和索引透明格式。在Photoshop 中如果选择 PNG 8，且勾选了透明度，那么导出的图片就是 PNG 8 索引透明，否则就是 PNG 8 不透明。 用 Photoshop 和 Fireworks 8 导出 PNG 8 的各种格式如下所示： 根据以上图片我们可以得出结论： Photoshop 导出的 PNG 8 图片都带有锯齿。 PNG 8 索引透明都带有锯齿，且 Fireworks 8 导出的 PNG 8索引透明的锯齿是白色的。 再来看看这些格式在不同浏览器下的表现情况： 根据以上图片我们可以得出结论： PNG 8 索引透明和 Alpha 透明都兼容IE 6；但美中不足的是，PNG 8Alpha透明在 IE 6下会产生锯齿。 其他格式的图片在各个浏览器下的表现一致。 Fireworks 8导出的 PNG 8索引透明带有白色锯齿，但是如果图片是放到白色的背景的容器下，那么这个白色锯齿就完全看不出来了，表现得和正常效果一样。 PNG 24 和 PNG 32 PNG 24 是不透明的；PNG 32 是支持透明的，且是 Alpha 透明。来看下它们在不同浏览器下的表现： PNG 32 图片的透明区域在 IE 6 下将不再透明，而是颜色值为 f0f0f0 的灰色填充，在更高级版本的 IE 下是正常的。PNG 32 图片不会有锯齿。 PNG压缩本文前面提到了 JPEG 在照片片这类颜色丰富的图像上的优秀表现，所以现在将它和 PNG 的3种格式进行对比。主要是对比压缩前后的存储体积以及表现效果等方面。用的是免费的在线压缩工具 TinyPNG，这个工具可以压缩 JPEG 和 PNG 格式。 从上图这个图中，我们可以从不同角度得出一些结论： PNG 8 格式的图片颜色过度处理得很突兀，能看到很明显的波浪褶皱，这就是因为它最多只能存储256种颜色导致的，所以PNG 8不适合用于存储颜色复杂的图像。相反，由于其相对于 PNG 24 或者 PNG 32 有先天的存储体积小优势，所以它非常适合应用于图标、颜色简单的或透明的图像上。 对比100%质量的 JPG、55%质量的 JPG、PNG 24 和 PNG 32，肉眼上看他们的图像表现效果都差不多，但是各自所占用的存储空间却是差得有些离谱。压缩前，当属55%质量的 JPG 占用存储最小；压缩后，PNG 24 和 PNG 32 一样，会比55%质量的 JPG 小一些，但是由于 PNG 32 支持透明，所以对于颜色丰富的图像建议用 PNG 32 格式导出，然后用压缩工具压缩一下即可。 对比压缩前后的 PNG 24 和 PNG 32 两者的存储体积相差巨大，但是表现效果却相差无几，所以用于 web 上的 PNG 24 或 PNG 32 图像一定要记得压缩，这对于客户端的性能优化将提供非常大的帮助。 GIF图形交换格式（Graphics Interchange Format）也是一种光栅格式，最多只能存储256种颜色，支持透明度，而且在 IE 6 下也支持得很好，唯一美中不足的是除了 Fireworks 8 导出的 GIF 不透明格式外，所有的其他 GIF 格式的图片都存在锯齿。 但是 GIF 也不是一无是处，最大的优点就是支持简单的动画。如下面简单的交通灯动画： SVG可伸缩矢量图形（Scalable Vector Graphics），顾名思义它是矢量的，而非光栅格式。区别于光栅格式的依靠像素点来存储图像，矢量图是通过XML格式来数据化的记录图像的信息。所以 SVG 相对于光栅格式的图像具有以下优势： 任意伸缩图像，而不会破坏图像的清晰度和细节。 完全支持 DOM，以及 JavaScript 能够很好的访问到它。 总体来讲，SVG的文件会比 GIF 或 JPG 的会小很多。 就像其它矢量格式，SVG 图片能不丢失任何细节地放大到任何大小。打个比方，同一个图标，可以以多种尺寸使用，并且在任何屏幕分辨率（比如 Retina 显示器）中都将看起来很清晰，而不需要存成多个文件。比如下面这个这个图对比，右边的是矢量图，左边的是其他格式图片： SVG用途SVG 在线条艺术，LOGO，图标，插画和数据可视化方面用途广泛。但它不适用于写实图像和有许多细节的复杂图片。在一些情况下，SVG 和 PNG 都能很好地达到同一个目的。对于线条艺术，SVG 通常能生成较小的文件。但是这不是必然的，实际情况会根据矢量图像究竟有多少个锚点，它甚至可能会生成比PNG更大的文件。 SVG 真正出色的地方是数据可视化。由于可以使用JavaScript 来操纵和创建矢量动画，诸如 D3 之类的库提供了无限的可能性。LOGO, 图标和数据可视化是 SVG 使用的优秀范例。 SVG压缩比较好的 SVG 方法应该是通过清除 SVG 矢量图形中不必要的锚点、元素和属性来减少文件大小。锚点绘制了矢量图像，因此，你需要确保已移除的锚点不会影响矢量图形的最终形状。如果您使用 Adobe Illustrator 编辑 SVG，请确保使用导 -&gt; 导出为，而不是文件 -&gt; 另存为进行保存，因为这样才能生成一个最小化的文件。 清理不必要的节点是缩减 SVG 尺寸的一种途径。元素标签是包含在 SVG 文件内的所有内容，包括开始和结束标签。矢量编辑软件，如 Adobe Illustrator 和 Sketch 可能会到处含有非必要元素和属性的 SVG 。SVG 压缩器可用于删除这种多余的信息。Compresso 和 SVGOMG 等在线工具可以完成此工作。 参考文章 在网页上使用JPG、PNG和SVG：新手指南 PNG使用技巧 PNG vs. GIF vs. JPEG vs. SVG - When best to use? JPG vs PNG vs GIF vs SVG – What is the Difference?","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://bubuzou.com/tags/svg/"},{"name":"图像","slug":"图像","permalink":"https://bubuzou.com/tags/%E5%9B%BE%E5%83%8F/"}]},{"title":"CSS自定义属性","slug":"css-custom-property","date":"2017-05-04T04:20:21.000Z","updated":"2019-07-26T07:57:49.748Z","comments":true,"path":"2017/05/04/css-custom-property/","link":"","permalink":"https://bubuzou.com/2017/05/04/css-custom-property/","excerpt":"CSS 自定义属性，很多人又把它称之为 CSS 变量，是由用户自己定义的用来指定 CSS 属性值的变量。来看一个简单的例子： 123456:root &#123; --color-red: red;&#125;.red &#123; color: var(--color-red);&#125; 上面这个例子中，首先在 :root(文档根元素即 html )处定义了一个全局变量，变量名称叫 color-red。然后在 red 元素里使用了这个变量，那么该元素颜色将变成红色。","text":"CSS 自定义属性，很多人又把它称之为 CSS 变量，是由用户自己定义的用来指定 CSS 属性值的变量。来看一个简单的例子： 123456:root &#123; --color-red: red;&#125;.red &#123; color: var(--color-red);&#125; 上面这个例子中，首先在 :root(文档根元素即 html )处定义了一个全局变量，变量名称叫 color-red。然后在 red 元素里使用了这个变量，那么该元素颜色将变成红色。 变量申明与使用参照上面的例子，你可能很容易看出 CSS 变量的声明方式：使用 --* 声明一个变量。这里的 * 表示变量名称。变量名称的组成可以是数组[0-9]、字母[a-zA-Z]、下划线_或者连字符-组合而成，更厉害的是变量名称甚至可以是中文，另外变量名称是区分大小写字母的。CSS 变量的取值可以是单值 10px、复合属性的值 1px solid #ddd，计算值 calc( 10px * 2 )，甚至属性值里又可以引用变量 var(--size) 10px。 12345678/* 变量申明，注意观察变量名称和属性值的定义 */:root &#123; --10: 10px; --marginTop: 20px; --color-red: red; --特殊的内间距: 10px 0 20px; --padv: calc( var(--10) * 2 ) 0; &#125; 变量的使用方式：使用 var(--*) 使用变量，其实比较完整的使用规则是这样的：var( &lt;–变量名称&gt; [, &lt;默认值&gt; ]? )，比如下面这样： 123div &#123; padding: var(--size, 10px 0);&#125; 这个表示，当 --size 这个变量未定义的时候，则使用默认值 10px 0，注意这个地方不能加分号。 还有一种情况是，假如定义了一个变量，但是变量值是不合法的，这个时候就会取属性的缺省值。比如： 12345body &#123; --color: 20px; background-color: #369; background-color: var(--color, #cd0000);&#125; 看上面的例子，此时的 body 的背景颜色到底是什么呢？A. transparent、B. 20px、C. #369、D. #cd0000答案是 A，因为这个时候变量 color 的值用在这里是不合法的，所以会取 background-color 的缺省值即默认替代值transparent，也不会用 #cd0000 再来看个例子： 1234body &#123; --size: 20; font-size: var(--size)px;&#125; 乍看上面这个例子，body 的字号是 20px，其实不然。var(--size)px 会解析完成后会变成 20 px，这个值是不合法的，所以会取缺省值 16px。注意到这个问题，稳妥的做法还是在变量申明的时候带上单位。或者使用 calc() 来计算： 1234body &#123; --size: 20; font-size: calc(var(--size) * 1px );&#125; CSS变量作用域居然是变量，那么自然的有作用域这一说法，在 CSS 变量中，也是存在作用域的。全局作用域，直接将变量定义在根元素上： 1234567891011121314:root &#123; --color-red: red;&#125;``` 局部作用域是会直接在某个元素上定义变量，且这个变量只在该元素及后代元素中有效：``` cssbody &#123; color: var(--color-red);&#125;div.red &#123; --color-red: red;&#125; 上面的例子中，body 的颜色不会被设置成红色。另外值得一提的是，变量的申明和变量的使用与定义在文件里的先后位置无关。 当存在多个变量的时候，变量的覆盖规则由 CSS 选择器的权重决定，但并无 !important 这种用法，因为没有必要，!important设计初衷是干掉 JS 的 style 设置，但对于变量的定义则没有这样的需求。 123456:root &#123; --color: red;&#125;div &#123; --color: blue;&#125; 此时有一个 div 元素，那么其颜色值会是蓝色的。 来实践一下先来看一个例子： 12345678div &#123; border: 1px solid #d2d2d2;&#125;div &#123; border-width: 1px; border-style: solid; border-color: #d2d2d2;&#125; 上面这两种设置的边框效果都是一样的，区别是一个用的是复合属性，一个是独立属性。在 CSS 里存在许许多多的属性值是由多个值组成的属性，比如 border、animation 等。如果要单独地修改这些多个属性值里的某一个，复合属性就可以直接修改它的独立属性，但是对于那种不是复合属性却有多个属性值的 CSS 属性就头大了，比如 box-shadow，特别是在 OOCSS 的世界里，这种情况就更尴尬了。但是现在有了 CSS 自定义属性，问题就可以迎刃而解了。比如，box-shadow: 1px 2px 3px 4px #ddd，这里可以把这5个值分别用5个全局变量表示： 1234567:root &#123; --box-shadow-offset-x: 1px; --box-shadow-offset-y: 2px; --box-shadow-blur: 3px; --box-shadow-spread: 4px; --box-shadow-color: #ddd;&#125; 当需要单独地修改某个值的时候，直接用 js 修改全局变量的值即可： 1document.documentElement.style.setProperty( &#x27;--box-shadow-offset-x&#x27;, &#x27;3px&#x27; ); 是不是很方便，是不是很好玩，戳我给你看一个例子。 CSS变量存在的意义在构建大型站点时，作者通常会面对可维护性的挑战。在这些网页中， 所使用的 CSS 的数量是非常庞大的，并且在许多场合大量的信息会重复使用。例如，在网页中维护一个配色方案，意味着一些颜色在 CSS 文件中多次出现，并被重复使用。当你修改配色方案时，不论是调整某个颜色或完全修改整个配色，都会成为一个复杂的问题，不容出错，而单纯查找替换是远远不够的。 如果使用了 CSS 框架，这种情况会变得尤其糟糕，此时如果要修改颜色，则需要对框架本身进行修改。在这些场合使用 LESS 或 Sass 类似的预处理器是非常有帮助的，但是这种通过添加额外步骤的方式，可能会增加系统的复杂性。CSS变量为我们带来一些预处理器的便利，并且不需要额外的编译。 这些变量的第二个优势就是名称本身就包含了语义的信息。CSS 文件变得易读和理解。main-text-color 比文档中的#00ff00 更容易理解，特别是同样的颜色出现在不同的文件中的时候。 兼容性CSS 自定义属性在 IE 上完全不支持啊，在其他浏览器上支持性还是不错的。戳我 参考文章 小tips:了解CSS/CSS3原生变量var 使用CSS变量 Now that CSS Custom Properties are a Thing, All Value Parts Can Be Changed Individually","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"理解 Flexbox：你需要知道这些","slug":"flexbox","date":"2017-04-18T08:48:21.000Z","updated":"2019-07-26T07:50:01.530Z","comments":true,"path":"2017/04/18/flexbox/","link":"","permalink":"https://bubuzou.com/2017/04/18/flexbox/","excerpt":"flexbox 顾名思义 flexible box 弹性盒子，是 css3 中定义的一种新的布局方式。通过在某元素上使用 display: flex; 即可把该元素定义为 flex 容器 ( flex container )，而容器的所有子元素就是 flex 项目 ( flex item )。再介绍 flex 语法之前，先来看看一个重要的东西。 flex轴线","text":"flexbox 顾名思义 flexible box 弹性盒子，是 css3 中定义的一种新的布局方式。通过在某元素上使用 display: flex; 即可把该元素定义为 flex 容器 ( flex container )，而容器的所有子元素就是 flex 项目 ( flex item )。再介绍 flex 语法之前，先来看看一个重要的东西。 flex轴线 在 flex 容器里，存在两条轴，main axis 和 cross axis，又分别叫做主轴和交叉轴。主轴之所以叫做主轴而不叫做 x 轴，是因为主轴不一定是在水平线上的，也有可能是垂直方向上，比如当 flex-direction: column; 的时候，主轴就是在垂直方向上。另外主轴和交叉轴都是有方向的，flex 项目就是沿着主轴方向进行布局。主轴默认方向是从左到右，交叉轴则是从上到下。 css3 里关于 flexbox 定义了2类的样式，分别是作用于 flex 容器上的和作用于 flex 项目上的。 flex容器能作用到 flex 容器上的样式有这么几个：flex-direction，flex-wrap，flex-flow，justify-content，align-items 和 align-content。看到这么几个东西，别被它们吓坏了，多读几遍你就能猜个八九不离十它们是干嘛用的了。下面我们一一来介绍这些样式。 flex-direction相信你也大概知道了这个样式的作用了，对了就是和方向有关的。flex-direction 这个样式就是用来控制 main axis 的方向的，默认值 row，表示水平从左到右。 row，默认的属性值，水平方向，从左到右 column，垂直方向，从上到下 row-reverse，水平方向，从右到左 column-reverse，垂直方向，从下到上 1234ul &#123; display: flex; flex-direction: row; /* column || row-reverse || column-reverse */&#125; 来一张图，你就更好理解了： flex-wrapflex-wrap 规定了 flex 项目在主轴上是按照一行还是多行显示。 nowrap，默认属性，单行显示，会尽力的压缩每个 flex 项目直到刚好容下里面的内容，实在压缩不了的时候 flex 项目就可能会溢出容器。 wrap，允许多行显示，当一行显示不下的时候，会变成多行显示。 wrap-reverse，多行显示，且行的显示顺序是从下到上，即第一行显示在容器的底部。 1234ul &#123; display: flex; flex-wrap: nowrap; /* wrap || wrap-reverse */&#125; flex-flowflex-flow 是一个复合属性，是由 flex-direction 和 flex-wrap 组成的属性。如果只定义了一个属性，那么另外一个属性取默认值。且属性书写顺序没有特别要求。 row nowrap，这是默认属性值 1234ul &#123; display: flex; flex-flow: row wrap;&#125; justify-contentjustify-content 规定了 flex 项目在主轴的对齐方式。比如当 flex-direction 被设置为 column 时，justify-content 定义的是垂直方向上的对齐方式。 flex-start, 默认属性值，flex项目将向着主轴起始位置对齐 flex-end, flex 项目将向着主轴结束位置对齐 center, flex 项目将在主轴上居中对齐 space-between, flex 项目将在主轴上以相同的间距贴着轴的两端对齐 space-around, flex 项目将在主轴上以相同的间距靠着两端对齐，且第一个头尾项目和轴的两端之间存在间距，间距是两个项目间距的一半 1234ul &#123; display: flex; justify-content: center;&#125; align-items居然有主轴上的对齐方式，那么肯定也有相关的属性是用来定义交叉轴上的对齐规则的。和 justify-content 一样，align-items 也有5个属性定义，其中 flex-start，flex-end 和 center 是一样的，就不多介绍了。来说说两个不同的： stretch，默认属性值，flex 项目在交叉轴上的尺寸如果没有指定或者是被设置为 auto，那么它将在这个方向上尽量延伸，直到靠着容器边界，但是同时延伸的程度也会受到 max-height 或者 max-width 的影响 baseline，flex项目在交叉轴上的对齐方式将是由每个项目内容的基线决定 1234ul &#123; display: flex; align-items: flex-start;&#125; align-content理解了 justify-content 和 align-items 的对齐方式，再来看 align-content 就容易理解多了。它只作用于容器，且只能是存在多个行的容器。注意这里的行是相对于交叉轴来说的。属性值有6个：flex-start，flex-end，center，stretch，space-between 和 space-around，这些对齐方式上面都介绍过了，大同小异。其中默认值是stretch。结合下图来加深理解： 12345ul &#123; display: flex; flex-wrap: wrap; align-content: space-around&#125; flex项目上面介绍了定义在 flex 容器上的 css 属性，规范了整个容器里所有项目的全局呈现。这样不够灵活多变，不足以表现某些需要特别显示的项目，所以针对这一现状，w3c 社区又推出了一套作用于 flex 项目上的 css 属性。他们分别是：align-self，order，flex-grow，flex-shrink，flex-basis 和 flex 等 css 属性。 align-self align-self 规定了单个 flex 项目在交叉轴上的对齐方式，属性值可以是下面一个：flex-start，flex-end，center，stretch，baseline和 auto，其中 auto 为默认属性值，如果被设置为了 auto，那么该 flex 项目最终的对齐方式将是由容器的 align-items决定。 123456ul &#123; display: flex;&#125;ul li &#123; align-self: center;&#125; orderorder 定义了 flex 项目在容器里的排列顺序。取值可以是负整数、0、正整数，默认取值是0。数值越大越靠近轴向的末端，数值相同则按照 html 里的顺序排列。 123456ul &#123; display: flex;&#125;ul li &#123; order: 2;&#125; flex-growflex-grow 规定了 flex 项目的伸展性，其值只能是 0 或者正整数，默认值是 0。如果一个 flex 项目同时设置了width 和值为正整数的 flex-grow 属性，则 width 属性将失效。取值如果是0表示不进行伸展；如果是正整数，则会进行伸展，且伸展的尺寸将和数值的大小有关，值越大，伸展得越大。伸展的具体计算数值是该项目占所有可伸展项目总和的比与这些所有可伸展项目占的尺寸的乘积。 flex-shrink与伸展相对应的属性是 flex-shrink，定义了项目的收缩性，值也只能是 0 或者正整数，默认值是 1。如果是 0 表示不进行收缩，如果是正整数则表示进行收缩。如果一个项目同时显示设置了尺寸和收缩值为 1，那么该项目将进行收缩，定义的尺寸将失效。项目能够进行收缩的前提是必须产生溢出，即所有项目所占尺寸之和必须大于容器尺寸。这个时候容器里所有可收缩的项目就需要通过收缩来消化掉这部分溢出的尺寸。而每个项目具体的收缩量则由其设置的收缩比例决定，数值越大，收缩得越厉害。比如一个容器的尺寸是 400px，只有2个项目且尺寸都是 300px，收缩比例是 1 比 3，那么容器将溢出 200px，所以第一个项目需要收缩 50px，第二个项目需要收缩 150px，那么收缩完成后它们占据的尺寸分别是 250px 和 150px。 flex-basisflex-basis 定义了项目在伸缩之前的初始尺寸，可以是长度设置（px、rem 和 em 等）；可以是用百分比基于父级来计算尺寸；也可以是默认的 auto，表示其尺寸由内容决定。除了 auto 外，如果尺寸溢出容器了，那么设置了 flex-basis 的项目间，则会根据每项设置的基准值，按比率伸缩剩余空间。 flexflex 是一个复合属性，是由flex-grow、flex-shrink 和 flex-basis 组成的。 flex-grow ，用来指定扩展比率，在 flex 属性中该值如果被省略则默认为1 flex-shrink，用来指定收缩比率，在收缩的时候收缩比率会以伸缩基准值加权，在 flex 属性中该值如果被省略则默认为1 flex-basis，用来指定伸缩基准值，即在根据伸缩比率计算出剩余空间的分布之前，表示尺寸的起始数值。在 flex 属性中该值如果被省略则默认为 0%。在flex属性中该值如果被指定为 auto，则伸缩基准值的计算值是自身的 width 设置，如果自身的宽度没有定义，则长度取决于内容。 一些缩写说明： flex: 1, 则其计算值为1 1 0% flex: auto, 则其计算值为1 1 auto flex: none, 则其计算值为0 0 auto flex: 0 auto 或者flex: initial, 则其计算值为0 1 auto 兼容性flex 布局在现代浏览器中兼容性还是比较令人满意的。可以去caniuse里看看，或者直接看这个用 flex 布局写的案例catty-music 参考文章 理解Flexbox：你需要知道的一切","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"CSS居中完整篇","slug":"css-center-skill","date":"2017-04-13T13:20:21.000Z","updated":"2019-07-26T07:43:04.463Z","comments":true,"path":"2017/04/13/css-center-skill/","link":"","permalink":"https://bubuzou.com/2017/04/13/css-center-skill/","excerpt":"水平居中 inline 或 inline-* 元素 此类元素需要水平居中，则父级元素必须是块级元素(block level)，且父级元素上需要这样设置样式： 123.parent &#123; text-align: center;&#125; 块级元素 块级元素水平居中，需要设置 margin-left 和 margin-right 为 auto，且需要显示设置宽度，不然就占满整行，就无所谓水平居中了。 1234.block &#123; width: 300px; margin: 0 auto;&#125;","text":"水平居中 inline 或 inline-* 元素 此类元素需要水平居中，则父级元素必须是块级元素(block level)，且父级元素上需要这样设置样式： 123.parent &#123; text-align: center;&#125; 块级元素 块级元素水平居中，需要设置 margin-left 和 margin-right 为 auto，且需要显示设置宽度，不然就占满整行，就无所谓水平居中了。 1234.block &#123; width: 300px; margin: 0 auto;&#125; 同一行多个块级元素 如果是在同一行里需要居中多个块级元素，可以尝试下面的两种方法： 12345678910111213141516/* 方法一 */.parent &#123; text-align: center;&#125;.parent div &#123; display: inline-block;&#125;/* 方法二 */.parent &#123; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center;&#125; 垂直居中垂直居中在 CSS 中比较不好处理。 单行文本 通过设置上下内间距一致达到垂直居中的效果： 1234.single-line &#123; padding-top: 10px; padding-bottom: 10px;&#125; 通过设置 height 和 line-height 一致达到垂直居中： 1234.single-line &#123; height: 100px; line-height: 100px;&#125; 多行文本 通过使用表格来垂直居中，但是这种方法显得很累赘： 1234567&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;通过表格使得多行文本自动垂直居中通过表格使得多行文本自动垂直居中通过表格使得多行文本自动垂直居中&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 通过设置 vertical-align 属性和将元素设置为 table-cell，且父元素要设置为 table 元素，这个和上面那种原理其实是一样的： 1234567.parent &#123; display: table;&#125;.parent div &#123; display: table-cell; vertical-align: middle;&#125; 通过伸缩盒来垂直居中： 1234567.flex-vertically &#123; -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex;&#125; 块级元素垂直居中 知道块元素的高度，那么使用绝对定位和负的 margin 即可实现垂直居中： 123456789.parent &#123; position: relative;&#125;.parent div &#123; position: absolute; top: 50%; height: 50px; margin-top: -25px;&#125; 块级元素高度是可变的，这个时候就需要用 transform 的Y轴平移来实现了： 12345678.parent &#123; position: relative;&#125;.parent div &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 也可以使用 flexbox: 12345.parent &#123; display: flexbox; justify-content: center; flex-direction: column;&#125; 如果对于块级元素高度不是固定的，且不由内容决定，那么还可以这么设置： 12345678.parent &#123; position: relative;&#125;.parent div &#123; position: absolute; top: 30%; bottom: 30%; &#125; 水平垂直居中水平垂直居中就是把上面介绍的方法相结合就可以了。 知道宽高的盒子 123456789101112.parent &#123; position: realtive;&#125;.parent div &#123; width: 300px; height: 300px; posotion: absoltue; left: 50%; top: 50%; margin-left: -150px; margin-top: -150px;&#125; 不知道宽高的盒子 123456789.parent &#123; position: realtive;&#125;.parent div &#123; posotion: absoltue; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125; 使用 flexbox 12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"chrome开发者工具实用小技巧","slug":"chrome-devtools","date":"2017-03-30T10:20:21.000Z","updated":"2019-07-26T07:35:22.544Z","comments":true,"path":"2017/03/30/chrome-devtools/","link":"","permalink":"https://bubuzou.com/2017/03/30/chrome-devtools/","excerpt":"chrome 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 chrome 开发者工具都有哪些很常用或实用的功能。写这篇文章的时候，chrome的版本如下：","text":"chrome 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 chrome 开发者工具都有哪些很常用或实用的功能。写这篇文章的时候，chrome的版本如下： Elements面板篇 在 Elements 面板中，使用 Ctrl + F 打开搜索输入框，可以输入常规字符串或选择器来选择 HTML 元素。 在元素前面的小黑三角上用 Alt + 鼠标左键即可展开收起当前元素下的所有子元素。 css数值使用快捷键调整： Up / Down：增加减少1 Ctrl + Up / Ctrl + Down：增加减少100 Shift + Up / Shift + Down：增加减少10 Alt + Up / Alt + Down： 增加减少0.1 Up / Down 等同于鼠标滚轮 查看事件监听器。选中一个元素，然后点击 Event Listeners 面板，可以看到当前元素绑定的所有事件。然后找到任一事件类型下的 handler，右键单击选择 Show function definition 即可在 Source 面板中打开且定位到当前事件的处理函数的所在位置。 点击颜色方格会打开 chrome 的调色板。如下图第1块是着色和阴影选择器。第2块像笔那个按钮( toggle color picker )是取色器，蓝色的时候表示激活状态，就可以在页面任何一处进行取色；右边绿色圆形的是当前的颜色值，点击会将当前颜色值的代码复制到剪贴板；再右边的两块条分别表示色调选择器和不透明度选择器。第3块是表示当前颜色的显示模式，后边的按钮可以切换显示模式。第4块，Color Palettes 里分3小块，分别是：Material Design，一组符合 Material Design 规范的颜色；Page Colors，一组从页面的 CSS 自动生成的颜色；Custom，自定义颜色。第5块颜色面板，长按颜色块可以弹出10个当前颜色由浅至深的小色块，这个功能对于精确定制网页主题颜色非常有帮助。第6块是自定义颜色，这里可以添加删除自定义颜色，并且会永久保存在 chrome 的 DevTools 里，不会因为刷新或关闭浏览器而消失。第7块是生成了一些和页面相关的颜色值。 可视化 Shadow DOM。在 dom 元素列表中，都是我们写的看得见的元素。其实在构建 dom 的时候，也存在一部分东西是我们没写的，但是实际存在而被浏览器隐藏起来的元素。如果想看到这些元素就可以通过勾选 Settings -&gt; Preferences -&gt; Elements 下的 Show user agent shadow DOM 来显示这样构建的元素。这样一来就可以很好的这些元素的样式了。 给元素添加状态。元素有4种用户行为状态：:active、:hover、:focus、:visited。可以通过2中方式主动触发用户行为。选中一个元素，然后右键点击选中一个状态即可，如果有设置对于的样式，就可以看到区别。另外一种方式是在 Styles面板中进行设置。 使用 Tab 键可以在 CSS 样式规则中进行遍历选定，选定的目标包括：选择器、属性和属性值。如果想跳回上一个目标，使用 Shift + Tab。但是再使用快捷键切换选定之前需要先让光标在 Styles 面板，处于输入状态即可。 Console面板篇 使用 $0-$4 选择元素。$0 返回最后一次选择的元素，$1 返回仅在最后一次之前选择的元素，以此类推。$(selector) 返回带有指定 CSS 选择器的第一个DOM元素的引用。$$(selector) 返回 CSS 选择所有匹配的元素数组。 如果页面使用了类 `Jquery` 库，则 `$(selector)` 功能将被覆盖， `$` 将与该库的实现对应。 一些实用的方法: console.log()、console.info()、console.warn()、console.error()打印不同的状态信息 使用CSS设置控制台输出样式，利用CSS格式说明符%c。 copy(object)，将指定对象的字符串表示复制到剪贴板。 getEventListeners(object)，返回一个在指定元素上绑定的所有事件监听器的数组。但是这里看不了事件的处理函数，也没有像 Event Listeners 面板那边 show function definition 那样的功能。 inspect(elem)， 跳转到 Elements 面板的指定元素节点 console.time(str) 和 console.timeEnd(str) 返回这中间间隔的时间。下图的 4.24e+3ms 是数字的科学计数法表示，表示的实际值是：4.24*10*10*10ms，即4.24秒。 Sources面板篇 Ctrl + Shift + F，根据文件内容查找所有站内资源文件，返回找出匹配的文件内容。这个功能很好用。比如我在别人的站点看到一个效果，但是不知道写到哪个文件里了，这个时候我就可以根据关键的 className 或者 id 把这个文件找出来。 Ctrl + P，根据文件名查找所有站内资源文件。 漂亮打印。对于 Sources 里的资源文件，可以将杂乱的或是压缩过的内容按照一定的缩进和换行规则进行打印输出。 在 Sources 面板中找到图片资源，然后在图片上右键即可获取图片的 Data URI。 使用 console.dir( ele ) 将 DOM 元素格式化为 JavaScript 对象 在 Sources 面板编辑文件小技巧 使用 Ctrl + p 打开输入框输入 :20:30 回车后，光标位置将跳转到当前文件的第20行第30列 使用使用 Alt + - 和 Alt + = 可以在上一个鼠标位置和下一个鼠标位置之间跳转 使用 Ctrl + 鼠标左键可以添加多个光标输入位置 使用 Alt + 鼠标拖动可以拉出一块矩形选区 参考文章 chrome-devtools","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://bubuzou.com/tags/chrome/"}]},{"title":"CSS特性检测@supports与Modernizr","slug":"detect-css-property","date":"2017-03-13T04:20:21.000Z","updated":"2019-07-26T07:37:58.588Z","comments":true,"path":"2017/03/13/detect-css-property/","link":"","permalink":"https://bubuzou.com/2017/03/13/detect-css-property/","excerpt":"什么是 CSS 特性检测？我们知道，前端技术日新月异的今天，各种新技术新属性层出不穷。在 CSS 层面亦不例外。 一些新属性能极大提升用户体验以及减少工程师的工作量，并且在当下的前端氛围下： 很多实验性功能未成为标准却被大量使用； 需要兼容多终端，多浏览器，而各浏览器对某一新功能的实现表现的天差地别； 所以有了优雅降级和渐进增强的说法，在这种背景下，又想使用新的技术给用户提供更好的体验，又想做好回退机制保证低版本终端用户的基本体验，CSS 特性检测就应运而生了。 CSS 特性检测就是针对不同浏览器终端，判断当前浏览器对某个特性是否支持。运用 CSS 特性检测，我们可以在支持当前特性的浏览器环境下使用新的技术，而不支持的则做出某些回退机制。 本文将主要介绍两种 CSS 特性检测的方式： @supports modernizr 用 javascript 进行特性检测","text":"什么是 CSS 特性检测？我们知道，前端技术日新月异的今天，各种新技术新属性层出不穷。在 CSS 层面亦不例外。 一些新属性能极大提升用户体验以及减少工程师的工作量，并且在当下的前端氛围下： 很多实验性功能未成为标准却被大量使用； 需要兼容多终端，多浏览器，而各浏览器对某一新功能的实现表现的天差地别； 所以有了优雅降级和渐进增强的说法，在这种背景下，又想使用新的技术给用户提供更好的体验，又想做好回退机制保证低版本终端用户的基本体验，CSS 特性检测就应运而生了。 CSS 特性检测就是针对不同浏览器终端，判断当前浏览器对某个特性是否支持。运用 CSS 特性检测，我们可以在支持当前特性的浏览器环境下使用新的技术，而不支持的则做出某些回退机制。 本文将主要介绍两种 CSS 特性检测的方式： @supports modernizr 用 javascript 进行特性检测 CSS @supports传统的 CSS 特性检测都是通过 javascript 实现的，但是未来，原生 CSS 即可实现。CSS @supports 通过 CSS 语法来实现特性检测，并在内部 CSS 区块中写入如果特性检测通过希望实现的 CSS 语句。 123@supports &lt;supports_condition&gt; &#123; /* specific rules */&#125; 举个例子： 12345678div &#123; position: fixed;&#125;@supports (position:sticky) &#123; div &#123; position:sticky; &#125;&#125; 上面的写法，首先定义了 div 的 position: fixed ，紧接着下面一句 @supports (position:sticky) 则是特性检测括号内的内容，如果当前浏览器支持 @supports 语法，并且支持 position:sticky 语法，那么 div 的 则会被设置为 position:sticky 。 我们可以看到，@supports 语法的核心就在于这一句：@supports (...) &#123; &#125; ，括号内是一个 CSS 表达式，如果浏览器判断括号内的表达式合法，那么接下来就会去渲染括号内的 CSS 表达式。除了这种最常规的用法，还可以配合其他几个关键字： @supports notnot 操作符可以放在任何表达式的前面来产生一个新的表达式，新的表达式为原表达式的值的否定。看个例子： 12345@supports not (background: linear-gradient(90deg, red, yellow)) &#123; div &#123; background: red; &#125;&#125; 因为添加了 not 关键字，所以与上面第一个例子相反，这里如果检测到浏览器不支持线性渐变 background: linear-gradient(90deg, red, yellow) 的语法，则将 div 的颜色设置为红色 background: red 。 @supports and用 and 操作符连接两个原始的表达式。只有两个原始表达式的值都为真，生成的表达式才为真，反之为假。来看个例子： 1234567891011p &#123; overflow: hidden; text-overflow: ellipsis;&#125;@supports (display:-webkit-box) and (-webkit-line-clamp:2) and (-webkit-box-orient:vertical) &#123; p &#123; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; &#125;&#125; 上面同时，检测 @supports (display:-webkit-box) and (-webkit-line-clamp:2) and (-webkit-box-orient:vertical) 了三个语法，如果同时支持，则设定三个 CSS 规则。这三个语法必须同时得到浏览器的支持，如果表达式为真。 @supports or@supports or 表示只要表达式里存在一个是真的，那么这个表达式就是返回真。 123456@supports (background:-webkit-linear-gradient(0deg, yellow, red)) or (background:linear-gradient(90deg, yellow, red))&#123; div &#123; background:-webkit-linear-gradient(0deg, yellow, red); background:linear-gradient(90deg, yellow, red) &#125;&#125; @supports的兼容性 这仍是一个实验中的功能，虽然大部分浏览器都已经支持了，但是目前看来，即是在移动端想要全部兼容仍需要等待一段时间。但是我们已经可以开始使用起来了，使用 @supports 实现渐进增强的效果。 渐进增强（`progressive enhancement`）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验： CSS.supports()谈到了 @supports，就有必要再说说 CSS.supports() 。它是作为 @supports 的另一种形式出现的，我们可以使用 javascript 的方式来获得 CSS 属性的支持情况。可以打开控制台，输入 CSS.supports 试试： 如果没有自己实现 CSS.supports 这个方法，输出上述信息，表示浏览器是支持 @supports 语法的，使用如下： 那它有什么用呢？如果你的页面需要动态添加一些你不确定哪些浏览器支持的新的属性，那它也许会派上用场。以及，它可以配合我们下文即将要讲的 modernizr 。 modernizr上面介绍了 CSS 方式的特性检测，在以前，通常是使用 javascript 来进行特性检测的，其中 modernizr 就是其中最为出色的佼佼者。modernizr（戳我查看 Github ）是一个开源的 javascript 库。有着将近 2W 的 star ，其优秀程度可见一斑。简单看看使用方法，假设页面已经引用了 modernizr ，语法如下： 123456789101112// Listen to a test, give it a callbackModernizr.on(&#x27;testname&#x27;, function( result ) &#123; if (result) &#123; console.log(&#x27;The test passed!&#x27;); &#125; else &#123; console.log(&#x27;The test failed!&#x27;); &#125;&#125;); // 或者是类似 CSS.supports()Modernizr.testAllProps(&#x27;background&#x27;, &#x27;linear-gradient(90deg, #888, #ccc)&#x27;); // true 特性检测原理如果嫌引入整一个 Modernizr 库太大，页面又不支持 @supports ，其实我们自己用简单的 javascript 实现也非常方便简单。想要知道浏览器支持多少 CSS 属性，可以在调试窗口试试： 上面图片截取的只是打印出来的一小部分。如果我们要检测某个属性样式是否被支持，在任意的 element.style 检测它是否存在即可。当然，元素可能有 background 属性，但是不支持具体的 linear-gradinet() 属性值。这个时候该如何检测呢？只需要将具体的值赋值给某一元素，再查询这个属性值能否被读取。 1234567var root = document.documentElement;root.style.backgroundImage = &#x27;linear-gradient(90deg, #888, #ccc)&#x27;;if(root.style.backgroundImage) &#123; // 支持&#125; else &#123; // 不支持&#125; 各种方式间的优劣 原生的 @supports 的性能肯定是最好的，而且无需引入外部 javascript ，首推这个，但是无奈兼容问题，目前来看不是最好的选择。 Modernizr 功能强大，兼容性好，但是需要引入外部 javascript，多一个 http 请求，如果只是进行几个特性检测，有点杀鸡用牛刀的感觉。 针对需要的特性检测，使用 javascript 实现一个简单的函数，再把上面用到的方法封装一下： 1234567891011121314151617181920212223242526/** * 用于简单的 CSS 特性检测 * @param [String] property 需要检测的 CSS 属性名 * @param [String] value 样式的具体属性值 * @return [Boolean] 是否通过检查 */function cssTest(property, value) &#123; // 用于测试的元素，隐藏在页面上 var ele = document.getElementById(&#x27;test-display-none&#x27;); // 只有一个参数的情况 if(arguments.length === 1) &#123; if(property in ele.style) &#123; return true; &#125; // 两个参数的情况 &#125;else if(arguments.length === 2)&#123; ele.style[property] = value; if(ele.style[property]) &#123; return true; &#125; &#125; return false;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"background属性","slug":"background-property","date":"2017-03-10T01:20:21.000Z","updated":"2019-12-31T01:53:13.002Z","comments":true,"path":"2017/03/10/background-property/","link":"","permalink":"https://bubuzou.com/2017/03/10/background-property/","excerpt":"一个元素可以使用 background 来设置他的背景特性，background 是一个复合的属性，包括了 8 个子属性。 background-colorbackground-color 用于定义元素的背景颜色，值可以是具体的十六进制颜色值 #dedd6f，可以是 rgb 颜色值rgb(222, 221, 111) ，或者直接用颜色对应的英文表示 gray ，甚至是用关键字 transparent 来表示透明的颜色。 123456789.yellow &#123; background-color: #dedd6f;&#125;.gray &#123; background-color: gray;&#125;.tran &#123; background-color: transparent;&#125;","text":"一个元素可以使用 background 来设置他的背景特性，background 是一个复合的属性，包括了 8 个子属性。 background-colorbackground-color 用于定义元素的背景颜色，值可以是具体的十六进制颜色值 #dedd6f，可以是 rgb 颜色值rgb(222, 221, 111) ，或者直接用颜色对应的英文表示 gray ，甚至是用关键字 transparent 来表示透明的颜色。 123456789.yellow &#123; background-color: #dedd6f;&#125;.gray &#123; background-color: gray;&#125;.tran &#123; background-color: transparent;&#125; background-imagebackground-image 用来定义元素的背景图像，可以通过 url(...) 来引入图片，也可以设置为 none 表示背景为空，还可以设置多张背景且中间用逗号隔开，写到前面的图片将会覆盖写到后面的。 1234567891011.url &#123; background-image: url(../images/cow.png)&#125;.none &#123; background-image :none;&#125;.muliple &#123; background-image: url(../images/penguin.jpg), url(../images/cow.png); background-repeat: no-repeat; background-size: 81%;&#125; background-repeatbackground-repeat 定义了背景图像将以何种方式进行平铺。必须先指定 background-image 属性。如果设置2个属性，那么第一个用于横向，第二个作用于纵向。如果提供一个参数，则用于横向和纵向。其中，repeat-x 和 repeat-y 只能单独使用。 repeat-x：横向平铺 repeat-y：纵向平铺 repeat：横向和纵向都平铺 no-repeat：不平铺 round：背景图像自动缩放直至适应填充满整个容器 space: 背景图像按照相同的间距平铺直至适应填充满整个容器或某个方向 123456789101112131415161718192021222324.repeat-x &#123; background-repeat: repeat-x;&#125;.repeat-y &#123; background-repeat: repeat-y;&#125;.repeat &#123; background-repeat: repeat;&#125;.no-repeat &#123; background-repeat: no-repeat;&#125;.round &#123; background-repeat: round;&#125;.space &#123; background-repeat: space;&#125;.round-space &#123; background-repeat: round space;&#125;.space-round &#123; background-repeat: space round;&#125; background-sizebackground-size 定义了背景图像的尺寸，可以用关键字来定义。contain 按照图片比例将背景图像等比缩放到完全适应容器，而 cover 是图像缩放到完全覆盖区域为止。也可以用长度值或者百分比值来设置。如果设置了2个参数，则分别表示横向和纵向。如果只设置了一个值，那表示横向宽度，纵向为 auto. 12345678910111213.contain &#123; background-size: contain;&#125;.cover &#123; background-size: cover;&#125;.size-demo .w100 &#123; background-size: 100px; background-image: url(../images/cow.png);&#125;.rate5080 &#123; background-size: 50% 80%;&#125; background-positionbackground-positioin 定义了背景图像在容器里的显示位置，可以用关键字 top、left、right、bottom、center 等来表示，当用1个参数的时候设置的时候，另一个方向默认是 center。当用2个关键字来设置的时候，和书写顺序无关。另外还可以用具体数值和百分比来设置，用这些方式来设置的时候第一个参数表示横向，第二个是纵向。如果只有一个参数，则表示横向，纵向默认是居中。 123456789101112.position-demo .top &#123; background-position: top;&#125;.position-demo .bottom-right &#123; background-position: bottom right;&#125;.position-demo .w20h40 &#123; background-position: 20px 40px;&#125;.position-demo .p20 &#123; background-position: 20%;&#125; background-attachmentbackground-attachment 控制背景图像在可视区或元素内如何滚动。fixed 是相对可视区域进行定位，背景图像相对于可视区域进行定位，不随元素滚动而滚动。scroll 背景图像将在元素区域内固定，不会随着元素内容的滚动而滚动。local 背景图像相对于元素内容占据的区域进行定位，当元素内容滚动的时候，背景图像随之滚动。 12345678910.attachment-demo .fixed &#123; background-attachment: fixed; background-position: bottom;&#125;.attachment-demo .scroll &#123; background-attachment: scroll;&#125;.attachment-demo .local &#123; background-attachment: local;&#125; background-originbackground-origin 规定了背景图像相对于盒模型的哪个区域来定位，对背景颜色无效。content-box 相对于内容区域定义，padding-box 相对于内边距区域定位，border-box 相对边框区域定位 123456789.origin-demo .content &#123; background-origin: content-box;&#125;.origin-demo .padding &#123; background-origin: padding-box;&#125;.origin-demo .border &#123; background-origin: border-box;&#125; background-clipbackground-clip 指定背景向外裁剪的区域。padding-box 从 padding 区域（不含 padding ）开始向外裁剪背景。border-box 从 border 区域（不含 border ）开始向外裁剪背景。content-box 从 content 区域开始向外裁剪背景。 123456789.clip-demo .content &#123; background-clip: content-box;&#125;.clip-demo .padding &#123; background-clip: padding-box;&#125;.clip-demo .border &#123; background-clip: border-box;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"高阶函数","slug":"higher-order-functions","date":"2016-12-06T02:12:21.000Z","updated":"2019-04-16T12:19:18.329Z","comments":true,"path":"2016/12/06/higher-order-functions/","link":"","permalink":"https://bubuzou.com/2016/12/06/higher-order-functions/","excerpt":"高阶函数是指满足下列条件之一的函数： 函数可以作为参数进行传递函数可以作为返回值进行输出JavaScript 语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当做参数传递，还是让函数的执行结果返回给另外一个函数，这两种情形都有很多应用场景。 函数作为参数传递把函数当做参数进行传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来就可以分离业务代码中变化和不变的部分。","text":"高阶函数是指满足下列条件之一的函数： 函数可以作为参数进行传递函数可以作为返回值进行输出JavaScript 语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当做参数传递，还是让函数的执行结果返回给另外一个函数，这两种情形都有很多应用场景。 函数作为参数传递把函数当做参数进行传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来就可以分离业务代码中变化和不变的部分。 回调函数 在 ajax 异步请求的应用中，回调函数的使用非常频繁。当我们想在 ajax 请求返回之后做些事情，但又并不知道请求返回的确切时间时，最常见的方案是把 callback 函数当做参数传入发起的 ajax 请求的方法中，待请求完成之后执行callback 函数： 1234567var getUserInfo = function( userId, callback ) &#123; $.ajax( &#x27;http://bubuzou.com/getUserInfo?&#x27; + userId, function( data ) &#123; if ( typeof callback === &#x27;function&#x27;) &#123; callback( data ); &#125; &#125;); &#125;; 再来看一个例子，假设有这样一个需求，需要创建 100 个 div元素，同时把他们隐藏起来，那么可以看到下面这种实现： 123456789var appendDiv = function() &#123; for( var i = 0; i &lt; 100; i++ ) &#123; var div = document.createElement( &#x27;div&#x27; ); div.innerHTML = i; document.body.appendChild( div ); div.style.display = &#x27;none&#x27;; &#125;&#125;;appendDiv(); 把 div.style.display = &#39;none&#39;的逻辑硬编码在 appendDiv 里显然是不合理的，appendDiv 未免有点个性化，成为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏。于是我们把这段代码抽离出来，用回调函数的形式传入 appendDiv 方法： 12345678910111213var appendDiv = function( callback ) &#123; for( var i = 0; i &lt; 100; i++ ) &#123; var div = document.createElement( &#x27;div&#x27; ); div.innerHTML = i; document.body.appendChild( div ); if ( typeof callback === &#x27;function&#x27;) &#123; callback( div ); &#125; &#125;&#125;; appendDiv(function( node ) &#123; node.style.display = &#x27;none&#x27;;&#125;); Array.prototype.sort Array.prototype.sort 接受一个函数作为参数，这个函数里面封装了数组元素的排序顺序。我们的目的是对数组进行排序，这是不变的部分；但用什么规则去排序这是可变的部分。 1234// 从小到大排序[3, 9, 8, 5].sort(function(a, b) &#123; return a - b;&#125;); 函数作为返回值输出 判断数据的类型 判断一个数据是否是数组，在以往的实现当中，可以基于鸭子类型的概念来判断，比如这个数据有没有 length 属性，有没有sort 方法等。但更好的方法是用 Object.prototype.toString 来计算。根据Object.prototype.toString.call( [1, 2, 3] ) 总是返回 ’[object Array]’ ，Object.prototype.toStrng.call( ‘str’ ) 也总是返回 ’[object Array]’ 得出， 它总是会返回一个类似结构的字符串。于是用循环语句来批量注册类型判断的函数： 123456789101112131415161718192021222324252627282930 var Type = &#123;&#125;; for ( var i = 0, type; type = [&#x27;String&#x27;, &#x27;Array&#x27;, &#x27;Number&#x27;][i++]; ) &#123; (function( type ) &#123; Type[ &#x27;is&#x27; + type ] = function( obj ) &#123; return Object.prototype.toString.call( obj ) === &#x27;[object &#x27; + type + &#x27;]&#x27;; &#125; &#125;)( type ); &#125; Type.isArray( [] ); // true Type.isString( &#x27;&#x27; ); // true ```` - getSingle 下面是一个单例模式的例子： ``` js var getSingle = function( fn ) &#123; var ret; return function() &#123; return ret || ( ret = fn.apply( this, arguments )); &#125;; &#125;; // 来看看这个单例的效果 var getScript = getSingle(function() &#123; return document.createElement( &#x27;script&#x27; ); &#125;); var script1 = getScript(); var script2 = getScript(); console.log( script1 === script2 ); // true 高阶函数实现AOPAOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来后，再通过“动态植入”的方式掺入业务逻辑模块中。这样做的好处是首先保证了业务逻辑模块的纯洁和高内聚性，其实是可以很方便的复用这些日志统计等功能模块。在 JavaScript 中，我们可以通过Function.prototype 来实现 AOP: 123456789101112131415161718192021222324Function.prototype.before = function( beforeFn) &#123; var _self = this; return function() &#123; beforeFn.apply( this, arguments ); return _self.apply( this, arguments ); &#125;&#125;;Function.prototype.after = function( afterFn ) &#123; var _self = this; return function() &#123; var ret = _self.apply( this, arguments ); afterFn.apply( this, arguments ); return ret; &#125;&#125;;var func = function() &#123; console.log( 2 );&#125;;func = func.before(function() &#123; console.log( 1 );&#125;).after(function() &#123; console.log( 3 );&#125;);func(); // 换行打印：1 2 3 高阶函数的其他应用 currying currying 的概念最早由俄国数学家 Moses Schoofinkel 发明，而后由著名的数理逻辑学家 Haskell Curry 将其丰富和发展，currying 由此得名。 currying 又称部分求值。这里我们讨论的是函数柯里化( function currying )。一个柯里化函数首先会接受一些参数，接受了这些参数会后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正求值的时候，之前传入的所有参数都会被一次性用于求值。来看一个例子： 假设我们要编写一个计算每月开销的函数。在每天结束之前，我们都要记录几天花掉了多少钱。 12345678var monthCost = 0;var cost = function( money ) &#123; monthCost += money;&#125;;cost( 100 ); 第一天cost( 200 ); 第二天cost( 300 ); 第三天console.log( monthCost ); // 600 通过这段代码，我们可以看到每天都花了多少钱，但是如果我们只想知道每个月的消费如何的话，那就没必要计算每天的花费了。 123456789101112131415161718var cost = (function() &#123; var args = []; return function() &#123; if ( arguments.length === 0 ) &#123; var money = 0; for ( var i = 0, l = args.length; i &lt; l; i++ ) &#123; money += args[i]; &#125; return money; &#125; else &#123; [].push.apply( args, arguments ); &#125; &#125;&#125;)();cost( 100 );cost( 200 );cost( 300 );console.log( cost() ); // 600 接下来编写一个通用的柯里化函数： 12345678910111213141516171819202122232425var currying = function( fn ) &#123; var args = []; return function() &#123; if ( arguments.length === 0 ) &#123; return fn.apply( this, args ); &#125; else &#123; [].push.apply( args, arguments ); return arguments.callee; &#125; &#125;&#125;;var cost = (function() &#123; var money = 0; return function() &#123; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; money += arguments[i]; &#125; return money; &#125;&#125;)();var cost = currying( cost );cost( 100 );cost( 200 );cost( 300 );console.log( cost() ); // 600 uncurrying uncurrying 是反柯里化，大概意思是扩大函数的应用范围，将本来只有特定对象才能使用的方法，扩展到更多的对象。 比如我们常常让类数组对象去借用 Array.prototype 的方法： 1234(function() &#123; Array.prototype.push.call( arguments, 4 ); console.log( arguments ); // [1, 2, 3, 4] &#125;)(1, 2, 3); uncurrying第一种实现： 123456789101112131415161718192021222324Function.prototype.uncurrying = function() &#123; var self = this; return function() &#123; var obj = Array.prototype.shift.call( arguments ); return self.apply( obj, arguments ); &#125;;&#125;;for ( var i = 0, fn, ary = [&#x27;push&#x27;, &#x27;shift&#x27;, &#x27;forEach&#x27;]; fn = ary[i++]; ) &#123; Array[ fn ] = Array.prototype[ fn ].uncurrying(); &#125;var obj = &#123; &quot;length&quot;: 3, &quot;0&quot;: 1, &quot;1&quot;: 2, &quot;2&quot;: 3&#125;;Array.push( obj, 4);console.log( obj.length ); // 4var first = Array.shift( obj ); console.log( first ); // 1console.log( obj ); // &#123;0:2, 1:3, 2:4, length: 3&#125;Array.forEach( obj, function( i, n ) &#123; console.log( n ); // 分别输出：0, 1, 2&#125;); uncurrying的第二种实现： 123456Function.prototype.uncurrying = function() &#123; var self = this; return function() &#123; return Function.prototype.call.apply( self, arguments ); &#125;&#125;; 函数节流 在 JavaScript 中，大部分的函数都是由用户主动调动触发的。但是也存在少数情况，这些情况下函数的触发并不是又用户直接控制的。这个时候函数就有可能被频繁地调用，而造成大的性能问题。以下几个场景函数将被频繁调用：给 window 绑定了onresize 事件的时候，如果存在 DOM 相关的操作，那这个时候是非常耗性能的，严重的时候浏览器可能会卡顿；mousemove 事件，如果给某个元素绑定了拖拽事件，那么该函数也会被频繁的触发；在比如上传一个文件的时候，可能需要频繁的通知进度信息等。 函数节流就是为了避免函数被频繁地调用而存在的一种解决方案，从而优化性能。通常是用 setTimeout 来实现： 123456789101112131415161718192021222324var throttle = function( fn, interval ) &#123;var _self = fn, timer, firstTime = true; return function() &#123; var args = arguments, _me = this; if ( firstTime ) &#123; _self.apply( _me, args ); return firstTime = false; &#125; if ( timer ) &#123; return false; &#125; timer = setTimeout(function() &#123; clearTimeout( timer ); timer = null; _self.apply( _me, args ); &#125;, interval || 500 ); &#125;&#125;;window.onresize = throttle(function() &#123; console.log( 1 );&#125;, 500); 分时函数 上面我们介绍了一种解决函数被频繁调用的方法。但是有时候，用户确实有这种需求，比如需要在短时间内把 1000 个 qq 好友渲染到列表上，这个时候就可能会很卡。但是如果把 1000ms 创建 1000 个节点，改成每 200ms 创建 8 个节点。这个时候就避免这种问题。 分时函数接受 3 个参数：第一个是创建节点的时候需要用到的数据，第二个是封装了创建节点的函数，第三个是每一批创建的节点数量。 12345678910111213141516171819var timeChunk = function( ary, fn, count ) &#123; var obj, t, start; start = function() &#123; for ( var i = 0; i &lt; Math.min( count || 1, ary.length ); i++ ) &#123; var obj = ary.shift(); fn( obj ); &#125; &#125;; return function() &#123; t = setInterval(function() &#123; if ( ary.length === 0 ) &#123; // 如果全部节点都已经创建好 clearInterval( t ); &#125; start(); &#125;, 200); &#125;;&#125;; 分时函数有了，现在我们来测试一下。假设有 1000 个好友，利用 timeChunk 函数，每批往页面上渲染 8 个： 12345678910var ary = [];for ( var i = 0; i &lt;= 1000; i++ ) &#123; ary.push( i );&#125;var renderFriendList = timeChunk( ary, function( n ) &#123; var div = document.createElement( &#x27;div&#x27; ); div.innerHTML = n; document.body.appendChild( div );&#125;, 8);renderFriendList(); 惰性加载函数 在 web 开发的过程中，因为浏览器之间的实现差异，一些嗅探工作总是避免不了的。比如我们需要一个能在各个浏览器都能通用的事件绑定函数 addEvent，常见的写法如下： 12345678var addEvent = function( elem, type, handler ) &#123; if ( window.addEventListener ) &#123; return elem.addEventListener( type, handler, false ); &#125; if ( window.attachEvent ) &#123; return elem.attachEvent( &#x27;on&#x27; + type, handler ); &#125;&#125;; 这种写法的缺点是每次调用函数都必须执行里面的if判断，虽然开销不大，但是有办法能避免这种操作： 123456789101112var addEvent = (function() &#123; if ( window.addEventListener ) &#123; return function( elem, type, handler ) &#123; elem.addEventListener( type, handler, false ); &#125; &#125; if ( window.attachEvent ) &#123; return function( elem, type, handler ) &#123; elem.attachEvent( &#x27;on&#x27; + type, handler ); &#125; &#125;&#125;)(); 把嗅探的操作提前到代码加载之前，在代码加载的时候就即可进行一次判断，以便让 addEvent返回一个正确的事件绑定函数。 但是这种写法还是存在缺点的，如果我们从头到尾都不需要进行事件绑定，那么前面那次的嗅探动作就显得多余了。 第三种方案是惰性载入函数方案，第一次进入 addEvent 函数的时候会重写事件绑定函数，在下次进去的时候就会直接执行事件绑定了。 12345678910111213var addEvent = function( elem, type, handler ) &#123; if ( window.addEventListener ) &#123; addEvent = function( elem, type, handler ) &#123; elem.addEventListener( type, handler, false ); &#125; &#125; if ( window.attachEvent ) &#123; addEvent = function( elem, type, handler ) &#123; elem.attachEvent( &#x27;on&#x27; + type, handler ); &#125; &#125; addEvent( elem, type, handler );&#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"闭包","slug":"closure","date":"2016-11-30T13:20:21.000Z","updated":"2019-01-08T01:38:23.670Z","comments":true,"path":"2016/11/30/closure/","link":"","permalink":"https://bubuzou.com/2016/11/30/closure/","excerpt":"对于 JavaScript 的程序员来说，闭包是一个难懂又必须征服的概念。在介绍闭包前，先来看看和闭包息息相关的变量作用域和变量的生存周期。 变量的作用域变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字 var 来声明此变量，那么它就是局部变量，如果没有 var 那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用 var 将变量声明在函数的外面。 12345var name = &#x27;bubuzou.com&#x27;; // 全局变量function func() &#123; var name = &#x27;bubuzou&#x27;; // 局部变量 age = 12; // 全局变量，建议少用这种全局变量的定义方式&#125;","text":"对于 JavaScript 的程序员来说，闭包是一个难懂又必须征服的概念。在介绍闭包前，先来看看和闭包息息相关的变量作用域和变量的生存周期。 变量的作用域变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字 var 来声明此变量，那么它就是局部变量，如果没有 var 那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用 var 将变量声明在函数的外面。 12345var name = &#x27;bubuzou.com&#x27;; // 全局变量function func() &#123; var name = &#x27;bubuzou&#x27;; // 局部变量 age = 12; // 全局变量，建议少用这种全局变量的定义方式&#125; 在 JavaScript 中，函数可以用来创造函数作用域。函数内部可以看到外面的变量，而外面看不到函数里的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，直到搜索到全局变量为止。 123456789101112var a = 1;var func1 = function()&#123; var b = 2; var func2 = function()&#123; var c = 3; console.log( b ); // 2 console.log( a ); // 1 &#125; func2(); console.log( c ); // 报错：c is not defined&#125;;func1(); 那么能不能从函数外部来访问局部变量呢？答案是可以。 1234567var func = function() &#123; var number = 6; return function() &#123; return number; &#125; &#125;;console.log( func()() ); // 6 变量的生存周期全局变量的生存周期是永久的，除非我们主动的销毁这个全局变量。而对于局部变量来说，当退出函数时，这些局部变量就失去了生存的环境，所以会随着函数调用的结束而被销毁。那么是否可以让局部变量在函数调用结束的时候不被销毁呢？来看下面这个例子： 1234567891011var func = function() &#123; var a = 1; return function() &#123; a++; console.log( a ); &#125; &#125;;var f = func();f(); // 2f(); // 3f(); // 4 从上面这个输出结果，我们可以看到局部变量 a 并没有随着 f() 的调用而被销毁。这是因为全局变量 f 保存着对 func 里面匿名函数的引用。而这个匿名函数是可以访问到局部变量 a 的，所以自然 a 也被保存下来了。所以这种情况下局部变量的生存周期就得以延续。上面这个匿名函数其实就是一个闭包。再来看一个闭包的经典应用。 1234567// 假设有5个divvar nodes = document.getElementsByTagName( &#x27;div&#x27; );for ( var i = 0, l = nodes.length; i &lt; l; i++ ) &#123; nodes[i].onclick = function() &#123; console.log( i ); &#125;&#125; 当真正执行这段代码的时候，发现无论点击那个 div，最后打印的结果都是 4。这是因为 onclick 事件是异步触发的，当事件触发的时候，for 循环早已经结束，此时变量 i 的值已经是 4。解决方案可以是用闭包把每次的 i 都保存起来： 1234567for ( var i = 0, l = nodes.length; i &lt; l; i++ ) &#123; (function( i ) &#123; nodes[i].onclick = function() &#123; console.log( i ); &#125; &#125;)( i );&#125; 同理，我们编写一段代码用来判断对象类型： 12345678910var Type = &#123;&#125;;for ( var i = 0, type; type = [ &#x27;String&#x27;, &#x27;Array&#x27;, &#x27;Number&#x27; ][ i++ ]; ) &#123; (function( type ) &#123; Type[ &#x27;is&#x27; + type ] = function( obj ) &#123; return Object.prototype.toString.call( obj ) === &#x27;[object &#x27; + type + &#x27;]&#x27;; &#125; &#125;)( type );&#125;Type.isArray( [] ); // trueType.isString( &#x27;str&#x27; ); // true 什么是闭包官方的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因为这些变量也是该表达式的一部分。这个概念不好理解，我们可以简单得理解成闭包就是能够访问函数内部变量的函数。 闭包的作用 可以在函数外部访问在函数内部定义的局部变量 延续局部变量的生存周期 封装变量 闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的函数： 12345678var mult = function() &#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return a;&#125;;mult(2, 3, 4); // 24 mult 函数接受一些 Number 类型的参数，并且返回他们的乘积。现再我们觉得对于那些相同参数来说，每次再进行计算是一种浪费，所以我们决定加入缓存机制来提高函数性能： 123456789101112var cache = &#123;&#125;;var mult = function() &#123; var args = Array.prototype.join.call( arguments, &#x27;&#x27; ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return cache[ args ] = a;&#125;; 我们看到 cache 这个变量仅仅在 mult 函数中被使用，所以为了避免 cache 污染全局变量，我们将它放到 mult 函数里面 1234567891011121314var mult = (function() &#123; var cache = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call( arguments, &#x27;&#x27; ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return cache[ args ] = a; &#125;&#125;)(); 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有利于代码的复用，如果这些小函数有一个良好的命名，那么它们本身就起到了一个很好的注释作用。 1234567891011121314151617var mult = (function() &#123; var cache = &#123;&#125;; var calculate = function() &#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return a; &#125;; return function() &#123; var args = Array.prototype.join.call( arguments, &#x27;&#x27; ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; return cache[ args ] = calculate.apply( null, arguments ); &#125;&#125;)(); 闭包与内存管理局部变量本来应该在函数退出的时候就被结束引用，但如果局部变量被封装在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上来看，闭包确实会使一些数据无法被及时销毁。如果将来需要回收这些变量，我们可以手动把这些变量设为 null。跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域中保存着一些 DOM 节点，这个时候就有可能造成内存泄露。在 IE9 之前的浏览器中，由于 BOM 和 DOM 中的对象是使用 C++ 对象以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数的垃圾收集机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。但我们只要把循环引用中的对象设为 null 即可解决这个问题。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"this、call和apply","slug":"this-call-apply","date":"2016-11-28T11:22:14.000Z","updated":"2019-03-29T02:31:00.239Z","comments":true,"path":"2016/11/28/this-call-apply/","link":"","permalink":"https://bubuzou.com/2016/11/28/this-call-apply/","excerpt":"this跟别的语言不同的是，JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this的指向除去不常用的 eval 和 with 语句的情况，具体到实际应用中，this 的指向大致可分为以下4种： 作为对象的方法调用 当作为对象的方法进行调用的时候，this 指向该对象： 12345678var obj = &#123; name: &#x27;bubuzou&#x27;, getName: function() &#123; console.log( this === obj ); // true console.log( this.name ); // &#x27;bubuzou&#x27; &#125;&#125;;obj.getName();","text":"this跟别的语言不同的是，JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this的指向除去不常用的 eval 和 with 语句的情况，具体到实际应用中，this 的指向大致可分为以下4种： 作为对象的方法调用 当作为对象的方法进行调用的时候，this 指向该对象： 12345678var obj = &#123; name: &#x27;bubuzou&#x27;, getName: function() &#123; console.log( this === obj ); // true console.log( this.name ); // &#x27;bubuzou&#x27; &#125;&#125;;obj.getName(); 作为普通函数调用 当函数不作为对象的属性进行调用的时候，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的JavaScript 里，这个全局对象是 window 对象。 123456789101112131415window.name = &#x27;bubuzou.com&#x27;;var getName = function() &#123; return this.name; &#125;;console.log( getName() ); // &#x27;bubuzou.com&#x27;// 或者window.name = &#x27;bubuzou.com&#x27;;var myObject = &#123; name: &#x27;bubuzou&#x27;, getName: function() &#123; return this.name; &#125;&#125;;var getName = myObject.getName;console.log( getName() ); // &#x27;bubuzou.com&#x27; 再来看一个实际的应用： 12345678910window.id = &#x27;bubuzou&#x27;;document.getElementById( &#x27;div&#x27; ).onclick = function() &#123; var that = this; console.log( this.id ); // &#x27;div&#x27; var callback = function() &#123; console.log( this.id ); // &#x27;bubuzou&#x27; console.log( that.id ); // &#x27;div&#x27; &#125;; callback();&#125;; 在 `ECMAScript 5` 的 `strict` 模式下，这种情况的 `this` 已经被规定不会指向全局对象了，而是 `undefined` 1234(function func() &#123; &quot;use strict&quot; console.log( this ); // undefined&#125;)(); 构造器调用 JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。除了宿主提供的一些内置函数外，大多数的 JavaScript 函数都可以当做内置构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就是指向返回的这个对象。 12345var MyClass = function() &#123; this.name = &#x27;bubuzou.com&#x27;&#125;;var obj = new MyClass();console.log( obj.name ); // &#x27;bubuzou.com&#x27; 但是使用构造器调用需要注意一个问题，如果构造器显示的返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们所期待的 this: 12345678var MyClass = function() &#123; this.name = &#x27;bubuzou.com&#x27;; return &#123; name: &#x27;bubuzou&#x27; &#125;&#125;; var obj = new MyClass();console.log( obj.name ); // &#x27;bubuzou&#x27; Function.prototype.call 或 Function.prototype.apply 调用 跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 调用可以动态地改变传入函数的 this： 1234567891011var obj1 = &#123; name: &#x27;bubuzou.com&#x27;, getName: function() &#123; return this.name; &#125;&#125;;var obj2 = &#123; name: &#x27;bubuzou&#x27;&#125;;console.log( obj1.getName() ); // &#x27;bubuzou.com&#x27;console.log( obj1.getName.call( obj2 ) ); // &#x27;bubuzou&#x27; 丢失的thisdocument.getElementById 这个方法名有点长，所以我们会尝试用一个简单点的来替代： 1234var getId = function( id ) &#123; return document.getElementById( id );&#125;;getId( &#x27;div&#x27; ); 我们也许思考过为什么不能用下面的这个更简单的方式： 12var getId = document.getElementById;getId( &#x27;div&#x27; ); 当我们执行上面这段代码的时候，在 Chrome 浏览器中会抛出异常。这是因为许多浏览器引擎的 document.getElementById 方法的内部实现中需要用到 this。而这个 this 本来期望指向 document，当getElementById 方法作为 document 的属性来调用的时候，内部的 this 确实是指向 document 的。但当用getId 来引用 document.getElementById 之后，再调用 getId，此时就成了普通函数调用，函数内部的 this 指向了 window，而是不是原来的 document，所以会抛出异常。不过我们可以尝试用 apply 把 document 当做 this 传入 getId 函数： 1234567document.getElementById = (function( func ) &#123; return function() &#123; return func.apply( document, arguments ); &#125;&#125;)( document.getElementById );var getId = document.getElementById;console.log( getId( &#x27;div&#x27; ).id ); // &#x27;div&#x27; call和apply的区别两者的作用一模一样，区别只是传入的参数形式不一样。apply接受2个参数，第一个参数是指定了函数体内的 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以是一个数组也可以是一个类数组。 call 的参数就不固定了，但是第一个参数和 apply 是一样的，从第二个参数开始往后，每个参数被依次传入函数。 12345var func = function( a, b, c ) &#123; console.log( [a, b, c] ); &#125;;func.apply( null, [1, 2, 3] ); // [1, 2, 3]func.call( null, 1, 2, 3 ); // [1, 2, 3] 当调用一个函数的时候，JavaScript 的解释器并不会计较形参和实参在数量、类型和顺序上的区别，从这个意义上来说，apply 比 call 的使用率更高。但是如果我们明确指定参数的个数，也可以用 call 来传送参数。 如果第一个参数是 `null`，那么函数体内的 `this` 会指向默认的宿主对象，在浏览器中是 `window`，但如果是在严格模式下，则还是为 `null` call和apply的用途 改变 this 指向 call 和 apply 最常见的用途是改变函数内部的 this 指向： 123456789window.name = &#x27;bubuzou&#x27;;var obj = &#123; name: &#x27;bubuzou.com&#x27;&#125;;var getName = function() &#123; console.log( this.name );&#125;;getName(); // &#x27;bubuzou&#x27;getName.apply( obj ); // &#x27;bubuzou.com&#x27; Function.prototype.bind 大部分高级的浏览器都实现内置的 Function.prototype.bind ，用来指定函数内部的 this 指向，即使没有原生的Function.prototype.bind 实现，我们来模拟实现一个也不是难事： 12345678910111213Function.prototype.bind = function( context ) &#123; var self = this; return function() &#123; return self.apply( context, arguments ); &#125;&#125;;var obj = &#123; name: &#x27;bubuzou.com&#x27; &#125;;var func = function() &#123; console.log( this.name );&#125;.bind( obj );func(); // &#x27;bubuzou.com&#x27; 这是一个简化版的实现，我们可以实现得更复杂一点，使得可以往 func 函数中预先填入一些参数： 12345678910111213141516Function.prototype.bind = function() &#123; var self = this, context = [].shift.call( arguments ), args = [].slice.call( arguments ); return function() &#123; return self.apply( context, [].concat.call( args, [].slice.call( arguments ))); &#125;&#125;;var obj = &#123; name: &#x27;bubuzou.com&#x27;&#125;;var func = function( a, b, c, d ) &#123; console.log( this.name ); // &#x27;bubuzou.com&#x27; console.log( [a, b, c, d] ); // [1, 2, 3, 4]&#125;.bind(obj, 1, 2);func(3, 4); 借用其他对象的方法 我们知道，杜鹃既不会筑巢，也不会孵雏，而是把自己的蛋寄托给云雀等其他鸟类，让他们代为孵化和养育。同样，在JavaScript中也存在类似的借用现象。借用的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果： 1234567891011var A = function( name ) &#123; this.name = name;&#125;;var B = function() &#123; A.apply( this, arguments );&#125;;B.prototype.getName = function() &#123; return this.name;&#125;;var b = new B( &#x27;bubuzou.com&#x27; );console.log( b.getName() ); // &#x27;bubuzou.com&#x27; 借用方法的第二种运用场景跟我们的关系更加密切。函数的参数列表 arguments 是一个类数组对象，所以不能像数组一样，进行排序操作或往集合里添加一个新的元素。在这种情况下，我们通常会借用 Array.prototype 对象上的方法。比如像往arguments 里添加一个元素： 1234(function() &#123; Array.prototype.push.call( arguments, 3); console.log( arguments ); // [1, 2, 3]&#125;)(1, 2); 先来看一个例子: 1234var a = &#123;&#125;;Array.prototype.push.call( a, &#x27;first&#x27; );console.log( a.length ); // 1console.log( a[0] ); // &#x27;first&#x27; 上面这段代码在低版本IE浏览器中执行的时候，必须显式地给对象a设置length属性: 123var a = &#123; length: 0&#125;; 然而并不是所有的对象都可以传入Array.prototype.push，必须满足以下2个条件: 对象本身可以存取属性 如果不是一个 object 类型的对象而是 number 类型，我们来看看会怎么样： 1234var a = 1;Array.prototype.push.call( a, &#x27;first&#x27; );console.log( a.length ); // undefinedconsole.log( a[0] ); // undefined 对象的 length 属性可以读写 函数的 length 就是只有一个只读的属性，表示形参的个数，我们尝试把一个函数当做 this 传入Array.prototype.push: 123var func = function()&#123;&#125;;Array.prototype.push.call( func, &#x27;first&#x27; );console.log( func.length ); // 报错：Cannot assign to read only property &#x27;length&#x27; of function","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"数组","slug":"js-array","date":"2016-11-17T09:29:04.000Z","updated":"2019-03-29T01:20:52.341Z","comments":true,"path":"2016/11/17/js-array/","link":"","permalink":"https://bubuzou.com/2016/11/17/js-array/","excerpt":"数组字面量数组字面量提供了一种非常方便的创建数组的方法。一个数组表达式是在一对方括号内包围零个或多个用逗号分隔的值的表达式。数组的第一个值的属性名是 0。 123456var empty = [];var numbers = [&#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;];empty[1]; // undefinednumbers[1]; // &#x27;one&#x27;empty.length; // 0numbers.length; // 8 在大多数语言中，一个数组的所有元素都要求是相同的类型。js 允许数组包含任意混合类型的值： 12var misc = [&#x27;string&#x27;, 98.6, true, false, null];misc.length; // 5","text":"数组字面量数组字面量提供了一种非常方便的创建数组的方法。一个数组表达式是在一对方括号内包围零个或多个用逗号分隔的值的表达式。数组的第一个值的属性名是 0。 123456var empty = [];var numbers = [&#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;];empty[1]; // undefinednumbers[1]; // &#x27;one&#x27;empty.length; // 0numbers.length; // 8 在大多数语言中，一个数组的所有元素都要求是相同的类型。js 允许数组包含任意混合类型的值： 12var misc = [&#x27;string&#x27;, 98.6, true, false, null];misc.length; // 5 长度每个数组都有一个 length 属性。和大多数的语言不同，js 中数组的 length 是没有上限的。如果用大于或等于 length 的数字作为下标来存储一个元素，那么 length 的值会被增大以便容纳新的值，不会发生数组越界的错误。可以直接设置 length 的值，如果 length 大于当前的 length 值，则更大的那些下标的值都是 undefined；如果更小，那么将会把所有下标大于等于新 length 的属性给删除。通过把下标指定为一个数组的当前 length，可以附加一个新元素到该数组的末尾。 1234567var arr = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;];arr.length; // 3arr.length = 6;arr; // [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, undefined, undefined, undefined]arr.length = 2;arr; // [&#x27;one&#x27;, &#x27;two&#x27;]arr[arr.length] = &#x27;last&#x27;; // [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;last&#x27;]; 删除由于 js 的数组其实就是对象，所以 delete 运算符可以删除数组的元素： 123var arr = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;];delete arr[1]; arr; // [&#x27;one&#x27;, undefined, &#x27;three&#x27;] 遗憾的是删除后的数组直接留了一个空位值是 undefined，幸运的是可以通过数组的 splice 方法来进行调整。splice 方法接受 2 个参数，第一个是数组的序号，第二个是删除的元素个数，并且返回一个数组，这个数组包含了所有的删除元素。 12arr.splice(1, 1); // [undefined]arr; // [&#x27;one&#x27;, &#x27;three&#x27;] 枚举因为 js 数组其实就是对象，所以 for in 语句可以用来遍历一个数组的所有属性。但是用 for in语句无法保证顺序。所以遍历还是用常规的 for 循环 1234var numbers = [1, 2, 3, 4, 5];for ( var i = 0, l = numbers.length; i &lt; l; i++ ) &#123; console.log( numbers[i] ); // 1, 2, 3, 4, 5&#125; 判断是否是数组1typeof [1, 2, 3]; // &#x27;object&#x27; js 本身对于数组和对象的区别是混乱的。typeof 运算符报告数组的类型是 object，没有任何意义。js 没有一个好的机制来区别是数组还是对象，但是我们可以自己实现一个 is_array 函数来弥补这个缺陷： 12345var isArray = function( obj ) &#123; return obj &amp;&amp; typeof obj === &#x27;object&#x27; &amp;&amp; obj.constructor === Array;&#125;; 上面这个判断基本在常规页面就能很好的区分出数组还是对象了。但是也有特例，比如在不同的窗口(window)或帧(frame)就会失败。这个时候可以用下面这个替换： 123var isArray = function( obj ) &#123; return Object.prototype.toString.apply( obj ) === &#x27;[object Array]&#x27;;&#125;; 判断某个对象是否是数组，还可以用原型链的方法： 123var isArray = function( obj ) &#123; return obj.__prototype__ === Array.prototype;&#125; 方法 array.concat(item1[, item2, item2, ...]) concat 产生一个新数组，参数 item 可以是一个任意类型的值，也可以是一个数组，如果是数组，那么数组的所有元素都会被添加到新数组里。 123var a = [&#x27;a&#x27;,&#x27;b&#x27;];var b = [&#x27;x&#x27;,&#x27;y&#x27;];a.concat(b, true); // [&quot;a&quot;, &quot;b&quot;, &quot;x&quot;, &quot;y&quot;, true] array.join(separator) join 方法把 array 中的每个元素构造成一个字符串，接着用一个 separator 分隔符把它们连接在一起。默认的separator 是逗号,。想要无间隔的连接，可以使用空字符串。 123var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];a.join(); // &#x27;a,b,c&#x27;a.join(&#x27;&#x27;); // &#x27;abc&#x27; 如果想把大量的字符串片段组装成一个字符串，用 `+` 元素运算符连接这些片段会比把这些片段放到一个数组中并且用 `join` 连接起来更快。 array.pop() pop 方法移除数组中的最后一个元素并返回该元素。如果 array 是空值，则会返回 undefined 123456var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];a.pop(); // &#x27;c&#x27;// pop可以这样实现：Array.method(&#x27;pop&#x27;, function() &#123; return this.splice( this.length - 1, 1 )[0];&#125;); array.push(item1[, item2, ...]) push 方法把一个或多个参数附加到一个数组的尾部。参数可以是任何类型的值，也可以是数组。如果是数组，它会把参数数组作为这个元素添加到数组中。返回修改后的数组长度。 12345678910111213var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var b = [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;];var c = a.push(b, true);// a: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;], true]// c: 5// push可以这样实现：Array.method(&#x27;push&#x27;, function() &#123; this.splice.apply( this, [this.length, 0]. concat(Array.prototype.slice.apply(arguments))); return this.length;&#125;); array.reverse() reverse 方法反转 array 里的元素的顺序，并返回 array 本身。 12var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var b = a.reverse(); // a和b都是[&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;] array.shift() shift 方法移除数组中的第一个元素，并且返回这个元素。如果数组为空，则返回 undefined。 shift 通常比 pop 慢得多。 123456var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var b = a.shift(); // a: [&#x27;b&#x27;, &#x27;c&#x27;], b: &#x27;a&#x27;// shift实现Array.method(&#x27;shift&#x27;, function() &#123; return this.splice(0, 1)[0];&#125;); array.slice(start, end) slice 方法对数组进行一段浅复制。复制从下标 start 到 end 结束。end 下标默认是 array.length 。如果两个参数任意一个是负数，那么 end 数值会是和 array.length 相加之后的值。如果 start 大于array.length，则返回一个空数组。 1234var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var b = a.slice(0, 1); // [&#x27;a&#x27;]var c = a.slice(1); // [&#x27;b&#x27;, &#x27;c&#x27;]var d = a.slice(-1); // [&#x27;c&#x27;] array.sort(comparefn) sort 方法对 array 里的所有元素进行排序，默认的比较函数是把被排序的元素都视为字符串。所以它不能正确地给一组数字进行排序： 12var n = [4, 8, 15, 16, 23, 42];n.sort(); // [15, 16, 23, 4, 42, 8] 幸运的是你可以使用自定义的比较函数来使得一组数字能正常排序，比较函数接受两个参数，如果他们相等，则返回0，如果第一个参数应该排序在前面，则返回负数，如果第二个参数应该排在前面，则返回一个正数。 123n.sort(function(a, b) &#123; return a - b;&#125;); // [4, 8, 15, 16, 23, 42] 如果想给包含任何简单值的数组进行排序，可以这样： 12345678910var m = [&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;a&#x27;, 5, 3, 10];m.sort(function(a, b) &#123; if (a === b) &#123; return 0; &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1;&#125;); // [3, 5, 10, &#x27;a&#x27;, &#x27;aa&#x27;, &#x27;bb&#x27;] array.splice(start, deleteCount, item...) splice 方法从 array 中移除一个或多个元素，并用新的 item 替换它们。start 是移除元素的起始位置，deleteCount 是移除个数。如果有额外的参数，则 item 会插入到被移除的元素的位置上。返回一个包含被移除元素的数组。 12var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var r = a.splice(1, 1, &#x27;ache&#x27;, &#x27;bug&#x27;); // a: [&#x27;a&#x27;, &#x27;ache&#x27;, &#x27;bug&#x27;, &#x27;c&#x27;], r: [&#x27;b&#x27;] array.unshift(item...) unshift 方法是把 item 插入到数组的开始部分。返回新数组的 length。 12var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var r = a.unshift(&#x27;#&#x27;, &#x27;$&#x27;); // a: [&#x27;#&#x27;, &#x27;$&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], r: 5","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"正则表达式理论篇","slug":"regexp-concept","date":"2016-11-04T02:09:04.000Z","updated":"2018-12-29T01:57:44.175Z","comments":true,"path":"2016/11/04/regexp-concept/","link":"","permalink":"https://bubuzou.com/2016/11/04/regexp-concept/","excerpt":"先来看一个例子这里有一个例子，用来匹配URL的正则表达式。 1234567var url = &quot;http://bubuzou.com:80/goodparts?q#fragment&quot;;var parse_url = /^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Z-a-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;console.log( parse_url.exec( url ) );/*上面这段代码产生的结果如下：[&quot;http://bubuzou.com:80/goodparts?q#fragment&quot;, &quot;http&quot;, &quot;//&quot;, &quot;bubuzou.com&quot;, &quot;80&quot;, &quot;goodparts&quot;, &quot;q&quot;, &quot;fragment&quot;]*/","text":"先来看一个例子这里有一个例子，用来匹配URL的正则表达式。 1234567var url = &quot;http://bubuzou.com:80/goodparts?q#fragment&quot;;var parse_url = /^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Z-a-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;console.log( parse_url.exec( url ) );/*上面这段代码产生的结果如下：[&quot;http://bubuzou.com:80/goodparts?q#fragment&quot;, &quot;http&quot;, &quot;//&quot;, &quot;bubuzou.com&quot;, &quot;80&quot;, &quot;goodparts&quot;, &quot;q&quot;, &quot;fragment&quot;]*/ 现在让我们来分解parse_url的各个部分，看看它是如何工作的： ^ 字符表示字符串的开始 (?:([A-Za-z]+):)?这个因子匹配一个协议名，但是只有当它后面跟随:的时候才匹配。(?:...) 表示一个非捕获型的分组。后缀 ? 表示这个分组是可选的，表示匹配 0 次或者 1 次。(...) 表示一个捕获型分组。一个捕获型分组会复制它所匹配的文本，并且将其放到 result 数组里。每个捕获型分组会被指定一个编号。第一个捕获型分组的编号是 1，所以该分组所匹配的结果会出现在 result[1] 中。[...] 表示一个字符类。A-Za-z 这个字符类包含 26 个大写字母和 26 个小写字母。+ 表示这个字符类会被匹配 1 次或多次。: 会按照字面进行匹配。 (\\/&#123;0,3&#125;) 这个因子是捕获分组 2 。\\/ 表示匹配 / （斜杠），它用 \\ 来进行转义。&#123;0,3&#125; 表示会被匹配0-3 次 ([0-9.\\-A-Z-a-z]+) 这个因子是捕获分组 3 。它会匹配一个主机名，由一个或多个数字、字母，以及 . 或-组成。 (?::(\\d+))? 这个因子匹配的是端口号。(\\d+) 是捕获分组 4，表示匹配一个或多个数字。 (?:\\/([^?#]*))? 是一个可选的分组，以一个 / 开始。[^?#] 是捕获分组 5 ，以一个 ^ 开始表示这个类包含除 ? 和 # 之外的所有字符。 * 表示匹配 0 次或多次。 (?:\\?([^#]*))? 是一个以 ? 开始的分组。包含捕获分组 6，这个分组包含 0 个或多个非 # 的字符 (?:#(.*))? 这个可选分组是以 # 开始的，. 会匹配除了行结束符以外的所有字符。 $ 表示字符串的结束 所谓正则表达式，就是一种描述字符串结构模式的形式化表达方法。 这是《精通正则表达式》对它的定义。正则表达式又叫做规则表达式(Regular Expression，简写regexp).正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式能干嘛 测试字符串是否满足某种模式。比如字符串内是否出现电话号码模式，又称为数据验证。 替换文本。可以用正则表达式来识别字符串中的特定文本，完全删除或者用其他文本替换它。 提取字符串。基本匹配模式从字符串中提取需要的子字符串。 正则表达式已经在很多软件中得到广泛的应用，包括 `*nix(Linux, Unix等)`，`HP` 等操作系统，`PHP`、`C#`、`Java`等开发环境，以及很多的应用软件中，都可以看到正则表达式的影子。 正则表达式结构优先考虑的方法是使用正则表达式字面量： 1var patt = /pattern/modifiers; 另一种方法是使用RegExp构造器： 1var patt = new RegExp(pattern, modifiers); pattern（模式） 描述了表达式的模式 modifiers（修饰符） 用于指定全局匹配、区分大小写的匹配和多行匹配 修饰符modifiers： 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配 m 执行多行匹配 123var patt = /hello/ig;var str = &#x27;Hello world!&#x27;;patt.exec( str ); // 将会匹配&#x27;Hello&#x27; 正则表达因子一个正则表达式因子可以是一个字符、一个圆括号包围的组、一个字符类或者是一个转义序列。下面这些字符都会按照字面进行处理\\ / [ ] ( ) &#123; &#125; ? + * | . ^ $如果你希望这些字符按照字面意思去匹配，那需要在其前面加上\\进行转义。 123var patt = /\\.\\d+/;var str = &#x27;-12.568&#x27;;patt.exec( str ); // 匹配&#x27;.568&#x27; 正则表达式特殊字符: 特殊字符 描述 ^ 匹配输入字符串开始处的位置；但在中括号表达式中是表示对字符集求反。若要匹配 ^ 字符本身，请使用 \\^。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，那么 $ 还匹配 \\n 或 \\r 前面的位置。若要匹配 $ 字符本身，请使用 \\$。 () 标记子表达式的开始和结束。可以捕获子表达式以供以后使用。若要匹配这两个字符，请使用 \\( 和 \\)。 * 零次或多次匹配前面的字符或子表达式。若要匹配 * 字符，请使用 \\*。 + 一次或多次匹配前面的字符或子表达式。若要匹配 + 字符，请使用 \\+。 ? 零次或一次匹配前面的字符或子表达式，或指示“非贪心”限定符。若要匹配 ? 字符，请使用\\?。 . 匹配除换行符 \\n 之外的任何单个字符。若要匹配 . 请使用 \\。 [] 标记中括号表达式的开始。若要匹配这些字符，请使用 \\[ 和\\]。 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，字符 n 匹配字符 n。\\n 匹配换行符。序列 \\\\ 匹配 \\，序列 \\( 匹配 (。 / 表示文本正则表达式的开始或结束。若要匹配 / 字符，请使用 \\/。 &#123;&#125; 标记限定符表达式的开始。若要匹配这些字符，请使用 \\&#123; 和 \\&#125;。 竖线 指出在两个项之间进行选择。要匹配竖线，请使用 \\ 竖线。 正则表达式序列一个正则表达式序列包含一个或多个正则表达式因子。每个因子能选择是否跟随一个量词，这个量词决定了这个因子被允许出现的次数。如果没有量词，则只匹配一次。 123var patt = /\\d&#123;3&#125;\\.\\d/;var str = &#x27;abc1893.65d&#x27;;patt.exec( str ); // 匹配&#x27;893.6&#x27; 正则表达式分支一个正则表达式分支包含一个或多个正则表达式序列。这些序列被|字符分隔。如果这些序列中的任何一项符合匹配条件，那么这个选择就被匹配。它会按照书写顺序从左到右依次匹配这些序列。 123var str = &#x27;information&#x27;;str.match( /or|for/ ); // 匹配&#x27;for&#x27;str.match( /or|orm/ ); // 匹配&#x27;or&#x27; 正则表达式分组正则表达式的分组共有6种。 (...)捕获型，捕获型分组是一个被包围在圆括号中的正则表达式分支。任何匹配这个分组的字符都会被捕获。每个捕获分组都将有一个编号。第一个捕获分组的编号是 1，以此类推。 12/(:\\d+)/.exec( &#x27;bubuzou.com:80/&#x27; ); // 结果是[&#x27;:80&#x27;, &#x27;:80&#x27;]，第一个&#x27;:80&#x27;表示整个正则的匹配，第二个&#x27;:80&#x27;表示捕获分组1的匹配 (?:...) 非捕获型，仅做简单的匹配，并不会捕获所匹配的文本。也不会进行编号。 1/(?::\\d+)/.exec( &#x27;bubuzou.com:80/&#x27; ); 结果是[&#x27;:80&#x27;]，不包含分组捕获。 (?=pattern) 正向肯定预查。匹配其跟随了 pattern 的字符串。这不是一个好的特性。 1/window(?=95|98|2000)/.exec( &#x27;window98&#x27; ); // 匹配&#x27;window&#x27; (?!pattern) 正向否定预查。匹配其没有跟随了 pattern 的字符串。这不是一个好的特性。 1/window(?!95|98|2000)/.exec( &#x27;windowNT&#x27; ); // 匹配&#x27;window&#x27; (?&lt;=pattern) 反向肯定预查。匹配前面带 pattern 的字符串。这不是一个好的特性。 1/(?&lt;=95|98|2000)windows/.exec( &#x27;95windows&#x27; ); // 匹配&#x27;windows&#x27; (?&lt;!pattern) 反向否定预查。匹配前面没有带 pattern 的字符串。这不是一个好的特性。 RegExp对象方法 方法 描述 regexp.exec(string) 检索字符串中指定的值。如果匹配成功，则返回一个数组。数组中下标为 0 的值表示匹配的子字符串，下标为1的值是分组1捕获的文本。如果匹配失败，则会返回 null. regexp.test(string) 检索字符串中指定的值。返回 true 或 false。 test 方法中不需要对 regexp 进行全局匹配的配置，因为结果都一样。 string.match(regexp) 获取匹配结果。如果没有 g 标识，则结果和 regexp.exec(string) 一样。如果有 g 标识，则返回包含所有匹配结果（除了分组捕获之外）的数组。 string.replace(searchValue, replaceValue) replace 方法对字符串执行查找和替换工作，并返回一个新的字符串。参数 searchValue 可以是一个字符串或者正则表达式。如果是字符串，则在字符串中第一次出现的地方被替换。如果是正则表达式且带有 g，则会替换所有匹配，如果没有g则只会替换第一个匹配。replaceValue 可以是一个字符串或者一个函数。如果是一个函数则有特别含义。如果是一个函数，则每遇到一个匹配函数就会被调用一次，而函数返回的字符串将作为替换的文本。 string.search(regexp) 和 indexOf 方法类似，只是它接受的参数是一个正则表达式而非字符串。如果找到匹配，则返回第一个匹配的首字符的位置，没找到就返回 -1 string.split(separator, limit) 把 string 分割成片段来创建一个字符串数组。limit 可以限制分割的数量。separator可以是字符串或正则表达式。 regexp.exec(string)： 123456789// RegExpObject.exec(string);var str=&quot;user1abcuser2abc&quot;, patt=/user\\d/g, result;while ( ( result = patt.exec( str ) ) ) &#123; console.log( result );&#125;// 第一次：[&quot;user1&quot;, index: 0, input: &quot;user1abcuser2abc&quot;]// 第二次：[&quot;user2&quot;, index: 8, input: &quot;user1abcuser2abc&quot;] 如果regexp带有g标识，那么查找不是从这个字符串的起始位置开始，而是从regexp.lastIndex位置开始。如果匹配成功，那么regexp.lastIndex将被设置为该匹配后第一个字符的位置。不成功的匹配会将regexp重新设置为0。 regexp.test(string)： 1/Hello/i.test( &#x27;hello world&#x27; ); // true string.match(regexp)： 12&#x27;user1abcuser2abc&#x27;.match( /user\\d/g ); // [&#x27;user1&#x27;, &#x27;user2&#x27;]&#x27;user1abcuser2abc&#x27;.match( /user\\d/ ); // [&#x27;user1&#x27;] string.replace(searchValue, replaceValue)： 123var patt = /\\((\\d&#123;3&#125;)\\)/g, str = &#x27;(555)666-1212&#x27;.replace(patt, &#x27;$1-&#x27;);console.log(str); // 结果：&#x27;555-666-1212&#x27; 美元符号序列 替换对象 $$ $ $&amp; 整个匹配的文本 $number 分组匹配的文本 $ 匹配之前的文本 $ 匹配之后的文本 string.search(regexp)： 1&#x27;hello world&#x27;.search( /world/ ); // 6 string.split(separator, limit)： 12&#x27;123456&#x27;.split(&#x27;&#x27;, 3); // [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]&#x27;last, first, middle&#x27;.split(/\\s*,\\s*/); // [&#x27;last&#x27;, &#x27;first&#x27;, &#x27;middle&#x27;] 正则表达式字符表 量词 描述 * 零次或多次匹配前面的字符或子表达式。例如，zo 匹配 z 和 zoo。 等效于 &#123;0,&#125;。 + 一次或多次匹配前面的字符或子表达式。例如，zo+ 匹配 zo 和 zoo，但不匹配 z。+ 等效于 &#123;1,&#125;。 ? 零次或一次匹配前面的字符或子表达式。例如，do(es)? 匹配 do 或 does 中的 do。? 等效于 &#123;0,1&#125;。 &#123;n&#125; n 是非负整数。正好匹配 n 次。例如，o&#123;2&#125; 不匹配 Bob 中的 o，但匹配 food 中的两个 o。 &#123;n,&#125; n 是非负整数。至少匹配 n 次。例如，o&#123;2,&#125; 不匹配 Bob 中的 o，而匹配 foooood 中的所有 o。o&#123;1,&#125; 等效于 o+。o&#123;0,&#125; 等效于 o*。 &#123;n,m&#125; m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，o&#123;1,3&#125; 匹配 fooooood 中的头三个 o。o&#123;0,1&#125; 等效于 o?。注意：您不能将空格插入逗号和数字之间。 方括号：方括号用于查找某个范围内的字符 表达式 描述 [abc] 查找方括号之间的任何字符 [^abc] 查找任何不在方括号之间的字符 [0-9] 查找任何从 0 至 9 的数字 [a-z] 查找任何从小写 a 至小写 a 的字符 () 匹配一个子表达式的开始和结束位置 元字符：拥有特殊含义的字符 元字符 描述 . 查找单个字符，除了换行和行结束符 \\w 查找单词字符 \\W 查找非单次字符 \\b 匹配一个字的边界，即字与空格间的位置 \\B 非字符边界匹配 \\d 查找数字 \\D 查找非数字字符 \\s 查找空白字符 \\S 查找非空白字符","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://bubuzou.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"},{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"},{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"},{"name":"git","slug":"git","permalink":"https://bubuzou.com/categories/git/"},{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/tags/vue/"},{"name":"小程序、wepy","slug":"小程序、wepy","permalink":"https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%81wepy/"},{"name":"node","slug":"node","permalink":"https://bubuzou.com/tags/node/"},{"name":"jest","slug":"jest","permalink":"https://bubuzou.com/tags/jest/"},{"name":"vue-test-utils","slug":"vue-test-utils","permalink":"https://bubuzou.com/tags/vue-test-utils/"},{"name":"单元测试","slug":"单元测试","permalink":"https://bubuzou.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"git","slug":"git","permalink":"https://bubuzou.com/tags/git/"},{"name":"图像","slug":"图像","permalink":"https://bubuzou.com/tags/%E5%9B%BE%E5%83%8F/"},{"name":"upload","slug":"upload","permalink":"https://bubuzou.com/tags/upload/"},{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"element-ui","slug":"element-ui","permalink":"https://bubuzou.com/tags/element-ui/"},{"name":"性能优化","slug":"性能优化","permalink":"https://bubuzou.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"},{"name":"svg","slug":"svg","permalink":"https://bubuzou.com/tags/svg/"},{"name":"chrome","slug":"chrome","permalink":"https://bubuzou.com/tags/chrome/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://bubuzou.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]}