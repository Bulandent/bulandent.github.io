{"meta":{"title":"步步走","subtitle":null,"description":"良好的css编码习惯能够提高开发、维护效率，所以前端很有必要养成一个好的编码习惯。","author":"typeR","url":"https://bubuzou.com","root":"/"},"pages":[{"title":"","date":"2020-07-29T06:57:38.699Z","updated":"2018-12-19T03:41:36.121Z","comments":true,"path":"google3f5e6f40d046c2a1.html","permalink":"https://bubuzou.com/google3f5e6f40d046c2a1.html","excerpt":"","text":"· 步步走 博文归档生活摄影关于2017-07-14-次访问google-site-verification: google3f5e6f40d046c2a1.html分类归档JavaScript7css7web综合2精通正则表达式1标签云JavaScript Javascript chrome css svg 图像 性能优化 正则表达式最近文章JS中类数组的遍历以及性能探究良好的CSS编码习惯jpg、gif、png和svg用于web上，我们该如何选择最合适的图像格式？CSS自定义属性理解 Flexbox：你需要知道这些搜索 (function() { var appid = 'cyt6h19Ve'; var conf = 'prod_0b4b95efa2ecfede2ddfb5adcef8c394'; var width = window.innerWidth || document.documentElement.clientWidth; if (width < 960) { window.document.write(''); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(\"head\")[0]||document.head||document.documentElement;var b=document.createElement(\"script\");b.setAttribute(\"type\",\"text/javascript\");b.setAttribute(\"charset\",\"UTF-8\");b.setAttribute(\"src\",d);if(typeof a===\"function\"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===\"loaded\"||e===\"complete\"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(\"https://changyan.sohu.com/upload/changyan.js\",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();© 2016 - 2017 typeR, powered by Hexo and hexo-theme-bubuzou 闽ICP备16007301号-2Hosted by Coding Pages(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',\"UA-65933410-1\",'auto');ga('send','pageview');"}],"posts":[{"title":"mac 环境变量与 shell","slug":"shell-mac","date":"2024-06-14T09:37:58.000Z","updated":"2024-06-17T01:08:20.017Z","comments":true,"path":"2024/06/14/shell-mac/","link":"","permalink":"https://bubuzou.com/2024/06/14/shell-mac/","excerpt":"背景最近在 mac 上安装了 nginx 用来跑本地 web 服务。但是启动的时候需要切换到 nginx 的安装目录下，然后执行命令才能启动。比如： 1234567891011121314# 进入 nginx 目录cd /usr/local/nginx# 启动 nginx 服务sudo sbin/nginx# 退出 nginxsudo sbin/nginx -s quit# 强制停止 nginxsudo sbin/nginx -s stop# 重启 nginxsudo sbin/nginx -s reload 可以看到每次操作 nginx 都需要切到对应目录才能执行命令，挺不方便的。有没有更便捷的方法呢？当然是有的，那就是使用环境变量。","text":"背景最近在 mac 上安装了 nginx 用来跑本地 web 服务。但是启动的时候需要切换到 nginx 的安装目录下，然后执行命令才能启动。比如： 1234567891011121314# 进入 nginx 目录cd /usr/local/nginx# 启动 nginx 服务sudo sbin/nginx# 退出 nginxsudo sbin/nginx -s quit# 强制停止 nginxsudo sbin/nginx -s stop# 重启 nginxsudo sbin/nginx -s reload 可以看到每次操作 nginx 都需要切到对应目录才能执行命令，挺不方便的。有没有更便捷的方法呢？当然是有的，那就是使用环境变量。 环境变量环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，如临时文件夹位置、系统文件夹位置以及某些应用软件文件的路径等等。环境变量相当于给系统或用户应用程序设置的一些参数，具体起什么作用这当然和具体的环境变量相关。 比如 Path，是告诉系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到哪些目录下去寻找。 环境变量的配置文件设置的环境变量需要生效，就必须要存起来，存到配置文件里。 在 Mac 中环境变量的配置文件有好几种类型。 系统级别 系统级别配置文件，系统启动就会加载，修改需要 Root 权限。 /etc/paths ：任何用户登陆时都会读取该文件，全局建议修改这个文件 。 /etc/profile：为系统的每个用户设置环境信息和启动程序，其配置对所有登录的用户都有效，一般不建议修改该文件。 用户级别 ~/.bash_profile：为当前用户设置专属的环境信息和启动程序，当用户登录时该文件执行一次。默认情况下，它用于设置环境变量，并执行当前用户的 .bashrc 文件，一般用户级环境变量会放到这个文件。 ~/.bash_login 和 ~/.profile：这三个文件也是依次执行的，如果 bash_profile 文件存在，则后面的两个文件就会被忽略不读了，如 bash_profile 文件不存在，才会以此类推读取后面的文件。 shell 打开时加载 /etc/bashrc 或 /etc/zshrc：系统级配置，为每个运行 bash/zhs shell 的用户执行该文件，当 bash/zhs shell 打开时，该文件被执行，其配置对所有使用 bash 的用户打开的每个 bash 都有效。 ~/.bashrc 或 ～/.zshrc：用户级配置，作用同上。它是 bash/zsh shell 打开的时候载入的，对当前用户打开的每个 bash 都有效。 如果系统默认 shell 使用的是 zsh 而不是 sh、bash，那么 zsh 是不加载 .bash_profile 文件的，而是加载 .zshrc。source .zshrc 在 zsh 环境下读取配置文件。 shell上面多个地方提到了 shell，环境变量也是需要运行在 shell 上，那 shell 到底是什么呢？ shell 的概念Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。 具体来说，Shell 这个词有多种含义。 首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（command line interface，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。 其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。 最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。 以上这个 shell 概念来自阮一峰的 《Bash 脚本教程》 shell 的种类不同的程序员写出的程序风格不同，有的喜欢这么写，有的喜欢那样写，所以就形成了不同的规范，就有了多种类型的 shell 了，就好像每个人喜欢穿不同的衣服一样。 历史上，主要的 Shell 有下面这些。 Bourne Shell（sh） Bourne Again shell（bash） C Shell（csh） TENEX C Shell（tcsh） Korn shell（ksh） Z Shell（zsh） Friendly Interactive Shell（fish） 随着时间的推移，每个 mac 系统会内置一些不同的 shell，那么如何查看你的 mac 安装了哪些 shell 呢？其实它的答案藏在了 /etc/shells 这个文件里： 12345678910cat /etc/shells# 我的 mac 电脑内置的 shell/bin/bash/bin/csh/bin/dash/bin/ksh/bin/sh/bin/tcsh/bin/zsh 如何查看默认使用的是哪个 shell 呢？ 1234567# 当前系统默认的 shellecho $SHELL&gt; /bin/zsh# 当前进程正在使用的 shellecho $0&gt; zsh 如果你想更改系统默认的 shell，你可以这么做： 12# 以下将把 bash 设置为 默认 shellchsh -s /bin/bash 配置环境变量通过上面的介绍，你知道了你系统默认的 shell 是什么了。我的是 zsh，那我就可以把我的环境变量保存在 ~/.zshrc 配置文件里。 12345# 同过 vim 打开 ~/.zshrc 文件vim ~/.zshrc# 配置 nginx 的环境变量 $PATHexport PATH=$PATH:/usr/local/nginx/sbin 通过 vim 编辑保存该文件后，想让环境变量立即生效还需要执行： 12# 该命令的作用是读取并且执行该文件脚本source ~/.zshrc 或者，可以把你的环境变量存在 ~/.bash_profile 里，然后在 ~/.zshrc 最后一行加上 source ~/.bash_profile，这样对于默认 shell 是 zsh 的用户来说，就可以让 ~/.bash_profile 里的配置生效了。 环境变量配置好后，就可以测试是否生效了。 12# 如果没有报错，那就说明 nginx 的环境变量已经生效了sudo nginx","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://bubuzou.com/tags/mac/"},{"name":"shell","slug":"shell","permalink":"https://bubuzou.com/tags/shell/"}]},{"title":"如何反编译微信小程序","slug":"decompile-applet","date":"2024-06-12T09:37:58.000Z","updated":"2024-06-17T01:21:58.695Z","comments":true,"path":"2024/06/12/decompile-applet/","link":"","permalink":"https://bubuzou.com/2024/06/12/decompile-applet/","excerpt":"什么是反编译微信小程序可以运行在手机微信或者 pc 版微信环境下，它是以一个应用包的形式存在的，这个应用包的后缀通常是 .wxapkg。如果想知道某个微信小程序的功能模块是如何实现的，就需要把这个包给解开，这个过程就叫反编译。 获取小程序包要反编译微信小程序，那首先就需要获取微信小程序的应用包。 可以在 pc 版本微信上获取包，那么就需要在 pc 版微信上先运行某个小程序；运行完成后，就会在电脑某个目录下生成这个小程序的包，我们需要找到这个目录，那么就找到了这个包了。 windows 和 mac 环境不同，包的位置也会不一样。 windows 系统 打开微信设置-文件管理-就能看到微信的目录了，继续往下找到 /applet 这个目录，就能看到小程序的包了。示例：D:\\软件\\WeChat Files\\WeChat Files\\Applet\\小程序 AppID__APP__.wxapkg mac 系统 包通常是被放在：/System/Volumes/Data/Users/你的用户名/Library/Containers/com.tencent.xinWeChat/Data/.wxapplet/packages/小程序 AppID/随机数/APP.wxapkg","text":"什么是反编译微信小程序可以运行在手机微信或者 pc 版微信环境下，它是以一个应用包的形式存在的，这个应用包的后缀通常是 .wxapkg。如果想知道某个微信小程序的功能模块是如何实现的，就需要把这个包给解开，这个过程就叫反编译。 获取小程序包要反编译微信小程序，那首先就需要获取微信小程序的应用包。 可以在 pc 版本微信上获取包，那么就需要在 pc 版微信上先运行某个小程序；运行完成后，就会在电脑某个目录下生成这个小程序的包，我们需要找到这个目录，那么就找到了这个包了。 windows 和 mac 环境不同，包的位置也会不一样。 windows 系统 打开微信设置-文件管理-就能看到微信的目录了，继续往下找到 /applet 这个目录，就能看到小程序的包了。示例：D:\\软件\\WeChat Files\\WeChat Files\\Applet\\小程序 AppID__APP__.wxapkg mac 系统 包通常是被放在：/System/Volumes/Data/Users/你的用户名/Library/Containers/com.tencent.xinWeChat/Data/.wxapplet/packages/小程序 AppID/随机数/APP.wxapkg 知道了目录后，就可以拿到包了。 在 mac 下进入某个目录可以这样做： 访达-前往-前往文件夹-然后把目录路径贴到输入框，选择某个路径就可以进去了； 或者在终端用命令：open 目录路径； 如果 mac 系统的包不在刚刚说的目录下，还有一种方式可以找到。那就是通过微信小程序 AppID 来搜索目录。那就需要先知道某个微信小程序的 AppID 是什么。 可以通过如下这张图的操作路径来获取 AppID： 拿到了 AppID 后，就可以通过终端里输入命令来进行搜索了： 1find / -name 某个AppID 当搜索到这种路径的时候就说明找到了，就可以停止搜索了。 反编译拿到了小程序应用包，接下来就需要通过代码把这个包给解开，然后还原成可以跑在微信开发者工具上的微信小程序项目代码了。 反编译使用的是 github 上的开源项目：wxappUnpacker 把这个项目 clone 到本地后，安装好依赖，就可以使用如下命令进行反编译了： 1node wuWxapkg.js /System/Volumes/Data/Users/你的用户名/Library/Containers/com.tencent.xinWeChat/Data/.wxapplet/packages/小程序AppID/随机数/__APP__.wxapkg 由于这个库的程序比较旧了，而小程序的项目结构或者语法再时时更新，所以在解包的时候有可能会报错，这个不用管。 解包完成后，会在 APP.wxapkg 的同级目录生成一个 APP 的文件夹，这个文件夹就是微信开发者工具的可识别的项目目录。把它复制到外面，好让微信开发者工具方便导入，导入项目过程中的 AppID 使用测试号即可。 在微信开发者加载代码的过程中，正常不会很顺利，我自己反编译了几个小程序也都会有问题。比如如下图： 问题一：require(…)() is not a function 比如如下文件 miniprogram_npm/@vant/weapp/wxs/utils.wxs 中的 require(…)() 改成 require(…) 即可。 1234567891011- var bem = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/bem.wxs&#x27;)();+ var bem = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/bem.wxs&#x27;);- var memoize = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/memoize.wxs&#x27;)();+ var memoize = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/memoize.wxs&#x27;);- var addUnit = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/add-unit.wxs&#x27;)();+ var addUnit = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/add-unit.wxs&#x27;);module.exports = (&#123; bem: memoize(bem), memoize: memoize, addUnit: addUnit,&#125;); 问题二：_typeof2 is not a function 这个错误文件是 @babel/runtime/helpers/typeof.js，把如下代码替换掉原文件代码即可。 1234567891011121314151617181920212223242526272829303132333435363738function _typeof2(o) &#123; &quot;@babel/helpers - typeof&quot;; return (_typeof2 = &quot;function&quot; == typeof Symbol &amp;&amp; &quot;symbol&quot; == typeof Symbol.iterator ? function (o) &#123; return typeof o; &#125; : function (o) &#123; return o &amp;&amp; &quot;function&quot; == typeof Symbol &amp;&amp; o.constructor === Symbol &amp;&amp; o !== Symbol.prototype ? &quot;symbol&quot; : typeof o; &#125;)(o);&#125;function _typeof(o) &#123; return ( &quot;function&quot; == typeof Symbol &amp;&amp; &quot;symbol&quot; === _typeof2(Symbol.iterator) ? (module.exports = _typeof = function (o) &#123; return _typeof2(o); &#125;) : (module.exports = _typeof = function (o) &#123; return o &amp;&amp; &quot;function&quot; == typeof Symbol &amp;&amp; o.constructor === Symbol &amp;&amp; o !== Symbol.prototype ? &quot;symbol&quot; : _typeof2(o); &#125;), _typeof(o) );&#125;module.exports = _typeof; 其他一些别的错误，需要看报错信息对应改一下，这里就不再多介绍了。","categories":[{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"反编译","slug":"反编译","permalink":"https://bubuzou.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"}]},{"title":"mac 终端命令大全","slug":"mac-terminal-command","date":"2024-06-06T09:37:58.000Z","updated":"2024-06-17T01:28:45.239Z","comments":true,"path":"2024/06/06/mac-terminal-command/","link":"","permalink":"https://bubuzou.com/2024/06/06/mac-terminal-command/","excerpt":"“终端” App 可让高级用户和开发者通过命令行界面 (CLI) 与 Mac 操作系统进行通信。你可以输入命令和脚本（称为 shell 脚本）在 Mac 上执行任务。 Mac 终端键盘快键键 目录操作 命令 功能描述 举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la dircmp 比较两个目录的内容 dircmp dir1 dir2","text":"“终端” App 可让高级用户和开发者通过命令行界面 (CLI) 与 Mac 操作系统进行通信。你可以输入命令和脚本（称为 shell 脚本）在 Mac 上执行任务。 Mac 终端键盘快键键 目录操作 命令 功能描述 举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la dircmp 比较两个目录的内容 dircmp dir1 dir2 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename pg 分页格式化显示文件内容 pg filename more 分屏显示文件内容 more filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 ln 联接文件 ln -s file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename open 使用默认的程序打开文件 open filename 选择操作 命令 功能描述 举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 paste 横向连接文件 paste file1 file2 diff 比较并显示两个文件的差异 diff file1 file2 sed 非交互方式流编辑器 sed “s/red/green/g” filename grep 在文件中按模式查找 grep “a” filename awk 在文件中查找并处理模式 awk ‘{print $1 $1}’ filename sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 安全操作 命令名 功能描述 使用举例 passwd 修改用户密码 passwd chmod 改变文件或目录的权限 chmod ug+x filename umask 定义创建文件的权限掩码 umask 027 chown 改变文件或目录的属主 chown newowner filename chgrp 改变文件或目录的所属组 chgrp staff filename xlock 给终端上锁 xlock -remote 编程操作 命令名 功能描述 使用举例 make 维护可执行程序的最新版本 make touch 更新文件的访问和修改时间 touch -m 05202400 filename dbx 命令行界面调试工具 dbx a.out xde 图形用户界面调试工具 xde a.out 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 nice 改变待执行命令的优先级 nice cc -c *.c renice 改变已运行进程的优先级 renice +20 32768 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftp ftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其他命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty du 查询磁盘使用情况 du -k subdir df 显示文件系统的总空间和可用空间 df /tmp w 显示当前系统活动的总信息 w","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://bubuzou.com/tags/mac/"},{"name":"命令","slug":"命令","permalink":"https://bubuzou.com/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"深入学习 TypeScript 类型体操","slug":"typescript-deep","date":"2024-02-18T06:19:26.000Z","updated":"2024-06-14T12:58:46.955Z","comments":true,"path":"2024/02/18/typescript-deep/","link":"","permalink":"https://bubuzou.com/2024/02/18/typescript-deep/","excerpt":"模式匹配做提取数组类型提取数组第一个元素的类型 123type GetFirst&lt;Arr extends unknown[]&gt; = Arr extends [infer First, ...unknown[]] ? First : never; 提取数组最后一个元素的类型 123type GetLast&lt;Arr extends unknown[]&gt; = Arr extends [...unknown[], infer Last] ? Last : never; 取去掉最后一个元素的数组 12345type PopArr&lt;Arr extends unknown[]&gt; = Arr extends [] ? [] : Arr extends [...infer Rest, unknown] ? Rest : never;","text":"模式匹配做提取数组类型提取数组第一个元素的类型 123type GetFirst&lt;Arr extends unknown[]&gt; = Arr extends [infer First, ...unknown[]] ? First : never; 提取数组最后一个元素的类型 123type GetLast&lt;Arr extends unknown[]&gt; = Arr extends [...unknown[], infer Last] ? Last : never; 取去掉最后一个元素的数组 12345type PopArr&lt;Arr extends unknown[]&gt; = Arr extends [] ? [] : Arr extends [...infer Rest, unknown] ? Rest : never; 字符串类型字符串是否以某个特定字符开头 1234type StartWidth&lt; Str extends string, Prefix extends String&gt; = Str extends `$&#123;Prefix&#125;$&#123;string&#125;` ? true : false; 将字符串中某个特定的部分替换成别的字符串 1234567type ReplaceStr&lt; Str extends string, From extends string, To extends string&gt; = Str extends `$&#123;infer Prefix&#125;$&#123;From&#125;$&#123;infer Suffix&#125;` ? `$&#123;Prefix&#125;$&#123;To&#125;$&#123;Suffix&#125;` : Str; 字符串去除右空格 123456type TrimStrRight&lt;Str extends string&gt; = Str extends `$&#123;infer Rest&#125;$&#123; | &quot; &quot; | &quot;\\n&quot; | &quot;\\t&quot;&#125;` ? TrimStrRight&lt;Rest&gt; : Str; 函数类型提取函数参数的类型 12345type GetParameters&lt;Func extends Function&gt; = Func extends ( ...args: infer Args) =&gt; unknown ? Args : never; 提取函数返回值的类型 12345type GetReturnType&lt;Func extends Function&gt; = Func extends ( ...args: any[]) =&gt; infer ReturnType ? ReturnType : never; 构造器提取构造器参数的类型 1234type GetInstanceParameters&lt;ConstructorType extends new (...args: any) =&gt; any&gt; = ConstructorType extends new (...args: infer ParametersType) =&gt; any ? ParametersType : never; 提取构造器返回值类型 1234type GetInstanceReturnType&lt;ConstructorType extends new (...args: any) =&gt; any&gt; = ConstructorType extends new (...args: any) =&gt; infer InstanceType ? InstanceType : never; 索引类型提取 props 中 ref 值的类型 12345type GetRefProps&lt;Props&gt; = &quot;ref&quot; extends keyof Props ? Props extends &#123; ref?: infer Value | undefined &#125; ? Value : never : never; 重新构造做变换TypeScript 的 type、infer、类型参数声明的变量都不能修改，想对类型做各种变换产生新的类型就需要重新构造。 数组类型的构造给数组/元组添加新类型 1type Push&lt;Arr extends unknown[], Ele&gt; = [...Arr, Ele]; 元组重组 1234567891011121314type tuple1 = [1, 2];type tuple2 = [&quot;guang&quot;, &quot;dong&quot;];// 重组成如下的元组type tuple = [[1, &quot;guang&quot;], [2, &quot;dong&quot;]];// 代码实现type Zip&lt;One extends unknown[], Other extends unknown[]&gt; = One extends [ infer OneFirst, ...infer OneRest] ? Other extends [infer OtherFirst, ...infer OtherRest] ? [[OneFirst, OtherFirst], ...Zip&lt;OneRest, OtherRest&gt;] : [] : []; 字符串类型的构造将字符串首字母大写 1234type CapitalizeStr&lt;Str extends string&gt; = Str extends `$&#123;infer First&#125;$&#123;infer Rest&#125;` ? `$&#123;Uppercase&lt;First&gt;&#125;$&#123;Rest&#125;` : Str; 将字符串下划线转驼峰 ```tstype CamelCase&lt;Str extends string&gt; = Str extends${infer Left}_${infer Right}${infer Rest}?${Left}${Uppercase}${CamelCase}`Str;12345678**删除字符串子串**&#96;&#96;&#96;tstype DropSubStr&lt;Str extends string, SubStr extends string&gt; &#x3D; Str extends &#96;$&#123;infer Prefix&#125;$&#123;SubStr&#125;$&#123;infer Suffix&#125;&#96; ? DropSubStr&lt;&#96;$&#123;Prefix&#125;$&#123;Suffix&#125;&#96;, SubStr&gt; : Str; 函数类型的构造给函数添加一个参数 12345type AppendArgument&lt;Func extends Function, Arg&gt; = Func extends ( ...args: infer Args) =&gt; infer ReturnType ? (...args: [...Args, Arg]) =&gt; ReturnType : never; 索引类型的构造索引类型是聚合多个元素的类型。比如 class 和对象都是索引类型。索引类型的元素的类型只能是 string、number 或者 Symbol 等类型。 索引类型的每个元素的类型可以添加修饰符：readonly（只读）、?（可选）。 映射类型语法 123type Mapping&lt;Obj extends object&gt; = &#123; [Key in keyof Obj]: Obj[Key];&#125;; 用 as 做重映射改变索引类型的 Key 转成大写 123type UppercaseKey&lt;Obj extends object&gt; = &#123; [Key in keyof Obj as Uppercase&lt;Key &amp; string&gt;]: Obj[Key];&#125;; 因为这里索引的类型可能是 string、number 或 symbol 类型，但是这里转成大写只能是限定为 string。 TS 内置高级类型 Record 1type Record&lt;K extends string | number | symbol, T&gt; = &#123; [P in K]: T &#125;; UppercaseKey 重写版：用 Record 来约束索引类型而不是 object 123type UppercaseKey&lt;Obj extends Record&lt;string, any&gt;&gt; = &#123; [Key in keyof Obj as Uppercase&lt;Key &amp; string&gt;]: Obj[Key];&#125;; 给索引类型添加只读的高级类型 123type ToReadonly&lt;T&gt; = &#123; readonly [Key in keyof T]: T[Key];&#125;; 给索引类型添加可选的高级类型 123type ToPartial&lt;T&gt; = &#123; [Key in keyof T]?: T[Key];&#125;; 给索引类型去掉只读修饰符 123type ToMutable&lt;T&gt; = &#123; -readonly [Key in keyof T]: T[Key];&#125;; 给索引类型去掉可选修饰符 123type ToRequired&lt;T&gt; = &#123; [Key in keyof T]-?: T[Key];&#125;; 返回特定值的类型的索引类型 123type FilterByValueType&lt;Obj extends Record&lt;string, any&gt;, ValueType&gt; = &#123; [Key in keyof Obj as Obj[Key] extends ValueType ? Key : never]: Obj[Key];&#125;; 递归复用做循环Promise 的递归复用提取 Promise 值的类型 1234567type DeepPromiseValueType&lt;P extends Promise&lt;unknown&gt;&gt; = P extends Promise&lt; infer ValueType&gt; ? ValueType extends Promise&lt;unknown&gt; ? DeepPromiseValueType&lt;ValueType&gt; : ValueType : never; 提取 Promise 值的类型简化版 123type DeepPromiseValueType&lt;T&gt; = T extends Promise&lt;infer ValueType&gt; ? DeepPromiseValueType&lt;ValueType&gt; : never; 数组类型的递归反转元组 123456type ReversrArr&lt;Arr extends unknown[]&gt; = Arr extends [ infer First, ...infer Rest] ? [...ReversrArr&lt;Rest&gt;, First] : Arr; 查找元素 12345678910type Includes&lt;Arr extends unknown[], FindItem&gt; = Arr extends [ infer First, ...infer Rest] ? IsEqual&lt;First, FindItem&gt; extends true ? true : Includes&lt;Rest, FindItem&gt; : false;type IsEqual&lt;A, B&gt; = (A extends B ? true : false) &amp; (B extends A ? true : false); 删除元素 1234567891011type RemoveItem&lt; Arr extends unknown[], Item, Result extends unknown[] = []&gt; = Arr extends [infer First, ...infer Rest] ? IsEqual&lt;First, Item&gt; extends true ? RemoveItem&lt;Rest, Item, Result&gt; : RemoveItem&lt;Rest, Item, [...Result, First]&gt; : Result;type IsEqual&lt;A, B&gt; = (A extends B ? true : false) &amp; (B extends A ? true : false); 构造指定类型的数组 12345type BuildArray&lt; Length extends number, Ele = unknown, Arr extends unknown[] = []&gt; = Arr[&quot;length&quot;] extends Length ? Arr : BuildArray&lt;Length, Ele, [...Arr, Ele]&gt;; 字符串类型的递归替换子串 1234567type ReplaceAll&lt; Str extends string, From extends string, To extends string&gt; = Str extends `$&#123;infer Left&#125;$&#123;From&#125;$&#123;infer Right&#125;` ? `$&#123;Left&#125;$&#123;To&#125;$&#123;ReplaceAll&lt;Right, From, To&gt;&#125;` : Str; 提取字符做联合类型 1234type StringToUnion&lt;Str extends string&gt; = Str extends `&#123;infer First&#125;$&#123;infer Rest&#125;` ? First | StringToUnion&lt;Rest&gt; : never; 反转字符串 123type ReverseStr&lt;Str extends string&gt; = Str extends `$&#123;infer First&#125;$&#123;infer Rest&#125;` ? `$&#123;ReverseStr&lt;Rest&gt;&#125;$&#123;First&#125;` : Str; 对象类型的递归深度递归 123456789type DeepToReadonly&lt;T extends Record&lt;string, any&gt;&gt; = T extends any ? &#123; readonly [Key in keyof T]: T[Key] extends Object ? T[Key] extends Function ? T[Key] : DeepToReadonly&lt;T[Key]&gt; : T[Key]; &#125; : never; 数组长度做计算数组长度实现加减乘除加法 12345678910type BuildArray&lt; Length extends number, Ele = unknown, Arr extends unknown[] = []&gt; = Arr[&quot;length&quot;] extends Length ? Arr : BuildArray&lt;Length, Ele, [...Arr, Ele]&gt;;type Add&lt;Num1 extends number, Num2 extends number&gt; = [ ...BuildArray&lt;Num1&gt;, ...BuildArray&lt;Num2&gt;][&quot;length&quot;]; 减法 123456type Subtract&lt; Num1 extends number, Num2 extends number&gt; = BuildArray&lt;Num1&gt; extends [...BuildArray&lt;Num2&gt;, ...infer Rest] ? Rest[&quot;length&quot;] : never; 乘法 1234567type Multiple&lt; Num1 extends number, Num2 extends number, ResultArr extends unknown[] = []&gt; = Num2 extends 0 ? ResultArr[&quot;length&quot;] : Multiple&lt;Num1, Subtract&lt;Num2, 1&gt;, [...ResultArr, ...BuildArray&lt;Num1&gt;]&gt;; 除法 1234567type Divide&lt; Num1 extends number, Num2 extends number, ResultArr extends unknown[] = []&gt; = Num1 extends 0 ? ResultArr[&quot;length&quot;] : Divide&lt;Subtract&lt;Num1, Num2&gt;, Num2, [...ResultArr, unknown]&gt;; 数组长度实现计数计算字符串长度 123456type StrLen&lt; Str extends string, CountArr extends unknown[] = []&gt; = Str extends `$&#123;string&#125;$&#123;infer Rest&#125;` ? StrLen&lt;Rest, [...CountArr, unknown]&gt; : CountArr[&quot;length&quot;]; 比较 2 个数值谁更大 1234567891011type GreaterThan&lt; Num1 extends number, Num2 extends number, CountArr extends unknown[] = []&gt; = Num1 extends Num2 ? false : CountArr[&quot;length&quot;] extends Num2 ? true : CountArr[&quot;length&quot;] extends Num1 ? false : GreaterThan&lt;Num1, Num2, [...CountArr, unknown]&gt;; 实现斐波那契数列 123456789101112131415type FibonacciLoop&lt; PrevArr extends unknown[], CurrentArr extends unknown[], IndexArr extends unknown[] = [], Num extends number = 1&gt; = IndexArr[&quot;length&quot;] extends Num ? CurrentArr[&quot;length&quot;] : FibonacciLoop&lt; CurrentArr, [...PrevArr, ...CurrentArr], [...IndexArr, unknown], Num &gt;;type Fibonacci&lt;Num extends number&gt; = FibonacciLoop&lt;[1], [], [], Num&gt;; 聚合分散可简化分布式条件类型当类型参数为联合类型，并且在条件类型左边直接引用该类型参数的时候，TypeScript 会把每一个元素单独传入来做类型运算，最后再合并成联合类型，这种语法叫做分布式条件类型。 1234type Union = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;;type UppercaseA&lt;Item extends string&gt; = Item extends &quot;a&quot; ? Uppercase&lt;Item&gt; : Item; 这和联合类型遇到字符串时的处理一样： 123type Union = &quot;a&quot; | &quot;b&quot;;type str = `$&#123;Union&#125;~`;// type str = &#x27;a~&#x27; | &#x27;b~&#x27;; 数组转联合类型123type Arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];type UnionArr = Arr[number];// type UnionArr = &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;; 判断是否是联合类型1type isUnion&lt;A, B = A&gt; = A extends A ? ([B] extends [A] ? false : true) : never; 当 A 是联合类型时： A extends A 这种写法是为了触发分布式条件类型，让每个类型单独传入处理的，没别的意义。 A extends A 和 [A] extends [A] 是不同的处理，前者是单个类型和整个类型做判断，后者两边都是整个联合类型，因为只有 extends 左边直接是类型参数才会触发分布式条件类型。 BEM12345type BEM&lt; Block extends string, Element extends string[], Modifiers extends string[]&gt; = `$&#123;Block&#125;__$&#123;Element[number]&#125;--$&#123;Modifiers[number]&#125;`; 全组合123456789// A 和 B 的全组合type Combination&lt;A extends string, B extends string&gt; = A | B | `$&#123;A&#125;$&#123;B&#125;` | `$&#123;B&#125;$&#123;A&#125;`// 全组合type AllCombinations&lt;A extends string, B extends string = A&gt; = A extens A ? Combination&lt;A, AllCombinations&lt;Exclude&lt;B, A&gt;&gt;&gt; : never; 特殊特性要记清IsAnyany 类型与任何类型的交叉都是 any，也就是 1 &amp; any 结果是 any。 1type IsAny&lt;T&gt; = &quot;a&quot; extends 1 &amp; T ? true : false; IsEqual12345678910// 以下这种写法不能判断 isAny，isEqual&lt;&#x27;a&#x27;, any&gt; 会返回 truetype IsEqual&lt;A, B&gt; = (A extends B ? true : false) &amp; (B extends A ? true : false);// 以下这个可以判断 IsEqual2&lt;&#x27;a&#x27;, any&gt; 会返回 falsetype IsEqual2&lt;A, B&gt; = (&lt;T&gt;() =&gt; T extends A ? 1 : 2) extends &lt; T&gt;() =&gt; T extends B ? 1 : 2 ? true : false; IsUnion1type IsUnion&lt;A, B&gt; = A extends A ? ([B] extends [A] ? false : true) : never; IsNevernever 在条件类型中也比较特殊，如果条件类型左边是类型参数，并且传入的是 never，那么直接返回 never。 123456type TestNever&lt;T&gt; = T extends number ? 1 : 2;// 如下会返回 nevertype result = TestNever&lt;never&gt;;// 正确的 IsNevertype IsNever&lt;T&gt; = [T] extends [never] ? true : false; 除此之外，any 在条件类型中也比较特殊，如果类型参数为 any，会直接返回 trueType 和 falseType 的合并。 123type TestAny&lt;T&gt; = T extends number ? 1 : 2;// 如下会返回 1 | 2type result = TestAny&lt;any&gt;; IsTuple元组类型的 length 是数字字面量，而数组的 length 是 number。 123456789type IsTuple&lt;T&gt; = T extends [...infer Eles] ? NotEqual&lt;Ele[&quot;length&quot;], number&gt; : false;type NotEqual&lt;A, B&gt; = (&lt;T&gt;() =&gt; T extends A ? 1 : 2) extends &lt; T&gt;() =&gt; T extends B ? 1 : 2 ? false : true; UnionToIntersection联合类型转交叉类型。 12345type UnionToIntersecion&lt;U&gt; = (U extends U ? (x: U) =&gt; unknown : never) extends ( x: infer R) =&gt; unknown ? R : never; GetOptional提取索引类型中的可选索引。 123456type GetOptional&lt;Obj extends Record&lt;string, any&gt;&gt; = &#123; [Key in keyof Obj as &#123;&#125; extends Pick&lt;Obj, Key&gt; ? Key : never]: Obj[Key];&#125;;// Pick 是 TS 内置高级类型type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P] &#125;; GetRequired提取索引类型中的非可选索引构造成新的索引类型。 123type GetRequired&lt;Obj extends Record&lt;string, any&gt;&gt; = &#123; [Key in keyof Obj as &#123;&#125; extends Pick&lt;Obj, Key&gt; ? never : Key]: Obj[Key];&#125;; RemoveIndexSignature过滤掉索引类型中的可索引签名，构造成一个新的索引类型。索引签名的特性：索引签名不能构造成字符串字面量类型，因为它没有名字，而其他索引可以 123type RemoveIndexSignature&lt;Obj extends Record&lt;string, any&gt;&gt; = &#123; [Key in keyof Obj as Key extends `$&#123;infer Str&#125;` ? Str : never]: Obj[Key];&#125;; ClassPublicProps过滤 class 的 public 属性。根据特性：keyof 只能拿到 class 的 public 索引，private 和 protected 的索引会被忽略。 123type ClassPublicProps&lt;Obj extends Record&lt;string, any&gt;&gt; = &#123; [Key in keyof Obj]: Obj[Key];&#125;; as constTypeScript 默认推导出来的类型并不是字面量类型。 123456789const obj = &#123; a: 1, b: 2,&#125;;type objType = typeof obj;// type objType = &#123;// a: number;// b: number// &#125; 如果想要推到出字面量，就需要用 as const： 1234567const arr = [1, 2, 3];type arrType = typeof arr;// type arrType = number[];const arr2 = [1, 2, 3] as const;type arrType2 = typeof arr2;// type arrType2 = readonly [1, 2, 3]; 反转 3 个元素的元组类型，需要加上 readonly 才能匹配成功。 123type ReverseArr&lt;Arr&gt; = Arr extends readonly [infer A, infer B, infer C] ? [C, B, A] : never; 练一练实现 ParseQueryString将 ‘a=1&amp;b=2&amp;c=3’ 转成 {a: 1, b: 2, c: 3} 123456789101112131415161718192021222324252627282930type ParseQueryString&lt;Str extends string&gt; = Str extends `$&#123;infer Param&#125;&amp;$&#123;infer Rest&#125;` ? MergeParams&lt;ParseParams&lt;Param&gt;, ParseQueryString&lt;Rest&gt;&gt; : ParseParam&lt;Str&gt;;type ParseParams&lt;Param extends string&gt; = Param extends `$&#123;infer Key&#125;=$&#123;infer Value&#125;` ? &#123; [K in Key]: Value; &#125; : Record&lt;string, any&gt;;type MergeParams&lt; OneParam extends Record&lt;string, any&gt;, OtherParam extends Record&lt;string, any&gt;&gt; = &#123; [Key in keyof OneParam | keyof OtherParam]: Key extends keyof OneParam ? Key extends keyof OtherParam ? MergeValue&lt;OneParam[Key], OtherParam[Key]&gt; : OneParam[Key] : Key extends keyof OtherParam ? OtherParam[Key] : never;&#125;;type MergeValue&lt;One, Other&gt; = One extends Other ? One : Other extends unknown[] ? [One, ...Other] : [One, Other]; TS 内置的高级类型Parameters提取函数类型的参数类型 12345type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends ( ...args: infer P) =&gt; any ? P : never; ReturnType提取函数类型的返回值类型 12345type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends ( ...args: any) =&gt; infer R ? R : never; ConstructorParameters提取构造函数的参数类型 12345type ConstructorParameters&lt;T extends new (...ars: any) =&gt; any&gt; = T extends new ( ...args: infer P) =&gt; any ? P : never; InstanceType提取构造器返回值类型 12345type InstanceType&lt;T extends new (...ars: any) =&gt; any&gt; = T extends new ( ...ars: any) =&gt; infer R ? R : any; ThisParameterType提取函数参数中 this 的类型 123type ThisParameterType&lt;T&gt; = T extends (this: infer U, ...args: any[]) =&gt; any ? U : unknown; OmitThisParameter去除函数参数中的 this 类型，并且返回一个新的类型 123456type OmitThisParameter&lt;T&gt; = unknown extends ThisParameterType&lt;T&gt; ? T : T extends (...args: infer A) =&gt; infer R ? （...args: A） =&gt; infer R : T; Partial把索引类型的所有索引变成可选类型 123type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;; Required把索引类型里可选索引改成必选索引 123type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P];&#125;; Readonly索引类型的索引添加只读 123type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125;; Pick过滤出指定的索引类型 123type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P];&#125;; Record创建索引类型 keyof any 会返回 string | number | symbol 123type Record&lt;K extends keyof any, T&gt; = &#123; [P in K]: T;&#125;; 如果 Record 里的第一个参数是 string | number | symbol，那么创建的就是索引签名索引类型： 1234type RecordRes = Record&lt;string, number&gt;;// RecordRes = &#123;// [x: string]: number;// &#125; Exclude去掉联合类型中的某些类型，即取差集 联合类型当作为类型参数出现在条件类型左边时，会被分散成单个类型传入，这叫做分布式条件类型。 1type Exclude&lt;T, U&gt; = T extends U ? never : T; Extract提取联合类型中的某些类型，即取交集 1type Extract&lt;T, U&gt; = T extends U ? T : never; Omit去掉某部分索引类型的索引构成新索引类型 1type Omit&lt;T, K in keyof any&gt; = Pick&lt;T, EXclude&lt;keyof T, K&gt;&gt;; Awaited提取 Promise 的返回值类型 12345678type Awaited&lt;T&gt; = T extends null | undefined ? T : T extends object &amp; &#123; then(onfulfilled: infer F): any&#125; ? F extends ((value, infer V, ...ars: any) =&gt; any) ? Awaited&lt;V&gt; : never : T; NonNullable判断是否是空类型，即不是 null 或 undefined 1type NonNullable&lt;T&gt; = T extends null | unfefined ? never : T; Uppercase、Lowercase、Capitalize、Uncapitalize这几个类型分别是实现大写、小写、首字母大写、去掉首字母大写的。他们的实现是直接用 js 实现的。 综合实战KebabCaseToCamelCase‘aa-bb-cc’ 这种是 KebabCase，而 ‘aaBbCc’ 这种是 CamelCase 1234type KebabCaseToCamelCase&lt;Str extends string&gt; = Str extends `$&#123;infer Item&#125;-$&#123;infer Rest&#125;` ? `$&#123;Item&#125;$&#123;KebabCaseToCamelCase&lt;Capitalize&lt;Rest&gt;&gt;&#125;` : Str; CamelCaseToKebabCase123456type CamelCaseToKebabCase&lt;Str extends string&gt; = Str extends `$&#123;infer First&#125;$&#123;infer Rest&#125;` ? First extends Lowercase&lt;First&gt; ? `$&#123;First&#125;$&#123;CamelCaseToKebabCase&lt;Rest&gt;&#125;` : `-$&#123;Lowercase&lt;First&gt;&#125;$&#123;CamelCaseToKebabCase&lt;Rest&gt;&#125;` : Str; Chunk对数组做分组，比如 1、2、3、4、5 的数组，每两个为 1 组，那就可以分为 1、2 和 3、4 以及 5 这三个 Chunk。 12345678910type Chunk&lt; Arr extends unknown[], ItemLen extends number, CurItem extends unknown[] = [], Res extends unknown[] = []&gt; = Arr extends [infer First, ...infer Rest] ? CurItem[&quot;length&quot;] extends ItemLen ? Chunk&lt;Rest, ItemLen, [First], [...Res, CurItem]&gt; : Chunk&lt;Rest, ItemLen, [...CurItem, First], Res&gt; : [...Res, CurItem]; TupleToNestedObject根据数组类型，比如 [‘a’, ‘b’, ‘c’] 的元组类型，再加上值的类型 ‘xxx’，构造出这样的索引类型： 1234567&#123; a: &#123; b: &#123; c: &quot;xxx&quot;; &#125; &#125;&#125; 123456789101112type TupleToNestedObject&lt;Tuple extends unknown[], ValueType&gt; = Tuple extends [ infer First, ...infer Rest] ? &#123; [Key in First as Key extends keyof any ? Key : never]: Rest extends unknown[] ? TupleToNestedObject&lt;Rest, ValueType&gt; : ValueType; &#125; : ValueType; PartialObjectPropByKeys把一个索引类型的某些 Key 转为 可选的，其余的 Key 不变。 1234567891011type PartialObjectPropByKeys&lt; Obj extends Record&lt;string, any&gt;, Key extends keyof any&gt; = Partial&lt;Pick&lt;Obj, Extract&lt;keyof Obj, Key&gt;&gt;&gt; &amp; Omit&lt;Obj, Key&gt;;type PartialObjectPropByKeys2&lt; Obj extends Record&lt;string, any&gt;, KeyType extends keyof any&gt; = &#123; [Key in keyof Obj as Key extends KeyType ? Key? : Key]: Obj[Key];&#125;; 函数重载的三种写法第一种 12345function add(a: number, b: number): number;function add(a: string, b: string): string;function add(a: any, b: any) &#123; return a + b;&#125; 第二种 12345interface Func &#123; (a: number, b: number): number; (a: string, b: string): string;&#125;const add: Func = (a: any, b: any) =&gt; a + b; 第三种 12type Func = ((a: number, b: number) =&gt; number) &amp; ((a: string, b: string): string)const add: Func = (a: any, b: any) =&gt; a + b; UnionToTuple将联合类型转成元组。 123456789101112type UnionToTuple&lt;T&gt; = UnionToIntersection&lt; T extends any ? () =&gt; T : never&gt; extends () =&gt; infer ReturnType ? [...UnionToTuple&lt;Exclude&lt;T, ReturnType&gt;&gt;, ReturnType] : [];// 联合转交叉type UnionToIntersection&lt;U&gt; = ( U extends U ? (x: U) =&gt; unknown : never) extends (x: infer R) =&gt; unknown ? R : never; join实现一个类似的效果，将： 12const res = join(&quot;-&quot;)(&quot;guang&quot;, &quot;and&quot;, &quot;dong&quot;);// 转成 res = &#x27;guang-and-dong&#x27; join 代码实现 123456789101112131415declare function join&lt;Delimiter extends string&gt;( delimiter: Delimiter): &lt;Items extends string[]&gt;(...parts: Items) =&gt; JoinType&lt;Items, Delimiter&gt;;type JoinType&lt; Items extends any[], Delimiter extends string, Result extends string = &quot;&quot;&gt; = Items extends [infer First, ...infer Rest] ? JoinType&lt;Rest, Delimiter, `$&#123;Result&#125;$&#123;First &amp; string&#125;-`&gt; : RemoveLastDelimiter&lt;Result&gt;;type RemoveLastDelimiter&lt;Str extends string&gt; = Str extends `$&#123;infer Rest&#125;-` ? Rest : Str; AllKeyPath拿到一个索引类型的所有 key 的路径。 1234567type AllKeyPath&lt;Obj extends Record&lt;string, any&gt;&gt; = &#123; [Key in keyof Obj]: Key extends string ? Obj[Key] extends Record&lt;string, any&gt; ? Key | `$&#123;Key&#125;.$&#123;AllKeyPath&lt;Obj[Key]&gt;&#125;` : Key : never;&#125;[keyof Obj]; Defaultize实现这样一个高级类型，对 A、B 两个索引类型做合并，如果是只有 A 中有的不变，如果是 A、B 都有的就变为可选，只有 B 中有的也变为可选。 123type Defaultize&lt;A, B&gt; = Pick&lt;A, Exclude&lt;keyof A, keyof B&gt;&gt; &amp; Partial&lt;Pick&lt;A, Extract&lt;keyof A, keyof B&gt;&gt;&gt; &amp; Partial&lt;Pick&lt;B, Exclude&lt;keyof B, keyof A&gt;&gt;&gt;; infer extends枚举值转联合类型以下会把枚举的数值类型转成字符串类型。 1234567enum Code &#123; a = 111, b = 222, c = &quot;abc&quot;,&#125;type res = `$&#123;Code&#125;`;// res = &#x27;111&#x27; | &#x27;222&#x27; | &#x27;abc&#x27; StrToNum使用 infer extends 后就就可以正常使用了。 12345678enum Code &#123; a = 111, b = 222, c = &quot;abc&quot;,&#125;type StrToNum&lt;Str&gt; = Str extends `$&#123;infer Num extends number&#125;` ? Num : Str;type res = StrToNum&lt;`$&#123;Code&#125;`&gt;;// res = &#x27;abc&#x27; | 111 | 222","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://bubuzou.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://bubuzou.com/tags/TypeScript/"}]},{"title":"微前端的几种架构介绍","slug":"micro-desc","date":"2024-02-02T02:19:26.000Z","updated":"2024-06-14T12:56:30.317Z","comments":true,"path":"2024/02/02/micro-desc/","link":"","permalink":"https://bubuzou.com/2024/02/02/micro-desc/","excerpt":"什么是微前端而提到微前端就离不开微服务，大家对微服务都比较熟悉了，微服务允许后端体系结构通过松散耦合的代码库进行扩展，每个代码库负责自己的业务逻辑，并公开一个 API，每个 API 均可独立部署，并且各自由不同的团队拥有和维护。 前端架构经历了从单体，到前后端分离，再到微服务，最终发展到现在的微前端的过程如下图所示： 微前端的思路是把微服务的架构引入到前端，其核心都是要能够以业务为单元构建端到端的垂直架构，使得单个的团队能够独立自主的进行相关的开发，同时又具备相当的灵活性，按需求来组成交付应用。 “微前端”一词最早于 2016 年底在 ThoughtWorks 技术雷达中提出的。它将微服务的概念扩展到了前端世界。微前端的核心思路其实是远程应用程序，包含组件／模块／包的运行时加载。","text":"什么是微前端而提到微前端就离不开微服务，大家对微服务都比较熟悉了，微服务允许后端体系结构通过松散耦合的代码库进行扩展，每个代码库负责自己的业务逻辑，并公开一个 API，每个 API 均可独立部署，并且各自由不同的团队拥有和维护。 前端架构经历了从单体，到前后端分离，再到微服务，最终发展到现在的微前端的过程如下图所示： 微前端的思路是把微服务的架构引入到前端，其核心都是要能够以业务为单元构建端到端的垂直架构，使得单个的团队能够独立自主的进行相关的开发，同时又具备相当的灵活性，按需求来组成交付应用。 “微前端”一词最早于 2016 年底在 ThoughtWorks 技术雷达中提出的。它将微服务的概念扩展到了前端世界。微前端的核心思路其实是远程应用程序，包含组件／模块／包的运行时加载。 如上图，对于用户而言，访问的是一个微前端的容器（container），容器加载运行在远程服务上的应用，把这些远程应用作为组件／模块／包在本地浏览器中加载。 组件是底层 UI 库的构建单元； 模块是相应运行时的构建单元； 包是依赖性解析器的构建单元； 微前端是所提出的应用程序的构建块。 上面说了很多，总结一下就是：微前端（Micro-Frontends）是一种类似于微服务的架构，他将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立开发、独立部署、独立运行。微前端不是单纯的前端框架或者工具，而是一套架构体系。 为什么需要微前端在前面我们看到的微前端之前的架构，所有的前端还是一个单体，前端团队会依赖所有的服务或者后台的 API，前端开发会成为整个系统的瓶颈。使用微前端，就是要让前端业务从水平分层变为垂直应用的一部分，进入业务团队，剥离耦合。 那么微前端有什么好处，为什么要采用微前端架构呢？ 各个团队独立开发，相互不影响，独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新； 增量升级，在面对各种复杂场景时，通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略。因为是运行时加载，可以在没有重建的情况下添加，删除或替换前端的各个部分； 不受技术影响，每个团队都应该能够选择和升级其技术栈，而无需与其他团队进行协调。也就是说 A 应用可以用 React，而 B 应用使用 Vue，大家可以通过同一个基座应用来加载； 独立运行时，每个微应用之间状态隔离，运行时状态不共享。隔离团队代码，即使所有团队都使用相同的框架，也不要共享运行时。构建自包含的独立应用程序。不要依赖共享状态或全局变量； 建立团队命名空间，对于 CSS，事件，本地存储和 Cookies，可以避免冲突并阐明所有权。 因此，微前端和微服务的本质都是关于去耦合。而只有当应用程序达到一定规模时，这才开始变得更有意义。 如何实现微前端架构微前端不是一个库，是一种前端架构的设计思路，要实现微前端，本质上就是在运行时远程加载应用。如下列了一些实现方案，但不仅仅只是这样： 纯 nginx 路由转发； 使用 iframe 创建容器； 组合式应用路由分发； 使用 Web Components 技术构建； Module Federation； 纯 nginx 路由转发即通过路由将不同的业务分发到不同的、独立前端应用上。其通常可以通过 HTTP 服务器的反向代理来实现。这种方案，不涉及前端的改造，完全是依靠运维层面的配置。 当在浏览器里访问 www.nrp.com/app1 的时候，其实访问的是 app1 这个应用；当访问 www.nrp.com/app2 的时候，其实访问的是 app2 这个应用。要实现这个功能，就可以用 nginx 的反向代理来实现路由分发： 12345678910111213141516http &#123; server &#123; listen 80; server_name www.nrp.com; location &#x2F; &#123; root &#x2F;www&#x2F;wwwroot&#x2F;www.nrp.com&#x2F;; index index.html index.htm; &#125; location &#x2F;app1 &#123; proxy_pass http:&#x2F;&#x2F;www.app1.com&#x2F;; &#125; location &#x2F;app2 &#123; proxy_pass http:&#x2F;&#x2F;www.app2.com&#x2F;; &#125; &#125;&#125; 通过 http 服务分发不同的路由到不同的独立应用上，虽然实现上很简单，但是缺点也相当明显： 每一次切换应用的时候都会重新请求资源，没办法做到局部更新当前页面，就相当于是刷新了浏览器，完全丢失了单页应用的体验； 需要配置一个通用可扩展的路由规则，否则当引入新的应用的时候，还需要修改 nginx 的路由配置； 使用 iframe 创建容器HTML 内联框架元素 &lt;iframe&gt; 表示嵌套的正在浏览的上下文，能有效地将另一个 HTML 页面嵌入到当前页面中。 1&lt;iframe src=&quot;http://www.baidu.com/&quot;&gt;&lt;/iframe&gt; iframe 可以创建一个全新的独立的宿主环境，这意味着我们的前端应用之间可以相互独立运行。通过给 iframe 的 src 指定不同的地址，来实现加载不同的子应用。 1234567&lt;template v-for=&quot;app in appList&quot;&gt; &lt;iframe v-show=&quot;currAppCode == app.code&quot; :key=&quot;app.code&quot; :src=&quot;app.src&quot; &gt;&lt;/iframe&gt;&lt;/template&gt; 使用 iframe 来加载不同的微应用，接入非常简单，且由于 iframe 天然的沙箱环境使得 js 和样式隔离都非常完美。但他存在以下一些问题： 页面加载问题：iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载，阻塞 onload 事件。相比于 SPA 加载会更慢； 布局问题：iframe 必须给一个指定的高度，否则会塌陷。另外有些时候会出现多个滚动条，用户体验不佳； 弹窗及遮罩层问题：弹窗只能在 iframe 区域进行展示，没办法在浏览器视口里显示，导致的问题是，弹窗遮罩无法覆盖浏览器视口且弹窗位置可能没有垂直水平居中； 浏览器记录和前进后退问题：iframe 和主页面共用浏览器记录，导致前进后退的时候不能切换不同的应用；刷新页面无法保存当前状态，比如访问一个微应用的列表页，当从列表页点击进入详情，此时刷新浏览器，会加载列表页 组合式应用路由分发这个方案和第一种方案很像，都是需要通过 nginx 来将路由分发到不同的应用上，可以认为是它的升级版，区别是这种方式的系统在运行时将由主应用来进行路由管理，子应用的加载、启动、卸载以及通信都需要依靠主应用来完成。 这种方式的代表开源框架就是 qiankun。 作为微前端的基座应用，是整个应用的入口，负责承载当前微应用的展示和对其他路由微应用的转发，对于当前微应用的展示，一般是由以下几步构成： 作为一个 SPA 的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用 iframe 之外，要能先拉取到微应用的页面内容，这就需要远程拉取机制。 远程拉取实施的前提是需要知道拉取的地址是什么？所以就需要先在主应用里集成一套微应用的管理机制，比如说当浏览器地址匹配 /app1 的时候就去加载 app1 应用的内容，而 app1 的地址其实是动态配置到本地的映射，最终将指向一个可以独立访问的域名。 有了拉取地址之后，通常会采用 fetch API 来首先获取到微应用的 HTML 内容。然后通过解析将微应用的 JavaScript 和 CSS 进行抽离，采用 eval 方法来运行 JavaScript，并将 CSS 和 HTML 内容 append 到基座应用中留给微应用的展示区域，当微应用切换走时，可以在主应用里同步卸载这些内容，这就构成的当前应用的展示流程。 对于路由分发而言，以采用 vue-router 开发的基座 SPA 应用来举例，主要是下面这个流程： 当浏览器的路径变化后，vue-router 会监听 hashchange 或者 popstate 事件，从而获取到路由切换的时机。最先接收到这个变化的是基座的 router，通过查询注册信息可以获取到转发到那个微应用，经过一些逻辑处理后，采用修改 hash 方法或者 pushState 方法来路由信息推送给微应用的路由，微应用可以是手动监听 hashchange 或者 popstate 事件接收，或者采用 React-router，vue-router 接管路由，后面的逻辑就由微应用自己控制。 使用 Web Components 技术构建Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 Web 应用中使用它们。 它主要有三项技术组件： Custom elements（自定义元素）：一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。 Shadow DOM（影子 DOM）：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。 HTML templates（HTML 模板）： &lt;template&gt; 和 &lt;slot&gt; 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。 这里有一个在线的 Web Components 示例 随后，在各自的 HTML 文件里，创建相应的组件元素，编写相应的组件逻辑。一个典型的 Web Components 应用架构如下图所示： 可以看到这边方式与我们上面使用 iframe 的方式很相似，组件拥有自己独立的 Scripts 和 Styles，以及对应的用于单独部署组件的域名。然而它并没有想象中的那么美好，要直接使用纯 Web Components 来构建前端应用的难度有： 重写现有的前端应用。是的，现在我们需要完成使用 Web Components 来完成整个系统的功能。 上下游生态系统不完善。缺乏相应的一些第三方控件支持，这也是为什么 jQuery 相当流行的原因。 系统架构复杂。当应用被拆分为一个又一个的组件时，组件间的通讯就成了一个特别大的麻烦。 Web Components 中的 ShadowDOM 更像是新一代的前端 DOM 容器。而遗憾的是并不是所有的浏览器，都可以完全支持 Web Components。 MicroApp 借鉴了 Web Component 的思想，通过 CustomElement 结合自定义的 ShadowDom，将微前端封装成一个类 Web Component 组件，从而实现微前端的组件化渲染。 Module FederationModule Federation 是 webpack 5 中的一个新特性，能轻易实现在两个使用 webpack 构建的项目之间共享代码，通俗点讲，Module Federation 提供了能在当前应用加载其他应用的能力。这就为实现微前端提供了另一种可能。 EMP 就是基于这个特性研发出来的微前端解决方案。 对于 Module Federation，它有几个概念： local module（本地模块）：就是普通模块，对于某个项目而言，每次构建就都是产生本地模块的过程； remote module（远程模块）：远程模块不属于当前构建，并在运行时从所谓的容器加载；加载远程模块被认为是异步操作，通常可以通过调用 import() 实现； container（容器）：每个构建都充当一个容器，也可将其他构建作为容器。通过这种方式，每个构建都能够通过从对应容器中加载模块来访问其他容器暴露出来的模块。 shared module（共享模块）：共享模块是指既可重写的又可作为向嵌套容器提供重写的模块。它们通常指向每个构建中的相同模块，例如相同的库。 所以，当前模块想要加载其他模块，就要有一个引入动作，同样，如果想让其他模块使用，就需要有一个导出动作。通过以下 2 个 webpack 插件配置参数可以实现模块的导入和导出。 expose：导出应用，被其他应用导入； remote：引入其他应用； 这与基座模式完全不同，像 iframe 和 qiankun 都是需要一个基座（中心容器）去加载其他子应用。而 Module Federation 任意一个模块都可以引用其他应用，同时也可以导出被其他应用使用，这就没有了容器中心的概念。 想要使用 Module Federation 功能需要引入 webpack 5 中内置的插件 ModuleFederationPlugin，通过配置该插件来完成。比如 base 应用需要引入 expose 应用里导出的 HelloWorld 模块，可以这样配置： expose 的 vue.config.js： 123456789101112new webpack.container.ModuleFederationPlugin(&#123; name: &quot;app_expose&quot;, filename: &quot;remoteEntry.js&quot; exposes: &#123; &quot;./HelloWorld.vue&quot;: &quot;./src/components/HelloWorld.vue&quot;, &#125;, shared: &#123; vue: &#123; singleton: true, &#125;, &#125;,&#125;), base 应用的 vue.config.js： 123456789101112new webpack.container.ModuleFederationPlugin(&#123; name: &quot;app_base&quot;, filename: &quot;remoteEntry.js&quot;, remotes: &#123; app_expose: &quot;app_expose@http://localhost:8082/remoteEntry.js&quot;, &#125;, shared: &#123; vue: &#123; singleton: true, &#125;, &#125;,&#125;), 使用 expose 应用的 HelloWorld 模块： 1234567891011121314151617&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot; /&gt; &lt;HelloWorld msg=&quot;Welcome to Your Vue.js&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;js&quot;&gt; import &#123; defineComponent &#125; from &quot;vue&quot;; import HelloWorld from &quot;app_expose/HelloWorld.vue&quot;; export default defineComponent(&#123; name: &#x27;HomeView&#x27;, components: &#123; HelloWorld &#125;, &#125;)&lt;/script&gt; webpack 5 与之前版本的模块管理对比图： 微前端的问题和缺点讲了这么多的优点和实现，那么微前端是不是解决前端开发问题的银弹呢？当然不是。所有的架构都是取舍和权衡，这个世界上并不存在银弹，微前端架构和微服务一样也存在他的弊端，单体架构未必就差。 微前端的构建通常比较复杂，从工具，打包，到部署，微前端都是更为复杂的存在，天下没有免费的午餐，对于小型项目，它的成本太高； 每个团队可以使用不同的框架，这个听上去很美，但是实际操作起来，除了要支持历史遗留的应用，它的意义不大。同时也为带来体验上的问题。可以远程加载不同的框架代码是一回事，把它们都用好是另一回事； 性能上来看，如果优化得不好微前端的性能可能会存在问题，至少微前端框架是额外的一层加载。如果不同的微前端使用了不同的框架，那么每一个框架都需要额外的加载； 微前端架构还在不断发展之中，本文提到的 nginx / iframe／ qiankun／Web Components / Module Federation 只是诸多解决方案中的一小部分，前端的发展变化和生态系统实在是丰富，相信未来会有更多以及更好用的微前端架构的出现。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"微前端","slug":"微前端","permalink":"https://bubuzou.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"}]},{"title":"git clone 的时候如何通过 SSH 链接来下载远程项目","slug":"git-clone-over-ssh","date":"2023-10-11T02:19:26.000Z","updated":"2024-06-14T13:05:58.378Z","comments":true,"path":"2023/10/11/git-clone-over-ssh/","link":"","permalink":"https://bubuzou.com/2023/10/11/git-clone-over-ssh/","excerpt":"当我们需要从 github 下载项目的时候，它提供了 2 种下载链接： 12https://github.com/ant-design/ant-design.gitgit@github.com:ant-design/ant-design.git 上面 2 种下载链接分别使用了 HTTPS 和 SSH 协议。那么这两种协议有什么区别呢？ 访问控制：SSH 协议使用公钥和私钥来进行身份验证，因此你需要在远程主机上安装你的公钥。只有拥有私钥的用户才能进行身份验证和访问。相反，HTTPS 协议使用用户名和密码进行身份验证。git clone 或 git fetch 的时候，如果使用 HTTPS 链接则不需要进行身份验证，而 SSH 链接需要。 传输速度：SSH 协议在传输数据时进行压缩，因此它可以在传输大量数据时比 HTTPS 更快。此外，SSH 协议通常可以在传输数据时使用更少的带宽，这对于连接速度较慢的网络非常有用。 防火墙限制： 某些公司或组织可能会在防火墙中阻止对 SSH 端口的访问，这可能会使 SSH 协议无法使用。另一方面，HTTPS 协议通常可以通过防火墙，因为它使用标准的 Web 端口 80 和 443。 想要通过 SSH 链接来下载项目，需要在客户端和服务器之间配置 SSH key，那么如何做呢？下面以 github 为例来说明具体步骤。 1. 在本地生成 SSH key1ssh-keygen -t ed25519 -C &quot;user@example.com&quot;","text":"当我们需要从 github 下载项目的时候，它提供了 2 种下载链接： 12https://github.com/ant-design/ant-design.gitgit@github.com:ant-design/ant-design.git 上面 2 种下载链接分别使用了 HTTPS 和 SSH 协议。那么这两种协议有什么区别呢？ 访问控制：SSH 协议使用公钥和私钥来进行身份验证，因此你需要在远程主机上安装你的公钥。只有拥有私钥的用户才能进行身份验证和访问。相反，HTTPS 协议使用用户名和密码进行身份验证。git clone 或 git fetch 的时候，如果使用 HTTPS 链接则不需要进行身份验证，而 SSH 链接需要。 传输速度：SSH 协议在传输数据时进行压缩，因此它可以在传输大量数据时比 HTTPS 更快。此外，SSH 协议通常可以在传输数据时使用更少的带宽，这对于连接速度较慢的网络非常有用。 防火墙限制： 某些公司或组织可能会在防火墙中阻止对 SSH 端口的访问，这可能会使 SSH 协议无法使用。另一方面，HTTPS 协议通常可以通过防火墙，因为它使用标准的 Web 端口 80 和 443。 想要通过 SSH 链接来下载项目，需要在客户端和服务器之间配置 SSH key，那么如何做呢？下面以 github 为例来说明具体步骤。 1. 在本地生成 SSH key1ssh-keygen -t ed25519 -C &quot;user@example.com&quot; 这里我把 &#117;&#x73;&#101;&#x72;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d; 替换成了我的 github.com 的邮箱。执行完后可能会有如下提示，不用管直接按回车即可。 12Generating public/private ed25519 key pair.Enter file in which to save the key (/home/johndoe/.ssh/id_ed25519): 12Enter passphrase (empty for no passphrase):Enter same passphrase again: 最后你会发现会打印这么一串信息： 12345678910111213SHA256:ToTEp33dDV8Sokslnx568DC5ABPQTmvlBjGx+r/W0k8 user@example.com The key&#x27;s randomart image is: +--[ED25519 256]--+ |o.+o .. | |. +o....+ | | +.= .o. | |o.+ o . . . | |o+ . . .So . | |*. oo+ o . | |o*. o =E= o | |ooo.o =..o o | |.o+o++ .. | +----[SHA256]-----+ 然后你就会发现在 .ssh 目录下多了 2 个文件： 12$ ls ~/.sshid_ed25519 id_ed25519.pub 2. 为你的 github 账户添加一个公共的 key上面已经在本地生成好了 SSH key，现在就要把这个 key 的内容贴到 github 账户里。 执行如下命令后，会在终端打印 key 的内容，可以选中它们然后复制。 1cat ~/.ssh/id_ed25519.pub 然后按照如下顺序把 key 的内容贴到 github 的账户里。 Log in to your GitHub account. Navigate to “Settings”. Click on “SSH and GPG keys” in the left menu. Click on the “New SSH key” button. 3. 测试是否可用接下来就可以找个 github 仓库，复制 SSH 的地址进行 clone 了： 1git clone git@github.com:ant-design/ant-design.git --depth=1 4. 为 SSH 代理指定 SSH key如果您不想每次 git 使用 SSH 键时输入密码，则可以将键添加到 SSH 代理管理的键列表中。 1eval &quot;$(ssh-agent -s)&quot; 然后： 1ssh-add ~/.ssh/id_ed25519 但是每次电脑重启后，如上设置就会失效，需要重新设置。","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"git","slug":"git","permalink":"https://bubuzou.com/tags/git/"}]},{"title":"从 ESLint 开始，说透我如何在团队项目中基于 Vue 做代码校验","slug":"eslint","date":"2021-06-16T02:23:14.000Z","updated":"2024-06-12T09:26:57.287Z","comments":true,"path":"2021/06/16/eslint/","link":"","permalink":"https://bubuzou.com/2021/06/16/eslint/","excerpt":"最近遇到了一个老项目，比较有意思的是这个项目集前后端的代码于一起，而后端也会去修改前端代码，所以就出现了后端用 IntelliJ IDEA 来开发前端项目，而前端用 VSCode 来开发前端项目的情况。于是乎，出现了代码规范的问题，所以就有了这篇文章，整理了一下前端代码校验以及在 Vue 项目中的实践。 阅读完这篇文章，你可以收获： 能够自己亲手写出一套 ESLint 配置； 会知道业界都有哪些著名的 JS 代码规范，熟读它们可以让你写出更规范的代码； vue-cli 在初始化一个包含代码校验的项目时都做了什么； Prettier 是什么？为什么要使用它？如何与 ESLint 配合使用？ EditorConfig 又是什么？如何使用？ 如何在 VSCode 中通过插件来协助代码校验工作； 如何保证 push 到远程仓库的代码是符合规范的；","text":"最近遇到了一个老项目，比较有意思的是这个项目集前后端的代码于一起，而后端也会去修改前端代码，所以就出现了后端用 IntelliJ IDEA 来开发前端项目，而前端用 VSCode 来开发前端项目的情况。于是乎，出现了代码规范的问题，所以就有了这篇文章，整理了一下前端代码校验以及在 Vue 项目中的实践。 阅读完这篇文章，你可以收获： 能够自己亲手写出一套 ESLint 配置； 会知道业界都有哪些著名的 JS 代码规范，熟读它们可以让你写出更规范的代码； vue-cli 在初始化一个包含代码校验的项目时都做了什么； Prettier 是什么？为什么要使用它？如何与 ESLint 配合使用？ EditorConfig 又是什么？如何使用？ 如何在 VSCode 中通过插件来协助代码校验工作； 如何保证 push 到远程仓库的代码是符合规范的； 下面开始阅读吧，如果你对 ESLint 比较熟悉，可以直接跳过这个部分。 ESLint 是什么ESLint 是一个集代码审查和修复的工具，它的核心功能是通过配置一个个规则来限制代码的合法性和风格。 配置解析器和解析参数ESLint 的解析器，早期的时候用的是 Esprima，后面基于 Esprima v1.2.2 版本开发了一个新的解析器 Espree，并且把它当做默认解析器。 除了使用 ESLint 自带的解析器外，还可以指定其他解析器： @babel/eslint-parser：使 Babel 和 ESLint 兼容，对一些 Babel 语法提供支持； @typescript-eslint/parser：TSLint 被弃用后，TypeScript 提供了此解析器用于将其与 ESTree 兼容，使 ESLint 对 TypeScript 进行支持； 为项目指定某个选择器的原则是什么？ 如果你的项目用到了比较新的 ES 语法，比如 ES2021 的 Promise.any()，那就可以指定 @babel/eslint-parser 为解析器； 如果项目是基于 TS 开发的，那就使用 @typescript-eslint/parser； 如果你对 ES 最新标准还不熟悉，可以看看这篇文章：送你一份精心总结的 3 万字 ES6 实用指南（下） 除了指定解析器 parser 外，还可以额外配置解析器参数 parserOption： 123456789101112131415161718192021&#123; // ESLint 默认解析器，也可以指定成别的 parser: &quot;espree&quot;, parserOption: &#123; // 指定要使用的 ECMAScript 版本，默认值 5 ecmaVersion: 5, // 设置为 script (默认) 或 module（如果你的代码是 ECMAScript 模块) sourceType: &quot;script&quot;, // 这是个对象，表示你想使用的额外的语言特性,所有选项默认都是 false ecmafeatures: &#123; // 是否允许在全局作用域下使用 return 语句 globalReturn: false, // 是否启用全局 strict 模式（严格模式） impliedStrict: false, // 是否启用JSX jsx: false, // 是否启用对实验性的objectRest/spreadProperties的支持 experimentalObjectRestSpread: false &#125; &#125;&#125; 指定环境 env指定不同的环境可以给对应环境下提供预设的全局变量。比如说在 browser 环境下，可以使用 window 全局变量；在 node 环境下，可以使用 process 全局变量等； ESLint 中可配置的环境比较多，这里有份完整的环境列表，下面列出几个比较常见的： browser：浏览器全局变量； node：Node.js 全局变量和作用域； es6：es6 中除了模块之外的其他特性，同时将自动设置 parserOptions.ecmaVersion 参数为 6；以此类推 ES2017 是 7，而 ES2021 是 12； es2017：parserOptions.ecmaVersion 为 8； es2020：parserOptions.ecmaVersion 为 11； es2021：parserOptions.ecmaVersion 为 12； 配置方式如下： 12345678910&#123; env: &#123; browser: true, node: true, es6: true, commonjs: true, mocha: true, jquery: true, &#125;&#125; 可以指定多个环境并不意味着配置的环境越多越好，实际配置的时候还是得依据当前项目的环境来选择。 配置全局变量 globalsESLint 的一些核心规则依赖于对代码在运行时可用的全局变量的了解。 由于这些在不同环境之间可能会有很大差异，并且在运行时会进行修改，因此 ESLint 不会假设你的执行环境中存在哪些全局变量。 如果你想使用这些全局变量，那就可以通过 globals 来指定。比如在 react .eslintrc.js 里就把 spyOnDev、 spyOnProd 等变量挂在了 global 下作为全局变量： 123456&#123; globals: &#123; spyOnDev: true, spyOnProd: true, &#125;&#125; 对于它的值需要特别说明下： false、readable、readonly 这 3 个是等价的，表示变量只可读不可写； true、writeable、writable 这 3 个是等价的，表示变量可读可写； 配置扩展 extends实际项目中配置规则的时候，不可能团队一条一条的去商议配置，太费精力了。通常的做法是使用业内大家普通使用的、遵循的编码规范；然后通过 extends 去引入这些规范。extends 配置的时候接受字符串或者数组： 123456789&#123; extends: [ &#x27;eslint:recommended&#x27;, &#x27;plugin:vue/essential&#x27;, &#x27;eslint-config-standard&#x27;, // 可以缩写成 &#x27;standard&#x27; &#x27;@vue/prettier&#x27;, &#x27;./node_modules/coding-standard/.eslintrc-es6&#x27; ]&#125; 从上面的配置，可以知道 extends 支持的配置类型可以是以下几种 eslint 开头的：是 ESLint 官方的扩展； plugin 开头的：是插件类型扩展，比如 plugin:vue/essential； eslint-config 开头的：来自 npm 包，使用时可以省略前缀 eslint-config-，比如上面的可以直接写成 standard； @开头的：扩展和 eslint-config 一样，只是在 npm 包上面加了一层作用域 scope； 一个执行配置文件的相对路径或绝对路径； 那有哪些常用的、比较著名扩展可以被 extends 引入呢 eslint:recommended：ESLint 内置的推荐规则，即 ESLint Rules 列表中打了钩的那些规则； eslint:all：ESLint 内置的所有规则； eslint-config-standard：standard 的 JS 规范； eslint-config-prettier：关闭和 ESLint 中以及其他扩展中有冲突的规则； eslint-config-airbnb-base：airbab 的 JS 规范； eslint-config-alloy：腾讯 AlloyTeam 前端团队出品，可以很好的针对你项目的技术栈进行配置选择，比如可以选 React、Vue（现已支持 Vue 3.0）、TypeScript 等； 使用插件 pluginsESLint 提供插件是干嘛用的 ESLint 虽然可以定义很多的 rules，以及通过 extends 来引入更多的规则，但是说到底只是检查 JS 语法。如果需要检查 Vue 中的 template 或者 React 中的 jsx，就束手无策了。所以引入插件的目的就是为了增强 ESLint 的检查能力和范围。 如何配置插件 ESLint 相关的插件的命名形式有 2 种：不带命名空间的和带命名空间的，比如： eslint-plugin- 开头的可以省略这部分前缀； @/ 开头的； 1234567&#123; plugins: [ &#x27;jquery&#x27;, // 是指 eslint-plugin-jquery &#x27;@jquery/jquery&#x27;, // 是指 @jquery/eslint-plugin-jquery &#x27;@foobar&#x27;, // 是指 @foobar/eslint-plugin ]&#125; 当需要基于插件进行 extends 和 rules 的配置的时候，需要加上插件的引用，比如： 1234567891011121314151617&#123; plugins: [ &#x27;jquery&#x27;, // eslint-plugin-jquery &#x27;@foo/foo&#x27;, // @foo/eslint-plugin-foo &#x27;@bar, // @bar/eslint-plugin ], extends: [ &#x27;plugin:jquery/recommended&#x27;, &#x27;plugin:@foo/foo/recommended&#x27;, &#x27;plugin:@bar/recommended&#x27; ], rules: &#123; &#x27;jquery/a-rule&#x27;: &#x27;error&#x27;, &#x27;@foo/foo/some-rule&#x27;: &#x27;error&#x27;, &#x27;@bar/another-rule&#x27;: &#x27;error&#x27; &#125;,&#125; 以上配置来自 ESLint plugins 配置规则 rulesESLint 提供了大量内置的规则，这里是它的规则列表 ESLint Rules，除此之外你还可以通过插件来添加更多的规则。 规则的校验说明，有 3 个报错等级 off 或 0：关闭对该规则的校验； warn 或 1：启用规则，不满足时抛出警告，且不会退出编译进程； error 或 2：启用规则，不满足时抛出错误，且会退出编译进程； 通常规则只需要配置开启还是关闭即可；但是也有些规则可以传入属性，比如： 12345678910&#123; rules: &#123; &#x27;quotes&#x27;: [&#x27;error&#x27;, &#x27;single&#x27;], // 如果不是单引号，则报错 &#x27;one-var&#x27;: [&#x27;error&#x27;, &#123; &#x27;var&#x27;: &#x27;always&#x27;, // 每个函数作用域中，只允许 1 个 var 声明 &#x27;let&#x27;: &#x27;never&#x27;, // 每个块作用域中，允许多个 let 声明 &#x27;const&#x27;: &#x27;never&#x27;, // 每个块作用域中，允许多个 const 声明 &#125;] &#125;&#125; 如何知道某个扩展有哪些规则可以配置，以及每个规则具体限制？这里直接给出业内著名且使用比较多的规则列表的快速链接： ESLint rules，这整个列表对应 eslint:all，而打钩 ✔️ 的是 eslint:recommenmed； Prettier rules standard rules airbnb rules AlloyTeam vue rules 规则的优先级 如果 extends 配置的是一个数组，那么最终会将所有规则项进行合并，出现冲突的时候，后面的会覆盖前面的； 通过 rules 单独配置的规则优先级比 extends 高； 其他配置配置当前目录为 root ESLint 检测配置文件步骤： 在要检测的文件同一目录里寻找 .eslintrc.* 和 package.json； 紧接着在父级目录里寻找，一直到文件系统的根目录； 如果在前两步发现有 root：true 的配置，停止在父级目录中寻找 .eslintrc； 如果以上步骤都没有找到，则回退到用户主目录 ~/.eslintrc 中自定义的默认配置； 通常我们都习惯把 ESLint 配置文件放到项目根目录，因此可以为了避免 ESLint 校验的时候往父级目录查找配置文件，所以需要在配置文件中加上 root: true。 123&#123; root: true,&#125; 添加共享数据 ESLint 支持在配置文件添加共享设置，你可以添加 settings 对象到配置文件，它将提供给每一个将被执行的规则。如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置： 12345&#123; settings: &#123; sharedData: &#x27;Hello&#x27; &#125;,&#125; 参考：ESLint 配置文件.eslintrc 参数说明 针对个别文件设置新的检查规则 比如 webpack 的中包含了某些运行时的 JS 文件，而这些文件是只跑在浏览器端的，所以需要针对这部分文件进行差异化配置： 123456789101112131415overrides: [ &#123; files: [&#x27;lib/**/*.runtime.js&#x27;, &#x27;hot/*.js&#x27;], env: &#123; es6: false, browser: true, &#125;, globals: &#123; Promise: false, &#125;, parserOptions: &#123; ecmaVersion: 5, &#125;, &#125;,] 以上配置来自 webpack .eslintrc.js 如何校验上面细说了 ESLint 的各种配置项，以及针对 Vue 项目如何进行差异配置的说明。 现在我们知道了如何配置，但是你知道这些配置都是配置到哪里的吗？ 配置方式ESLint 支持 3 种配置方式： 命令行：不推荐，不做介绍； 单文件内注释：不推荐，不做介绍； 配置文件：配置文件的类型可以是好几种，比如：.js、.yml、json 等。推荐使用 .eslintrc.js； 下面通过命令来生成一个配置文件： 12345# 安装 eslintnpm i eslint -D# 初始化一个配置文件npx eslint --init 最后会在当前目录生成一个 .eslintrc.js 文件。这里就不把代码贴出来了，没参考意义。 上面我们知道了可以将配置统一写到一个配置文件里，但是你知道该如何去触发这个配置文件的校验规则嘛？ 校验单个文件12345// 校验 a.js 和 b.jsnpx eslint a.js b.js// 校验 src 和 scripts 目录npx eslint src scripts 校验别的类型的文件通常 ESLint 只能校验 JS 文件。比如需要校验 .vue 文件，光配置 vue 插件和 vue-eslint-parser 解析器是不够的，还需要让 ESLint 在查找文件的时候找到 .vue 文件。 可以通过 –ext 来指定具体需要校验的文件： 1npx eslint --ext .js,.jsx,.vue src 自动修复部分校验错误的代码rules 列表项中标识了一个扳手 🔧 图案的规则就标识该规则是可以通过 ESLint 工具自动修复代码的。如何自动修复呢？通过 –fix 即可。比如对于 ESLint Rules 里的这个 semi 规则，它就是带扳手图案的。 对于如下的 a.js 代码： 1const num = 12 当在配置文件配置了 ‘semi’: [2, ‘always’] 后，运行命令： 1npx eslint --fix a.js 校验直接就通过了，且会自动修复代码，在代码末尾自动加上分号。 把校验命令加到 package.json检验命令比较长，也难记，习惯上会把这些命名直接写到 package.json 里： 123456&#123; &quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;npx eslint --ext .js,.jsx,.vue src&quot;, &quot;lint:fix&quot;: &quot;npx eslint --fix --ext .js,.jsx,.vue src&quot; &#125;&#125; 过滤一些不需要校验的文件对于一些公共的 JS、测试脚本或者是特定目录下的文件习惯上是不需要校验的，因此可以在项目根目录通过创建一个 .eslintignore 文件来配置，告诉 ESLint 校验的时候忽略它们： 12public&#x2F;src&#x2F;main.js 除了 .eslintignore 中指定的文件或目录，ESLint 总是忽略 /node_modules/ 和 /bower_components/ 中的文件；因此对于一些目前解决不了的规则报错，但是如果又急于打包上线，在不影响运行的情况下，我们就可以利用 .eslintignore 文件将其暂时忽略。 在 Vue 项目中的实践上面把 ESLint 的几乎所有的配置参数和校验方式都详细的介绍了一遍，但是如果想在项目中落地，仅仅靠上面的知识还是不够的。下面将细说如何在 Vue 中落地代码校验。 关于如何在 Vue 中落地代码校验，一般是有 2 种情况： 通过 vue-cli 初始化项目的时候已经选择了对应的校验配置 对于一个空的 Vue 项目，想接入代码校验 其实这 2 种情况最终的校验的核心配置都是一样的，只是刚开始的时候安装的包有所区别。下面通过分析 vue-cli 配置的代码校验，来看看它到底做了哪些事情，通过它安装的包以及包的作用，我们就会知道如何在空项目中配置代码校验了。 通过 vue-cli 初始化的项目如果你的项目最初是通过 vue-cli 新建的，那么在新建的时候会让你选 是否支持 eslint； 是否开启保存校验； 是否开启提交前校验； 如果都开启了话，会安装如下几个包： eslint：前面 2 大章节介绍的就是这玩意，ESLint 出品，是代码校验的基础包，且提供了很多内置的 Rules，比如 eslint:recommended 经常被作为项目的 JS 检查规范被引入； babel-eslint：一个对 Babel 解析器的包装，使其能够与 ESLint 兼容； lint-staged：请看后面 pre-commit 部分； @vue/cli-plugin-eslint eslint-plugin-vue 下面重点介绍 @vue/cli-plugin-eslint 和 eslint-plugin-vue，说下这 2 个包是干嘛的。 @vue/cli-plugin-eslint这个包它主要干了 2 件事情： 第一件事 往 package.json 里注册了一个命令： 12345&#123; &quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;&#125; 执行这个命令之后，它会去检查和修复部分可以修复的问题。默认查找的文件是 src 和 tests 目录下所有的 .js,.jsx,.vue 文件，以及项目根目录下所有的 js 文件（比如，也会检查 .eslintrc.js）。 当然你也可以自定义的传入参数和校验文件： 1vue-cli-service lint [options] [...files] 支持的参数如下： –no-fix: 不会修复 errors 和 warnings； –max-errors [limit]：指定导致出现 npm ERR 错误的最大 errors 数量； 第二件事 增加了代码保存触发校验的功能 lintOnSave，这个功能默认是开启的。如果想要关闭这个功能，可以在 vue.config.js 里配置，习惯上只开启 development 环境下的代码保存校验功能： 123module.exports = &#123; lintOnSave: process.env.NODE_ENV === &#x27;development&#x27;,&#125; lintOnSave 参数说明： true 或者 warning：开启保存校验，会将 errors 级别的错误在终端中以 WARNING 的形式显示。默认的，WARNING 将不会导致编译失败； false：不开启保存校验； error：开启保存校验，会将 errors 级别的错误在终端中以 ERROR 的形式出现，会导致编译失败，同时浏览器页面变黑，显示 Failed to compile。 eslint-plugin-vueeslint-plugin-vue 是对 .vue 文件进行代码校验的插件。 针对这个插件，它提供了这几个扩展 plugin:vue/base：基础 plugin:vue/essential：预防错误的（用于 Vue 2.x） plugin:vue/recommended：推荐的，最小化任意选择和认知开销（用于 Vue 2.x）； plugin:vue/strongly-recommended：强烈推荐，提高可读性（用于 Vue 2.x）； plugin:vue/vue3-essential：（用于 Vue 3.x） plugin:vue/vue3-strongly-recommended：（用于 Vue 3.x） plugin:vue/vue3-recommended：（用于 Vue 3.x） 各扩展规则列表：vue rules 看到这么一堆的扩展，是不是都不知道选哪个了 代码规范的东西，原则还是得由各自的团队去磨合商议出一套适合大家的规则。不过，如果你用的是 Vue2，我这里可以推荐 2 套 extends 配置： 1234567&#123; // Vue 官方示例上的配置 extends: [&#x27;eslint:recommended&#x27;, &#x27;plugin:vue/recommended&#x27;], // 或者使用 AlloyTeam 团队那套 extends: [&#x27;alloy&#x27;, &#x27;alloy/vue&#x27;]&#125; 配置和插件对应的解析器 如果是 Vue 2.x 项目，配置了 eslint-plugin-vue 插件和 extends 后，template 校验还是会失效，因为不管是 ESLint 默认的解析器 Espree 还是 babel-eslint 都只能解析 JS，无法解析 template 的内容。 而 vue-eslint-parser 只能解析 template 的内容，但是不会解析 JS，因此还需要对解析器做如下配置： 12345678910111213&#123; parser: &#x27;vue-eslint-parser&#x27;, parserOptions: &#123; parser: &#x27;babel-eslint&#x27;, ecmaVersion: 12, sourceType: &#x27;module&#x27; &#125;, extends: [ &#x27;eslint:recommended&#x27;, &#x27;plugin:vue/recommended&#x27; ], plugins: [&#x27;vue&#x27;]&#125; 参考：eslint-plugin-vue faq 让 Prettier 管控代码风格针对 Prettier 不得不提出以下疑问？ Prettier 是什么？ 为什么有了 ESLint，还需要引入 Prettier 呢？它两之间有什么区别？ 如何配置 Prettier？ Prettier 如何和 ESLint 结合使用？ Prettier 是什么用它自己的话来说：我是一个自以为是的代码格式化工具，而且我支持的文件类型很多，比如： JavaScript（包括实验中的特性） JSX Vue TypeScript CSS、Less、SCSS HTML JSON Markdown 以及还有一些其他类型的文件。 Prettier 对比 ESLint我们知道 ESLint 负责了对代码的校验功能，并且主要提供了 2 类规则： 检查格式化的规则 检查代码质量的规则 说到底 ESLint 就是通过一条条的规则去限制代码的规范，但是这些规则毕竟是有限的，而且更重要的是这些规则的重点并不在代码风格上，所以单凭 ESLint 并不能完全的统一代码风格。 这个时候就需要引入 Prettier 了，因为它干的事就是只管代码格式化，不管代码质量。 Prettier：在代码风格这一块，我一直拿捏的死死的。 如何配置 Prettier初始化操作： 12345678# 安装包npm i prettier -D# 新建 .prettierrc.jsecho module.exports = &#123;&#125; &gt; .prettierrc.js# 新建 .prettierignoreecho &gt; .prettierignore Prettier 支持可以配置参数不多，总共才 21 个，这里是所有参数的说明 prettier options 所有参数都有默认值，也就是说即使你没有配置 .prettierrc.js，当你用 Prettier 去格式化代码的时候全部都会走默认配置。针对个别参数，你不想用默认设置的话，就可以在 .prettierrc.js 配置具体想要的值。 如下，把项目中会用到的参数进行一个说明： 12345678910111213141516module.exports = &#123; printWidth: 80, //（默认值）单行代码超出 80 个字符自动换行 tabWidth: 2, //（默认值）一个 tab 键缩进相当于 2 个空格 useTabs: true, // 行缩进使用 tab 键代替空格 semi: false, //（默认值）语句的末尾加上分号 singleQuote: true, // 使用单引号 quoteProps: &#x27;as-needed&#x27;, //（默认值）仅仅当必须的时候才会加上双引号 jsxSingleQuote: true, // 在 JSX 中使用单引号 trailingComma: &#x27;all&#x27;, // 不用在多行的逗号分隔的句法结构的最后一行的末尾加上逗号 bracketSpacing: true, //（默认值）在括号和对象的文字之间加上一个空格 jsxBracketSameLine: true, // 把 &gt; 符号放在多行的 JSX 元素的最后一行 arrowParens: &#x27;avoid&#x27;, // 当箭头函数中只有一个参数的时候可以忽略括弧 htmlWhitespaceSensitivity: &#x27;ignore&#x27;, // vue template 中的结束标签结尾尖括号掉到了下一行 vueIndentScriptAndStyle: false, //（默认值）对于 .vue 文件，不缩进 &lt;script&gt; 和 &lt;style&gt; 里的内容 embeddedLanguageFormatting: &#x27;auto&#x27;, //（默认值）允许自动格式化内嵌的代码块&#125; 扩展阅读：关于 Trailing commas 你或许想了解更多。 然后可以通过命令来格式化代码： 12345# 将格式化当前目录及子目录下所有文件npx prettier --write .# 检查某个文件是否已经格式化npx prettier --check src/main.js 如果有些文件不想被 Prettier 格式化，可以将其写入到 .prettierignore 里： 1234build&#x2F;package.jsonpublic&#x2F;test&#x2F;*.* Prettier 和 ESLint 一起干活更配哦上面介绍了 Prettier 的具体配置，这里主要介绍和 ESLint 结合使用的配置和注意事项。 和 ESLint 配合使用需要用到 eslint-plugin-prettier 这个插件： 1npm i eslint-plugin-prettier -D 配置： 123456&#123; plugins: [&#x27;prettier&#x27;], rules: &#123; &#x27;prettier/prettier&#x27;: &#x27;error&#x27; &#125;&#125; 这个插件的工作原理是先调用 Prettier 对你的代码进行格式化，然后会把格式化前后不一致的地方进行标记，通过配置 ‘prettier/prettier’: ‘error’ 此条规则会将标记地方进行 error 级别的报错提示，然后可以通过 ESLint 的 –fix 自动修复功能将其修复。 冲突了怎么办 通过前面的介绍，我们知道 ESLint 也是会对代码风格做一些限制的，而 Prettier 主要就是规范代码风格，所以在把它们结合一起使用的时候是存会在一些问题的。对于个别规则，会使得双方在校验后出现代码格式不一致的问题。 那么当 Prettier 和 ESLint 出现冲突之后，该怎么办呢？ 用 Prettier 的话来说很简单，只要使用 eslint-config-prettier 就可以了。解决冲突的思路就是通过将这个包提供的扩展放到 extends 最后面引入，依据 rules 生效的优先级，所以它会覆盖前面起冲突的规则，比如： 123456&#123; extends: [ &#x27;eslint:recommended&#x27;, &#x27;prettier&#x27;, // 必须放最后 ],&#125; 除了能覆盖和 ESLint 中起冲突的规则之外，eslint-config-prettier 还能覆盖来自以下插件的规则（只列了部分）： eslint-plugin-standard eslint-plugin-vue 那 eslint-config-prettier 到底提供了哪些覆盖规则呢？直接看这个列表：eslint-config-prettier rules 如果想覆盖某些插件的规则，需要引入对应插件的扩展，比如： 12345678&#123; extends: [ &#x27;standard&#x27;, &#x27;plugin:vue/recommended&#x27;, &#x27;prettier/standard&#x27;, // 覆盖 eslint-config-stanard &#x27;prettier/vue&#x27;, // 覆盖 eslint-plugin-vue ],&#125; 提示：在 eslint-config-prettier 8.0.0 版本后，extends 不再需要为单独的插件引入对应扩展来覆盖冲突了，统一引入 ‘prettier’ 即可。 如果同时使用了 eslint-plugin-prettier 和 eslint-config-prettier 可以这么配置： 123&#123; extends: [&#x27;plugin:prettier/recommended&#x27;],&#125; 它其实和下面这些配置是等价的： 123456789&#123; extends: [&#x27;prettier&#x27;], // eslint-config-prettier 提供的，用于覆盖起冲突的规则 plugins: [&#x27;prettier&#x27;], // 注册 eslint-plugin-prettier 插件 rules: &#123; &#x27;prettier/prettier&#x27;: &#x27;error&#x27;, &#x27;arrow-body-style&#x27;: &#x27;off&#x27;, &#x27;prefer-arrow-callback&#x27;: &#x27;off&#x27; &#125;&#125; 所以如果是在 Vue 2 项目中配置 ESLint 和 Prettier 会这么配置： 1234567891011121314&#123; parser: &#x27;vue-eslint-parser&#x27;, parserOptions: &#123; parser: &#x27;babel-eslint&#x27;, ecmaVersion: 12, sourceType: &#x27;module&#x27; &#125;, extends: [ &#x27;eslint:recommended&#x27;, &#x27;plugin:vue/recommended&#x27;, &#x27;plugin:prettier/recommended&#x27;, // 在前面 Vue 配置的基础上加上这行 ], plugins: [&#x27;vue&#x27;]&#125; 其实如果你的项目是用 vue-cli 初始化的，且选择了 eslint + prettier 方案的话，生成的项目中，.eslintrc.js 配置文件中 extends 的配置是这样的： 1234567&#123; extends: [ &#x27;plugin:vue/essential&#x27;, &#x27;eslint:recommended&#x27;, &#x27;@vue/prettier&#x27; ]&#125; 它的最后一项扩展是 @vue/prettier，这个对应的是 @vue/eslint-config-prettier 这个包，让我们看看这个包下面的 index.js 内容： 12345678910&#123; plugins: [&#x27;prettier&#x27;], extends: [ require.resolve(&#x27;eslint-config-prettier&#x27;), require.resolve(&#x27;eslint-config-prettier/vue&#x27;) ], rules: &#123; &#x27;prettier/prettier&#x27;: &#x27;warn&#x27; &#125;&#125; 这个和我们上面配置的内容是相差无几的，而引入 eslint-config-prettier/vue 是因为这个 @vue/eslint-config-prettier 包依赖的 eslint-config-prettier 版本是 ^6.0.0 版本的，所以在处理冲突的时候需要特别指定和对应类型插件匹配的扩展。 让 EditorConfig 助力多编辑器开发吧EditorConfig 是个啥玩意？它可以对多种类型的单文件进行简单的格式化，它提供的配置参数很少： 123456789101112131415161718192021222324252627282930# 告诉 EditorConfig 插件，这是根文件，不用继续往上查找root = true# 匹配全部文件[*]# 设置字符集charset = utf-8# 缩进风格，可选 space、tabindent_style = tab# 缩进的空格数，当 indent_style = tab 将使用 tab_width# 否则使用 indent_sizeindent_size = 2tab_width = 2# 结尾换行符，可选 lf、cr、crlfend_of_line = lf# 在文件结尾插入新行insert_final_newline = true# 删除一行中的前后空格trim_trailing_whitespace = true# 匹配md结尾的文件[*.md]insert_final_newline = falsetrim_trailing_whitespace = false 虽然它提供的格式化的配置参数很少，就 3 个，缩进风格、是否在文件末尾插入新行和是否删除一行中前后空格。但是它还是非常有必要存在的，理由有 3 个： 能够在不同的编辑器和 IDE 中保持一致的代码风格； 配合插件打开文件即自动格式化，非常方便 支持格式化的文件类型很多； 如果需要让以上的配置生效，还得在 VSCode 里安装 EditorConfig for VS Code 这个插件配合使用。 重点来了 可以看到 EditorConfig 和 Prettier 会存在一些重复的配置，比如都提供了对缩进的配置参数，所以在实际使用的时候需要避免它们，或者把他们的参数设置为一致。 在 VSCode 中支持 ESLint前面做的配置，都需要执行命令才能进行检查和修复代码，还是挺不方便的，如果我希望编辑完或者保存的时候去检查代码该如何做呢？可以直接在 IDE 里安装 ESLint 插件，因为我使用的是 VSCode，所以这里只介绍在 VSCode 中的配置。 在使用前，需要把 ESLint 扩展安装到 VSCode 里，这里我就不细说安装步骤了。安装完成后，需要在设置里写入配置： 在 VSCode 左下角找到一个齿轮 ⚙ 图标，点击后选择设置选项，这个时候打开了设置面板； 然后在 VSCode 右上角找到打开设置（json）的图标，点击后，会打开 settings.json 文件； 然后把以下配置贴进去即可； 123456789&#123; &quot;eslint.alwaysShowStatus&quot;: true, // 总是在 VSCode 显示 ESLint 的状态 &quot;eslint.quiet&quot;: true, // 忽略 warning 的错误 &quot;editor.codeActionsOnSave&quot;: &#123; // 保存时使用 ESLint 修复可修复错误 &quot;source.fixAll&quot;: true, &quot;source.fixAll.eslint&quot;: true &#125;&#125; 配置说明，在 ESLint 2.0.4 版本开始： 不需要通过 eslint.validate 来指定校验的文件类型了，已经自动支持了 .vue 文件； editor.codeActionsOnSave 开启保存自动修复功能； 当这样配置之后呢，每次编辑代码 ESLint 都会实时校验代码，且当保存的时候会自动 fix，是不是很方便呢。不过对于有些无法自动 fix 的代码就需要你手动去修改了，如果不想修改的话就可以配置 rules 把该条规则给关闭掉。 其实在团队开发的时候，最好把针对 VSCode 的配置，写一个文件跟随着项目，一起提交到远程仓库，这样的话就保证了项目成员都是用的这套配置。比如可以在项目根目录新建 .vscode/settings.json，然后写入上面的那串配置内容。 在提交前做校验 pre-commit以上只是通过 ESLint 自动修复能够修复的错误以及通过 Prettier 进行代码的格式化，但是在实际开发的时候难免会遇到无法 fix 的错误，可能开发人员也忘记修改，如果这个时候把代码提交到远程仓库，那就把糟糕的代码给提交上去了。 那么如何杜绝把糟糕的代码提交上去呢？可以通过配置 git hooks 的 pre-commit 钩子来实现这个目的。主要是利用了 husky 和 lint-staged 这 2 个包。husky 就是用来配置 git hooks 的，而 lint-staged 则是对拿到的 staged 文件进行处理，比如执行 npx eslint –fix 进行代码校验。 具体操作步骤如下： 1、执行以下命令： 1npx mrm lint-staged 会自动安装 lint-staged 和 husky 并且在 package.json 里写入 lint-staged。 注意：mrm 是一个自动化工具，它将根据 package.json 依赖项中的代码质量工具来安装和配置 husky 和 lint-staged，因此请确保在此之前安装并配置所有代码质量工具，如 Prettier 和 ESlint。 如果上面顺利会在 package.json 里写入 lint-staged，可以自行修改让它支持 .vue 文件的校验： 12345&#123; &quot;lint-staged&quot;: &#123; &quot;*.&#123;js,vue&#125;&quot;: &quot;eslint --cache --fix&quot; &#125;&#125; 2、启动 git hooks 1npx husky install 经过上面的命令后，v6 版本的 husky 会在项目根目录新建一个 .husky 目录。如果是 v4 版本的则会写入到 package.json 里。 3、创建 pre-commit 钩子 1npx husky add .husky/pre-commit &quot;npx lint-staged&quot; 到这里后，git commit 前自动执行代码校验和修复的功能就算完成了。然后你可以试试修改文件，然后提交试试。 总结这篇文章比较长，前前后后讲了很多代码校验的东西，现在我们来梳理下。 首先用 ESLint 来做代码校验，它自带的 ruels 能提供 2 种类型的校验，分别是代码错误校验和代码格式校验，而 ESLint 本身的核心工作其实就是校验和修复错误的代码，而对格式化的规则提供的不多。 所以如果想要对代码格式化进行一个更加精细的配置则需要借助 Prettier，因为它是只负责风格的管控，所以用它再适合不过了。但是如果把 ESLint 和 Prettier 结合起来一起使用的话，就可能会出现规则的冲突了，毕竟它们两者都会对风格进行处理，所以这个时候就可以通过 eslint-config-prettier 这个扩展来把冲突的规则进行关闭，这个扩展不仅可以关闭和 ESLint 内置规则的冲突，还可以关闭实际项目中引用到的扩展规则的冲突，比如和 Vue、React、TypeScript、Flow 的冲突。 在把 ESLint 和 Prettier 结合的时候，我们希望让 ESLint 来检查代码错误，而 Prettier 校验代码风格，那么这个时候其实是有 2 个任务的，需要用 2 条命令来处理的。但是有了 eslint-plugin-prettier 这个插件后就可以很方便的把它们结合起来，当需要校验代码错误的时候 ESLint 自动会给你校验，当然前提是 VSCode 里必须按照 ESLint 插件，而当需要校验代码风格的时候 ESLint 就会调用 Prettier 的能力进行代码风格的检查。 文章的后面分别又细说了 EditorConfig 和提交代码前校验的处理，这里就不多讲了。 看到这里希望你对代码校验和规范有一个新的认识，不过我最希望的是你能够自己动手为你的项目配置一套校验规则，如果不能成功，一定是我的文章写的有问题，欢迎评论区留言指出不足之处，我是大海我来了，下篇文章见。","categories":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"}],"tags":[{"name":"eslint","slug":"eslint","permalink":"https://bubuzou.com/tags/eslint/"}]},{"title":"死磕 36 个 JS 手写题（搞懂后，提升真的大）","slug":"write-js-hand-by-hand","date":"2021-04-02T09:30:05.000Z","updated":"2021-04-30T01:47:48.107Z","comments":true,"path":"2021/04/02/write-js-hand-by-hand/","link":"","permalink":"https://bubuzou.com/2021/04/02/write-js-hand-by-hand/","excerpt":"为什么要写这类文章 作为一个程序员，代码能力毋庸置疑是非常非常重要的，就像现在为什么大厂面试基本都问什么 API 怎么实现可见其重要性。我想说的是居然手写这么重要，那我们就必须掌握它，所以文章标题用了死磕，一点也不过分，也希望不被认为是标题党。 作为一个普通前端，我是真的写不出 Promise A+ 规范，但是没关系，我们可以站在巨人的肩膀上，要相信我们现在要走的路，前人都走过，所以可以找找现在社区已经存在的那些优秀的文章，比如工业聚大佬写的 100 行代码实现 Promises/A+ 规范，找到这些文章后不是收藏夹吃灰，得找个时间踏踏实实的学，一行一行的磨，直到搞懂为止。我现在就是这么干的。 能收获什么 这篇文章总体上分为 2 类手写题，前半部分可以归纳为是常见需求，后半部分则是对现有技术的实现； 对常用的需求进行手写实现，比如数据类型判断函数、深拷贝等可以直接用于往后的项目中，提高了项目开发效率； 对现有关键字和 API 的实现，可能需要用到别的知识或 API，比如在写 forEach 的时候用到了无符号位右移的操作，平时都不怎么能够接触到这玩意，现在遇到了就可以顺手把它掌握了。所以手写这些实现能够潜移默化的扩展并巩固自己的 JS 基础； 通过写各种测试用例，你会知道各种 API 的边界情况，比如 Promise.all， 你得考虑到传入参数的各种情况，从而加深了对它们的理解及使用； 阅读的时候需要做什么 阅读的时候，你需要把每行代码都看懂，知道它在干什么，为什么要这么写，能写得更好嘛？比如在写图片懒加载的时候，一般我们都是根据当前元素的位置和视口进行判断是否要加载这张图片，普通程序员写到这就差不多完成了。而大佬程序员则是会多考虑一些细节的东西，比如性能如何更优？代码如何更精简？比如 yeyan1996 写的图片懒加载就多考虑了 2 点：比如图片全部加载完成的时候得把事件监听给移除；比如加载完一张图片的时候，得把当前 img 从 imgList 里移除，起到优化内存的作用。 除了读通代码之外，还可以打开 Chrome 的 Script snippet 去写测试用例跑跑代码，做到更好的理解以及使用。 在看了几篇以及写了很多测试用例的前提下，尝试自己手写实现，看看自己到底掌握了多少。条条大路通罗马，你还能有别的方式实现嘛？或者你能写得比别人更好嘛？ 好了，还楞着干啥，开始干活。","text":"为什么要写这类文章 作为一个程序员，代码能力毋庸置疑是非常非常重要的，就像现在为什么大厂面试基本都问什么 API 怎么实现可见其重要性。我想说的是居然手写这么重要，那我们就必须掌握它，所以文章标题用了死磕，一点也不过分，也希望不被认为是标题党。 作为一个普通前端，我是真的写不出 Promise A+ 规范，但是没关系，我们可以站在巨人的肩膀上，要相信我们现在要走的路，前人都走过，所以可以找找现在社区已经存在的那些优秀的文章，比如工业聚大佬写的 100 行代码实现 Promises/A+ 规范，找到这些文章后不是收藏夹吃灰，得找个时间踏踏实实的学，一行一行的磨，直到搞懂为止。我现在就是这么干的。 能收获什么 这篇文章总体上分为 2 类手写题，前半部分可以归纳为是常见需求，后半部分则是对现有技术的实现； 对常用的需求进行手写实现，比如数据类型判断函数、深拷贝等可以直接用于往后的项目中，提高了项目开发效率； 对现有关键字和 API 的实现，可能需要用到别的知识或 API，比如在写 forEach 的时候用到了无符号位右移的操作，平时都不怎么能够接触到这玩意，现在遇到了就可以顺手把它掌握了。所以手写这些实现能够潜移默化的扩展并巩固自己的 JS 基础； 通过写各种测试用例，你会知道各种 API 的边界情况，比如 Promise.all， 你得考虑到传入参数的各种情况，从而加深了对它们的理解及使用； 阅读的时候需要做什么 阅读的时候，你需要把每行代码都看懂，知道它在干什么，为什么要这么写，能写得更好嘛？比如在写图片懒加载的时候，一般我们都是根据当前元素的位置和视口进行判断是否要加载这张图片，普通程序员写到这就差不多完成了。而大佬程序员则是会多考虑一些细节的东西，比如性能如何更优？代码如何更精简？比如 yeyan1996 写的图片懒加载就多考虑了 2 点：比如图片全部加载完成的时候得把事件监听给移除；比如加载完一张图片的时候，得把当前 img 从 imgList 里移除，起到优化内存的作用。 除了读通代码之外，还可以打开 Chrome 的 Script snippet 去写测试用例跑跑代码，做到更好的理解以及使用。 在看了几篇以及写了很多测试用例的前提下，尝试自己手写实现，看看自己到底掌握了多少。条条大路通罗马，你还能有别的方式实现嘛？或者你能写得比别人更好嘛？ 好了，还楞着干啥，开始干活。 数据类型判断typeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。 123456function typeOf(obj) &#123; return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()&#125;typeOf([]) // &#x27;array&#x27;typeOf(&#123;&#125;) // &#x27;object&#x27;typeOf(new Date) // &#x27;date&#x27; 继承原型链继承12345678910111213function Animal() &#123; this.colors = [&#x27;black&#x27;, &#x27;white&#x27;]&#125;Animal.prototype.getColor = function() &#123; return this.colors&#125;function Dog() &#123;&#125;Dog.prototype = new Animal()let dog1 = new Dog()dog1.colors.push(&#x27;brown&#x27;)let dog2 = new Dog()console.log(dog2.colors) // [&#x27;black&#x27;, &#x27;white&#x27;, &#x27;brown&#x27;] 原型链继承存在的问题： 问题1：原型中包含的引用类型属性将被所有实例共享； 问题2：子类在实例化的时候不能给父类构造函数传参； 借用构造函数实现继承12345678910function Animal(name) &#123; this.name = name this.getName = function() &#123; return this.name &#125;&#125;function Dog(name) &#123; Animal.call(this, name)&#125;Dog.prototype = new Animal() 借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。 组合继承组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。 12345678910111213141516171819function Animal(name) &#123; this.name = name this.colors = [&#x27;black&#x27;, &#x27;white&#x27;]&#125;Animal.prototype.getName = function() &#123; return this.name&#125;function Dog(name, age) &#123; Animal.call(this, name) this.age = age&#125;Dog.prototype = new Animal()Dog.prototype.constructor = Doglet dog1 = new Dog(&#x27;奶昔&#x27;, 2)dog1.colors.push(&#x27;brown&#x27;)let dog2 = new Dog(&#x27;哈赤&#x27;, 1)console.log(dog2) // &#123; name: &quot;哈赤&quot;, colors: [&quot;black&quot;, &quot;white&quot;], age: 1 &#125; 寄生式组合继承组合继承已经相对完善了，但还是存在问题，它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。 所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。 寄生式组合继承写法上和组合继承基本类似，区别是如下这里： 12345678- Dog.prototype = new Animal()- Dog.prototype.constructor = Dog+ function F() &#123;&#125;+ F.prototype = Animal.prototype+ let f = new F()+ f.constructor = Dog+ Dog.prototype = f 稍微封装下上面添加的代码后： 1234567891011function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function inheritPrototype(child, parent) &#123; let prototype = object(parent.prototype) prototype.constructor = child child.prototype = prototype&#125;inheritPrototype(Dog, Animal) 如果你嫌弃上面的代码太多了，还可以基于组合继承的代码改成最简单的寄生式组合继承： 12345- Dog.prototype = new Animal()- Dog.prototype.constructor = Dog+ Dog.prototype = Object.create(Animal.prototype)+ Dog.prototype.constructor = Dog class 实现继承1234567891011121314class Animal &#123; constructor(name) &#123; this.name = name &#125; getName() &#123; return this.name &#125;&#125;class Dog extends Animal &#123; constructor(name, age) &#123; super(name) this.age = age &#125;&#125; 数组去重ES5 实现： 123456function unique(arr) &#123; var res = arr.filter(function(item, index, array) &#123; return array.indexOf(item) === index &#125;) return res&#125; ES6 实现： 1var unique = arr =&gt; [...new Set(arr)] 数组扁平化数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层： 1[1, [2, [3]]].flat(2) // [1, 2, 3] 现在就是要实现 flat 这种效果。 ES5 实现：递归。 1234567891011function flatten(arr) &#123; var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if (Array.isArray(arr[i])) &#123; result = result.concat(flatten(arr[i])) &#125; else &#123; result.push(arr[i]) &#125; &#125; return result;&#125; ES6 实现： 123456function flatten(arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125; 深浅拷贝浅拷贝：只考虑对象类型。 1234567891011function shallowCopy(obj) &#123; if (typeof obj !== &#x27;object&#x27;) return let newObj = obj instanceof Array ? [] : &#123;&#125; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key] &#125; &#125; return newObj&#125; 简单版深拷贝：只考虑普通对象属性，不考虑内置对象和函数。 12345678910function deepClone(obj) &#123; if (typeof obj !== &#x27;object&#x27;) return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === &#x27;object&#x27; ? deepClone(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125; 复杂版深克隆：基于简单版的基础上，还考虑了内置对象比如 Date、RegExp 等对象和函数以及解决了循环引用的问题。 1234567891011121314151617181920212223242526const isObject = (target) =&gt; (typeof target === &quot;object&quot; || typeof target === &quot;function&quot;) &amp;&amp; target !== null;function deepClone(target, map = new WeakMap()) &#123; if (map.get(target)) &#123; return target; &#125; // 获取当前值的构造函数：获取它的类型 let constructor = target.constructor; // 检测当前对象target是否与正则、日期格式对象匹配 if (/^(RegExp|Date)$/i.test(constructor.name)) &#123; // 创建一个新的特殊对象(正则类/日期类)的实例 return new constructor(target); &#125; if (isObject(target)) &#123; map.set(target, true); // 为循环引用的对象做标记 const cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; for (let prop in target) &#123; if (target.hasOwnProperty(prop)) &#123; cloneTarget[prop] = deepClone(target[prop], map); &#125; &#125; return cloneTarget; &#125; else &#123; return target; &#125;&#125; 事件总线（发布订阅模式）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class EventEmitter &#123; constructor() &#123; this.cache = &#123;&#125; &#125; on(name, fn) &#123; if (this.cache[name]) &#123; this.cache[name].push(fn) &#125; else &#123; this.cache[name] = [fn] &#125; &#125; off(name, fn) &#123; let tasks = this.cache[name] if (tasks) &#123; const index = tasks.findIndex(f =&gt; f === fn || f.callback === fn) if (index &gt;= 0) &#123; tasks.splice(index, 1) &#125; &#125; &#125; emit(name, once = false, ...args) &#123; if (this.cache[name]) &#123; // 创建副本，如果回调函数内继续注册相同事件，会造成死循环 let tasks = this.cache[name].slice() for (let fn of tasks) &#123; fn(...args) &#125; if (once) &#123; delete this.cache[name] &#125; &#125; &#125;&#125;// 测试let eventBus = new EventEmitter()let fn1 = function(name, age) &#123; console.log(`$&#123;name&#125; $&#123;age&#125;`)&#125;let fn2 = function(name, age) &#123; console.log(`hello, $&#123;name&#125; $&#123;age&#125;`)&#125;eventBus.on(&#x27;aaa&#x27;, fn1)eventBus.on(&#x27;aaa&#x27;, fn2)eventBus.emit(&#x27;aaa&#x27;, false, &#x27;布兰&#x27;, 12)// &#x27;布兰 12&#x27;// &#x27;hello, 布兰 12&#x27; 解析 URL 参数为对象1234567891011121314151617181920212223function parseParam(url) &#123; const paramsStr = /.+\\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来 const paramsArr = paramsStr.split(&#x27;&amp;&#x27;); // 将字符串以 &amp; 分割后存到数组中 let paramsObj = &#123;&#125;; // 将 params 存到对象中 paramsArr.forEach(param =&gt; &#123; if (/=/.test(param)) &#123; // 处理有 value 的参数 let [key, val] = param.split(&#x27;=&#x27;); // 分割 key 和 value val = decodeURIComponent(val); // 解码 val = /^\\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字 if (paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值 paramsObj[key] = [].concat(paramsObj[key], val); &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值 paramsObj[key] = val; &#125; &#125; else &#123; // 处理没有 value 的参数 paramsObj[param] = true; &#125; &#125;) return paramsObj;&#125; 字符串模板123456789function render(template, data) &#123; const reg = /\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;/; // 模板字符串正则 if (reg.test(template)) &#123; // 判断模板里是否有模板字符串 const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段 template = template.replace(reg, data[name]); // 将第一个模板字符串渲染 return render(template, data); // 递归的渲染并返回渲染后的结构 &#125; return template; // 如果模板没有模板字符串直接返回&#125; 测试： 123456let template = &#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;;let person = &#123; name: &#x27;布兰&#x27;, age: 12&#125;render(template, person); // 我是布兰，年龄12，性别undefined 图片懒加载与普通的图片懒加载不同，如下这个多做了 2 个精心处理： 图片全部加载完成后移除事件监听； 加载完的图片，从 imgList 移除； 123456789101112131415161718192021222324let imgList = [...document.querySelectorAll(&#x27;img&#x27;)]let length = imgList.lengthconst imgLazyLoad = (function() &#123; let count = 0 return function() &#123; let deleteIndexList = [] imgList.forEach((img, index) =&gt; &#123; let rect = img.getBoundingClientRect() if (rect.top &lt; window.innerHeight) &#123; img.src = img.dataset.src deleteIndexList.push(index) count++ if (count === length) &#123; document.removeEventListener(&#x27;scroll&#x27;, imgLazyLoad) &#125; &#125; &#125;) imgList = imgList.filter((img, index) =&gt; !deleteIndexList.includes(index)) &#125;&#125;)()// 这里最好加上防抖处理document.addEventListener(&#x27;scroll&#x27;, imgLazyLoad) 参考：图片懒加载 函数防抖触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。 简单版：函数内部支持使用 this 和 event 对象； 1234567891011function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; 使用： 123456var node = document.getElementById(&#x27;layout&#x27;)function getUserAction(e) &#123; console.log(this, e) // 分别打印：node 这个节点 和 MouseEvent node.innerHTML = count++;&#125;;node.onmousemove = debounce(getUserAction, 1000) 最终版：除了支持 this 和 event 外，还支持以下功能： 支持立即执行； 函数可能有返回值； 支持取消功能； 123456789101112131415161718192021222324252627282930function debounce(func, wait, immediate) &#123; var timeout, result; var debounced = function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;; debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125; 使用： 123456var setUseAction = debounce(getUserAction, 10000, true);// 使用防抖node.onmousemove = setUseAction// 取消防抖setUseAction.cancel() 参考：JavaScript专题之跟着underscore学防抖 函数节流触发高频事件，且 N 秒内只执行一次。 简单版：使用时间戳来实现，立即执行一次，然后每 N 秒执行一次。 1234567891011121314function throttle(func, wait) &#123; var context, args; var previous = 0; return function() &#123; var now = +new Date(); context = this; args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125; 最终版：支持取消节流；另外通过传入第三个参数，options.leading 来表示是否可以立即执行一次，opitons.trailing 表示结束调用的时候是否还要执行一次，默认都是 true。注意设置的时候不能同时将 leading 或 trailing 设置为 false。 1234567891011121314151617181920212223242526272829303132333435363738function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = null; &#125; return throttled;&#125; 节流的使用就不拿代码举例了，参考防抖的写就行。 参考：JavaScript专题之跟着 underscore 学节流 函数柯里化什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。还不懂？来举个例子。 123456function add(a, b, c) &#123; return a + b + c&#125;add(1, 2, 3)let addCurry = curry(add)addCurry(1)(2)(3) 现在就是要实现 curry 这个函数，使函数从一次调用传入多个参数变成多次调用每次传一个参数。 1234567function curry(fn) &#123; let judge = (...args) =&gt; &#123; if (args.length == fn.length) return fn(...args) return (...arg) =&gt; judge(...args, ...arg) &#125; return judge&#125; 偏函数什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。举个例子： 12345function add(a, b, c) &#123; return a + b + c&#125;let partialAdd = partial(add, 1)partialAdd(2, 3) 发现没有，其实偏函数和函数柯里化有点像，所以根据函数柯里化的实现，能够能很快写出偏函数的实现： 12345function partial(fn, ...args) &#123; return (...arg) =&gt; &#123; return fn(...args, ...arg) &#125;&#125; 如上这个功能比较简单，现在我们希望偏函数能和柯里化一样能实现占位功能，比如： 12345function clg(a, b, c) &#123; console.log(a, b, c)&#125;let partialClg = partial(clg, &#x27;_&#x27;, 2)partialClg(1, 3) // 依次打印：1, 2, 3 _ 占的位其实就是 1 的位置。相当于：partial(clg, 1, 2)，然后 partialClg(3)。明白了原理，我们就来写实现： 123456function partial(fn, ...args) &#123; return (...arg) =&gt; &#123; args[index] = return fn(...args, ...arg) &#125;&#125; JSONPJSONP 核心原理：script 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求； 123456789101112131415161718192021const jsonp = (&#123; url, params, callbackName &#125;) =&gt; &#123; const generateUrl = () =&gt; &#123; let dataSrc = &#x27;&#x27; for (let key in params) &#123; if (params.hasOwnProperty(key)) &#123; dataSrc += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;` &#125; &#125; dataSrc += `callback=$&#123;callbackName&#125;` return `$&#123;url&#125;?$&#123;dataSrc&#125;` &#125; return new Promise((resolve, reject) =&gt; &#123; const scriptEle = document.createElement(&#x27;script&#x27;) scriptEle.src = generateUrl() document.body.appendChild(scriptEle) window[callbackName] = data =&gt; &#123; resolve(data) document.removeChild(scriptEle) &#125; &#125;)&#125; AJAX12345678910111213141516const getJSON = function(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#x27;Mscrosoft.XMLHttp&#x27;); xhr.open(&#x27;GET&#x27;, url, false); xhr.setRequestHeader(&#x27;Accept&#x27;, &#x27;application/json&#x27;); xhr.onreadystatechange = function() &#123; if (xhr.readyState !== 4) return; if (xhr.status === 200 || xhr.status === 304) &#123; resolve(xhr.responseText); &#125; else &#123; reject(new Error(xhr.responseText)); &#125; &#125; xhr.send(); &#125;)&#125; 实现数组原型方法forEach1234567891011121314151617Array.prototype.forEach2 = function(callback, thisArg) &#123; if (this == null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;) &#125; if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &#x27; is not a function&#x27;) &#125; const O = Object(this) // this 就是当前的数组 const len = O.length &gt;&gt;&gt; 0 // 后面有解释 let k = 0 while (k &lt; len) &#123; if (k in O) &#123; callback.call(thisArg, O[k], k, O); &#125; k++; &#125;&#125; 参考：forEach#polyfill O.length &gt;&gt;&gt; 0 是什么操作？就是无符号右移 0 位，那有什么意义嘛？就是为了保证转换后的值为正整数。其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。感兴趣可以阅读 something &gt;&gt;&gt; 0是什么意思?。 map基于 forEach 的实现能够很容易写出 map 的实现： 123456789101112131415161718192021- Array.prototype.forEach2 = function(callback, thisArg) &#123;+ Array.prototype.map2 = function(callback, thisArg) &#123; if (this == null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;) &#125; if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &#x27; is not a function&#x27;) &#125; const O = Object(this) const len = O.length &gt;&gt;&gt; 0- let k = 0+ let k = 0, res = [] while (k &lt; len) &#123; if (k in O) &#123;- callback.call(thisArg, O[k], k, O);+ res[k] = callback.call(thisArg, O[k], k, O); &#125; k++; &#125;+ return res&#125; filter同样，基于 forEach 的实现能够很容易写出 filter 的实现： 1234567891011121314151617181920212223- Array.prototype.forEach2 = function(callback, thisArg) &#123;+ Array.prototype.filter2 = function(callback, thisArg) &#123; if (this == null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;) &#125; if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &#x27; is not a function&#x27;) &#125; const O = Object(this) const len = O.length &gt;&gt;&gt; 0- let k = 0+ let k = 0, res = [] while (k &lt; len) &#123; if (k in O) &#123;- callback.call(thisArg, O[k], k, O);+ if (callback.call(thisArg, O[k], k, O)) &#123;+ res.push(O[k]) + &#125; &#125; k++; &#125;+ return res&#125; some同样，基于 forEach 的实现能够很容易写出 some 的实现： 12345678910111213141516171819202122- Array.prototype.forEach2 = function(callback, thisArg) &#123;+ Array.prototype.some2 = function(callback, thisArg) &#123; if (this == null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;) &#125; if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &#x27; is not a function&#x27;) &#125; const O = Object(this) const len = O.length &gt;&gt;&gt; 0 let k = 0 while (k &lt; len) &#123; if (k in O) &#123;- callback.call(thisArg, O[k], k, O);+ if (callback.call(thisArg, O[k], k, O)) &#123;+ return true+ &#125; &#125; k++; &#125;+ return false&#125; reduce12345678910111213141516171819202122232425262728293031Array.prototype.reduce2 = function(callback, initialValue) &#123; if (this == null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;) &#125; if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &#x27; is not a function&#x27;) &#125; const O = Object(this) const len = O.length &gt;&gt;&gt; 0 let k = 0, acc if (arguments.length &gt; 1) &#123; acc = initialValue &#125; else &#123; // 没传入初始值的时候，取数组中第一个非 empty 的值为初始值 while (k &lt; len &amp;&amp; !(k in O)) &#123; k++ &#125; if (k &gt; len) &#123; throw new TypeError( &#x27;Reduce of empty array with no initial value&#x27; ); &#125; acc = O[k++] &#125; while (k &lt; len) &#123; if (k in O) &#123; acc = callback(acc, O[k], k, O) &#125; k++ &#125; return acc&#125; 实现函数原型方法call使用一个指定的 this 值和一个或多个参数来调用一个函数。 实现要点： this 可能传入 null； 传入不固定个数的参数； 函数可能有返回值； 1234567891011121314Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;); &#125; var result = eval(&#x27;context.fn(&#x27; + args +&#x27;)&#x27;); delete context.fn return result;&#125; applyapply 和 call 一样，唯一的区别就是 call 是传入不固定个数的参数，而 apply 是传入一个数组。 实现要点： this 可能传入 null； 传入一个数组； 函数可能有返回值； 123456789101112131415161718Function.prototype.apply2 = function (context, arr) &#123; var context = context || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push(&#x27;arr[&#x27; + i + &#x27;]&#x27;); &#125; result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;) &#125; delete context.fn return result;&#125; bindbind 方法会创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 实现要点： bind() 除了 this 外，还可传入多个参数； bing 创建的新函数可能传入多个参数； 新函数可能被当做构造函数调用； 函数可能有返回值； 123456789101112131415Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 实现 new 关键字new 运算符用来创建用户自定义的对象类型的实例或者具有构造函数的内置对象的实例。 实现要点： new 会产生一个新对象； 新对象需要能够访问到构造函数的属性，所以需要重新指定它的原型； 构造函数可能会显示返回； 123456789function objectFactory() &#123; var obj = new Object() Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); // ret || obj 这里这么写考虑了构造函数显示返回 null 的情况 return typeof ret === &#x27;object&#x27; ? ret || obj : obj;&#125;; 使用： 123456function person(name, age) &#123; this.name = name this.age = age&#125;let p = objectFactory(person, &#x27;布兰&#x27;, 12)console.log(p) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 实现 instanceof 关键字instanceof 就是判断构造函数的 prototype 属性是否出现在实例的原型链上。 12345678910function instanceOf(left, right) &#123; let proto = left.__proto__ while (true) &#123; if (proto === null) return false if (proto === right.prototype) &#123; return true &#125; proto = proto.__proto__ &#125;&#125; 上面的 left.proto 这种写法可以换成 Object.getPrototypeOf(left)。 实现 Object.createObject.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 123456789101112131415161718Object.create2 = function(proto, propertyObject = undefined) &#123; if (typeof proto !== &#x27;object&#x27; &amp;&amp; typeof proto !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Object prototype may only be an Object or null.&#x27;) if (propertyObject == null) &#123; new TypeError(&#x27;Cannot convert undefined or null to object&#x27;) &#125; function F() &#123;&#125; F.prototype = proto const obj = new F() if (propertyObject != undefined) &#123; Object.defineProperties(obj, propertyObject) &#125; if (proto === null) &#123; // 创建一个没有原型对象的对象，Object.create(null) obj.__proto__ = null &#125; return obj&#125; 实现 Object.assign12345678910111213141516Object.assign2 = function(target, ...source) &#123; if (target == null) &#123; throw new TypeError(&#x27;Cannot convert undefined or null to object&#x27;) &#125; let ret = Object(target) source.forEach(function(obj) &#123; if (obj != null) &#123; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; ret[key] = obj[key] &#125; &#125; &#125; &#125;) return ret&#125; 实现 JSON.stringifyJSON.stringify([, replacer [, space]) 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 replacer 和第三个参数 space，如果对这两个参数的作用还不了解，建议阅读 MDN 文档。 基本数据类型： undefined 转换之后仍是 undefined(类型也是 undefined) boolean 值转换之后是字符串 “false”/“true” number 类型(除了 NaN 和 Infinity)转换之后是字符串类型的数值 symbol 转换之后是 undefined null 转换之后是字符串 “null” string 转换之后仍是string NaN 和 Infinity 转换之后是字符串 “null” 函数类型：转换之后是 undefined 如果是对象类型(非函数) 如果是一个数组：如果属性值中出现了 undefined、任意的函数以及 symbol，转换成字符串 “null” ； 如果是 RegExp 对象：返回 {} (类型是 string)； 如果是 Date 对象，返回 Date 的 toJSON 字符串值； 如果是普通对象； 如果有 toJSON() 方法，那么序列化 toJSON() 的返回值。 如果属性值中出现了 undefined、任意的函数以及 symbol 值，忽略。 所有以 symbol 为属性键的属性都会被完全忽略掉。 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function jsonStringify(data) &#123; let dataType = typeof data; if (dataType !== &#x27;object&#x27;) &#123; let result = data; //data 可能是 string/number/null/undefined/boolean if (Number.isNaN(data) || data === Infinity) &#123; //NaN 和 Infinity 序列化返回 &quot;null&quot; result = &quot;null&quot;; &#125; else if (dataType === &#x27;function&#x27; || dataType === &#x27;undefined&#x27; || dataType === &#x27;symbol&#x27;) &#123; //function 、undefined 、symbol 序列化返回 undefined return undefined; &#125; else if (dataType === &#x27;string&#x27;) &#123; result = &#x27;&quot;&#x27; + data + &#x27;&quot;&#x27;; &#125; //boolean 返回 String() return String(result); &#125; else if (dataType === &#x27;object&#x27;) &#123; if (data === null) &#123; return &quot;null&quot; &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &#x27;function&#x27;) &#123; return jsonStringify(data.toJSON()); &#125; else if (data instanceof Array) &#123; let result = []; //如果是数组 //toJSON 方法可以存在于原型链中 data.forEach((item, index) =&gt; &#123; if (typeof item === &#x27;undefined&#x27; || typeof item === &#x27;function&#x27; || typeof item === &#x27;symbol&#x27;) &#123; result[index] = &quot;null&quot;; &#125; else &#123; result[index] = jsonStringify(item); &#125; &#125;); result = &quot;[&quot; + result + &quot;]&quot;; return result.replace(/&#x27;/g, &#x27;&quot;&#x27;); &#125; else &#123; //普通对象 /** * 循环引用抛错(暂未检测，循环引用时，堆栈溢出) * symbol key 忽略 * undefined、函数、symbol 为属性值，被忽略 */ let result = []; Object.keys(data).forEach((item, index) =&gt; &#123; if (typeof item !== &#x27;symbol&#x27;) &#123; //key 如果是symbol对象，忽略 if (data[item] !== undefined &amp;&amp; typeof data[item] !== &#x27;function&#x27; &amp;&amp; typeof data[item] !== &#x27;symbol&#x27;) &#123; //键值如果是 undefined、函数、symbol 为属性值，忽略 result.push(&#x27;&quot;&#x27; + item + &#x27;&quot;&#x27; + &quot;:&quot; + jsonStringify(data[item])); &#125; &#125; &#125;); return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&#x27;/g, &#x27;&quot;&#x27;); &#125; &#125;&#125; 参考：实现 JSON.stringify 实现 JSON.parse介绍 2 种方法实现： eval 实现； new Function 实现； eval 实现第一种方式最简单，也最直观，就是直接调用 eval，代码如下： 12var json = &#x27;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#x27;;var obj = eval(&quot;(&quot; + json + &quot;)&quot;); // obj 就是 json 反序列化之后得到的对象 但是直接调用 eval 会存在安全问题，如果数据中可能不是 json 数据，而是可执行的 JavaScript 代码，那很可能会造成 XSS 攻击。因此，在调用 eval 之前，需要对数据进行校验。 1234567891011121314var rx_one = /^[\\],:&#123;&#125;\\s]*$/;var rx_two = /\\\\(?:[&quot;\\\\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g;var rx_three = /&quot;[^&quot;\\\\\\n\\r]*&quot;|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;if ( rx_one.test( json.replace(rx_two, &quot;@&quot;) .replace(rx_three, &quot;]&quot;) .replace(rx_four, &quot;&quot;) )) &#123; var obj = eval(&quot;(&quot; +json + &quot;)&quot;);&#125; 参考：JSON.parse 三种实现方式 new Function 实现Function 与 eval 有相同的字符串参数特性。 12var json = &#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;;var obj = (new Function(&#x27;return &#x27; + json))(); 实现 Promise实现 Promise 需要完全读懂 Promise A+ 规范，不过从总体的实现上看，有如下几个点需要考虑到： then 需要支持链式调用，所以得返回一个新的 Promise； 处理异步问题，所以得先用 onResolvedCallbacks 和 onRejectedCallbacks 分别把成功和失败的回调存起来； 为了让链式调用正常进行下去，需要判断 onFulfilled 和 onRejected 的类型； onFulfilled 和 onRejected 需要被异步调用，这里用 setTimeout 模拟异步； 处理 Promise 的 resolve； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140const PENDING = &#x27;pending&#x27;;const FULFILLED = &#x27;fulfilled&#x27;;const REJECTED = &#x27;rejected&#x27;;class Promise &#123; constructor(executor) &#123; this.status = PENDING; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) = &gt; &#123; if (this.status === PENDING) &#123; this.status = FULFILLED; this.value = value; this.onResolvedCallbacks.forEach((fn) = &gt; fn()); &#125; &#125;; let reject = (reason) = &gt; &#123; if (this.status === PENDING) &#123; this.status = REJECTED; this.reason = reason; this.onRejectedCallbacks.forEach((fn) = &gt; fn()); &#125; &#125;; try &#123; executor(resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125; then(onFulfilled, onRejected) &#123; // 解决 onFufilled，onRejected 没有传值的问题 onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : (v) = &gt; v; // 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获 onRejected = typeof onRejected === &quot;function&quot; ? onRejected : (err) = &gt; &#123; throw err; &#125;; // 每次调用 then 都返回一个新的 promise let promise2 = new Promise((resolve, reject) = &gt; &#123; if (this.status === FULFILLED) &#123; //Promise/A+ 2.2.4 --- setTimeout setTimeout(() = &gt; &#123; try &#123; let x = onFulfilled(this.value); // x可能是一个proimise resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === REJECTED) &#123; //Promise/A+ 2.2.3 setTimeout(() = &gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === PENDING) &#123; this.onResolvedCallbacks.push(() = &gt; &#123; setTimeout(() = &gt; &#123; try &#123; let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); this.onRejectedCallbacks.push(() = &gt; &#123; setTimeout(() = &gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); &#125; &#125;); return promise2; &#125;&#125;const resolvePromise = (promise2, x, resolve, reject) = &gt; &#123; // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise Promise/A+ 2.3.1 if (promise2 === x) &#123; return reject( new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;)); &#125; // Promise/A+ 2.3.3.3.3 只能调用一次 let called; // 后续的条件要严格判断 保证代码能和别的库一起使用 if ((typeof x === &quot;object&quot; &amp;&amp; x != null) || typeof x === &quot;function&quot;) &#123; try &#123; // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候） Promise/A+ 2.3.3.1 let then = x.then; if (typeof then === &quot;function&quot;) &#123; // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty Promise/A+ 2.3.3.3 then.call( x, (y) = &gt; &#123; // 根据 promise 的状态决定是成功还是失败 if (called) return; called = true; // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1 resolvePromise(promise2, y, resolve, reject); &#125;, (r) = &gt; &#123; // 只要失败就失败 Promise/A+ 2.3.3.3.2 if (called) return; called = true; reject(r); &#125;); &#125; else &#123; // 如果 x.then 是个普通值就直接返回 resolve 作为结果 Promise/A+ 2.3.3.4 resolve(x); &#125; &#125; catch (e) &#123; // Promise/A+ 2.3.3.2 if (called) return; called = true; reject(e); &#125; &#125; else &#123; // 如果 x 是个普通值就直接返回 resolve 作为结果 Promise/A+ 2.3.4 resolve(x); &#125;&#125;; Promise 写完之后可以通过 promises-aplus-tests 这个包对我们写的代码进行测试，看是否符合 A+ 规范。不过测试前还得加一段代码： 123456789101112// promise.js// 这里是上面写的 Promise 全部代码Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new Promise((resolve,reject)=&gt;&#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;module.exports = Promise; 全局安装： 1npm i promises-aplus-tests -g 终端下执行验证命令： 1promises-aplus-tests promise.js 上面写的代码可以顺利通过全部 872 个测试用例。 参考： BAT前端经典面试问题：史上最最最详细的手写Promise教程 100 行代码实现 Promises/A+ 规范 Promise.resolvePromsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。 1234567Promise.resolve = function(value) &#123; // 如果是 Promsie，则直接输出它 if(value instanceof Promise)&#123; return value &#125; return new Promise(resolve =&gt; resolve(value))&#125; 参考：深入理解 Promise Promise.reject和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。 123Promise.reject = function(reason) &#123; return new Promise((resolve, reject) =&gt; reject(reason))&#125; Promise.allPromise.all 的规则是这样的： 传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise； 只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值； 只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise； 12345678910111213141516Promise.all = function(promiseArr) &#123; let index = 0, result = [] return new Promise((resolve, reject) =&gt; &#123; promiseArr.forEach((p, i) =&gt; &#123; Promise.resolve(p).then(val =&gt; &#123; index++ result[i] = val if (index === promiseArr.length) &#123; resolve(result) &#125; &#125;, err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125; Promise.racePromise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。 1234567891011Promise.race = function(promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; promiseArr.forEach(p =&gt; &#123; Promise.resolve(p).then(val =&gt; &#123; resolve(val) &#125;, err =&gt; &#123; rejecte(err) &#125;) &#125;) &#125;)&#125; Promise.allSettledPromise.allSettled 的规则是这样： 所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise，且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象； 如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例； 12345678910111213141516171819202122232425Promise.allSettled = function(promiseArr) &#123; let result = [] return new Promise((resolve, reject) =&gt; &#123; promiseArr.forEach((p, i) =&gt; &#123; Promise.resolve(p).then(val =&gt; &#123; result.push(&#123; status: &#x27;fulfilled&#x27;, value: val &#125;) if (result.length === promiseArr.length) &#123; resolve(result) &#125; &#125;, err =&gt; &#123; result.push(&#123; status: &#x27;rejected&#x27;, reason: err &#125;) if (result.length === promiseArr.length) &#123; resolve(result) &#125; &#125;) &#125;) &#125;) &#125; Promise.anyPromise.any 的规则是这样： 空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误； 只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例； 其他情况都会返回一个 pending 的新实例； 1234567891011121314151617Promise.any = function(promiseArr) &#123; let index = 0 return new Promise((resolve, reject) =&gt; &#123; if (promiseArr.length === 0) return promiseArr.forEach((p, i) =&gt; &#123; Promise.resolve(p).then(val =&gt; &#123; resolve(val) &#125;, err =&gt; &#123; index++ if (index === promiseArr.length) &#123; reject(new AggregateError(&#x27;All promises were rejected&#x27;)) &#125; &#125;) &#125;) &#125;)&#125; 后话能看到这里的对代码都是真爱了，毕竟代码这玩意看起来是真的很枯燥，但是如果看懂了后，就会像打游戏赢了一样开心，而且这玩意会上瘾，当你通关了越多的关卡后，你的能力就会拔高一个层次。用标题的话来说就是：搞懂后，提升真的大。加油吧💪，干饭人 噢不，代码人。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"1.5 万字 CSS 基础拾遗（核心知识、常用需求）","slug":"css_base","date":"2021-03-22T01:20:26.000Z","updated":"2021-09-06T09:56:22.607Z","comments":true,"path":"2021/03/22/css_base/","link":"","permalink":"https://bubuzou.com/2021/03/22/css_base/","excerpt":"本篇文章围绕了 CSS 的核心知识点和项目中常见的需求来展开。虽然行文偏长，但偏基础，适合初级中级前端阅读，阅读的时候请适当跳过已经掌握的部分。 这篇文章断断续续写了比较久，也参考了许多优秀的文章，但或许文章里还是存在不好或不对的地方，请多多指教，可以评论里直接提出来哈。 小 tip：后续内容更精彩哦。","text":"本篇文章围绕了 CSS 的核心知识点和项目中常见的需求来展开。虽然行文偏长，但偏基础，适合初级中级前端阅读，阅读的时候请适当跳过已经掌握的部分。 这篇文章断断续续写了比较久，也参考了许多优秀的文章，但或许文章里还是存在不好或不对的地方，请多多指教，可以评论里直接提出来哈。 小 tip：后续内容更精彩哦。 核心概念和知识点语法CSS 的核心功能是将 CSS 属性设定为特定的值。一个属性与值的键值对被称为声明（declaration）。 1color: red; 而如果将一个或者多个声明用 &#123;&#125; 包裹起来后，那就组成了一个声明块（declaration block）。 1234 &#123; color: red; text-align: center;&#125; 声明块如果需要作用到对应的 HTML 元素，那还需要加上选择器。选择器和声明块组成了CSS 规则集（CSS ruleset），常简称为 CSS 规则。 1234span &#123; color: red; text-align: center;&#125; 规则集中最后一条声明可以省略分号，但是并不建议这么做，因为容易出错。 CSS 中的注释： 123456/* 单行注释 *//* 多行 注释*/ 在 CSS 文件中，除了注释、CSS 规则集以及 @规则 外，定义的一些别的东西都将被浏览器忽略。 @规则CSS 规则是样式表的主体，通常样式表会包括大量的规则列表。但有时候也需要在样式表中包括其他的一些信息，比如字符集，导入其它的外部样式表，字体等，这些需要专门的语句表示。 而 @规则 就是这样的语句。CSS 里包含了以下 @规则： @namespace 告诉 CSS 引擎必须考虑 XML 命名空间。 @media, 如果满足媒体查询的条件则条件规则组里的规则生效。 @page, 描述打印文档时布局的变化. @font-face, 描述将下载的外部的字体。 @keyframes, 描述 CSS 动画的关键帧。 @document, 如果文档样式表满足给定条件则条件规则组里的规则生效。 (推延至 CSS Level 4 规范) 除了以上这几个之外，下面还将对几个比较生涩的 @规则 进行介绍。 @charset@charset 用于定义样式表使用的字符集。它必须是样式表中的第一个元素。如果有多个 @charset 被声明，只有第一个会被使用，而且不能在 HTML 元素或 HTML 页面的 &lt;style&gt; 元素内使用。 注意：值必须是双引号包裹，且和 1@charset &quot;UTF-8&quot;; 平时写样式文件都没写 @charset 规则，那这个 CSS 文件到底是用的什么字符编码的呢？ 某个样式表文件到底用的是什么字符编码，浏览器有一套识别顺序（优先级由高到低）： 文件开头的 Byte order mark 字符值，不过一般编辑器并不能看到文件头里的 BOM 值； HTTP 响应头里的 content-type 字段包含的 charset 所指定的值，比如： 1Content-Type: text&#x2F;css; charset&#x3D;utf-8 CSS 文件头里定义的 @charset 规则里指定的字符编码； &lt;link&gt; 标签里的 charset 属性，该条已在 HTML5 中废除； 默认是 UTF-8。 @import@import 用于告诉 CSS 引擎引入一个外部样式表。 link 和 @import 都能导入一个样式文件，它们有什么区别嘛？ link 是 HTML 标签，除了能导入 CSS 外，还能导入别的资源，比如图片、脚本和字体等；而 @import 是 CSS 的语法，只能用来导入 CSS； link 导入的样式会在页面加载时同时加载，@import 导入的样式需等页面加载完成后再加载； link 没有兼容性问题，@import 不兼容 ie5 以下； link 可以通过 JS 操作 DOM 动态引入样式表改变样式，而@import 不可以。 @supports@supports 用于查询特定的 CSS 是否生效，可以结合 not、and 和 or 操作符进行后续的操作。 123456/* 如果支持自定义属性，则把 body 颜色设置为变量 varName 指定的颜色 */@supports (--foo: green) &#123; body &#123; color: var(--varName); &#125;&#125; 层叠性层叠样式表，这里的层叠怎么理解呢？其实它是 CSS 中的核心特性之一，用于合并来自多个源的属性值的算法。比如说针对某个 HTML 标签，有许多的 CSS 声明都能作用到的时候，那最后谁应该起作用呢？层叠性说的大概就是这个。 针对不同源的样式，将按照如下的顺序进行层叠，越往下优先级越高： 用户代理样式表中的声明(例如，浏览器的默认样式，在没有设置其他样式时使用)。 用户样式表中的常规声明(由用户设置的自定义样式。由于 Chrome 在很早的时候就放弃了用户样式表的功能，所以这里将不再考虑它的排序。)。 作者样式表中的常规声明(这些是我们 Web 开发人员设置的样式)。 作者样式表中的 !important 声明。 用户样式表中的 !important 声明 S。 理解层叠性的时候需要结合 CSS 选择器的优先级以及继承性来理解。比如针对同一个选择器，定义在后面的声明会覆盖前面的；作者定义的样式会比默认继承的样式优先级更高。 选择器CSS 选择器无疑是其核心之一，对于基础选择器以及一些常用伪类必须掌握。下面列出了常用的选择器。想要获取更多选择器的用法可以看 MDN CSS Selectors。 基础选择器 标签选择器：h1 类选择器：.checked ID 选择器：#picker 通配选择器：* 属性选择器 [attr]：指定属性的元素； [attr=val]：属性等于指定值的元素； [attr*=val]：属性包含指定值的元素； [attr^=val] ：属性以指定值开头的元素； [attr$=val]：属性以指定值结尾的元素； [attr~=val]：属性包含指定值(完整单词)的元素(不推荐使用)； [attr|=val]：属性以指定值(完整单词)开头的元素(不推荐使用)； 组合选择器 相邻兄弟选择器：A + B 普通兄弟选择器：A ~ B 子选择器：A &gt; B 后代选择器：A B 伪类条件伪类 :lang()：基于元素语言来匹配页面元素； :dir()：匹配特定文字书写方向的元素； :has()：匹配包含指定元素的元素； :is()：匹配指定选择器列表里的元素； :not()：用来匹配不符合一组选择器的元素； 行为伪类 :active：鼠标激活的元素； :hover： 鼠标悬浮的元素； ::selection：鼠标选中的元素； 状态伪类 :target：当前锚点的元素； :link：未访问的链接元素； :visited：已访问的链接元素； :focus：输入聚焦的表单元素； :required：输入必填的表单元素； :valid：输入合法的表单元素； :invalid：输入非法的表单元素； :in-range：输入范围以内的表单元素； :out-of-range：输入范围以外的表单元素； :checked：选项选中的表单元素； :optional：选项可选的表单元素； :enabled：事件启用的表单元素； :disabled：事件禁用的表单元素； :read-only：只读的表单元素； :read-write：可读可写的表单元素； :blank：输入为空的表单元素； :current()：浏览中的元素； :past()：已浏览的元素； :future()：未浏览的元素； 结构伪类 :root：文档的根元素； :empty：无子元素的元素； :first-letter：元素的首字母； :first-line：元素的首行； :nth-child(n)：元素中指定顺序索引的元素； :nth-last-child(n)：元素中指定逆序索引的元素；； :first-child ：元素中为首的元素； :last-child ：元素中为尾的元素； :only-child：父元素仅有该元素的元素； :nth-of-type(n) ：标签中指定顺序索引的标签； :nth-last-of-type(n)：标签中指定逆序索引的标签； :first-of-type ：标签中为首的标签； :last-of-type：标签中为尾标签； :only-of-type：父元素仅有该标签的标签； 伪元素 ::before：在元素前插入内容； ::after：在元素后插入内容； 优先级 优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。为了记忆，可以把权重分成如下几个等级，数值越大的权重越高： 10000：!important； 01000：内联样式； 00100：ID 选择器； 00010：类选择器、伪类选择器、属性选择器； 00001：元素选择器、伪元素选择器； 00000：通配选择器、后代选择器、兄弟选择器； 可以看到内联样式（通过元素中 style 属性定义的样式）的优先级大于任何选择器；而给属性值加上 !important 又可以把优先级提至最高，就是因为它的优先级最高，所以需要谨慎使用它，以下有些使用注意事项： 一定要优先考虑使用样式规则的优先级来解决问题而不是 !important； 只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important； 永远不要在你的插件中使用 !important； 永远不要在全站范围的 CSS 代码中使用 !important； 继承性 在 CSS 中有一个很重要的特性就是子元素会继承父元素对应属性计算后的值。比如页面根元素 html 的文本颜色默认是黑色的，页面中的所有其他元素都将继承这个颜色，当申明了如下样式后，H1 文本将变成橙色。 123456body &#123; color: orange;&#125;h1 &#123; color: inherit;&#125; 设想一下，如果 CSS 中不存在继承性，那么我们就需要为不同文本的标签都设置一下 color，这样一来的后果就是 CSS 的文件大小就会无限增大。 CSS 属性很多，但并不是所有的属性默认都是能继承父元素对应属性的，那哪些属性存在默认继承的行为呢？一定是那些不会影响到页面布局的属性，可以分为如下几类： 字体相关：font-family、font-style、font-size、font-weight 等； 文本相关：text-align、text-indent、text-decoration、text-shadow、letter-spacing、word-spacing、white-space、line-height、color 等； 列表相关：list-style、list-style-image、list-style-type、list-style-position 等； 其他属性：visibility、cursor 等； 对于其他默认不继承的属性也可以通过以下几个属性值来控制继承行为： inherit：继承父元素对应属性的计算值； initial：应用该属性的默认值，比如 color 的默认值是 #000； unset：如果属性是默认可以继承的，则取 inherit 的效果，否则同 initial； revert：效果等同于 unset，兼容性差。 文档流在 CSS 的世界中，会把内容按照从左到右、从上到下的顺序进行排列显示。正常情况下会把页面分割成一行一行的显示，而每行又可能由多列组成，所以从视觉上看起来就是从上到下从左到右，而这就是 CSS 中的流式布局，又叫文档流。文档流就像水一样，能够自适应所在的容器，一般它有如下几个特性： 块级元素默认会占满整行，所以多个块级盒子之间是从上到下排列的； 内联元素默认会在一行里一列一列的排布，当一行放不下的时候，会自动切换到下一行继续按照列排布； 如何脱离文档流呢？ 脱流文档流指节点脱流正常文档流后，在正常文档流中的其他节点将忽略该节点并填补其原先空间。文档一旦脱流，计算其父节点高度时不会将其高度纳入，脱流节点不占据空间。有两种方式可以让元素脱离文档流：浮动和定位。 使用浮动（float）会将元素脱离文档流，移动到容器左/右侧边界或者是另一个浮动元素旁边，该浮动元素之前占用的空间将被别的元素填补，另外浮动之后所占用的区域不会和别的元素之间发生重叠； 使用绝对定位（position: absolute;）或者固定定位（position: fixed;）也会使得元素脱离文档流，且空出来的位置将自动被后续节点填补。 盒模型在 CSS 中任何元素都可以看成是一个盒子，而一个盒子是由 4 部分组成的：内容（content）、内边距（padding）、边框（border）和外边距（margin）。 盒模型有 2 种：标准盒模型和 IE 盒模型，分别是由 W3C 和 IExplore 制定的标准。 如果给某个元素设置如下样式： 1234567.box &#123; width: 200px; height: 200px; padding: 10px; border: 1px solid #eee; margin: 10px;&#125; 标准盒模型认为：盒子的实际尺寸 = 内容（设置的宽/高） + 内边距 + 边框 所以 .box 元素内容的宽度就为 200px，而实际的宽度则是 width + padding-left + padding-right + border-left-width + border-right-width = 200 + 10 + 10 + 1 + 1 = 222。 IE 盒模型认为：盒子的实际尺寸 = 设置的宽/高 = 内容 + 内边距 + 边框 .box 元素所占用的实际宽度为 200px，而内容的真实宽度则是 width - padding-left - padding-right - border-left-width - border-right-width = 200 - 10 - 10 - 1 - 1 = 178。 现在高版本的浏览器基本上默认都是使用标准盒模型，而像 IE6 这种老古董才是默认使用 IE 盒模型的。 在 CSS3 中新增了一个属性 box-sizing，允许开发者来指定盒子使用什么标准，它有 2 个值： content-box：标准盒模型； border-box：IE 盒模型； 视觉格式化模型视觉格式化模型（Visual formatting model）是用来处理和在视觉媒体上显示文档时使用的计算规则。CSS 中一切皆盒子，而视觉格式化模型简单来理解就是规定这些盒子应该怎么样放置到页面中去，这个模型在计算的时候会依赖到很多的因素，比如：盒子尺寸、盒子类型、定位方案（是浮动还是定位）、兄弟元素或者子元素以及一些别的因素。 从上图中可以看到视觉格式化模型涉及到的内容很多，有兴趣深入研究的可以结合上图看这个 W3C 的文档 Visual formatting model。所以这里就简单介绍下盒子类型。 盒子类型由 display 决定，同时给一个元素设置 display 后，将会决定这个盒子的 2 个显示类型（display type）： outer display type（对外显示）：决定了该元素本身是如何布局的，即参与何种格式化上下文； inner display type（对内显示）：其实就相当于把该元素当成了容器，规定了其内部子元素是如何布局的，参与何种格式化上下文； outer display type对外显示方面，盒子类型可以分成 2 类：block-level box（块级盒子） 和 inline-level box（行内级盒子）。 依据上图可以列出都有哪些块级和行内级盒子： 块级盒子：display 为 block、list-item、table、flex、grid、flow-root 等； 行内级盒子：display 为 inline、inline-block、inline-table 等； 所有块级盒子都会参与 BFC，呈现垂直排列；而所有行内级盒子都参会 IFC，呈现水平排列。 除此之外，block、inline 和 inline-block 还有什么更具体的区别嘛？ block 占满一行，默认继承父元素的宽度；多个块元素将从上到下进行排列； 设置 width/height 将会生效； 设置 padding 和 margin 将会生效； inline 不会占满一行，宽度随着内容而变化；多个 inline 元素将按照从左到右的顺序在一行里排列显示，如果一行显示不下，则自动换行； 设置 width/height 将不会生效； 设置竖直方向上的 padding 和 margin 将不会生效； inline-block 是行内块元素，不单独占满一行，可以看成是能够在一行里进行左右排列的块元素； 设置 width/height 将会生效； 设置 padding 和 margin 将会生效； inner display type对内方面，其实就是把元素当成了容器，里面包裹着文本或者其他子元素。container box 的类型依据 display 的值不同，分为 4 种： block container：建立 BFC 或者 IFC； flex container：建立 FFC； grid container：建立 GFC; ruby container：接触不多，不做介绍。 值得一提的是如果把 img 这种替换元素（replaced element）申明为 block 是不会产生 container box 的，因为替换元素比如 img 设计的初衷就仅仅是通过 src 把内容替换成图片，完全没考虑过会把它当成容器。 参考： CSS 原理 - 你所不知道的 display 格式化上下文 格式化上下文格式化上下文（Formatting Context）是 CSS2.1 规范中的一个概念，大概说的是页面中的一块渲染区域，规定了渲染区域内部的子元素是如何排版以及相互作用的。 不同类型的盒子有不同格式化上下文，大概有这 4 类： BFC (Block Formatting Context) 块级格式化上下文； IFC (Inline Formatting Context) 行内格式化上下文； FFC (Flex Formatting Context) 弹性格式化上下文； GFC (Grid Formatting Context) 格栅格式化上下文； 其中 BFC 和 IFC 在 CSS 中扮演着非常重要的角色，因为它们直接影响了网页布局，所以需要深入理解其原理。 BFC块格式化上下文，它是一个独立的渲染区域，只有块级盒子参与，它规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。 BFC 渲染规则 内部的盒子会在垂直方向，一个接一个地放置； 盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠； 每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此； BFC 的区域不会与 float 盒子重叠； BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算 BFC 的高度时，浮动元素也参与计算。 如何创建 BFC？ 根元素：html 非溢出的可见元素：overflow 不为 visible 设置浮动：float 属性不为 none 设置定位：position 为 absolute 或 fixed 定义成块级的非块级元素：display: inline-block/table-cell/table-caption/flex/inline-flex/grid/inline-grid BFC 应用场景 1、 自适应两栏布局 应用原理：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。 1234&lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;&lt;/div&gt; 12345678.aside &#123; float: left; width: 100px;&#125;.main &#123; &lt;!-- 触发 BFC --&gt; overflow: auto;BFCoverflow&#125; 2、清除内部浮动 浮动造成的问题就是父元素高度坍塌，所以清除浮动需要解决的问题就是让父元素的高度恢复正常。而用 BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。 123.parent &#123; overflow: hidden;&#125; 3、 防止垂直 margin 合并 BFC 渲染原理之一：同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个 BFC 中即可阻止垂直 margin 合并。那如何让 2 个相邻的兄弟元素不在同一个 BFC 中呢？可以给其中一个元素外面包裹一层，然后触发其包裹层的 BFC，这样一来 2 个元素就不会在同一个 BFC 中了。 123456&lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;a&quot;&gt;a&lt;/div&gt; &lt;div class=&quot;contain-b&quot;&gt; &lt;div class=&quot;b&quot;&gt;b&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678.demo3 .a,.demo3 .b &#123; border: 1px solid #999; margin: 10px;&#125;.contain-b &#123; overflow: hidden;&#125; 针对以上 3 个 示例 ，可以结合这个 BFC 应用示例 配合观看更佳。 参考：CSS 原理 - Formatting Context IFCIFC 的形成条件非常简单，块级元素中仅包含内联级别元素，需要注意的是当 IFC 中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。 IFC 渲染规则 子元素在水平方向上一个接一个排列，在垂直方向上将以容器顶部开始向下排列； 节点无法声明宽高，其中 margin 和 padding 在水平方向有效在垂直方向无效； 节点在垂直方向上以不同形式对齐； 能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的线盒（line box）。线盒的宽度是由包含块（containing box）和与其中的浮动来决定； IFC 中的 line box 一般左右边贴紧其包含块，但 float 元素会优先排列。 IFC 中的 line box 高度由 line-height 计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同； 当内联级盒子的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性值来决定； 当一个内联盒子超过父元素的宽度时，它会被分割成多盒子，这些盒子分布在多个 line box 中。如果子元素未设置强制换行的情况下，inline box 将不可被分割，将会溢出父元素。 针对如上的 IFC 渲染规则，你是不是可以分析下下面这段代码的 IFC 环境是怎么样的呢？ 1&lt;p&gt;It can get &lt;strong&gt;very complicated&lt;/storng&gt; once you start looking into it.&lt;/p&gt; 对应上面这样一串 HTML 分析如下： p 标签是一个 block container，对内将产生一个 IFC； 由于一行没办法显示完全，所以产生了 2 个线盒（line box）；线盒的宽度就继承了 p 的宽度；高度是由里面的内联盒子的 line-height 决定； It can get：匿名的内联盒子； very complicated：strong 标签产生的内联盒子； once you start：匿名的内联盒子； looking into it.：匿名的内联盒子。 参考：Inline formatting contexts IFC 应用场景 水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中。 偷个懒，demo 和图我就不做了。 层叠上下文在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴。众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开，而这其实就是层叠上下文所要描述的东西。 我们对层叠上下文的第一印象可能要来源于 z-index，认为它的值越大，距离屏幕观察者就越近，那么层叠等级就越高，事实确实是这样的，但层叠上下文的内容远非仅仅如此： z-index 能够在层叠上下文中对元素的堆叠顺序其作用是必须配合定位才可以； 除了 z-index 之外，一个元素在 Z 轴上的显示顺序还受层叠等级和层叠顺序影响； 在看层叠等级和层叠顺序之前，我们先来看下如何产生一个层叠上下文，特定的 HTML 元素或者 CSS 属性产生层叠上下文，MDN 中给出了这么一个列表，符合以下任一条件的元素都会产生层叠上下文： html 文档根元素 声明 position: absolute/relative 且 z-index 值不为 auto 的元素； 声明 position: fixed/sticky 的元素； flex 容器的子元素，且 z-index 值不为 auto； grid 容器的子元素，且 z-index 值不为 auto； opacity 属性值小于 1 的元素； mix-blend-mode 属性值不为 normal 的元素； 以下任意属性值不为 none 的元素： transform filter perspective clip-path mask / mask-image / mask-border isolation 属性值为 isolate 的元素； -webkit-overflow-scrolling 属性值为 touch 的元素； will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素； contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。 层叠等级 层叠等级指节点在三维空间 Z 轴上的上下顺序。它分两种情况： 在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在 Z 轴上的上下顺序； 在其他普通元素中，它描述定义的是这些普通元素在 Z 轴上的上下顺序； 普通节点的层叠等级优先由其所在的层叠上下文决定，层叠等级的比较只有在当前层叠上下文中才有意义，脱离当前层叠上下文的比较就变得无意义了。 层叠顺序 在同一个层叠上下文中如果有多个元素，那么他们之间的层叠顺序是怎么样的呢？ 以下这个列表越往下层叠优先级越高，视觉上的效果就是越容易被用户看到（不会被其他元素覆盖）： 层叠上下文的 border 和 background z-index &lt; 0 的子节点 标准流内块级非定位的子节点 浮动非定位的子节点 标准流内行内非定位的子节点 z-index: auto/0 的子节点 z-index &gt; 0 的子节点 如何比较两个元素的层叠等级？ 在同一个层叠上下文中，比较两个元素就是按照上图的介绍的层叠顺序进行比较。 如果不在同一个层叠上下文中的时候，那就需要比较两个元素分别所处的层叠上下文的等级。 如果两个元素都在同一个层叠上下文，且层叠顺序相同，则在 HTML 中定义越后面的层叠等级越高。 参考：彻底搞懂 CSS 层叠上下文、层叠等级、层叠顺序、z-index 值和单位CSS 的声明是由属性和值组成的，而值的类型有许多种： 数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值； 百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的 font-size； 颜色：用于指定 background-color、color 等； 坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性； 函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等； 而还有些值是需要带单位的，比如 width: 100px，这里的 px 就是表示长度的单位，长度单位除了 px 外，比较常用的还有 em、rem、vw/vh 等。那他们有什么区别呢？又应该在什么时候使用它们呢？ px屏幕分辨率是指在屏幕的横纵方向上的像素点数量，比如分辨率 1920×1080 意味着水平方向含有 1920 个像素数，垂直方向含有 1080 个像素数。 而 px 表示的是 CSS 中的像素，在 CSS 中它是绝对的长度单位，也是最基础的单位，其他长度单位会自动被浏览器换算成 px。但是对于设备而言，它其实又是相对的长度单位，比如宽高都为 2px，在正常的屏幕下，其实就是 4 个像素点，而在设备像素比(devicePixelRatio) 为 2 的 Retina 屏幕下，它就有 16 个像素点。所以屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。 讲到这里，还有一些相关的概念需要理清下： 设备像素（Device pixels） 设备屏幕的物理像素，表示的是屏幕的横纵有多少像素点；和屏幕分辨率是差不多的意思。 设备像素比（DPR） 设备像素比表示 1 个 CSS 像素等于几个物理像素。 计算公式：DPR = 物理像素数 / 逻辑像素数； 在浏览器中可以通过 window.devicePixelRatio 来获取当前屏幕的 DPR。 像素密度（DPI/PPI） 像素密度也叫显示密度或者屏幕密度，缩写为 DPI(Dots Per Inch) 或者 PPI(Pixel Per Inch)。从技术角度说，PPI 只存在于计算机显示领域，而 DPI 只出现于打印或印刷领域。 计算公式：像素密度 = 屏幕对角线的像素尺寸 / 物理尺寸 比如，对于分辨率为 750 * 1334 的 iPhone 6 来说，它的像素密度为： 1Math.sqrt(750 * 750 + 1334 * 1334) / 4.7 = 326ppi 设备独立像素（DIP） DIP 是特别针对 Android 设备而衍生出来的，原因是安卓屏幕的尺寸繁多，因此为了显示能尽量和设备无关，而提出的这个概念。它是基于屏幕密度而计算的，认为当屏幕密度是 160 的时候，px = DIP。 计算公式：dip = px * 160 / dpi emem 是 CSS 中的相对长度单位中的一个。居然是相对的，那它到底是相对的谁呢？它有 2 层意思： 在 font-size 中使用是相对于父元素的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px； 在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等； 我们都知道每个浏览器都会给 HTML 根元素 html 设置一个默认的 font-size，而这个值通常是 16px。这也就是为什么 1em = 16px 的原因所在了。 em 在计算的时候是会层层计算的，比如： 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 123456div &#123; font-size: 2em;&#125;p &#123; font-size: 2em;&#125; 对于如上一个结构的 HTML，由于根元素 html 的字体大小是 16px，所以 p 标签最终计算出来后的字体大小会是 16 _ 2 _ 2 = 64px remrem(root em) 和 em 一样，也是一个相对长度单位，不过 rem 相对的是 HTML 的根元素 html。 rem 由于是基于 html 的 font-size 来计算，所以通常用于自适应网站或者 H5 中。 比如在做 H5 的时候，前端通常会让 UI 给 750px 宽的设计图，而在开发的时候可以基于 iPhone X 的尺寸 375px * 812px 来写页面，这样一来的话，就可以用下面的 JS 依据当前页面的视口宽度自动计算出根元素 html 的基准 font-size 是多少。 12345678910111213141516171819202122232425262728293031;(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = &#x27;orientationchange&#x27; in window ? &#x27;orientationchange&#x27; : &#x27;resize&#x27;, psdWidth = 750, // 设计图宽度 recalc = function () &#123; var clientWidth = docEl.clientWidth if (!clientWidth) return if (clientWidth &gt;= 640) &#123; docEl.style.fontSize = 200 * (640 / psdWidth) + &#x27;px&#x27; &#125; else &#123; docEl.style.fontSize = 200 * (clientWidth / psdWidth) + &#x27;px&#x27; &#125; &#125; if (!doc.addEventListener) return // 绑定事件的时候最好配合防抖函数 win.addEventListener(resizeEvt, debounce(recalc, 1000), false) doc.addEventListener(&#x27;DOMContentLoaded&#x27;, recalc, false) function debounce(func, wait) &#123; var timeout return function () &#123; var context = this var args = arguments clearTimeout(timeout) timeout = setTimeout(function () &#123; func.apply(context, args) &#125;, wait) &#125; &#125;&#125;)(document, window) 比如当视口是 375px 的时候，经过计算 html 的 font-size 会是 100px，这样有什么好处呢？好处就是方便写样式，比如从设计图量出来的 header 高度是 50px 的，那我们写样式的时候就可以直接写： 123header &#123; height: 0.5rem;&#125; 每个从设计图量出来的尺寸只要除于 100 即可得到当前元素的 rem 值，都不用经过计算，非常方便。偷偷告诉你，如果你把上面那串计算 html 标签 font-size 的 JS 代码中的 200 替换成 2，那在计算 rem 的时候就不需要除于 100 了，从设计图量出多大 px，就直接写多少个 rem。 vw/vhvw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位： 1vw = 视口宽度均分成 100 份中 1 份的长度； 1vh = 视口高度均分成 100 份中 1 份的长度； 在 JS 中 100vw = window.innerWidth，100vh = window.innerHeight。 vw/vh 的出现使得多了一种写自适应布局的方案，开发者不再局限于 rem 了。 相对视口的单位，除了 vw/vh 外，还有 vmin 和 vmax： vmin：取 vw 和 vh 中值较小的； vmax：取 vw 和 vh 中值较大的； 颜色体系CSS 中用于表示颜色的值种类繁多，足够构成一个体系，所以这里就专门拿出一个小节来讲解它。 根据 CSS 颜色草案 中提到的颜色值类型，大概可以把它们分为这几类： 颜色关键字 transparent 关键字 currentColor 关键字 RGB 颜色 HSL 颜色 颜色关键字颜色关键字（color keywords）是不区分大小写的标识符，它表示一个具体的颜色，比如 white（白），黑（black）等； 可接受的关键字列表在 CSS 的演变过程中发生了改变： CSS 标准 1 只接受 16 个基本颜色，称为 VGA 颜色，因为它们来源于 VGA 显卡所显示的颜色集合而被称为 VGA colors （视频图形阵列色彩）。 CSS 标准 2 增加了 orange 关键字。 从一开始，浏览器接受其它的颜色，由于一些早期浏览器是 X11 应用程序，这些颜色大多数是 X11 命名的颜色列表，虽然有一点不同。SVG 1.0 是首个正式定义这些关键字的标准；CSS 色彩标准 3 也正式定义了这些关键字。它们经常被称作扩展的颜色关键字， X11 颜色或 SVG 颜色 。 CSS 颜色标准 4 添加可 rebeccapurple 关键字来纪念 web 先锋 Eric Meyer。 如下这张图是 16 个基础色，又叫 VGA 颜色。截止到目前为止 CSS 颜色关键字总共有 146 个，这里可以查看 完整的色彩关键字列表。 需要注意的是如果声明的时候的颜色关键字是错误的，浏览器会忽略它。 transparent 关键字transparent 关键字表示一个完全透明的颜色，即该颜色看上去将是背景色。从技术上说，它是带有 alpha 通道为最小值的黑色，是 rgba(0,0,0,0) 的简写。 透明关键字有什么应用场景呢？ 实现三角形 下面这个图是用 4 条边框填充的正方形，看懂了它你大概就知道该如何用 CSS 写三角形了。 12345678div &#123; border-top-color: #ffc107; border-right-color: #00bcd4; border-bottom-color: #e26b6b; border-left-color: #cc7cda; border-width: 50px; border-style: solid;&#125; 用 transparent 实现三角形的原理： 首先宽高必须是 0px，通过边框的粗细来填充内容； 那条边需要就要加上颜色，而不需要的边则用 transparent； 想要什么样姿势的三角形，完全由上下左右 4 条边的中有颜色的边和透明的边的位置决定； 等腰三角形：设置一条边有颜色，然后紧挨着的 2 边是透明，且宽度是有颜色边的一半；直角三角形：设置一条边有颜色，然后紧挨着的任何一边透明即可。 看下示例： 增大点击区域 常常在移动端的时候点击的按钮的区域特别小，但是由于现实效果又不太好把它做大，所以常用的一个手段就是通过透明的边框来增大按钮的点击区域： 123.btn &#123; border: 5px solid transparent;&#125; currentColor 关键字currentColor 会取当前元素继承父级元素的文本颜色值或声明的文本颜色值，即 computed 后的 color 值。 比如，对于如下 CSS，该元素的边框颜色会是 red： 1234.btn &#123; color: red; border: 1px solid currentColor;&#125; RGB[A] 颜色RGB[A] 颜色是由 R(red)-G(green)-B(blue)-A(alpha) 组成的色彩空间。 在 CSS 中，它有两种表示形式： 十六进制符号； 函数符； 十六进制符号 RGB 中的每种颜色的值范围是 00~ff，值越大表示颜色越深。所以一个颜色正常是 6 个十六进制字符加上 # 组成，比如红色就是 #ff0000。 如果 RGB 颜色需要加上不透明度，那就需要加上 alpha 通道的值，它的范围也是 00~ff，比如一个带不透明度为 67% 的红色可以这样写 #ff0000aa。 使用十六进制符号表示颜色的时候，都是用 2 个十六进制表示一个颜色，如果这 2 个字符相同，还可以缩减成只写 1 个，比如，红色 #f00；带 67% 不透明度的红色 #f00a。 函数符 当 RGB 用函数表示的时候，每个值的范围是 0255 或者 0%100%，所以红色是 rgb(255, 0, 0)， 或者 rgb(100%, 0, 0)。 如果需要使用函数来表示带不透明度的颜色值，值的范围是 01 及其之间的小数或者 0%100%，比如带 67% 不透明度的红色是 rgba(255, 0, 0, 0.67) 或者 rgba(100%, 0%, 0%, 67%) 需要注意的是 RGB 这 3 个颜色值需要保持一致的写法，要嘛用数字要嘛用百分比，而不透明度的值的可以不用和 RGB 保持一致写法。比如 rgb(100%, 0, 0) 这个写法是无效的；而 rgb(100%, 0%, 0%, 0.67) 是有效的。 在第 4 代 CSS 颜色标准中，新增了一种新的函数写法，即可以把 RGB 中值的分隔逗号改成空格，而把 RGB 和 alpha 中的逗号改成 /，比如带 67% 不透明度的红色可以这样写 rgba(255 0 0 / 0.67)。另外还把 rgba 的写法合并到 rgb 函数中了，即 rgb 可以直接写带不透明度的颜色。 HSL[A] 颜色HSL[A] 颜色是由色相(hue)-饱和度(saturation)-亮度(lightness)-不透明度组成的颜色体系。 色相（H）是色彩的基本属性，值范围是 0360 或者 0deg360deg， 0 (或 360) 为红色, 120 为绿色, 240 为蓝色； 饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0~100% 的数值；0% 为灰色， 100% 全色； 亮度（L），取 0~100%，0% 为暗，100% 为白； 不透明度（A），取 0100%，或者 01 及之间的小数； 写法上可以参考 RGB 的写法，只是参数的值不一样。 给一个按钮设置不透明度为 67% 的红色的 color 的写法，以下全部写法效果一致： 12345678button &#123; color: #ff0000aa; color: #f00a; color: rgba(255, 0, 0, 0.67); color: rgb(100% 0% 0% / 67%); color: hsla(0, 100%, 50%, 67%); color: hsl(0deg 100% 50% / 67%);&#125; 小提示：在 Chrome DevTools 中可以按住 shift + 鼠标左键可以切换颜色的表示方式。 媒体查询媒体查询是指针对不同的设备、特定的设备特征或者参数进行定制化的修改网站的样式。 你可以通过给 &lt;link&gt; 加上 media 属性来指定该样式文件只能对什么设备生效，不指定的话默认是 all，即对所有设备都生效： 12&lt;link rel=&quot;stylesheet&quot; src=&quot;styles.css&quot; media=&quot;screen&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; src=&quot;styles.css&quot; media=&quot;print&quot; /&gt; 都支持哪些设备类型？ all：适用于所有设备； print：适用于在打印预览模式下在屏幕上查看的分页材料和文档； screen：主要用于屏幕； speech：主要用于语音合成器。 需要注意的是：通过 media 指定的 资源尽管不匹配它的设备类型，但是浏览器依然会加载它。 除了通过 &lt;link&gt; 让指定设备生效外，还可以通过 @media 让 CSS 规则在特定的条件下才能生效。响应式页面就是使用了 @media 才让一个页面能够同时适配 PC、Pad 和手机端。 12@media (min-width: 1000px) &#123;&#125; 媒体查询支持逻辑操作符： and：查询条件都满足的时候才生效； not：查询条件取反； only：整个查询匹配的时候才生效，常用语兼容旧浏览器，使用时候必须指定媒体类型； 逗号或者 or：查询条件满足一项即可匹配； 媒体查询还支持众多的媒体特性，使得它可以写出很复杂的查询条件： 123/* 用户设备的最小高度为680px或为纵向模式的屏幕设备 */@media (min-height: 680px), screen and (orientation: portrait) &#123;&#125; 常见需求自定义属性之前我们通常是在预处理器里才可以使用变量，而现在 CSS 里也支持了变量的用法。通过自定义属性就可以在想要使用的地方引用它。 自定义属性也和普通属性一样具有级联性，申明在 :root 下的时候，在全文档范围内可用，而如果是在某个元素下申明自定义属性，则只能在它及它的子元素下才可以使用。 自定义属性必须通过 --x 的格式申明，比如：–theme-color: red; 使用自定义属性的时候，需要用 var 函数。比如： 1234567&lt;!-- 定义自定义属性 -- &gt; :root &#123; --theme-color: red;&#125;&lt;!-- 使用变量 -- &gt; h1 &#123; color: var(--theme-color);&#125; 上图这个是使用 CSS 自定义属性配合 JS 实现的动态调整元素的 box-shadow，具体可以看这个 codepen demo。 1px 边框解决方案Retina 显示屏比普通的屏幕有着更高的分辨率，所以在移动端的 1px 边框就会看起来比较粗，为了美观通常需要把这个线条细化处理。这里有篇文章列举了 7 种方案可以参考一下：7 种方法解决移动端 Retina 屏幕 1px 边框问题 而这里附上最后一种通过伪类和 transform 实现的相对完美的解决方案： 只设置单条底部边框： 1234567891011121314151617.scale-1px-bottom &#123; position: relative; border: none;&#125;.scale-1px-bottom::after &#123; content: &#x27;&#x27;; position: absolute; left: 0; bottom: 0; background: #000; width: 100%; height: 1px; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;&#125; 同时设置 4 条边框： 1234567891011121314151617181920.scale-1px &#123; position: relative; margin-bottom: 20px; border: none;&#125;.scale-1px::after &#123; content: &#x27;&#x27;; position: absolute; top: 0; left: 0; border: 1px solid #000; -webkit-box-sizing: border-box; box-sizing: border-box; width: 200%; height: 200%; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: left top; transform-origin: left top;&#125; 清除浮动什么是浮动：浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。 为什么要清楚浮动，它造成了什么问题？ 因为浮动元素会脱离正常的文档流，并不会占据文档流的位置，所以如果一个父元素下面都是浮动元素，那么这个父元素就无法被浮动元素所撑开，这样一来父元素就丢失了高度，这就是所谓的浮动造成的父元素高度坍塌问题。 父元素高度一旦坍塌将对后面的元素布局造成影响，为了解决这个问题，所以需要清除浮动，让父元素恢复高度，那该如何做呢？ 这里介绍两种方法：通过 BFC 来清除、通过 clear 来清除。 BFC 清除浮动前面介绍 BFC 的时候提到过，计算 BFC 高度的时候浮动子元素的高度也将计算在内，利用这条规则就可以清楚浮动。 假设一个父元素 parent 内部只有 2 个子元素 child，且它们都是左浮动的，这个时候 parent 如果没有设置高度的话，因为浮动造成了高度坍塌，所以 parent 的高度会是 0，此时只要给 parent 创造一个 BFC，那它的高度就能恢复了。 而产生 BFC 的方式很多，我们可以给父元素设置 overflow: auto 来简单的实现 BFC 清除浮动，但是为了兼容 IE 最好用 overflow: hidden。 123.parent &#123; overflow: hidden;&#125; 通过 overflow: hidden 来清除浮动并不完美，当元素有阴影或存在下拉菜单的时候会被截断，所以该方法使用比较局限。 通过 clear 清除浮动我先把结论贴出来： 12345678.clearfix &#123; zoom: 1;&#125;.clearfix::after &#123; content: &#x27;&#x27;; display: block; clear: both;&#125; 这种写法的核心原理就是通过 ::after 伪元素为在父元素的最后一个子元素后面生成一个内容为空的块级元素，然后通过 clear 将这个伪元素移动到所有它之前的浮动元素的后面，画个图来理解一下。 可以结合这个 codepen demo 一起理解上图的 clear 清楚浮动原理。 上面这个 demo 或者图里为了展示需要所以给伪元素的内容设置为了 ::after，实际使用的时候需要设置为空字符串，让它的高度为 0，从而父元素的高度都是由实际的子元素撑开。 该方式基本上是现在人人都在用的清除浮动的方案，非常通用。 参考：CSS 中的浮动和清除浮动，梳理一下 消除浏览器默认样式针对同一个类型的 HTML 标签，不同的浏览器往往有不同的表现，所以在网站制作的时候，开发者通常都是需要将这些浏览器的默认样式清除，让网页在不同的浏览器上能够保持一致。 针对清除浏览器默认样式这件事，在很早之前 CSS 大师 Eric A. Meyer 就干过。它就是写一堆通用的样式用来重置浏览器默认样式，这些样式通常会放到一个命名为 reset.css 文件中。比如大师的 reset.css 是这么写的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section &#123; display: block;&#125;body &#123; line-height: 1;&#125;ol,ul &#123; list-style: none;&#125;blockquote,q &#123; quotes: none;&#125;blockquote:before,blockquote:after,q:before,q:after &#123; content: &#x27;&#x27;; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125; 他的这份 reset.css 据说是被使用最广泛的重设样式的方案了。 除了 reset.css 外，后来又出现了 Normalize.css 。关于 Normalize.css, 其作者 necolas 专门写了一篇文章介绍了它，并谈到了它和 reset.css 的区别。这个是他写那篇文章的翻译版：让我们谈一谈 Normalize.css。 文章介绍到：Normalize.css 只是一个很小的 CSS 文件，但它在默认的 HTML 元素样式上提供了跨浏览器的高度一致性。相比于传统的 CSS reset，Normalize.css 是一种现代的、为 HTML5 准备的优质替代方案，现在已经有很多知名的框架和网站在使用它了。 Normalize.css 的具体样式可以看这里 Normalize.css 区别于 reset.css，Normalize.css 有如下特点： reset.css 几乎为所有标签都设置了默认样式，而 Normalize.css 则是有选择性的保护了部分有价值的默认值； 修复了很多浏览器的 bug，而这是 reset.css 没做到的； 不会让你的调试工具变的杂乱，相反 reset.css 由于设置了很多默认值，所以在浏览器调试工具中往往会看到一大堆的继承样式，显得很杂乱； Normalize.css 是模块化的，所以可以选择性的去掉永远不会用到的部分，比如表单的一般化； Normalize.css 有详细的说明文档； 长文本处理默认：字符太长溢出了容器 字符超出部分换行 字符超出位置使用连字符 单行文本超出省略 多行文本超出省略 查看以上这些方案的示例： codepen demo 有意思的是刚好前两天看到 chokcoco 针对文本溢出也写了一篇文章，主要突出的是对整块的文本溢出处理。啥叫整块文本？比如，下面这种技术标签就是属于整块文本： 另外他还对 iOS/Safari 做了兼容处理，感兴趣的可以去阅读下：CSS 整块文本溢出省略特性探究。 水平垂直居中让元素在父元素中呈现出水平垂直居中的形态，无非就 3 种情况： 单行的文本、inline 或者 inline-block 元素； 固定宽高的块级盒子； 不固定宽高的块级盒子； 以下列到的所有水平垂直居中方案这里写了个 codepen demo，配合示例阅读效果更佳。 单行的文本、inline 或 inline-block 元素水平居中 此类元素需要水平居中，则父级元素必须是块级元素(block level)，且父级元素上需要这样设置样式： 123.parent &#123; text-align: center;&#125; 垂直居中 方法一：通过设置上下内间距一致达到垂直居中的效果： 1234.single-line &#123; padding-top: 10px; padding-bottom: 10px;&#125; 方法二：通过设置 height 和 line-height 一致达到垂直居中： 1234.single-line &#123; height: 100px; line-height: 100px;&#125; 固定宽高的块级盒子方法一：absolute + 负 margin 方法二：absolute + margin auto 方法三：absolute + calc 不固定宽高的块级盒子这里列了 6 种方法，参考了颜海镜 写的文章 ，其中的两种 line-height 和 writing-mode 方案看后让我惊呼：还有这种操作？学到了学到了。 方法一：absolute + transform 方法二：line-height + vertical-align 方法三：writing-mode 方法四：table-cell 方法五：flex 方法六：grid 常用布局两栏布局（边栏定宽主栏自适应）针对以下这些方案写了几个示例： codepen demo 方法一：float + overflow（BFC 原理） 方法二：float + margin 方法三：flex 方法四：grid 三栏布局（两侧栏定宽主栏自适应）针对以下这些方案写了几个示例： codepen demo 方法一：圣杯布局 方法二：双飞翼布局 方法三：float + overflow（BFC 原理） 方法四：flex 方法五：grid 多列等高布局结合示例阅读更佳：codepen demo 方法一：padding + 负 margin 方法二：设置父级背景图片 三行布局（头尾定高主栏自适应）列了 4 种方法，都是基于如下的 HTML 和 CSS 的，结合示例阅读效果更佳：codepen demo 1234567&lt;div class=&quot;layout&quot;&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/div&gt; 123456789101112131415html,body,.layout &#123; height: 100%;&#125;body &#123; margin: 0;&#125;header,footer &#123; height: 50px;&#125;main &#123; overflow-y: auto;&#125; 方法一：calc 方法二：absolute 方法三：flex 方法四：grid 结了个尾这是我断断续续写了 2 周完成的文章，算是自己对 CSS 的一个总结，虽然写得很长，但不足以覆盖所有 CSS 的知识，比如动画和一些 CSS3 的新特性就完全没涉及，因为这要写下来估计得有大几万字（其实就是懒 😝 ）。 码字作图不易，如果喜欢或者对你有丝毫帮助的话，帮忙点个 👍 哈，点赞就是我的动力。同时也希望自己能坚持认真的写下去，因为在总结提升自己的同时如果也能帮助更多的前端 er，那将会让我感觉很开心。","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"为你的网站加上 WebP 格式的图片吧","slug":"webp","date":"2021-01-23T01:49:25.000Z","updated":"2021-09-06T09:58:29.176Z","comments":true,"path":"2021/01/23/webp/","link":"","permalink":"https://bubuzou.com/2021/01/23/webp/","excerpt":"之前写了一篇文章：jpg、gif、png 和 svg 用于 web 上，我们该如何选择最合适的图像格式，介绍了这几种图片格式的特点，以及如何为网站选择合适的图片，然后评论区有位大佬让我补充下 WebP 格式，于是乎它来了。 什么是 WebP 格式WebP 是一种现代图像格式，可为 Web 上的图像提供出色的无损和有损压缩。 使用 WebP，网站管理员和 Web 开发人员可以创建更小，更丰富的图像，从而使 Web 更快。 与 PNG 相比，WebP 无损图像的尺寸要小 26％。 在同等的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。 无损 WebP 支持透明性（也称为 Alpha 通道），而仅增加了 22％ 的字节数。 对于可以接受有损 RGB 压缩的情况，有损 WebP 还支持透明性，与 PNG 相比，文件大小通常小 3 倍。 上面这 3 段话来源于 https://developers.google.com/speed/webp","text":"之前写了一篇文章：jpg、gif、png 和 svg 用于 web 上，我们该如何选择最合适的图像格式，介绍了这几种图片格式的特点，以及如何为网站选择合适的图片，然后评论区有位大佬让我补充下 WebP 格式，于是乎它来了。 什么是 WebP 格式WebP 是一种现代图像格式，可为 Web 上的图像提供出色的无损和有损压缩。 使用 WebP，网站管理员和 Web 开发人员可以创建更小，更丰富的图像，从而使 Web 更快。 与 PNG 相比，WebP 无损图像的尺寸要小 26％。 在同等的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。 无损 WebP 支持透明性（也称为 Alpha 通道），而仅增加了 22％ 的字节数。 对于可以接受有损 RGB 压缩的情况，有损 WebP 还支持透明性，与 PNG 相比，文件大小通常小 3 倍。 上面这 3 段话来源于 https://developers.google.com/speed/webp 为什么你需要这个格式因为 WebP 图像比 JPEG 和 PNG 图像小-通常文件大小减少 25-35％。这样可以减小页面大小并提高性能。举 2 个例子： YouTube 发现，切换到 WebP 缩略图可将页面加载速度提高 10％。 当他们切换到使用 WebP 时，Facebook 节省了 25-35％ 的 JPEG 文件大小，节省了 80％ 的 PNG 文件大小。 WebP 是 JPEG，PNG 和 GIF 图像的理想替代品。 另外，WebP 提供无损压缩和有损压缩。 在无损压缩中，不会丢失任何数据。 有损压缩会减小文件大小，但会以降低图像质量为代价。 如何将图片转成 WebP 格式通常，开发者会用如下两种方式来将图片转成 WebP 格式： cwebp 命令行工具 Imagemin WebP 插件（npm 包） 如果你的项目比较简单或者你仅需要将图片转化一次，那么 cwebp 命令行工具是一个很好的选择；而如果你使用构建工具比如 Webpack 或 Gulp 等去构建你的项目的时候，那么将图片转 WebP 使用 Imagemin WebP 插件就是你最好的选择了。 当你需要把图片转成 WebP 格式的时候，你可以设置很多的参数，但是你最需要关心的就仅仅只是压缩质量，你可以指定一个压缩的质量等级，它的范围是从 0 ~ 100，0 表示质量最差，100 是最好。那么该把它设置成多少才最合适呢？这就需要你好好的花费一翻功夫去实践到底哪个质量等级是既兼顾了呈现质量又不会使得文件太大呢？ 使用 cwebp 转换图片使用这个命令前需要先安装它的工具包 webp，按照如下几个步骤操作即可： 可以去这下载 webp 工具包 ，这个网站提供了很多版本的包，选择一个和电脑匹配的包，比如我是 Mac 系统，我下载的是 libwebp-1.1.0-rc2-mac-10.15 版本的包，下载完成后解压，然后把解压后的文件夹放到你想要存放的目录，我是把他放到了 /Applications/Utilities/ 下； 设置环境变量，使得命令可以在终端下使用。而我是直接修改当前用户下的 .bash_profile 文件，该文件目录：/Users/ccp/.bash_profile： 1export PATH&#x3D;$PATH:&#x2F;Applications&#x2F;Utilities&#x2F;libwebp-1.1.0-rc2-mac-10.15&#x2F;bin 修改完成后，需要让命令立即生效的话，需要在终端下运行：source .bash_profile 然后就可以在终端下输入 cwebp，如果它能提示你如何使用该命令，说明这个包安装好了，可以正常使用 cwebp 命令了。 阅读 libwebp 包的下的 READMD，可以发现，该包除了有 cwebp 命令外，还提供了很多额外的命令，具体用法可以自行查阅相关文档。 除了以上这种操作稍微麻烦的安装方式外，还可以使用 OS X 的包管理工具进行安装（你怎么不早说 😭）： Homebrew WebP package Macports WebP package 安装成功后，就可以愉快的使用 cwebp 命令了。来看看以下操作： 使用 cwebp 的默认压缩设置转换单张图片（默认是有损压缩，且默认的压缩的质量参数是 75）： 1cwebp images&#x2F;flower.jpg -o images&#x2F;flower.webp 使用 50 质量等级去转换单张图片： 1cwebp -q 50 images&#x2F;flower.jpg -o images&#x2F;flower.webp 转换指定目录下的所有文件： 1for file in images&#x2F;*; do cwebp &quot;$file&quot; -o &quot;$&#123;file%.*&#125;.webp&quot;; done 使用 Imagemin 转换图片Imagemin Webp 插件可以在 Node 环境中独立使用，也可以结合 Webpack 等构建工具使用。通常只需要 10 行左右代码即可配置完成。 Node 环境下配置，以下代码会把 images 目录下的图片转成 WebP 图片后存到 compressed_images 目录下： 123456789const imagemin = require(&#x27;imagemin&#x27;)const imageminWebp = require(&#x27;imagemin-webp&#x27;)imagemin([&#x27;images/*&#x27;], &#123; destination: &#x27;compressed_images&#x27;, plugins: [imageminWebp(&#123; quality: 50 &#125;)],&#125;).then(() =&gt; &#123; console.log(&#x27;Done!&#x27;)&#125;) 在构建工具 Webpack 下使用，这里还配合了 copy-webpack-plugin 插件实现图片的复制。以下代码来源于 webp-webpack： 123456789101112131415161718192021222324252627// Copyright 2018 Google LLC.// SPDX-License-Identifier: Apache-2.0const ImageminWebP = require(&#x27;imagemin-webp&#x27;)const ImageminPlugin = require(&#x27;imagemin-webpack-plugin&#x27;).defaultconst CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;)const path = require(&#x27;path&#x27;)module.exports = &#123; entry: &#x27;./index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), &#125;, plugins: [ new CopyWebpackPlugin([ &#123; from: &#x27;./images/**/**&#x27;, to: &#x27;./images/[name].webp&#x27;, &#125;, ]), new ImageminPlugin(&#123; // imagemin-webp docs: https://github.com/imagemin/imagemin-webp plugins: [ImageminWebP(&#123; quality: 50 &#125;)], &#125;), ],&#125; 你也可以尝试使用 imagemin-webp-webpack-plugin 这个插件，因为我看它最近 4 个月内有过更新，下载量也快 10K 了，应该可以满足需求。 对比 WebP 和 其他图片格式下面我用 PS 做了一张图片： 然后用它导出了 4 张图片，它们的信息如下： jpg_60.jpg：质量为 60 的 JPG 格式图片，48KB； jpg_100.jpg：质量为 100 的 JPG 格式图片，142KB； png_8.png：8 位的 PNG 格式图片，60KB； png_24.png：24 位的 PNG 格式图片，200KB； 然后我用如下命令，批量将他们转成了 WebP 格式的图片： 1for file in Downloads&#x2F;img&#x2F;*; do cwebp &quot;$file&quot; -o &quot;$&#123;file%.*&#125;.webp&quot;; done 然后可以看到 Downloads/img/ 文件夹下所有文件的信息如下： 发现这 4 张图片被转成 WebP 格式的图片后文件大小居然都差不多大，大概都是 22KB，比原来真的小了太多了，尤其是 PNG 24 和 JPG 质量 100 的图片体积缩减更加明显。而最差的 JPG 质量 60 的图片再被转成 WebP 格式后，体积竟然还缩减了 54% 左右。 接下来我们再把这 4 张图片通过在线工具 TinyPNG 压缩一下，以下是文件压缩后的信息（左右两列绿色数字分别表示：文件压缩前大小和压缩后大小）： 发现 TinyPNG 对 PNG 24 和 JPG 质量 100 的图片压缩效果比较明显。**另外将这压缩过的 4 张图片和 WebP 格式的图片（22KB）相比，发现 WebP 图片的文件大小还是明显小很多，小了超过 50%**，所以这就是为什么建议在 Web 应用上使用 WebP 图片的原因，真的优化太大了。 让 WebP 图片在 Mac 下正常预览从这往上翻的第二张图，可以发现 WebP 格式的图片在 Mac 下是无法正常预览的，所以需要给 Mac 加上这种能力。另外需要说一句 WebP 图片在 Chrome 下可以很好的支持了，直接将图片拖到浏览器中即可显示。 说到预览，看一下 WebP 在各浏览器下的兼容程度： 由上图可以看出，基本上现代浏览器已经能很好的支持 WebP 图片了，所以在生产环境上使用它是一点问题都没有。 Mac 需要正常预览 WebP 图片，可以在这里 qlImageSize 下载了 2 个插件来支持它： qlImageSize：QuickLook 插件，用来预览 WebP 图片，且能在标题栏里显示尺寸、文件大小等信息，另外还可以让 WebP 图片在访达中以缩略图的形式显示出来。 mdImageSize：Spotlight 插件，用来在显示简介的时候能够支持 WebP 图片的信息； 下载完这 2 个插件包后，解压，然后把插件复制到对应的目录下保存： qlImageSize 复制到 /Library/QuickLook 目录下； mdImageSize 复制到 /Library/Spotlight 目录下； 这个时候 WebP 图片应该就能快速预览了，还不行的话就重启下访达进程（按住 option，同时鼠标右键点击访达，选择重新开启）。 兼容不同浏览器如果你的网站对于不兼容 WebP 格式的图片的浏览器（比如 IE11）也有需求的话，那这里有一套方案可以让图片不会因为浏览器兼容性而显示出错： 12345&lt;picture&gt; &lt;source type=&quot;image/webp&quot; srcset=&quot;flower.webp&quot; /&gt; &lt;source type=&quot;image/jpeg&quot; srcset=&quot;flower.jpg&quot; /&gt; &lt;img src=&quot;flower.jpg&quot; alt=&quot;&quot; /&gt;&lt;/picture&gt; 对于上面这段代码，浏览器会首先检测是否支持 &lt;source&gt; 标签列表里的资源，如果兼容的话，默认会加载 flower.webp 图片，如果都不支持 &lt;source&gt; 列表里的资源的话，则会去加载 &lt;img&gt; 里指定的图片。 接下来该干什么之前我做的项目里的图片基本都是 JPG\\PNG 格式的，我找了一张我们网站首页的 Banner 图，就是那种 1920px 宽度的图片，它在被压缩工具压缩后文件大小还有 275 KB ，而当我用 cwebp 工具用 -q 75 的质量参数去转换成 WebP 图片后，你们知道它的文件大小变成多少了吗？它变成 50KB 😱 真的的不试不知道，一试吓一跳，原来 WebP 格式的图片能够带来这么大的优化效果，最关键的是 2 张图片用肉眼看起来显示效果差不多。 真的很棒 👍，WebP 凭借一己之力将网站的性能优化提高了一个档次。所以接下来 KPI 就有了：可以很愉快的把项目里所有的图片都转成 WebP 图片了。这么干完之后，你就可以和领导提涨薪了，领导领导我把我们网站优化了一下，性能提升了 10% ~ 20% 左右。不过接下来发生什么，可不要来找我哈。 参考文章 https://web.dev/serve-images-webp/ https://developers.google.com/speed/webp https://github.com/Nyx0uf/qlImageSize","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"图像","slug":"图像","permalink":"https://bubuzou.com/tags/%E5%9B%BE%E5%83%8F/"},{"name":"性能优化","slug":"性能优化","permalink":"https://bubuzou.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"让人爱不释手的 JS 扩展操作符 13 用","slug":"spread-operator","date":"2021-01-13T01:49:25.000Z","updated":"2021-01-26T00:43:28.808Z","comments":true,"path":"2021/01/13/spread-operator/","link":"","permalink":"https://bubuzou.com/2021/01/13/spread-operator/","excerpt":"我相信你一定或多或少的接触或使用过 JS 中的扩展操作符（Spread Operator），在基本形式中，扩展操作符看起来像三个点，比如如下这样： 1[...arr] 而实际上，它也就是这么用的，但是如果事情有这么简单，就不用我在这里写了。扩展操作符给我最大的印象就是，这玩意还挺方便的，然而最近写代码的时候经常性的遇到需要使用扩展操作符的场景，所以我干脆在网上找了些资料，把平时常见的应用场景给罗列了下，发现这个操作符是真的强大，有多强大？来看看下面这些用法吧。 1. 字符串转数组字符串转数组最普遍的做法是这样： 123let str = &#x27;hello&#x27;let arr = str.split(&#x27;&#x27;)console.log(arr) // [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] 而使用了扩展操作符后可以这样： 123let str = &#x27;hello&#x27;let arr = [...str]console.log(arr) // [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]","text":"我相信你一定或多或少的接触或使用过 JS 中的扩展操作符（Spread Operator），在基本形式中，扩展操作符看起来像三个点，比如如下这样： 1[...arr] 而实际上，它也就是这么用的，但是如果事情有这么简单，就不用我在这里写了。扩展操作符给我最大的印象就是，这玩意还挺方便的，然而最近写代码的时候经常性的遇到需要使用扩展操作符的场景，所以我干脆在网上找了些资料，把平时常见的应用场景给罗列了下，发现这个操作符是真的强大，有多强大？来看看下面这些用法吧。 1. 字符串转数组字符串转数组最普遍的做法是这样： 123let str = &#x27;hello&#x27;let arr = str.split(&#x27;&#x27;)console.log(arr) // [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] 而使用了扩展操作符后可以这样： 123let str = &#x27;hello&#x27;let arr = [...str]console.log(arr) // [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] 2. 将类数组转换为数组在 JS 中有一种数据结构叫做 NodeList，它和数组很相似，也被叫做“类数组”，类数组是什么？在 MDN 中是这么定义它的： 类数组：拥有一个 length 属性和若干索引属性的任意对象。 类数组有哪些呢？以下这些可以看成是类数组： NodeList：document.querySelectorAll() 返回的对象； HTMLCollection：document.getElementsByTagName() 返回的对象； Arguments：函数里的参数对象； 类数组没有数组的一些方法比如 push、map 等，所以经常需要将它们转成数组，而通常我们是这么转化的： 12345678910111213let nodeList = document.querySelectorAll(&#x27;div&#x27;)console.log(nodeList instanceof NodeList) // truelet arr = Array.apply(null, nodeList)console.log(arr instanceof Array) // true// 或者let arr2 = [].slice.call(nodeList)console.log(arr2 instanceof Array) // true// 又或者let arr3 = Array.from(nodeList)console.log(arr3 instanceof Array) // true 而有了扩展操作符可以这么做： 123let nodeList = document.querySelectorAll(&#x27;div&#x27;)let arr = [...nodeList]console.log(arr instanceof Array) // true 3. 向数组中添加项往数组中添加几项通常这样操作： 12345678910111213let arr = [5]// 从头部添加arr.unshift(1, 2)console.log(arr) // [1, 2, 5]// 从尾部添加arr.push(6, 7)console.log(arr) // [1，2, 5, 6, 7]// 从任意位置添加arr.splice(2, 0, 3, 4)console.log(arr) // [1，2, 3, 4, 5, 6, 7] 使用扩展操作符后： 123let arr = [3, 4]arr = [1, 2, ...arr, 5, 6]console.log(arr) // [1, 2, 3, 4, 5, 6] 4. 拷贝数组和对象通常拷贝一个数组，可以这么做： 123456789let arr = [1, 3, 5, 7]let arr2 = arr.concat()// 或者let arr3 = arr.slice()arr[0] = 2console.log(arr) // [2, 3, 5, 7]console.log(arr2) // [1, 3, 5, 7]console.log(arr3) // [1, 3, 5, 7] 但是有了扩展操作符，拷贝数组就能写得很简单： 1234let arr = [1, 3, 5, 7]let arr2 = [...arr]arr[0] = 2console.log(arr2) // [1, 3, 5, 7] 同样的，扩展操作符还能拷贝对象。拷贝对象的通常做法： 12345let person = &#123; name: &#x27;布兰&#x27;, age: 12&#125;let p2 = Object.assign(&#123;&#125;, person)person.age = 20console.log(person) // &#123; name: &#x27;布兰&#x27;, age: 20 &#125;console.log(p2) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 有了扩展操作符，拷贝一个对象就相当方便了： 12345678let person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;let p2 = &#123;...person&#125;person.age = 20console.log(person) // &#123; name: &#x27;布兰&#x27;, age: 20 &#125;console.log(p2) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125;// 甚至还可以这么写let &#123;...p3&#125; = person 注意：扩展操作符只能深拷贝结构为一层的对象，如果对象是两层的结构，那么使用扩展操作符拷贝会是浅拷贝。 5. 合并数组或对象数组合并通常是这么做的： 1234let arr1 = [1, 3, 5]let arr2 = [2, 4, 6]let arr3 = arr1.concat( arr2 )console.log(arr3) // [1, 3, 5, 2, 4, 6] 使用扩展操作符后，可以这么写： 1234let arr1 = [1, 3, 5]let arr2 = [2, 4, 6]let arr3 = [...arr1, ...arr2]console.log(arr3) // [1, 3, 5, 2, 4, 6] 对了，它除了能合并数组外还能合并对象呢。合并对象，通常的做法是： 1234let p1 = &#123; name: &#x27;布兰&#x27; &#125;let p2 = &#123; age: 12 &#125;let p3 = Object.assign(&#123;&#125;, p1, p2)console.log(p3) // &#123; name: &#x27;布兰&#x27;, age: 12&#125; 用扩展操作符合并对象： 1234let p1 = &#123; name: &#x27;布兰&#x27; &#125;let p2 = &#123; age: 12 &#125;let p3 = &#123; ...p1, ...p2 &#125;console.log(p3) // &#123; name: &#x27;布兰&#x27;, age: 12&#125; 6. 解构对象经常我们给对象设置参数的时候会这么做： 12345678let person = &#123; name: &#x27;布兰&#x27;, age: 12, sex: &#x27;male&#x27;&#125;let name = person.namelet age = person.agelet sex = person.sex 而有了扩展操作符，我们就可以这么写，不过其实如下这种写法并不是扩展操作符的写法🤣，而是剩余操作符的写法，虽然写出来后看起来差不多，但就在操作对象这一点上，基本上可以认为它和扩展操作符是相反的操作，扩展操作符是用来展开对象的属性到多个变量上，而剩余操作符是用来把多个参数凝聚到一个变量上。 12345678let person = &#123; name: &#x27;布兰&#x27;, age: 12, sex: &#x27;male&#x27;&#125;let &#123; name, ...reset &#125; = personconsole.log(name) // &#x27;布兰&#x27;console.log(reset) // &#123; age: 12, sex: &#x27;male&#x27; &#125; 7. 给对象添加属性给对象加属性通常这样加： 123let person = &#123; name: &#x27;布兰&#x27; &#125;person.age = 12console.log(person) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 使用扩展操作符给对象添加属性： 123let person = &#123; name: &#x27;布兰&#x27; &#125;person = &#123;...person, age: 12&#125;console.log(person) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 关于使用扩展操作符给对象添加属性，这里有 2 个小技巧： 给新对象设置默认值： 123// 默认 person 对象的 age 属性值 为 12let person = &#123;age: 12, ...&#123; name: &#x27;布兰&#x27; &#125; &#125;console.log(person) // &#123; age: 12, name: &#x27;布兰&#x27; &#125; 重写对象属性 12345let person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;// person 对象的 age 属性被重写为 20person = &#123;...person, age: 20 &#125;console.log(person) // &#123; name: &#x27;布兰&#x27;, age: 20 &#125; 8. 设置对象 Getter设置对象 Getter 通常做法是这样： 1234567let person = &#123; name: &#x27;布兰&#x27; &#125;Object.defineProperty(person, &#x27;age&#x27;, &#123; get() &#123; return 12 &#125;, enumerable: true, configurable: true&#125;)console.log(person.age) // 12 而有了扩展操作符后可以这么写： 123456let person = &#123; name: &#x27;布兰&#x27; &#125;person = &#123; ...person, get age() &#123; return 12 &#125;&#125;console.log(person.age) // 12 9. 将数组作为函数参数展开如果我们有一个形参是多个参数的函数，但是当调用的时候发现入参却是一个数组，常规做法是这样： 123let arr = [1, 3, 5]function fn(a, b, c) &#123; &#125; fn.apply(null, arr) 使用扩展操作符后，就简单多了： 123let arr = [1, 3, 5]function fn(a, b, c) &#123; &#125; fn(...arr) 10. 无限参数的函数如果有这么一个累加函数，他会把所有传递进来的参数都加起来，普通做法是把参数都整合到数组里，然后这样做： 12345function doSum(arr) &#123; return arr.reduce((acc, cur) =&gt; acc + cur)&#125;console.log( doSum([1, 3]) ) // 4console.log( doSum([1, 3, 5]) ) // 9 如果参数不是数组，而是需要一个个传递，相当于函数必须支持无限参数，那可能会这么做： 1234567891011121314function doSum() &#123; let sum = 0 for(let i = 0, l = arguments.length; i &lt; l; i++)&#123; sum += arguments[i] &#125; return sum // 或者 // let args = [].slice.call(arguments) // return args.reduce((acc, cur) =&gt; acc + cur)&#125;console.log( doSum(1, 3) ) // 4console.log( doSum(1, 3, 5) ) // 9console.log( doSum(1, 3, 5, 7) ) // 16 而有了扩展操作符，就简单多了： 123456function doSum(...arr) &#123; return arr.reduce((acc, cur) =&gt; acc + cur)&#125;console.log( doSum(1, 3) ) // 4console.log( doSum(1, 3, 5) ) // 9console.log( doSum(1, 3, 5, 7) ) // 16 11. 扩展函数的剩余参数有的时候一个函数需要传递很多的参数，比如小程序页面（WePY）的 onLoad 生命周期函数里就可能有很多别的页面传递过来的参数，然后还需要在函数里进行一些数据初始化工作，这样一来就会显得很臃肿不美观，比如： 123function init(a, b, x, y) &#123; // 进行一系列初始化数据工作&#125; 而使用了扩展操作符后，我们就可以按照业务把参数进行解构，把本该在一个函数里进行初始化的工作拆分成多个，可以这么做： 123456function other( x, y ) &#123;&#125;function init(a, b, ...restConfig) &#123; // 使用 a 和 b 参数进行操作 // 其余参数传给原始函数 return other( ...restConfig )&#125; 12. 结合 Math 函数使用比如当需要对一个数组求最大值的时候，通常会这么做： 1234567891011let arr = [3, 1, 8, 5, 4]function max(arr) &#123; return [].concat(arr).sort((a, b) =&gt; b - a)&#125;console.log(max(arr)[0]) // 8// 或者arr.reduce((acc, cur) =&gt; Math.max(acc, cur)) // 8// 又或者Math.max.apply(null, arr) // 8 但是使用扩展操作符后，能够把给数组求最大值写得更加简洁： 123let arr = [3, 1, 8, 5, 4]let max = Math.max(...arr)console.log(max) // 8 13. 在 new 表达式中使用假设有一个数组格式的日期，想要通过 Date 构造函数创建一个日期实例的话，可能会这么做： 12345678910let arr = [2021, 1, 1]let date = new Date([].toString.call(arr))console.log(date) // &#x27;Mon Feb 01 2021 00:00:00 GMT+0800 (中国标准时间)&#x27;// 或者let date2 = new (Function.prototype.bind.apply( Date, [null].concat(arr)))console.log(date2) // &#x27;Mon Feb 01 2021 00:00:00 GMT+0800 (中国标准时间)&#x27; 而有了扩展操作符就简单多了： 123let arr = [2021, 1, 1]let date = new Date(...arr)console.log(date) // &#x27;Mon Feb 01 2021 00:00:00 GMT+0800 (中国标准时间)&#x27; 总结这个操作符真可谓使用简单无脑，但是功能效率上不得不说很强大，所以我们要做的就是只要记住在什么时候使用它就好了，于是乎为了让大家能更好的记住这 13 种使用场景，我特意做了一个图，方便大家记忆，是不是很贴？是的话请不要吝啬你的爱心，给个小星星👍吧，感谢感谢。以上这些只列了 13 种写法，我觉得作为一个这么强大的操作符，肯定有更多使用的场景，欢迎把你们知道的写到评论区吧。 参考文章 「建议收藏」送你一份精心总结的3万字ES6实用指南（下） https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md https://github.com/tc39/proposal-object-rest-spread/blob/master/Rest.md https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"6 分钟了解 HTTP 发展史","slug":"http","date":"2021-01-05T01:49:25.000Z","updated":"2021-09-06T09:57:14.538Z","comments":true,"path":"2021/01/05/http/","link":"","permalink":"https://bubuzou.com/2021/01/05/http/","excerpt":"HTTP/0.9HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。 完整请求流程 因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。 建立好连接之后，会发送一个 GET 请求行的信息，如 GET /index.html 用来获取 index.html。 服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。 HTML 文档传输完成后，断开连接。","text":"HTTP/0.9HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。 完整请求流程 因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。 建立好连接之后，会发送一个 GET 请求行的信息，如 GET /index.html 用来获取 index.html。 服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。 HTML 文档传输完成后，断开连接。 特点 第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。 第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。 第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。 HTTP/1.0HTTP/0.9 存在许多的问题，比如如下的这些： 只支持 HTML 类型文件，无法传输 JS、CSS、字体、图片和视频等类型的文件； 文件传输格式局限于 ASCII，无法输出其他类型编码的文件； 只有请求行，传输给服务器的信息太少； 只响应请求数据，不能传输额外的数据给浏览器。 所以它已经不能满足当时的需求了，于是乎 HTTP/1.0 来了，它带来了这些： 新增了请求头和请求体，能传输更多的信息给服务器，比如如下请求头字段：Accept 文件类型，Accept-Encoding 压缩格式，Accept-Charset 字符编码格式，Accept-Language 国际化语音： 1234Accept: text&#x2F;htmlAccept-Encoding: gzip, deflate, brAccept-Charset: ISO-8859-1,utf-8Accept-Language: zh-CN,zh 请求头新增 User-Agent 字段，用于服务器统计客户端信息： 1User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 新增了响应头，能够告诉浏览器更多的信息，比如 Content-Encoding 表示服务器返回文件的压缩类型，Content-Type 告诉浏览器服务器返回的是什么类型的文件以及使用了什么编码格式： 12Content-Encoding: gzipContent-Type: text&#x2F;html; charset&#x3D;utf-8 新增响应行状态码，用于告知浏览器当前请求的状态，比如 200 表示请求成功： 1HTTP&#x2F;1.1 200 OK 新增缓存机制，用来缓存已经下载过的资源，减轻了服务端压力。 在构建请求流程上来看，HTTP/1.0 区别于 HTTP/0.9 最大的区别就是在请求和响应的时候新增了不少字段用于在浏览器和服务器之间通信。 HTTP/1.1HTTP/1.0 虽说已经能够传输不同类型的文件了，但是它还是有缺点的，比如每发出一次 HTTP 请求都需要经历如下阶段： 建立 TCP 连接； HTTP 请求； HTTP 响应； 断开 TCP 连接。 HTTP/1.0 发送多个同域名请求： 可以发现每次请求都需要重新建立 TCP 连接和断开连接的操作，这无疑增加了网络开销，同时也延迟了页面显示。 HTTP/1.1 在请求头中增加了 Connection 字段：用于提供 TCP 的持久连接**： 1Connection: keep-alive 它默认是开启持久连接的，即对于同一个域名，浏览器默认支持 6 个 TCP 持久连接。当启用持久连接后，多个同域名下的请求发送会是如下情况： HTTP/1.1 中新增 Host 字段，用于支持虚拟主机 1Host: bubuzou.com 虚拟主机：一台物理机器上绑定多个虚拟主机，每个虚拟主机有单独的域名，这些域名都公用一个 IP 地址。 HTTP/1.1 通过引入 Chunk transfer 机制来支持动态内容：服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。 HTTP/1.1 还引入了客户端 Cookie 机制和安全机制 HTTP/2我们知道 HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式： 增加了持久连接； 浏览器为每个域名最多同时维护 6 个 TCP 持久连接； 使用 CDN 的实现域名分片机制。 HTTP/1.1 中依然存在的问题虽然 HTTP/1.1 采取了很多优化资源加载速度的策略，也取得了一定的效果，但是 HTTP/1.1 对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题。 带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。 之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。 之所以会出现这个问题，主要是 3 个问题导致的： 第一个原因，TCP 的慢启动 一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。这个过程可以想象是一辆车的启动过程，开始的时候慢，当速度起来后加速就更快了。 而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。 第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽 你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。 这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。 第三个原因，HTTP/1.1 队头阻塞的问题 我们知道在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。 这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。 HTTP/2 的多路复用为了解决 HTTP/1.1 中存在的问题，在 HTTP/2 中采用最具颠覆性的方案：多路复用机制。 HTTP/2 多路复用是什么 HTTP/2 的多路复用机制用简单的话来说就是浏览器针对同一域名的资源，只建立一个 TCP 连接通道，所有的针对这个域名的请求全部都在这个通道中完成； 除此之外，数据的传输不再使用文本格式，而是会将它们分割为更小的流和帧，并对他们采用二进制格式的编码。在一个 TCP 连接通道中，支持任意数量的双向数据流，这些数据流是并行、乱序的且它们之间互不干扰。而数据流中传输的数据是二进制帧，它是 HTTP/2 中数据传输的最小单位，一个流中的帧是按照顺序传输的，且是并行的，所以无需按顺序等待。 解决了什么问题 因为只使用一个 TCP 连接，所以减少了由于 TCP 慢启动而消耗的时间，另外也由于只有单条 TCP 连接，所以不存在不同的 TCP 争夺网络带宽的问题。 客户端发送的请求经过二进制分帧层后，不再是一个个完整的 HTTP 请求报文，而是一堆乱序的帧（即不同流的帧是乱的，但是同一条流的帧数顺序传输的），所以就不会按顺序传输，也就不存在等待，从而解决了 HTTP 对头阻塞问题。 是如何实现的 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。请求头的信息存在 header 帧中，而请求体数据存在 data 帧中。 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。 HTTP/2 其他特性1. 可以设置请求的优先级 在浏览器中，某些数据是非常重要的，比如关键 CSS 或者 JS，这些重要的数据如果比较晚才推送到浏览器，那么对用户来说肯定是一个不好的体验。 所以 HTTP/2 中可以支持设置请求的优先级，这样服务器收到高优先级的请求后，会优先处理。 2. 服务器推送 在 HTTP/2 中服务器解析到一个 HTML 页面后，服务器知道浏览器需要这个页面上引用到的资源，比如 CSS 和 JS，那么服务器就会主动的把这些资源一并推送给浏览器，减少客户端的等待时间。 3. 头部压缩 HTTP/2 使用 HPACK 压缩算法对请求头和响应头进行压缩，虽然单个请求压缩之后效果不是很明显，但是如果一个页面有 100 个请求，那每个请求压缩 20% 之后，那提速效果就很明显了。 而 HPACK 的压缩原理其实就是 2 点： 它要求客户端和服务器两者都维护和更新先前看到的报头字段的索引列表（即，建立共享的压缩上下文），然后将该列表用作有效编码先前传输的值的参考。在实际传输的时候用索引代替每一侧的静态或动态表中已经存在的字段，从而减小每个请求的大小。 它允许通过静态霍夫曼码对发送的标头字段进行编码，从而减小了它们各自的传输大小。 HTTP/3HTTP/2 依然是基于 TCP 的，所以还存在以下一些问题。 TCP 的队头阻塞HTTP/2 中多个请求是跑在一个 TCP 连接中的，如果某个数据流中出现了丢包的情况，就会阻塞该 TCP 连接中的所有请求。这个和 HTTP/1.1 中的不同，在 HTTP/1.1 中，由于浏览器为每个域名建立了 6 个 TCP 连接，如果其中一个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。 TCP 建立连接的延时在传输数据之前，需要进行 TCP 的 3 次握手，需要花费 1.5 个 RTT；如果是 HTTPS，那还需要进行 TLS 连接，又需要 1 ~ 2 个 RTT。 网络延迟又叫 RTT(Round Trip Time)，是从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间。 总之，在传输数据之前需要花掉 3 ~ 4 个 RTT。如果客户端和服务器距离近的话，那 1 个 RTT 大概是 10ms，但如果远的话，可能是 100ms，所以传输数据之前需要花掉 300ms 左右，这个时候就能感觉到慢了。 TCP 协议僵化我们知道 TCP 协议存在队头阻塞和建立连接延迟的问题，但是又没办法改进 TCP 协议，理由有如下 2 个： 中间设备僵化。中间设备比如路由器、交换机、防火墙和 NAT 等，这些设备依赖的软件使用了大量的 TCP 特性，一旦功能被设置后就很少进行更新了。如果在客户端进行升级 TCP 协议，那么当新协议的数据包经过这些设备的时候，可能会不理解包的内容，造成数据丢失。 操作系统也是导致 TCP 协议僵化的另外一个原因。 QUIC 协议 HTTP/3 是基于 UDP 实现的，实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。 实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。 集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。 实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。 实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。 HTTP/3 的挑战 第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。 第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。 第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～ 7% 的丢包率。","categories":[{"name":"http","slug":"http","permalink":"https://bubuzou.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://bubuzou.com/tags/http/"}]},{"title":"Resourse Hints 知多少","slug":"resource-hints","date":"2020-12-28T01:49:25.000Z","updated":"2021-01-14T02:21:56.536Z","comments":true,"path":"2020/12/28/resource-hints/","link":"","permalink":"https://bubuzou.com/2020/12/28/resource-hints/","excerpt":"在上篇文章 探究网页资源究竟是如何阻塞浏览器加载的 中介绍到 JS 会阻塞 DOM 的加载，样式会阻塞页面的渲染，外链样式里的自定义字体还会对文字造成闪动给用户带来不好的体验，诸如此类问题还有挺多，那到底该如何解决它们呢？ 今天我们就来学习通过在 link 标签里加上特定的属性，比如 preload、prefetch 等来解决此类问题，那么你对这些属性又了解多少呢？把它们用在了你们的项目优化中了嘛？","text":"在上篇文章 探究网页资源究竟是如何阻塞浏览器加载的 中介绍到 JS 会阻塞 DOM 的加载，样式会阻塞页面的渲染，外链样式里的自定义字体还会对文字造成闪动给用户带来不好的体验，诸如此类问题还有挺多，那到底该如何解决它们呢？ 今天我们就来学习通过在 link 标签里加上特定的属性，比如 preload、prefetch 等来解决此类问题，那么你对这些属性又了解多少呢？把它们用在了你们的项目优化中了嘛？ preloadpreload 提升了资源加载的优先级，使得它提前开始加载（预加载），在需要用的时候能够更快的使用上。另外 onload 事件必须等页面所有资源都加载完成才触发，而当给某个资源加上 preload 后，该资源将不会阻塞 onload。 preload 怎么用当某个页面加载了 2 个脚本 jquery.min.js 和 main.js： 12&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; 此时该页面的资源加载 Waterfall 长这样： 当在 &lt;head&gt; 里通过 &lt;link&gt; 标签给 main.js 配置 preload 预加载后： 1&lt;link rel=&quot;preload&quot; as=&quot;script&quot; href=&quot;./main.js&quot;&gt; 此时的 main.js 加载顺序出现在了 jquery.min.js 的前面，这就是 preload 提升资源加载优先级的效果。 当一直刷新浏览器的时候，偶然出现 Waterfall 并不能准确的显示资源加载的顺序，所以这个时候就需要比较每个资源被加入到下载队列的时间，比如如下的 main.js 由于用了 preload 预加载，所以 queue time 比较早。 通过 &lt;link rel=&quot;preload&quot;&gt; 只是预加载了资源，但是资源加载完成后并不会执行，所以需要在想要执行的地方通过 &lt;script&gt; 来引入它： 1&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; 但是也有一个例外，因为 CSS 的加载也是通过 &lt;link&gt; 标签引入的，所以我们可以巧妙的利用这点，当 onload 事件触发的时候修改 rel 属性的值，使得它由原来的预加载样式变成引入样式： 1&lt;link rel=&quot;preload&quot; as=&quot;style&quot; onload=&quot;this.rel=&#x27;stylesheet&#x27;&quot; href=&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;/&gt; 如果通过 preload 加载了资源，但是又没有使用它，则浏览器会报一个警告： preload 除了能够预加载脚本之外，还可以通过 as 指定别的资源类型，比如： style 样式表； font：字体文件； image：图片文件； audio：音频文件； video：视频文件； document：文档。 preload 应用案例preload 主要用于提升当前页面某些阻塞资源的下载优先级，使得页面能够尽快渲染显示出来。 案例一：预加载定义在 CSS 中资源的下载，比如自定义字体 当页面中使用了自定义字体的时候，就必须在 CSS 中引入该字体，而由于字体必须要等到浏览器下载完且解析该 CSS 文件的时候才开始下载，所以对应页面上该字体处可能会出现闪动的现象，为了避免这种现象的出现，就可以使用 preload 来提前加载字体，type 可以用来指定具体的字体类型，加载字体必须指定 crossorigin 属性，否则会导致字体被加载两次。 1&lt;link rel=&quot;preload&quot; as=&quot;font&quot; crossorigin type=&quot;font/woff2&quot; href=&quot;myfont.woff2&quot;&gt; 以上这种写法和指定 crossorigin=&quot;anonymous&quot; 是等同的效果。 案例二：预加载 CSS 文件 在首屏加载优化中一直存在一种技术，叫做抽取关键 CSS，意思就是把页面中在视口中出现的样式抽出一个独立的 CSS 文件出来 critical.css，然后剩余的样式在放到另外一个文件上 non-critical.css： 由于 CSS 会阻塞页面的渲染，当同时去加载这 2 部分样式的时候，只要 non-critical.css 还没加载完成，那么页面就显示不了，而实际上只需要显示出视口下的界面即可，所以期待的结果是：当加载完成 critical.css 的时候马上显示出视口下的界面，不让 non-critical.css 阻塞渲染，则需要给 non-critical.css 加上预加载： 123&lt;link rel=&quot;preload&quot; as=&quot;style&quot; href=&quot;https://bubuzou.com/non-critical.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://bubuzou.com/critical.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://bubuzou.com/non-critical.css&quot;&gt; 案例三：创建动态的预加载资源 当需要预先加载的时候调用 downloadScript，而希望执行的时候则调用 runScript 函数。 123456789101112function downloadScript(src) &#123; var el = document.createElement(&quot;link&quot;) el.as = &quot;script&quot; el.rel = &quot;preload&quot; el.href = src document.body.appendChild(el)&#125; function runScript(src) &#123; var el = document.createElement(&quot;script&quot;) el.src = src&#125; 案例四：结合媒体查询预加载响应式图片 preload 甚至还可以结合媒体查询加载对应尺寸下的资源，对于以下代码当可视区域尺寸小于 600px 的时候会提前加载这张图片。 1&lt;link rel=&quot;preload&quot; as=&quot;image&quot; href=&quot;someimage.jpg&quot; media=&quot;(max-width: 600px)&quot;&gt; 案例五：结合 Webpack 预加载 JS 模块 Webpack 从 4.6.0 版本开始支持在魔术注释中配置预加载模块： 1import(_/* webpackPreload: true */_ &quot;CriticalChunk&quot;) 如果是版本比较老的，则可以使用 preload-webpack-plugin 进行处理。 prefetchpreload 用于提前加载用于当前页面的资源，而 prefetch 则是用于加载未来（比如下一个页面）会用到的资源，并且告诉浏览器在空闲的时候去下载，它会将下载资源的优先级降到最低。 比如在首页配置如下代码： 1&lt;link rel=&quot;prefetch&quot; as=&quot;script&quot; href=&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;&gt; 我们会在页面中看到该脚本的下载优先级已经被降低为 Lowest： 当资源被下载完成后，会被存到浏览器缓存中，当从首页跳转到页面 A 的时候，假如页面 A 中引入了该脚本，那么浏览器会直接从 prefetch cache 中读取该资源，从而实现资源加载优化。 preconnect当浏览器向服务器请求一个资源的时候，需要建立连接，而建立一个安全的连接需要经历以下 3 个步骤： 查询域名并将其解析成 IP 地址（DNS Lookup）； 建立和服务器的连接（Initial connection）； 加密连接以确保安全（SSL）； 以上 3 个步骤浏览器都需要和服务器进行通信，而这一来一往的请求和响应势必会耗费不少时间。 而就基于这点上，可以使用 preconnect 或者 dns-prefetch 进行优化，而它两又是什么呢？怎么使用呢？ preconnect 是什么，怎么用当我们的站点需要对别的域下的资源进行请求的时候，就需要和那个域建立连接，然后才能开始下载资源，如果我都已经知道了是和哪个域进行通信，那不就可以先建立连接，然后等需要进行资源请求的时候就可以直接进行下载了。 假设当前站点是 https://a.com，这个站点的主页需要请求 https://b.com/b.js 这个资源。对比正常请求和配置了 preconnect 时候的请求，它们在请求时间轴上看到的表现是不一样的： 通过如下配置可以提前建立和 https://b.com 这个域的连接： 1&lt;link rel=&quot;preconnect&quot; href=&quot;https://b.com&quot;&gt; 通过 preconnect 提早建立和第三方源的连接，可以将资源的加载时间缩短 100ms ~ 500ms，这个时间虽然看起来微不足道，但是它是实实在在的优化了页面的性能，提升了用户的体验。 通过 preconnect 和别的域建立连接后，应该尽快的使用它，因为浏览器会关闭所有在 10 秒内未使用的连接。不必要的预连接会延迟其他重要资源，因此要限制 preconnect 连接域的数量。 preconnect 应用场景场景一： 当知道资源是来源于哪个源下，但是对于加载哪个资源不是很明确的时候，比如对于如下这些资源： 它们要嘛是动态的，要嘛是根据不同环境携带不同参数，所以它们很适合用 preconnect 进行加载。 场景二： 如果页面上有流媒体，但是没那么快播放，又希望当按下播放按钮的时候可以越快开始越好，此时就可以使用 preconnect 预建立连接，节省一段时间。 如果用 preconnect 预建立连接的资源是一个字体文件，那么也是需要加上 crossorigin 属性。 dns-prefetch通常我们记住一个网站都是通过它的域名，但是对于服务器来说，它是通过 IP 来记住它们的。浏览器使用 DNS 来将站点转成 IP 地址，这个是建立连接的第一步，而这一步骤通常需要花费的时间大概是 20ms ~ 120ms。因此，可以通过 dns-prefetch 来节省这一步骤的时间。 居然能通过 preconnect 来减少整个建立连接的时间，那为什么还需要 dns-prefetch 来减少建立连接中第一步 DNS 查找解析的时间呢？ 假如页面引入了许多第三方域下的资源，而如果它们都通过 preconnect 来预建立连接，其实这样的优化效果反而不好，甚至可能变差，所以这个时候就有另外一个方案，那就是对于最关键的连接使用 preconnect，而其他的则可以用 dns-prefetch。 可以按照如下方式配置 dns-prefetch： 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://cdn.bootcss.com&quot;&gt; 另外由于 preconnect 的浏览器兼容稍微比 dns-prefetch 低，看下图： 因此 dns-prefetch 可以作为不支持预连接的浏览器的后备选择，同时配置它们两即可： 12&lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.bootcss.com&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://cdn.bootcss.com&quot;&gt; 参考文章 前端性能优化之关键路径渲染优化 https://web.dev/link-prefetch/ https://www.w3.org/TR/resource-hints/ 译文Preload，Prefetch 和它们在 Chrome 之中的优先级 preload-prefetch-preconnect https://web.dev/extract-critical-css/","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"探究网页资源究竟是如何阻塞浏览器加载的","slug":"browser-block","date":"2020-12-26T01:49:25.000Z","updated":"2021-01-14T02:09:49.712Z","comments":true,"path":"2020/12/26/browser-block/","link":"","permalink":"https://bubuzou.com/2020/12/26/browser-block/","excerpt":"一个页面允许加载的外部资源有很多，常见的有脚本、样式、字体、图片和视频等，对于这些外部资源究竟是如何影响整个页面的加载和渲染的呢？今天我们来一探究竟。 阅读完这篇文章你将解开如下谜团： 如何用 Chrome 定制网络加载速度？ 图片/视频/字体会阻塞页面加载嘛？ CSS 是如何阻塞页面加载的？ JS 又是如何阻塞页面加载的？ JS 一定会阻塞 DOM 加载嘛？ defer 和 async 是什么？又有何特点？ 动态脚本会造成阻塞嘛？ 阻塞是怎么和 DOMContentLoaded 与 onload 扯上关系的？","text":"一个页面允许加载的外部资源有很多，常见的有脚本、样式、字体、图片和视频等，对于这些外部资源究竟是如何影响整个页面的加载和渲染的呢？今天我们来一探究竟。 阅读完这篇文章你将解开如下谜团： 如何用 Chrome 定制网络加载速度？ 图片/视频/字体会阻塞页面加载嘛？ CSS 是如何阻塞页面加载的？ JS 又是如何阻塞页面加载的？ JS 一定会阻塞 DOM 加载嘛？ defer 和 async 是什么？又有何特点？ 动态脚本会造成阻塞嘛？ 阻塞是怎么和 DOMContentLoaded 与 onload 扯上关系的？ 测试前环境准备测试之前我们需要对浏览器下载资源的速度进行控制，将它重新设置为 50kb/s，操作方式： 打开 Chrome 开发者工具； 在 Network 面板下找到 Disable cache 右侧的下拉列表，然后选择 Add 添加自定义节流配置； 添加一个下载速度为 50kb/s 的配置； 最后在第二步骤中的下拉列表选择刚刚配置的选项即可； 注意：如果当前选择的自定义选项被修改了，则需要切换到别的选项再切回来才可生效。 为什么是这个速度？因为如下的一些资源，比如图片、样式或者脚本体积都是 50kb 的好几倍，方便测试。 图片会造成阻塞嘛直接写个示例来看下结果： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;script&gt; document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123; console.log(&#x27;DOMContentLoaded&#x27;) &#125;) window.onload = function() &#123; console.log(&#x27;onload&#x27;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是 h1 标签&lt;/h1&gt; &lt;img src=&quot;https://xxx.oss-cn-shenzhen.aliyuncs.com/images/flow.png&quot; /&gt; &lt;h2&gt;我是 h2 标签&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 上面这张图片的大小大概是 200kb，当把网络下载速度限制成 50kb/s，打开该页面，可以看到如下结果：当 h1 和 h2 标签渲染出来且打印了 DOMContentLoaded 的时候，此时图片还在加载中，这就说明了图片并不会阻塞 DOM 的加载，更加不会阻塞页面渲染；当图片加载完成的时候，会打印 onload，说明图片延迟了 onload 事件的触发。 视频、字体和图片其实是一样的，也不会阻塞 DOM 的加载和渲染。 CSS 加载阻塞同样的，我们还是直接用代码来测试 CSS 加载对页面阻塞的情况，因为下面代码加载的 bootstrap.css 是 192kb 的，所以理论上下载它应该需要花费 3 到 4 秒左右。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是 h1 标签&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 测试过程如下： 在 Elements 面板下，选中 h1 这个标签，然后按 delete 键将它从 DOM 中删掉，从而模拟首次加载； 刷新浏览器，马上 Elements 面板下就加载出 h1 标签，继续加载 3 到 4 秒后（此时正在加载 bootstrap.css），页面出现 我是 h1 标签 字样，此时页面已经渲染完成。 从而得出结论： bootstrap.css 还没加载完成，而 DOM 中就已经出现 h1 标签，说明 CSS 不会阻塞 DOM 的解析； 页面直到 bootstrap.css 加载完成才出现 h1 里的文案，说明 CSS 会阻塞 DOM 的渲染。 为什么是这个结论呢？试想一下页面渲染的流程就知道了。浏览器首先解析 HTML 生成 DOM 树，解析 CSS 生成 CSSOM 树，然后 DOM 树和 CSSOM 树进行合成生成渲染树，通过渲染树进行布局并且计算每个节点信息，绘制页面。 可以说解析 DOM 和 解析 CSS 其实是并列进行的，既然是并列进行的，那 CSS 和 DOM 就不会互相影响了，这和结论一相符；另外渲染页面一定是在得到 CSSOM 树之后进行的，这和结论二相符。 CSS 一定会阻塞 DOM 的渲染嘛？答案是否定的，当把外链样式放到 &lt;body&gt; 最尾部去加载： 1234&lt;body&gt; &lt;h1&gt;我是 h1 标签&lt;/h1&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/body&gt; 此时刷新浏览器，页面上会马上显示出 我是 h1 标签 字样，当 3 到 4 秒过后样式加载完成的时会造成二次渲染，页面重新渲染出该字样，这就**说明 CSS 阻塞 DOM 的渲染只阻塞定义在 CSS 后面的 DOM**。二次渲染会对用户造成不好的体验且加重了浏览器的负担，所以这也就是为什么需要把外链样式提前到 &lt;head&gt; 里加载的原因。 CSS 会阻塞后面 JS 的执行嘛CSS 阻塞了后面 DOM 的渲染，那它会阻塞 JS 的执行嘛？ 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是 h1 标签&lt;/h1&gt; &lt;script&gt; console.log(&#x27;888&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 刷新浏览器的时候可以看到，浏览器 Console 面板下没有打印内容，而当样式加载完成的时候打印了 888，这就说明 CSS 会阻塞定义在其之后 JS 的执行。 为什么会这样呢？试想一下，如果 JS 里执行的操作需要获取当前 h1 标签的样式，而由于样式没加载完成，所以就无法得到想要的结果，从而证明了 CSS 需要阻塞定义在其之后 JS 的执行。 JS 加载阻塞CSS 会阻塞 DOM 的渲染和阻塞定义在其之后的 JS 的执行，那 JS 加载会对渲染过程造成什么影响呢？ 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是 h1 标签&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 首先删除页面中已经存在的 h1 标签（如果存在的话），仔细观察 Elements 面板，当刷新浏览器的时候，一直未加载出 h1 标签（期间页面一直白屏），直到 JS 加载完成后，DOM 中才出现，这足以说明了 JS 会阻塞定义在其之后的 DOM 的加载，所以应该将外部 JS 放到 &lt;body&gt; 的最尾部去加载，减少页面加载白屏时间。 defer 和 asyncJS 一定会阻塞定义在其之后的 DOM 的加载嘛？来测试一下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;script async src=&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是 h1 标签&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 上面这段代码的测试结果是当页面中显示出 h1 标签的时候，脚本还没有加载完成，这就说明了 async 脚本不会阻塞 DOM 的加载；同理我们可以用同样的方式测试 defer，也会得到这个结论。 现在我们知道了通过 defer 或者 async 方式加载 JS 的时候，它是不会阻塞 DOM 加载的。那么你知道 defer 和 async 是什么嘛？它们两者有什么区别呢？ 回答这些疑问之前，我们先来看下当浏览器解析 HTML 遇到 script 标签的时候会发生什么？ 暂停解析 DOM； 执行 script 里的脚本，如果该 script 是外链，则会先下载它，下载完成后立刻执行； 执行完成后继续解析剩余 DOM。 上面这是解析时遇到一个正常的外链的情况，正常外链的下载和执行都会阻塞页面解析；而如果外链是通过 defer 或者 async 加载的时候又会是如何呢？ defer 特点 对于 defer 的 script，浏览器会继续解析 html，且同时并行下载脚本，等 DOM 构建完成后，才会开始执行脚本，所以它不会造成阻塞； defer 脚本下载完成后，执行时间一定是 DOMContentLoaded 事件触发之前执行； 多个 defer 的脚本执行顺序严格按照定义顺序进行，而不是先下载好的先执行； async 特点 对于 async 的 script，浏览器会继续解析 html，且同时并行下载脚本，一旦脚本下载完成会立刻执行；和 defer 一样，它在下载的时候也不会造成阻塞，但是如果它下载完成后 DOM 还没解析完成，则执行脚本的时候是会阻塞解析的； async 脚本的执行 和 DOMContentLoaded 的触发顺序无法明确谁先谁后，因为脚本可能在 DOM 构建完成时还没下载完，也可能早就下载好了； 多个 async，按照谁先下载完成谁先执行的原则进行，所以当它们之间有顺序依赖的时候特别容易出错。 defer 和 async 都只能用于外部脚本，如果 script 没有 src 属性，则会忽略它们。 动态脚本会造成阻塞嘛对于如下这段代码，当刷新浏览器的时候会发现页面上马上显示出 我是 h1 标签，而过几秒后才加载完动态插入的脚本，所以可以得出结论：动态插入的脚本不会阻塞页面解析。 12345678910&lt;!-- 省略了部分内容 --&gt;&lt;script&gt; function loadScript(src) &#123; let script = document.createElement(&#x27;script&#x27;) script.src = src document.body.append(script) &#125; loadScript(&#x27;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&#x27;)&lt;/script&gt;&lt;h1&gt;我是 h1 标签&lt;/h1&gt; 动态插入的脚本在加载完成后会立即执行，这和 async 一致，所以如果需要保证多个插入的动态脚本的执行顺序，则可以设置 script.async = false，此时动态脚本的执行顺序将按照插入顺序执行和 defer 一样。 DOMContentLoaded 和 onload在浏览器中加载资源涉及到 2 个事件，分别是 DOMContentLoaded 和 onload，那么它们之间有什么区别呢？ onload：当页面所有资源（包括 CSS、JS、图片、字体、视频等）都加载完成才触发，而且它是绑定到 window 对象上； DOMContentLoaded：当 HTML 已经完成解析，并且构建出了 DOM，但此时外部资源比如样式和脚本可能还没加载完成，并且该事件需要绑定到 document 对象上； 细心的你一定看到了上面的可能二字，为什么当 DOMContentLoaded 触发的时候样式和脚本是可能还没加载完成呢？ DOMContentLoaded 遇到脚本当浏览器处理一个 HTML 文档，并在文档中遇到 &lt;script&gt; 标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 document.write 操作，所以 DOMContentLoaded 必须等待脚本执行结束后才触发。以下这段代码验证了这个结论：当脚本加载完成的时候，Console 面板下才会打印出 DOMContentLoaded。 1234567&lt;script&gt; document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123; console.log(&#x27;DOMContentLoaded&#x27;) &#125;)&lt;/script&gt;&lt;h1&gt;我是 h1 标签&lt;/h1&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; 那么一定是脚本执行完成后才会触发 DOMContentLoaded 嘛？答案也是否定的，有两个例外，对于 async 脚本和动态脚本是不会阻塞 DOMContentLoaded 触发的。 DOMContentLoaded 遇到样式前面我们已经介绍到 CSS 是不会阻塞 DOM 的解析的，所以理论上 DOMContentLoaded 应该不会等到外部样式的加载完成后才触发，这么分析是对的，让我们用下面代码进行测试一翻就知道了： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;script&gt; document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123; console.log(&#x27;DOMContentLoaded&#x27;) &#125;) &lt;/script&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是 h1 标签&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 测试结果：当样式还没加载完成的时候，就已经打印出 DOMContentLoaded，这和我们分析的结果是一致的。但是一定是这样嘛？显然不一定，这里有个小坑，（基于上面代码）在样式后面再加上 &lt;script&gt; 标签的时候，会发现只有等样式加载完成了才会打印出 DOMContentLoaded，为什么会这样呢？正是因为 &lt;script&gt; 会阻塞 DOMContentLoaded 的触发，所以当外部样式后面有脚本（async 脚本和动态脚本除外）的时候，外部样式就会阻塞 DOMContentLoaded 的触发。 1234&lt;!-- 只显示了部分内容 --&gt;&lt;link href=&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;/&gt;&lt;script&gt;&lt;/script&gt;&lt;/head&gt; 参考文章 DOMContentLoaded https://html.spec.whatwg.org/multipage/scripting.html","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"很多人知道 Web Storage，但是你清楚 Cookie 嘛","slug":"browser-store","date":"2020-12-24T01:49:25.000Z","updated":"2021-07-07T07:26:28.837Z","comments":true,"path":"2020/12/24/browser-store/","link":"","permalink":"https://bubuzou.com/2020/12/24/browser-store/","excerpt":"可以在浏览器的 Application 面板下看到浏览器的本地存储包含了：Cookie、sessionStorage、localStorage 和 IndexedDB。 CookieCookie 是什么Cookie 又叫 HTTP Cookie 或者叫浏览器 Cookie。Cookie 的作用是维护服务端和客户端的会话状态，简而言之就是告诉服务器当前客户端用户的一些信息，比如是否登录啥的。","text":"可以在浏览器的 Application 面板下看到浏览器的本地存储包含了：Cookie、sessionStorage、localStorage 和 IndexedDB。 CookieCookie 是什么Cookie 又叫 HTTP Cookie 或者叫浏览器 Cookie。Cookie 的作用是维护服务端和客户端的会话状态，简而言之就是告诉服务器当前客户端用户的一些信息，比如是否登录啥的。 Cookie 是如何工作的Cookie 通常是由服务端生成，然后通过响应头的 Set-Cookie 发送给客户端浏览器： 123HTTP&#x2F;1.0 200 OKContent-type: text&#x2F;htmlSet-Cookie: my_cookie&#x3D;bulandent 浏览器会将 Cookie 保存在本地，并且会在下次请求头部的 Cookie 中附上这个值： GET /home.html HTTP/1.1 Host: www.example.org Cookie: my_cookie=bulandent Cookie 分类按照 Cookie 的生命周期可以将它分为两类： 会话 Cookie：没有指定过期时间 （Expires）或有效期（Max-Age）的 Cookie，当浏览器关闭后会被自动删除，但是现在很多浏览器都实现了会话恢复功能，即使浏览器关闭，会话 Cookie 也会被保留下来；这种类型的 Cookie 会保存在浏览器的内存中； 持久性 Cookie：通过指定过期时间 （Expires）或有效期（Max-Age）的一种 Cookie，存储于客户端硬盘中。设定的日期和时间是指和客户端系统时间进行比较的。 Cookie 限制Cookie 会绑定特定的域名（Domain），除此之外，它还有如下一些限制： 通常，只要遵守以下大致的限制，就不会在任何浏览器中碰到问题： 不超过 300 个 Cookie； 每个 Cookie 不超过 4KB； 每个域名下不超过 20 个 Cookie。 每个域能设置的 Cookie 总数也是受限的，但不同浏览器的限制不同。例如： 最新版 IE 和 Edge 限制每个域不超过 50 个 Cookie； 最新版 Firefox 限制每个域不超过 150 个 Cookie； 最新版 Opera 限制每个域不超过 180 个 Cookie； Safari 和 Chrome 对每个域的 Cookie 数没有硬性限制。 如果 Cookie 总数超过了单域名的上限，浏览器就会删除之前设置的 Cookie，而删除的逻辑不同浏览器也不大相同。 Cookie 构成Cookie 构成除了以上提到的 Name、Value、Domain、Expires/Max-Age 外，还有几个比较重要的需要说下： Path：请求 URL 中包含这个路径才会把 Cookie 发送到服务器； Secure：只有 HTTPS 请求才会发送标记为 Secure 的 Cookie； HttpOnly：将限制在客户端通过 document.cookie 读取设置为 HttpOnly 的 Cookie； SameSite：控制 Cookie 在跨站请求的时候是否会被发送，有 3 个值： None 允许跨站请求发送； Lax：允许跨站 GET 请求发送； Strict：不允许跨站请求发送； 除了服务器能够设置 Cookie 外，客户端也可以通过 document.cookie 设置。 Cookie 缺陷 Cookie 会被附加在每个 HTTP 请求中，所以无形中增加了流量； 由于在 HTTP 请求中的 Cookie 是明文传递的，所以安全性成问题，除非用超文本传输安全协定； Cookie 的大小限制在 4KB 左右，对于复杂的存储需求来说是不够用的。 Cookie 安全黑客常常会利用 Cookie 进行攻击，比如 XSS 和 CSRF 等；所以为了网站安全，通常需要针对 Cookie 做一些安全措施： 对特殊的 Cookie 设置 HttpOnly，防止被客户端脚本读取，比如维护登录状态的 Cookie 就可以这么做； 用于敏感信息（例如指示身份验证）的 Cookie 的生存期应较短，并且 SameSite 属性设置为Strict 或 Lax。 Web StorageWeb Storage 存在的目的就是为了解决每次向服务器请求的时候都需要携带 Cookie 信息的问题。Web Storage 包含了 2 个对象：sessionStorage 和 localStorage。通过这 2 个对象实现了： 提供在 Cookie 之外的存储会话数据的途径； 提供跨会话持久化存储大量数据的机制。 Web Storage 的限制和其他客户端数据存储方案一样，Web Storage 也有限制。 存储大小：不同浏览器给 sessionStorage 和 localStorage 设置了不同的空间限制，但大多数会限制为每个源 5MB； 存储类型：只能存储字符串，所以如果数据是对象结构的，需要通过 JSON.stringify 先转成字符串； 存储限制于同一个源（origin），这也是同源策略的限制之一。即 http://a.com 和 https://a.com 存储的 ``Web Storage` 数据是不相同的。 Web Storage 提供了一套详细的 API 使得我们可以很好的进行数据存储： 属性 Storage.length：返回一个整数，表示存储在 Storage 对象中的数据项数量。 方法 Storage.key(n)：该方法接受一个数值 n 作为参数，并返回存储中的第 n 个键名； Storage.getItem()：该方法接受一个键名作为参数，返回键名对应的值； Storage.setItem()：该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值； Storage.removeItem()：该方法接受一个键名作为参数，并把该键名从存储中删除； Storage.clear()：调用该方法会清空存储中的所有键名。 sessionStorage 和 localStorage 都是 Storage 的实例，所以自然而然的它们都拥有上面的属性和方法。 sessionStoragesessionStorage 对象只会存储会话数据，这意味着当浏览器 tab 页被关闭的时候，对应的 sessionStorage 数据将被清除。除此之外，它还有如下表现： 不受页面刷新（包括强制刷新）影响，并且可以在浏览器崩溃并重启后恢复； 在当前页面通过新标签页或窗口打开一个新页面的时候，新页面会复制父级页面的 sessionStorage 数据； 使用同一个 URL 打开多个标签页，它们各自的 sessionStorage 数据不同； localStorage区别于 sessionStorage，localStorage 的存储不受会话限制而且能够长期存储于客户端浏览器中，直到手动删除或者清除浏览器缓存。 IndexedDB虽然 Web Storage 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心，这个时候就需要用到 IndexedDB，它类似于 MySQL，但是和传统数据库最大的区别在于，它是适用对象存储而不是表格保存数据。IndexedDB 也受到源的限制。 和 Web Storage 的区别 存储大小：Web Storage 限制每个源大约 5MB。IndexedDB 的存储空间有 2 个限制：全局限制即为浏览器的最大存储空间一般是可用磁盘空间的 50%；组限制为全局限制的 20%，且它至少有 10MB，最大为 2GB 存储空间； 存储类型：Web Storage 只能存储字符串，IndexedDB 可以存储字符串、Blob 和 ArrayBuffer； Web Storage 的存储操作是同步进行的；IndexedDB 由于数据量大，所以多数操作都是异步执行的； 参考文章 HTTP Cookies Browser_storage_limits_and_eviction_criteria","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"浏览器专题之缓存篇","slug":"browser-cache","date":"2020-12-20T01:49:25.000Z","updated":"2021-01-14T02:04:36.932Z","comments":true,"path":"2020/12/20/browser-cache/","link":"","permalink":"https://bubuzou.com/2020/12/20/browser-cache/","excerpt":"浏览器缓存一直是个老生常谈的话题，也是面试官常常用来鉴别面试者的利器，作为前端来讲这块知识是属于必须掌握的，再者利用好缓存也是做性能优化的有效方法。本文将从缓存原因、缓存读写顺序，缓存位置以及缓存策略这几个角度介绍浏览器缓存，并且最后给出实践的应用举例。 为什么要缓存很多同学知道缓存的位置和字段，知道怎么用，但是你有没有想过为什么我们的页面需要浏览器缓存呢？ 缓存可以减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定是比从服务器请求更快的； 减少网络带宽消耗：对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。试想一下如果可以使用缓存，只会产生极小的网络流量，这将有效的降低运营成本。 降低服务器压力：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。","text":"浏览器缓存一直是个老生常谈的话题，也是面试官常常用来鉴别面试者的利器，作为前端来讲这块知识是属于必须掌握的，再者利用好缓存也是做性能优化的有效方法。本文将从缓存原因、缓存读写顺序，缓存位置以及缓存策略这几个角度介绍浏览器缓存，并且最后给出实践的应用举例。 为什么要缓存很多同学知道缓存的位置和字段，知道怎么用，但是你有没有想过为什么我们的页面需要浏览器缓存呢？ 缓存可以减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定是比从服务器请求更快的； 减少网络带宽消耗：对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。试想一下如果可以使用缓存，只会产生极小的网络流量，这将有效的降低运营成本。 降低服务器压力：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。 缓存读写顺序当浏览器对一个资源（比如一个外链的 a.js）进行请求的时候会发生什么？请从缓存的角度大概说下： 调用 Service Worker 的 fetch 事件获取资源； 查看 memory cache； 查看 disk cache；这里又细分： 如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200； 如果有强制缓存但已失效，使用协商缓存，比较后确定 304 还是 200； 发送网络请求，等待网络响应； 把响应内容存入 disk cache (如果请求头信息配置可以存的话)； 把响应内容的引用存入 memory cache (无视请求头信息的配置，除了 no-store 之外)； 把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())； 上面这一系列过程其实是浏览器查找缓存和把资源存入缓存的执行流程。这其中出现了很多专业词汇，让人看了一脸懵逼，下面将从缓存位置和缓存策略两个角度简要介绍浏览器的缓存。 缓存位置 从浏览器开发者工具的 Network 面板下某个请求的 Size 中可以看到当前请求资源的大小以及来源，从这些来源我们就知道该资源到底是从 memory cache 中读取的呢，还是从 disk cache 中读取的，亦或者是服务器返回的。而这些就是缓存位置： Service Worker 是一个注册在指定源和路径下的事件驱动 worker；特点是： 运行在 worker 上下文，因此它不能访问 DOM； 独立于主线程之外，不会造成阻塞； 设计完全异步，所以同步 API（如 XHR 和 localStorage ）不能在 Service Worker 中使用； 最后处于安全考虑，必须在 HTTPS 环境下才可以使用； 说了这么多特点，那它和缓存有啥关系？其实它有一个功能就是离线缓存：Service Worker Cache；区别于浏览器内部的 memory cache 和 disk cache，它允许我们自己去操控缓存，具体操作过程可以参看 Using_Service_Workers；通过 Service Worker 设置的缓存会出现在浏览器开发者工具 Application 面板下的 Cache Storage 中。 memory cache是浏览器内存中的缓存，相比于 disk cache 它的特点是读取速度快，但容量小，且时效性短，一旦浏览器 tab 页关闭，memory cache 就将被清空。memory cache 会自动缓存所有资源嘛？答案肯定是否定的，当 HTTP 头设置了 Cache-Control: no-store 的时候或者浏览器设置了 Disabled cache 就无法把资源存入内存了，其实也无法存入硬盘。当从 memory cache 中查找缓存的时候，不仅仅会去匹配资源的 URL，还会看其 Content-type 是否相同。 disk cache也叫 HTTP cache 是存在硬盘中的缓存，根据 HTTP 头部的各类字段进行判定资源的缓存规则，比如是否可以缓存，什么时候过期，过期之后需要重新发起请求吗？相比于 memory cache 的 disk cache 拥有存储空间时间长等优点，网站中的绝大多数资源都是存在 disk cache 中的。 浏览器如何判断一个资源是存入内存还是硬盘呢？关于这个问题，网上说法不一，不过比较靠谱的观点是：对于大文件大概率会存入硬盘中；当前系统内存使用率高的话，文件优先存入硬盘。 缓存按照缓存位置划分，其实还有一个 HTTP/2 的内容 push cache，由于目前国内对 HTTP/2 应用还不广泛，且网上对 push cache 的知识还不齐全，所以本篇不打算介绍这块，感兴趣的可以阅读这篇文章：HTTP/2 push is tougher than I thought 缓存策略 根据 HTTP header 的字段又可以将缓存分成强缓存和协商缓存。强缓存可以直接从缓存中读取资源返回给浏览器而不需要向服务器发送请求，而协商缓存是当强缓存失效后（过了过期时间），浏览器需要携带缓存标识向服务器发送请求，服务器根据缓存标识决定是否使用缓存的过程。强缓存的字段有：Expires 和 Cache-Control。协商缓存的字段有：Last-Modified 和 ETag。 ExpiresExpires 是 HTTP/1.0 的字段，表示缓存过期时间，它是一个 GMT 格式的时间字符串。Expires 需要在服务端配置（具体配置也根据服务器而定），浏览器会根据该过期日期与客户端时间对比，如果过期时间还没到，则会去缓存中读取该资源，如果已经到期了，则浏览器判断为该资源已经不新鲜要重新从服务端获取。由于 Expires 是一个绝对的时间，所以会局限于客户端时间的准确性，从而可能会出现浏览器判断缓存失效的问题。如下是一个 Expires 示例，是一个日期/时间： 1Expires: Wed, 21 Oct 2020 07:28:00 GMT Cache-Control它是 HTTP/1.1 的字段，其中的包含的值很多： max-age 最大缓存时间，值的单位是秒，在该时间内，浏览器不需要向浏览器请求。这个设置解决了 Expires 中由于客户端系统时间不准确而导致缓存失效的问题； must-revalidate：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效； public 响应可以被任何对象（客户端、代理服务器等）缓存； private 响应只能被客户端缓存； no-cache 跳过强缓存，直接进入协商缓存阶段； no-store 不缓存任何内容，设置了这个后资源也不会被缓存到内存和硬盘； Cache-Control 的值是可以混合使用的，比如： 1Cache-Control: private, max-age&#x3D;0, no-cache 当混合使用的时候它们的优先级如下图所示： 当 Expires 和 Cache-Control 都被设置的时候，浏览器会优先考虑后者。当强缓存失效的时候，则会进入到协商缓存阶段。具体细节是这样：浏览器从本地查找强缓存，发现失效了，然后会拿着缓存标识请求服务器，服务器拿着这个缓存标识和对应的字段进行校验资源是否被修改，如果没有被修改则此时响应状态会是 304，且不会返回请求资源，而是直接从浏览器缓存中读取。 而浏览器缓存标识可以是：Last-Modified 和 ETag： Last-Modified资源的最后修改时间；第一次请求的时候，响应头会返回该字段告知浏览器资源的最后一次修改时间；浏览器会将值和资源存在缓存中；再次请求该资源的时候，如果强缓存过期，则浏览器会设置请求头的 If-Modifined-Since 字段值为存储在缓存中的上次响应头 Last-Modified 的值，并且发送请求；服务器拿着 If-Modifined-Since 的值和 Last-Modified 进行对比。如果相等，表示资源未修改，响应 304；如果不相等，表示资源被修改，响应 200，且返回请求资源。如果资源更新的速度是小于 1 秒的，那么该字段将失效，因为 Last-Modified 时间是精确到秒的。所以有了 ETag。 ETag根据资源内容生成的唯一标识，资源是否被修改的判断过程和上面的一致，只是对应的字段替换了。Last-Modified 替换成 ETag，If-Modifined-Since 替换成 If-None-Match。 当 Last-Modified 和 ETag 都被设置的时候，浏览器会优先考虑后者。 浏览器的行为 浏览器地址栏输入 URL 后回车： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新 (⌘ + R)：因为 TAB 页并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)，其次才是 disk cache。 强制刷新 (⇧ + ⌘ + R)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache)。服务器直接返回 200 和最新内容。 当在开发者工具 Network 面板下设置了 Disabled cache 禁用缓存后，浏览器将不会从 memory cache 或者 disk cache 中读取缓存，而是直接发起网络请求。 缓存应用静态资源比如页面引入了一个 JQuery，对于页面来说这个脚本就是一个工具库，基本上是不会发生变化的，对于这种资源可以将它的缓存时间设置得长一点，比如如下这个地址的脚本： 1&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; 你会看到它的响应头里设置了，max-age=2592000 直接缓存 30 天： 1cache-control: public, max-age&#x3D;2592000 频繁变化的资源对于频繁变化的资源，比如某个页面经常需要调整，那么这个页面就需要在每次请求的时候都进行验证，可以在响应头这样设置： 1cache-control: no-cache 不进行缓存当然并不是所有请求都能被缓存，无法被浏览器缓存的请求如下： HTTP 信息头中包含 Cache-Control: no-cache ，pragma: no-cache（HTTP1.0），或 Cache-Control: max-age=0 等告诉浏览器不用缓存的请求； 需要根据 Cookie、认证信息等决定输入内容的动态请求是不能被缓存的； 经过 HTTPS 安全加密的请求； POST 请求无法被缓存； HTTP 响应头中不包含 Last-Modified/Etag，也不包含 Cache-Control/Expires 的请求无法被缓存； 参考文章 深入理解浏览器的缓存机制 一文读懂前端缓存 Service_Worker_API","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"从输入 URL 到页面显示发生了什么","slug":"browser-url","date":"2020-12-16T01:49:25.000Z","updated":"2021-01-14T02:01:49.390Z","comments":true,"path":"2020/12/16/browser-url/","link":"","permalink":"https://bubuzou.com/2020/12/16/browser-url/","excerpt":"读了李兵老师的 浏览器的工作原理与实践，让我对浏览器的工作原理有了更加深刻的理解，尤其是从用户输入 URL 到页面显示这一过程发生的事情，以往看的文章都是点到为止，而他却说得面面俱到非常详细，遂我把内容总结了一下分享给大家，值得你花个 5 分钟阅读一下。","text":"读了李兵老师的 浏览器的工作原理与实践，让我对浏览器的工作原理有了更加深刻的理解，尤其是从用户输入 URL 到页面显示这一过程发生的事情，以往看的文章都是点到为止，而他却说得面面俱到非常详细，遂我把内容总结了一下分享给大家，值得你花个 5 分钟阅读一下。 用户输入阶段 合成 URL：用户输入 URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容 + 默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL； 加载：用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得； 发起URL请求阶段 构建请求：浏览器进程首先会构建请求行信息，然后通过进程间通信（IPC）将 URL 请求发送给网络进程； 查找缓存：网络进程获取到 URL，先去本地缓存中查找是否有缓存资源，如果有则拦截请求，直接将缓存资源返回给浏览器进程；否则，进入网络请求阶段； DNS 解析：网络进程请求首先会从 DNS 数据缓存服务中查找是否缓存过当前域名信息，有则直接返回；否则，会进行 DNS 解析返回域名对应的 IP 和端口号，如果没有指定端口号，http 默认 80 端口，https 默认 443。如果是 https 请求，还需要建立 TLS 连接； 等待 TCP 队列：Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立 TCP 连接； 建立 TCP 连接：TCP 三次握手与服务器建立连接，然后进行数据的传输，最后； 发送 HTTP 请求：浏览器首先会向服务器发送请求行，它包含了请求方法、请求 URI 和 HTTP 协议的版本；另外还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核，请求域名、Cookie 等；如果需要传递参数，则还需要发送请求体； 服务器处理请求：服务器首先返回响应行，包括协议版本和状态码，比如状态码 200 表示继续处理该请求；（如果是 301，则表示重定向，将会在响应头的 Locaiton 字段中加上重定向的地址信息，接下来浏览器获取这个地址，将会重新导航。）服务器也会向浏览器发送响应头，包含了一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等；继续发送响应体的数据； 断开 TCP 连接：数据传输完成，正常情况下 TCP 将四次挥手断开连接。但是如果浏览器或者服务器在HTTP头部加上 Connection: keep-alive，TCP 就会一直保持连接。保持 TCP 连接可以省下下次需要建立连接的时间，提示资源加载速度； 准备渲染进程阶段 网络进程将获取到的数据包进行解析，根据响应头中的 Content-type 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 text/html 类型，就通知浏览器进程获取到的是 HTML，应该准备渲染进程了； 正常情况下每个浏览器的 tab 会对应一个渲染进程，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程，否则就会创建一个新的渲染进程； 提交文档阶段 渲染进程准备好后，浏览器会发出 “提交文档” 的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的 “管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程； 浏览器收到 “确认提交” 的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 web 页面，此时的 web 页面是空白页； 页面渲染阶段 文档一旦提交，渲染进程将开始页面解析和子资源加载；渲染阶段比较复杂，所以将分为多个子阶段，按照渲染的时间顺序可以分为：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成； 构建 DOM 树：HTML 经过解析后输出一个以 document 为顶层节点的树状结构的 DOM； 样式计算：这里有 3 个步骤： 将 3 个来源（&lt;link&gt; 标签引入的外部样式、&lt;style&gt; 标签里定义的样式、以及元素的 style 属性上的样式）的 CSS 转化成浏览器能够理解的结构 styleSheets； 转换样式表中的属性值，使其标准化；比如 font-weight: bold; 会转成 font-weight: 700;、color: blue; 会转成 color: rgb(0, 0, 255); 等； 依据 CSS 的继承和层叠规则计算出 DOM 树中每个节点的具体样式； 布局阶段：DOM 树中依然存在许多不可见的元素（比如 head），这些元素对于布局是丝毫没用的，所以又会生成一棵只包含可见元素的布局树；然后再根据布局树的每个节点计算出其具体位置和尺寸大小； 分层：页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树；关于层叠上下文的知识，具体可以参考这里彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index； 绘制：为每个图层生成绘制列表，并将其提交到合成线程； 光栅化：通常一个页面很大，而视口很局限，所以合成线程会按照视口附近的图块来优先生成位图，并在光栅化线程池中将图块转换成位图； 合成：一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 DrawQuad，然后将该命令提交给浏览器进程；之后浏览器将开始生成显示页面。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"浏览器专题之事件机制","slug":"browser-event","date":"2020-12-11T01:49:25.000Z","updated":"2021-01-14T02:01:38.840Z","comments":true,"path":"2020/12/11/browser-event/","link":"","permalink":"https://bubuzou.com/2020/12/11/browser-event/","excerpt":"事件流在早期 IE 和 Netscape 团队在开发第四代浏览器的时候，遇到一个问题：当点击一个按钮的时候，是应该先处理父级的事件呢？还是应该先处理按钮的事件呢？IE 和 Netscape 给出了 2 种完全相反的答案，IE 提出事件冒泡的概念，而 Netscape 则支持事件捕获。 事件冒泡事件冒泡认为事件应该由最具体的元素开始触发，然后层层往父级传播：","text":"事件流在早期 IE 和 Netscape 团队在开发第四代浏览器的时候，遇到一个问题：当点击一个按钮的时候，是应该先处理父级的事件呢？还是应该先处理按钮的事件呢？IE 和 Netscape 给出了 2 种完全相反的答案，IE 提出事件冒泡的概念，而 Netscape 则支持事件捕获。 事件冒泡事件冒泡认为事件应该由最具体的元素开始触发，然后层层往父级传播： 事件捕获而事件捕获则相反，认为最外层的元素应该最先收到事件，然后层层往下级传递： DOM 事件流为了在浏览器中兼容这 2 种事件流，在 DOM2 Events 规范中将事件流分为 3 个阶段：事件捕获阶段、到底目标阶段、事件冒泡阶段。 可以通过指定 addEventListener 的第三个参数为 true 来设置事件是在捕获阶段调用事件处理程序，默认是 false 指在冒泡阶段调用事件处理程序。 所有现代浏览器都支持 DOM 事件流，只有 IE8 及更早版本不支持。 事件处理程序HTML 事件处理程序就是将事件处理程序直接绑定到 HTML 的属性中： 12345678// 方式一&lt;div onclick=&quot;console.log(&#x27;hello world&#x27;)&quot;&gt;&lt;/div&gt;方式二&lt;div onclick=&quot;print(event)&quot;&gt;&lt;/div&gt;&lt;script&gt; function print(e) &#123; &#125;&lt;/script&gt; HTML 事件处理程序修改事件相对麻烦，可能需要同时修改 HTML 和 JS，所以大家都不爱使用这种方式绑定事件。 DOM0 事件处理程序将一个函数赋值给 DOM 元素的一个事件处理程序属性，比如 onclick： 1234567let btn = document.getElementById(&#x27;div&#x27;)// 添加事件btn.onclick = function() &#123; &#125;// 移除事件btn.onclick = null DOM2 事件处理程序通过 addEventListener 可以添加 DOM2 级别的事件处理程序，它接收 3 个参数：事件名、事件处理程序和 useCapture （它是一个可选参数，是个布尔值，默认为 false 表示在冒泡阶段调用事件处理程序） 1234let btn = document.getElementById(&#x27;div&#x27;)btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; &#125;, false) 和 DOM0 事件处理程序的区别： addEventListener 可以改变事件流，即可以在捕获阶段触发事件，而 DOM0 是不行的； addEventListener 可以为同一个元素多次添加同一类型的事件处理程序，先添加的事件处理程序会先触发，而 DOM0 如果给同一个元素绑定多个相同类型的事件处理程序的话，则后面添加的会覆盖前面定义的； 它有几个注意事项： 如果不需要在捕获阶段进行拦截操作，则 useCapture 即第三个参可以不传； 通过 addEventListener 添加的事件处理程序只能通过 removeEventListener 移除，而且绑定的事件处理程序必须是同一个。 1234let btn = document.getElementById(&#x27;div&#x27;)let handler = function() &#123; &#125;btn.addEventListener(&quot;click&quot;, handler)btn.removeEventListener(&quot;click&quot;, handler) IE 事件处理函数由于 addEventListener 无法兼容 IE8 及更早版本，所以此时就可以使用 attachEvent 添加事件处理程序和用 detachEvent 移除事件处理程序。 12let btn = document.getElementById(&#x27;div&#x27;)btn.attachEvent(&quot;onclick&quot;, function() &#123; &#125;) 它有这么几个注意事项： 注册的事件名和 DOM0 一样，需要带上 on，比如 onclick； 在通过 attachEvent 添加的事件处理程序内部 this 会指向 window，而 DOM0 和 DOM2 的 this 会指向元素本身； 和 addEventListener 一样， attachEvent 也可以针对同一元素多次添加同一个事件类型的处理程序，但是触发顺序是后定义的先触发； 通过 detachEvent 移除事件处理程序的时候，处理函数必须是和注册的同一个，这点和 addEventListener 保持一致； attachEvent 和 detachEvent 是 IE 专属的 API，所以如果有兼容性要求，我们可以写出跨浏览器的事件处理程序： 1234567891011121314151617181920var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false) &#125; else if (element.attachEvent) &#123; element.attachEvent(&quot;on&quot; + type, handler) &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false) &#125; else if (element.detachEvent) &#123; element.detachEvent(&quot;on&quot; + type, handler) &#125; else &#123; element[&quot;on&quot; + type] = null &#125; &#125;&#125; 事件对象通过不同的事件处理程序添加的事件，event 对象的属性略有不同，我们不需要记住他们的差异，只需要在平时写代码的时候养成一个写兼容代码的习惯即可，如下是一个兼容各种 event 对象的事件处理程序： 123456789101112131415161718192021let handler = function(event) &#123; // 事件对象 let event = event || window.event // 目标元素 let target = event.target || event.srcElement // 阻止默认事件触发 if (event.preventDefault) &#123; event.preventDefault() &#125; else &#123; event.returnValue = false &#125; // 阻止事件冒泡 if (event.stopPropagation) &#123; event.stopPropagation() &#125; else &#123; event.cancelBubble = true &#125;&#125; 事件类型DOM3 Events 定义了如下事件类型： 用户界面事件(UIEvent)：涉及与 BOM 交互的通用浏览器事件，比如 onload、resize、scroll、input、select 等； 焦点事件(FocusEvent)：在元素获得和失去焦点时触发，比如 focus、blur； 鼠标事件(MouseEvent)：使用鼠标在页面上执行某些操作时触发，比如 click、mousedown、mouseover 等； 滚轮事件(WheelEvent)：使用鼠标滚轮(或类似设备)时触发，比如 mousewheel； 输入事件(InputEvent)：向文档中输入文本时触发，比如 textInput； 键盘事件(KeyboardEvent)：使用键盘在页面上执行某些操作时触发，比如 keydown、keypress； 合成事件(CompositionEvent)：在使用某种 IME(Input Method Editor，输入法编辑器)输入字符时触发，比如 compositionstart。 事件委托事件委托是指将多个元素上绑定的事件通过利用事件冒泡的原理从而转移到他们共同的父级上去绑定，从而在一定程度上起到优化的作用，有的人也喜欢叫它事件代理。比如在 Vue 中经常会将事件绑定到每个列表项中： 1234567891011&lt;ul&gt; &lt;li v-for=&quot;item in list&quot; :key=&quot;item&quot; @click=&quot;handleClick(item)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt;``` 其实更好的做法是利用事件委托，将事件绑定到 `ul` 上：```html&lt;ul @click=&quot;handleClick&quot;&gt; &lt;li v-for=&quot;item in list&quot; :key=&quot;item&quot; :data-item=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 123456handleClick(event) &#123; let target = event.target if (target === &#x27;li&#x27;) &#123; let data = target.dataset.item &#125;&#125;","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"浏览器专题之安全篇","slug":"web-security","date":"2020-12-04T01:49:25.000Z","updated":"2021-03-10T15:27:17.919Z","comments":true,"path":"2020/12/04/web-security/","link":"","permalink":"https://bubuzou.com/2020/12/04/web-security/","excerpt":"同源策略（Same Origin Policy）如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。 比如，这个 http://store.company.com/dir/page.html 和下面这些 URL 相比源的结果如下： 12345http:&#x2F;&#x2F;store.company.com&#x2F;dir2&#x2F;other.html &#x2F;&#x2F; 同源，只有路径不同http:&#x2F;&#x2F;store.company.com&#x2F;dir&#x2F;inner&#x2F;another.html &#x2F;&#x2F; 同源，只有路径不同https:&#x2F;&#x2F;store.company.com&#x2F;secure.html &#x2F;&#x2F; 失败，协议不同http:&#x2F;&#x2F;news.company.com&#x2F;dir&#x2F;other.html &#x2F;&#x2F; 失败，域名不同http:&#x2F;&#x2F;store.company.com:81&#x2F;dir&#x2F;etc.html &#x2F;&#x2F; 失败，端口不同 ( http:&#x2F;&#x2F; 默认端口是80)","text":"同源策略（Same Origin Policy）如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。 比如，这个 http://store.company.com/dir/page.html 和下面这些 URL 相比源的结果如下： 12345http:&#x2F;&#x2F;store.company.com&#x2F;dir2&#x2F;other.html &#x2F;&#x2F; 同源，只有路径不同http:&#x2F;&#x2F;store.company.com&#x2F;dir&#x2F;inner&#x2F;another.html &#x2F;&#x2F; 同源，只有路径不同https:&#x2F;&#x2F;store.company.com&#x2F;secure.html &#x2F;&#x2F; 失败，协议不同http:&#x2F;&#x2F;news.company.com&#x2F;dir&#x2F;other.html &#x2F;&#x2F; 失败，域名不同http:&#x2F;&#x2F;store.company.com:81&#x2F;dir&#x2F;etc.html &#x2F;&#x2F; 失败，端口不同 ( http:&#x2F;&#x2F; 默认端口是80) 同源策略的限制 限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作； 限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据； 限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。 由于浏览器同源策略的限制使得 Web 项目难以开发和使用，所以为了既保证安全性又能够灵活开发 Web 应用，从而出现了一些新技术 页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了内容安全策略 CSP 来限制其自由程度； 使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略 CORS，让其可以安全地进行跨域操作； 两个不同源的 DOM是不能相互操纵的，因此浏览器中又实现了跨文档消息机制，让其可以比较安全地通信，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。 内容安全策略（CSP）内容安全策略（Content Security Policy）简称 CSP，通过它可以明确的告诉客户端浏览器当前页面的哪些外部资源可以被加载执行，而哪些又是不可以的。 2 种方式启用 CSP 通过 HTTP 头配置 Content-Security-Policy，以下配置说明该页面只允许当前源和 https://apis.google.com 这 2 个源的脚本加载和执行： 1Content-Security-Policy: script-src &#39;self&#39; https:&#x2F;&#x2F;apis.google.com 通过页面 &lt;meta&gt; 标签配置： 1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#x27;self&#x27; https://apis.google.com&quot;&gt; CSP 的限制CSP 提供了丰富的限制，除了能限制脚本的加载和执行，对其他资源也有限制，比如： font-src：字体来源； img-src：图片来源； style-src：样式来源； 以上只是列举了一些常见的外部资源的限制，想要查看更多资源限制可以看这里。 默认情况下，这些指令的适用范围很广。如果您不为某条指令（例如，font-src）设置具体的策略，则默认情况下，该指令在运行时假定您指定 * 作为有效来源（例如，您可以从任意位置加载字体，没有任何限制。 另外你可以通过 default-src 设置资源限制的默认行为，但它只适用于 -src 结尾的所有指令，比如设置了如下的 CSP 规则，则只允许从 https://cdn.example.net 加载脚本、字体、图片、样式等资源： 1Content-Security-Policy: default-src https:&#x2F;&#x2F;cdn.example.net CSP 配置事项如果要配置多个同一类型的资源限制，需要将它们进行合并： 1Content-Security-Policy: script-src https:&#x2F;&#x2F;host1.com https:&#x2F;&#x2F;host2.com 不同的资源类型之间需要用分号分隔： 1Content-Security-Policy: script-src https:&#x2F;&#x2F;host1.com; img-src https:&#x2F;&#x2F;host2.com 可以通过以下值来灵活配置来源列表： 协议：https:、data:； 主机名：example.com、example.com:443； 路径名：example.com/js； 通配符：*://*.example.com:*。 还可以给来源列表指定关键字，包含如下 4 个关键字，使用关键字需要加上单引号： &#39;none&#39;：不执行任何匹配； &#39;self&#39;：与当前来源（而不是其子域）匹配； &#39;unsafe-inline&#39;：允许使用内联 JavaScript 和 CSS； &#39;unsafe-eval&#39;：允许使用类似 eval 的 text-to-JavaScript 机制。 CSP 应用举例让我们假设一下，您在运行一个银行网站，并希望确保只能加载您自己写入的资源。 在此情形下，首先设置一个阻止所有内容的默认政策 (default-src &#39;none&#39;)，然后在此基础上逐步构建。 假设此银行网站在 https://cdn.mybank.net 上加载所有来自 CDN 的图像、样式和脚本，并通过 XHR 连接到 https://api.mybank.com/ 以抽取各种数据。可使用帧，但仅用于网站的本地页面（无第三方来源）。 网站上没有 Flash，也没有字体和 Extra。 我们能够发送的最严格的 CSP 标头为： 1Content-Security-Policy: default-src &#39;none&#39;; script-src https:&#x2F;&#x2F;cdn.mybank.net; style-src https:&#x2F;&#x2F;cdn.mybank.net; img-src https:&#x2F;&#x2F;cdn.mybank.net; connect-src https:&#x2F;&#x2F;api.mybank.com; child-src &#39;self&#39; 安全沙箱（Sandbox）我们知道早期的浏览器是单进程架构的，这样当某个标签页挂了之后，将影响到整个浏览器。所以出现了多进程架构，它通过给每个标签页分配一个渲染进程解决了这个问题。 而渲染进程的工作是进行 HTML、CSS 的解析，JavaScript 的执行等，而这部分内容是直接暴露给用户的，所以也是最容易被黑客利用攻击的地方，如果黑客攻击了这里就有可能获取到渲染进程的权限，进而威胁到操作系统。所以需要一道墙用来把不可信任的代码运行在一定的环境中，限制不可信代码访问隔离区之外的资源，而这道墙就是浏览器的安全沙箱。 多进程的浏览器架构将主要分为两块：浏览器内核和渲染内核。而安全沙箱能限制了渲染进程对操作系统资源的访问和修改，同时渲染进程内部也没有读写操作系统的能力，而这些都是在浏览器内核中一一实现了，包括持久存储、网络访问和用户交互等一系列直接与操作系统交互的功能。浏览器内核和渲染内核各自职责分明，当他们需要进行数据传输的时候会通过 IPC 进行。 安全沙箱的存在是为了保护客户端操作系统免受黑客攻击，但是阻止不了 XSS 和 CSRF。 跨站脚本攻击（XSS）跨站脚本攻击（Cross Site Scripting）本来缩写是 CSS，但是为了和层叠样式表（Cascading Style Sheet）的简写区分开来，所以在安全领域被称为 XSS。它是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。 可以通过 3 种方式注入恶意脚本 存储型 XSS 攻击 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中，比如在表单输入框中输入这样一段内容： 1&lt;script src=&quot;http://tod.cn/ReFgeasE&quot;&gt;&lt;/script&gt; 然后用户向网站请求包含了恶意 JavaScript 脚本的页面； 当用户浏览该页面的时候，恶意脚本可以通过 document.cookie 获取到页面 Cookie 信息，然后通过 XMLHttpRequest 将这些信息发送给恶意服务器，恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行操作。 反射型 XSS 攻击恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。 基于 DOM 的 XSS 攻击通常是由于是前端代码不够严谨，把不可信的内容插入到了页面。在使用 .innerHTML、.outerHTML、.appendChild、document.write()等 API 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 .innerText、.textContent、.setAttribute() 等代替。比如对于如下代码：当输入 &quot; onclick=alert(&#39;xss&#39;) 且点击生成的链接的时候，就会提示 xss： 123456789&lt;div id=&quot;link&quot;&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; id=&quot;text&quot; value=&quot;&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;按钮&quot; id=&quot;button&quot; onclick=&quot;test()&quot; /&gt;&lt;script&gt;function test() &#123; let text = document.getElementById(&#x27;text&#x27;).value document.getElementById(&#x27;link&#x27;).innerHTML = `&lt;a href=&quot;$&#123;text&#125;&quot;&gt;链接&lt;/a&gt;`&#125;&lt;/script&gt; 阻止 XSS 攻击的措施 服务器对输入脚本进行过滤或转码，比如：&lt;script&gt; 转成 &amp;lt;script&amp;gt; 后脚本就无法执行了； 使用 HttpOnly 属性，服务器通过响应头来将某些重要的 Cookie 设置为 HttpOnly 值，限制了客户端浏览器可以通过 document.cookie 获取这些重要的 Cookie 信息； 充分利用 CSP，可以通过 &lt;meta&gt; 来配置 CSP，这也是前端用于防止 XSS 的最合适手段。 1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;&gt; 跨站请求伪造（CSRF）跨站请求伪造（Cross-site request forgery）简称是 CSRF：是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。 CSRF 是怎么攻击的一个典型的 CSRF 攻击过程应该是这样子的： 用户登录 A 网站，并且保留了登录信息（Cookie）； 被黑客诱导访问了 B 网站，从 A 跳转到 B； B 网站对 A 网站发出请求（这个就是下面将介绍的几种伪造请求的方式），浏览器请求头中会默认携带 A 网站的 Cookie； A 网站服务器收到请求后，经过验证发现用户是登录了的，所以会处理请求。 下面将举一个例子来模拟几种伪造请求的方式。假设： 1https:&#x2F;&#x2F;platforma.com&#x2F;withdraw?account&#x3D;账户名&amp;money&#x3D;转账金额&#96; 这是某个资金平台 A 的转账接口，黑客知道这个接口后就可以通过以下方式进行攻击： 1. 自动发起 GET 请求 黑客在他自己网站的页面上加载了一张图片，而链接地址是指向那个转账接口。所以需要做的就是，只要某个用户在资金平台 A 上刚登录过，且此时被诱导点击了黑客的页面，一进入这个页面就会自动发起 GET 请求去加载图片，实而是去请求去执行转账接口。 1&lt;img src=&quot;https://platforma.com/withdraw?account=hacker名&amp;money=1000&quot;&gt; 2. 自动发起 POST 请求 这类其实就是表单的自动提交。以下是黑客网站上的代码，一旦跳转到黑客指定的页面就会自动提交表单： 12345&lt;form action=&quot;https://platforma.com/withdraw&quot; method=POST&gt; &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;hacker&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot; /&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit()&lt;/script&gt; 3. 点击链接来触发请求 这种伪造请求的方式和第一种很像，不过是将请求的接口放到了 &lt;a&gt; 链接上： 1234&lt;img src=&quot;美女图片的链接&quot; /&gt;&lt;a href=&quot;https://platforma.com/withdraw?account=hacker名&amp;money=1000&quot;&gt; 点击查看更多美女图片&lt;a/&gt; 如何预防 CSRF 攻击1. 给 Cookie 设置合适的 SameSite 当从 A 网站登录后，会从响应头中返回服务器设置的 Cookie 信息，而如果 Cookie 携带了 SameSite=strict 则表示完全禁用第三方站点请求头携带 Cookie，比如当从 B 网站请求 A 网站接口的时候，浏览器的请求头将不会携带该 Cookie。SameSite 还有另外 2 个属性值： Lax 是默认值，允许第三方站点的 GET 请求携带； None 任何情况下都会携带； 以下是一个响应头的 Set-Cookie 示例： 1Set-Cookie: flavor&#x3D;choco; SameSite&#x3D;strict 2. 同源检测 在服务端，通过请求头中携带的 Origin 或者 Referer 属性值进行判断请求是否来源同一站点，同时服务器应该优先检测 Origin。为了安全考虑，相比于 Referer，Origin 只包含了域名而不带路径。 3. CSRF Token 大概过程是可以分成 2 步骤： 在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的随机字符串，然后将该字符串植入到返回的页面中，通常是放到表单的隐藏输入框中，这样能够很好的保护 CSRF Token 不被泄漏； 123456&lt;form action=&quot;https://platforma.com/withdraw&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;csrf-token&quot; value=&quot;nc98P987b&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;account&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;money&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 当浏览器再次发送请求的时候（比如转账），就需要携带这个 CSRF Token 值一并提交； 服务器验证 CSRF Token 是否一致；从第三方网站发出的请求是无法获取用户页面中的 CSRF Token 值的。 点击劫持（ClickJacking）点击劫持（Clickjacking）是一种通过视觉欺骗的手段来达到攻击目的手段。往往是攻击者将目标网站通过 iframe 嵌入到自己的网页中，通过 opacity 等手段设置 iframe 为透明的，使得肉眼不可见，这样一来当用户在攻击者的网站中操作的时候，比如点击某个按钮（这个按钮的顶层其实是 iframe），从而实现目标网站被点击劫持。 防护手段即不希望自己网站的页面被嵌入到别人的网站中。 frame busting如果 A 页面通过 iframe 被嵌入到 B 页面，那么在 A 页面内部window 对象将指向 iframe，而 top 将指向最顶层的网页这里是 B。所以可以依据这个原理来判断自己的页面是被 iframe 引入而嵌入到别人页面，如果是的话，则通过如下的判断会使得 B 页面将直接替换 A 的内容而显示，从而让用户发觉自己被骗。 123if (top.location != window.location) &#123; top.location = window.location&#125; X-Frame-Options通过给页面响应头里设置 X-Frame-Options 为某个属性值，就能达到控制该页面是否可以通过 iframe 的方式被嵌入到别人的网站中。 它有 3 个属性值： deny 表示该页面不允许嵌入到任何页面，包括同一域名页面也不允许； sameorigin 表示只允许嵌入到同一域名的页面； allow-from uri 表示可以嵌入到指定来源的页面中。 点击劫持中的本质就是通过视觉来欺骗用户，顺着这个思路，还有一个攻击方法也和这个类似，那就是图片覆盖攻击大概的原理就是通过样式把图片覆盖在攻击者所希望的任意位置，比如盖在一个网站的 logo 上，当用户点击图片的时候就会被链接到攻击者的站点。 123&lt;a src=&quot;https://hacker.com&quot;&gt; &lt;img src=&quot;图片链接&quot; style=&quot;position: absolute; left: 100; top: 100; z-index: 100;&quot;/&gt;&lt;/a&gt; 对于这种攻击方式，预防的手段就是需要用户在提交的 HTML 中检查，&lt;img&gt; 标签是否有可能导致浮出。 参考文章 浏览器的工作原理与实践 Same-origin_policy CSP 白帽子讲Web安全","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"安全","slug":"安全","permalink":"https://bubuzou.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"「建议收藏」送你一份精心总结的3万字ES6实用指南（全）","slug":"es6","date":"2020-11-17T07:53:04.000Z","updated":"2024-06-12T09:26:57.393Z","comments":true,"path":"2020/11/17/es6/","link":"","permalink":"https://bubuzou.com/2020/11/17/es6/","excerpt":"写本篇文章目的是为了夯实基础，基于阮一峰老师的著作 ECMAScript 6 入门 以及 tc39-finished-proposals 这两个知识线路总结提炼出来的重点和要点，涉及到从 ES2015 到 ES2021 的几乎所有知识，基本上都是按照一个知识点配上一段代码的形式来展示，所以篇幅较长，也正是因为篇幅过长，所以就没把 Stage 2 和 Stage 3 阶段的提案写到这里，后续 ES2021 更新了我再同步更新。 有 5 个提案已经列入 Expected Publication Year in 2021 所以本篇中暂且把他们归为 ES2021。","text":"写本篇文章目的是为了夯实基础，基于阮一峰老师的著作 ECMAScript 6 入门 以及 tc39-finished-proposals 这两个知识线路总结提炼出来的重点和要点，涉及到从 ES2015 到 ES2021 的几乎所有知识，基本上都是按照一个知识点配上一段代码的形式来展示，所以篇幅较长，也正是因为篇幅过长，所以就没把 Stage 2 和 Stage 3 阶段的提案写到这里，后续 ES2021 更新了我再同步更新。 有 5 个提案已经列入 Expected Publication Year in 2021 所以本篇中暂且把他们归为 ES2021。 ES6 前言发展史能写好 JS 固然是重要的，但是作为一个前端，我们也要了解自己所使用语言的发展历程，这里强烈推荐看 《JavaScript 20 年》，本书详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化历程。 版本说明2011 年，发布了 ECMAScript 5.1 版，而 2015 年 6 月发布了 ES6 的第一个版本又叫 ES2015。ES6 其实是一个泛指，指代 5.1 版本以后的下一代标准。TC39 规定将于每年的 6 月发布一次正式版本，版本号以当年的年份为准，比如当前已经发布了 ES2015、ES2016、ES2017、ES2018、ES2019、ES2020 等版本。 提案发布流程任何人都可以向 TC39 提案，要求修改语言标准。一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。 Stage 0 - Strawperson（展示阶段） Stage 1 - Proposal（征求意见阶段） Stage 2 - Draft（草案阶段） Stage 3 - Candidate（候选人阶段） Stage 4 - Finished（定案阶段） 一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在这里查看 ecma262。关于提案流程可以在这里 TC39_Process 看到更加详细的信息。 ES2015 声明const：声明一个常量，let：声明一个变量；const/let 声明的常量/变量都只能作用于代码块（块级作用域或函数作用域）里； 1234if (true) &#123; let name = &#x27;布兰&#x27;&#125;console.log(name) // undefined const/let 不存在变量提升，所以在代码块里必须先声明然后才可以使用，这叫暂时性死区； 123456let name = &#x27;bubuzou&#x27;if (true) &#123; name = &#x27;布兰&#x27; let name&#125;console.log(name) const/let 不允许在同一个作用域内，重复声明； 123function setName(name) &#123; let name = &#x27;&#x27; // SyntaxError&#125; const 声明时必须初始化，且后期不能被修改，但如果初始化的是一个对象，那么不能修改的是该对象的内存地址； 123456const person = &#123; name: &#x27;布兰&#x27;,&#125;person.name = &#x27;bubuzou&#x27;console.log(person.name) // &#x27;bubuzou&#x27;person = &#x27;&#x27; // TypeError const/let 在全局作用域中声明的常量/变量不会挂到顶层对象（浏览器中是 window ）的属性中； 1234var name = &#x27;布兰&#x27;let age = 12console.log(window.name) // &#x27;布兰&#x27;console.log(window.age) // undefined 解构赋值解构类型： 字符串解构 12let [a, b, c = &#x27;c&#x27;] = &#x27;12&#x27;console.log(a, b, c) // &#x27;1&#x27; &#x27;2&#x27; &#x27;c&#x27; 数值解构 12let &#123; toFixed: tf &#125; = 10console.log(tf.call(Math.PI, 2)) // 3.14 布尔值解构 12let &#123; toString: ts &#125; = trueconsole.log(ts.call(false)) // &#x27;false&#x27; 数组解构：等号右侧的数据具有 Iterator 接口可以进行数组形式的解构赋值； 1234567// 解构不成功的变量值为 undefinedlet [a, b, c] = [1, 2]console.log(a, b, c) // 1, 2, undefined// 可以设置默认值let [x, y, z = 3] = [1, 2, null]console.log(x, y, z) // 1, 2, null 什么样的数据具有 Iterator 接口呢？如果一个对象能够通过 [Symbol.iterator] 访问，且能够返回一个符合迭代器协议的对象，那么该对象就是可迭代的。目前内置的可迭代对象有：String、Array、TypeArray、Map、Set、arguments 和 NodeList 等。 对象解构：与数组按照索引位置进行解构不同，对象解构是按照属性名进行解构赋值，如果在当前对象属性匹配不成功则会去对象的原型属性上查找： 12// 默认写法let &#123; name: name, age: age &#125; = &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 12// 简写let &#123; name, age &#125; = &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 123// 改名且设置默认值let &#123; name: name1, age: age1 = 12 &#125; = &#123; name: &#x27;布兰&#x27; &#125;console.log(name1, age1) // &#x27;布兰&#x27; 12 函数参数解构：其实就是运用上面的对象解构和数组解构规则； 12345678function move(&#123; x = 0, y = 0 &#125; = &#123;&#125;) &#123; console.log([x, y]) return [x, y]&#125;move(&#123; x: 3, y: 8 &#125;) // [3, 8]move(&#123; x: 3 &#125;) // [3, 0]move(&#123;&#125;) // [0, 0]move() // [0, 0] 解构要点： 只要等号两边的模式相同（同是对象或同是数组），则左边的变量会被赋予对应的值； 解构不成功的变量值为 undefined； 默认值生效的前提是当等号右边对应的值全等于 undefined 的时候； 只要等号右边的值不是对象或者数组，则会进行自动装箱将其转成对象； null 和 undefined 都无法转成对象，所以无法解构。 解构应用： 交换变量的值； 1234let x = 1, y = 2;[x, y] = [y, x]console.log(x, y) // 2 1 通过函数返回对象属性 1234567function getParams() &#123; return &#123; name: &#x27;布兰&#x27;, age: 12, &#125;&#125;let &#123; name, age &#125; = getParams() 通过定义函数参数来声明变量 12345678910111213let person = &#123; name: &#x27;布兰&#x27;, age: 12,&#125;init(person)// 普通用法function init(person) &#123; let &#123; name, age &#125; = person&#125;// 更简洁用法function init(&#123; name, age &#125;) &#123;&#125; 指定函数参数默认值 12345function initPerson(&#123; name = &#x27;布兰&#x27;, age = 12 &#125; = &#123;&#125;) &#123; console.log(name, age)&#125;initPerson() // &#x27;布兰&#x27; 12initPerson(&#123; age: 20 &#125;) // &#x27;布兰&#x27; 20 提取 JSON 数据 1234567let responseData = &#123; code: 1000, data: &#123;&#125;, message: &#x27;success&#x27;,&#125;let &#123; code, data = &#123;&#125; &#125; = responseData 遍历 Map 结构 1234567let map = new Map()map.set(&#x27;beijing&#x27;, &#x27;北京&#x27;)map.set(&#x27;xiamen&#x27;, &#x27;厦门&#x27;)for (let [key, value] of map) &#123; console.log(key, value)&#125; 输入模块的指定方法和属性 1const &#123; readFile, writeFile &#125; = require(&#x27;fs&#x27;) 字符串扩展 可以使用 Unicode 编码来表示一个字符： 123456// 以下写法都可以用来表示字符 z&#x27;\\z&#x27; // 转义&#x27;\\172&#x27; // 十进制表示法&#x27;\\x7A&#x27; // 十六进制表示法&#x27;\\u007A&#x27; // Unicode 普通表示法&#x27;\\u&#123;7A&#125;&#x27; // Unicode 大括号表示法 www.52unicode.com 这个网站可以查询到常见符号的 Unicode 编码。 可以使用 for...of 正确遍历字符串： 1234567let str = &#x27;😀🤣😜😍🤗🤔&#x27;for (const emoji of str) &#123; console.log(emoji) // 😀🤣😜😍🤗🤔&#125;for (let i = 0, l = str.length; i &lt; l; i++) &#123; console.log(str[i]) // 不能正确输出表情&#125; 模板字符串使用两个反引号标识（``），可以用来定义多行字符串，或者使用它在字符串中插入变量： 1234let name = &#x27;hero&#x27;let tips = `Hello $&#123;name&#125;, welcome to my world.`alert(tips) 标签模板：在函数名后面接一个模板字符串相当于给函数传入了参数进行调用： 1234567let name = &#x27;布兰&#x27;, age = 12let tips = parse`Hello $&#123;name&#125;, are you $&#123;age&#125; years old this year?`function parse(stringArr, ...variable) &#123;&#125;// 相当于传递如下参数进行调用 parse 函数parse([&#x27;Hello &#x27;, &#x27;, are you &#x27;, &#x27; years old this year?&#x27;], name, age) String.fromCodePoint() 用于从 Unicode 码点返回对应字符，可以支持 0xFFFF 的码点： 12String.fromCharCode(0x1f600) // &quot;&quot;String.fromCodePoint(0x1f600) // &quot;😀&quot; String.raw() 返回把字符串所有变量替换且对斜杠进行转义的结果： 1String.raw`Hi\\n$&#123;2 + 3&#125;!` // &quot;Hi\\n5!&quot; codePointAt() 返回字符的十进制码点，对于 Unicode 大于 0xFFFF 的字符，会被认为是 2 个字符，十进制码点转成十六进制可以使用 toString(16)： 123456let emoji = &#x27;🤣&#x27;emoji.length // 2emoji.charCodeAt(0).toString(16) // &#x27;d83d&#x27;emoji.charCodeAt(1).toString(16) // &#x27;de00&#x27;String.fromCodePoint(0xd83d, 0xde00) === &#x27;🤣&#x27; // true normalize() 方法会按照指定的一种 Unicode 正规形式将当前字符串正规化。（如果该值不是字符串，则首先将其转换为一个字符串）： 12345678let str1 = &#x27;\\u00F1&#x27;let str2 = &#x27;\\u006E\\u0303&#x27;str1 // ñstr2 // ñstr1 === str2 // falsestr1.length === str2.length // falsestr1.normalize() === str2.normalize() // true 字符串是否包含子串： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = &#x27;Hello world!&#x27;s.includes(&#x27;o&#x27;) // trues.startsWith(&#x27;Hello&#x27;) // trues.endsWith(&#x27;!&#x27;) // true 这三个方法都支持第二个参数，表示开始搜索的位置： 12345let s = &#x27;Hello world!&#x27;s.includes(&#x27;Hello&#x27;, 6) // falses.startsWith(&#x27;world&#x27;, 6) // trues.endsWith(&#x27;Hello&#x27;, 5) // true 上面代码表示，使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。 repeat(n) 将当前字符串重复 n 次后，返回一个新字符串： 12345678&#x27;x&#x27;.repeat(2) // &#x27;xx&#x27;&#x27;x&#x27;.repeat(1.9) // &#x27;x&#x27;&#x27;x&#x27;.repeat(NaN) // &#x27;&#x27;&#x27;x&#x27;.repeat(undefined) // &#x27;&#x27;&#x27;x&#x27;.repeat(&#x27;2a&#x27;) // &#x27;&#x27;&#x27;x&#x27;.repeat(-0.6) // &#x27;&#x27;，解释：0 ~ 1 之间的小数相当于 0&#x27;x&#x27;.repeat(-2) // RangeError&#x27;x&#x27;.repeat(Infinity) // RangeError 数值扩展 二进制（0b）和八进制（0o）表示法： 12345let num = 100let b = num.toString(2) // 二进制的100：1100100let o = num.toString(8) // 八进制的100：1440b1100100 === 100 // true0o144 === 100 // true Number.isFinite() 判断一个数是否是有限的数，入参如果不是数值一律返回 false： 12345Number.isFinite(-2.9) // trueNumber.isFinite(NaN) // falseNumber.isFinite(&#x27;&#x27;) // falseNumber.isFinite(false) // trueNumber.isFinite(Infinity) // false Number.isNaN() 判断一个数值是否为 NaN，如果入参不是 NaN 那结果都是 false： 123Number.isNaN(NaN) // trueNumber.isFinite(&#x27;a&#x27; / 0) // trueNumber.isFinite(&#x27;NaN&#x27;) // false 数值转化：Number.parseInt() 和 Number.parseFloat()，非严格转化，从左到右解析字符串，遇到非数字就停止解析，并且把解析的数字返回： 1234parseInt(&#x27;12a&#x27;) // 12parseInt(&#x27;a12&#x27;) // NaNparseInt(&#x27;&#x27;) // NaNparseInt(&#x27;0xA&#x27;) // 10，0x开头的将会被当成十六进制数 parseInt() 默认是用十进制去解析字符串的，其实他是支持传入第二个参数的，表示要以多少进制的 基数去解析第一个参数： 12parseInt(&#x27;1010&#x27;, 2) // 10parseInt(&#x27;ff&#x27;, 16) // 255 参考：parseInt Number.isInteger() 判断一个数值是否为整数，入参为非数值则一定返回 false： 1234567Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger() // falseNumber.isInteger(null) // falseNumber.isInteger(&#x27;15&#x27;) // falseNumber.isInteger(true) // falseNumber.isInteger(3.0000000000000002) // true 如果对数据精度的要求较高，不建议使用 Number.isInteger() 判断一个数值是否为整数。 Number.EPSILON 表示一个可接受的最小误差范围，通常用于浮点数运算： 120.1 + 0.2 === 0.3 // falseMath.abs(0.1 + 0.2 - 0.3) &lt; Number.EPSILON // true Number.isSafeInteger() 用来判断一个数是否在最大安全整数（Number.MAX_SAFE_INTEGER）和最小安全整数（Number.MIN_SAFE_INTEGER）之间： 123456Number.MAX_SAFE_INTEGER === 2 ** 53 - 1 // trueNumber.MAX_SAFE_INTEGER === 9007199254740991 // trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // trueNumber.isSafeInteger(2) // trueNumber.isSafeInteger(&#x27;2&#x27;) // falseNumber.isSafeInteger(Infinity) // false Math.trunc()：返回数值整数部分 Math.sign()：返回数值类型(正数 1、负数 -1、零 0) Math.cbrt()：返回数值立方根 Math.clz32()：返回数值的 32 位无符号整数形式 Math.imul()：返回两个数值相乘 Math.fround()：返回数值的 32 位单精度浮点数形式 Math.hypot()：返回所有数值平方和的平方根 Math.expm1()：返回 e^n - 1 Math.log1p()：返回 1 + n 的自然对数(Math.log(1 + n)) Math.log10()：返回以 10 为底的 n 的对数 Math.log2()：返回以 2 为底的 n 的对数 Math.sinh()：返回 n 的双曲正弦 Math.cosh()：返回 n 的双曲余弦 Math.tanh()：返回 n 的双曲正切 Math.asinh()：返回 n 的反双曲正弦 Math.acosh()：返回 n 的反双曲余弦 Math.atanh()：返回 n 的反双曲正切 数组扩展 数组扩展运算符（…）将数组展开成用逗号分隔的参数序列，只能展开一层数组： 123456789101112131415// 应用一：函数传参Math.max(...[1, 2, 3]) // 3// 应用二：数组合并let merge = [...[1, 2], ...[3, 4], 5, 6] // 1, 2, 3, 4, 5, 6// 应用三：浅克隆let a = [1, 2, 3]let clone = [...a]a === clone // false// 应用四：数组解构const [x, ...y] = [1, 2, 3]x // 1y // [2, 3] Array.from() 可以将类数组对象（ NodeList，arguments）和可迭代对象转成数组： 123456789101112// 应用一：字符串转数组Array.from(&#x27;foo&#x27;) // [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]// 应用二：数组合并去重let merge = [...[1, 2], ...[2, 3]]Array.from(new Set(merge)) // [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]// 应用三：arguments 转数组function f() &#123; return Array.from(arguments)&#125;f(1, 2, 3) // [1, 2, 3] 如果 Array.from() 带第二个参数 mapFn，将对生成的新数组执行一次 map 操作： 12Array.from([1, 2, 3], (x) =&gt; x * x) // [1, 4, 9]Array.from(&#123; length: 3 &#125;, (v, i) =&gt; ++i) // [1, 2, 3] Array.of() 将一组参数转成数组： 1234567Array.of(1, 2, 3) // [1, 2, 3]// 类似于function arrayOf(...params) &#123; return [].slice.call(params)&#125;arrayOf(1, 2, 3) // [1, 2, 3] Array.copyWithin() 在当前数组内部，将制定位置的成员复制到其他位置（会覆盖原来位置的成员），最后返回一个新数组。接收 3 个参数，参数为负数表示右边开始计算： target（必选）：替换位置的索引； start（可选）：从该位置开始读取数据，默认为 0； end（可选）：从该位置结束读取数据（不包括该位置的数据），默认为原数组长度； 12345;[1, 2, 3, 4, 5] .copyWithin(-1) // [1, 2, 3, 4, 1] [(1, 2, 3, 4, 5)].copyWithin(1) // [1, 1, 2, 3, 4] [(1, 2, 3, 4, 5)].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5] [(1, 2, 3, 4, 5)].copyWithin(0, -3, -1) // [3, 4, 3, 4, 5] 查找第一个出现的子成员：find() 和 findIndex()： 12345678// 找出第一个偶数;[1, 6, 9] .find((val, index, arr) =&gt; val % 2 === 0) // 6 [ // 找出第一个偶数的索引位置 (1, 6, 9) ].findIndex((val, index, arr) =&gt; val % 2 === 0) // 1 fill() 使用给定的值来填充数组，有 3 个参数： value：填充值； start（可选），开始索引，默认为 0； end（可选）：结束索引，默认为数组长度，不包括该索引位置的值； 12345// 初始化空数组Array(3) .fill(1) // [1, 1, 1] [(1, 2, 3, 4)].fill(&#x27;a&#x27;, 2, 4) // [1, 2, &#x27;a&#x27;, &#x27;a&#x27;] 通过 keys()（键名）、entries()（键值）和 values()（键值对） 获取数组迭代器对象，可以被 for...of 迭代， 12345678910let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]for (let x of arr.keys()) &#123; console.log(x) // 1, 2, 3&#125;for (let v of arr.values()) &#123; console.log(v) // &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;&#125;for (let e of arr.entries()) &#123; console.log(e) // [0, &#x27;a&#x27;] [0, &#x27;b&#x27;] [0, &#x27;c&#x27;]&#125; 数组空位，是指数组没有值，比如：[,,]，而像这种 [undefined] 是不包含空位的。由于 ES6 之前的一些 API 对空位的处理规则很不一致，所以实际操作的时候应该尽量避免空位的出现，而为了改变这个现状，ES6 的 API 会默认将空位处理成 undefined： 12[...[1, , 3].values()] // [1, undefined, 3][1, , 3].findIndex(x =&gt; x === undefined) // 1 对象扩展 对象属性简写： 1234567891011121314let name = &#x27;布兰&#x27;let person = &#123; name, getName() &#123; return this.name &#125;,&#125;// 等同于let person1 = &#123; name: &#x27;布兰&#x27;, getName: function () &#123; return this.name &#125;,&#125; 属性名表达式：在用对象字面量定义对象的时候，允许通过属性名表达式来定义对象属性： 1234567let name = &#x27;name&#x27;,let person = &#123; [name]: &#x27;布兰&#x27;, [&#x27;get&#x27;+ name]()&#123; return this.name &#125;&#125; 方法的 name 属性，存在好几种情况，这里仅列出常见的几种： 情况一：普通对象方法的 name 属性直接返回方法名，函数声明亦是如此，函数表达式返回变量名： 1234let person = &#123; hi() &#123;&#125;,&#125;person.hi.name // &#x27;hi&#x27; 情况二：构造函数的 name 为 anonymous： 1new Function().name // &#x27;anonymous&#x27; 情况三：绑定函数的 name 将会在函数名前加上 bound： 12function foo() &#123;&#125;foo.bind(&#123;&#125;).name // &#x27;bound foo&#x27; 情况四：如果对象的方法使用了取值函数（getter）和存值函数（setter），则 name 属性不是在该方法上面，而是该方法的属性的描述对象的 get 和 set 属性上面： 12345678let o = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;,&#125;o.foo.name // TypeError: Cannot read property &#x27;name&#x27; of undefinedlet descriptor = Object.getOwnPropertyDescriptor(o, &#x27;foo&#x27;)descriptor.get.name // &quot;get foo&quot;descriptor.set.name // &quot;set foo&quot; 参考：function_name 属性的可枚举性 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。可以通过 Object.getOwnPropertyDescriptor() 来获取对象某个属性的描述： 12345678let person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;Object.getOwnPropertyDescriptor(person, &#x27;name&#x27;)// &#123;// configurable: true,// enumerable: true,// value: &quot;布兰&quot;,// writable: true,// &#125; 这里的 enumerable 就是对象某个属性的可枚举属性，如果某个属性的 enumerable 值为 false 则表示该属性不能被枚举，所以该属性会被如下 4 种操作忽略： for...in ：只遍历对象自身的和继承的可枚举的属性； Object.keys()：返回对象自身的所有可枚举的属性的键名； JSON.stringify()：只串行化对象自身的可枚举的属性； Object.assign()： 只拷贝对象自身的可枚举的属性。 12345678910111213141516let person = &#123; name: &#x27;布兰&#x27; &#125;Object.defineProperty(person, &#x27;age&#x27;, &#123; configurable: true, enumerable: false, value: 12, writable: true,&#125;)person // &#123; name: &#x27;布兰&#x27;, age: 12 &#125;// 以下操作都将忽略 person 对象的 age 属性for (let x in person) &#123; console.log(x) // &#x27;name&#x27;&#125;Object.keys(person) // [&#x27;name&#x27;]JSON.stringify(person) // &#x27;&#123;&quot;name&quot;: &quot;布兰&quot;&#125;&#x27;Object.assign(&#123;&#125;, person) // &#123; name: &#x27;布兰&#x27; &#125; Reflect.ownKeys(obj)： 返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举： 12// 基于上面的代码Reflect.ownKeys(person) // [&#x27;name&#x27;, &#x27;age&#x27;] super 关键字，指向对象的原型对象，只能用于对象的方法中，其他地方将报错： 123456789101112131415161718192021let person = &#123; name: &#x27;布兰&#x27;, getName() &#123; return super.name &#125;,&#125;Object.setPrototypeOf(person, &#123; name: &#x27;hello&#x27; &#125;)person.getName() // &#x27;hello&#x27;// 以下几种 super 的使用将报错const obj1 = &#123; foo: super.foo,&#125;const obj2 = &#123; foo: () =&gt; super.foo,&#125;const obj3 = &#123; foo: function () &#123; return super.foo &#125;,&#125; Object.is() 用来判断两个值是否相等，表现基本和 === 一样，除了以下两种情况： 1234;+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target），如果有同名属性，则后面的会直接替换前面的： 12345let target = &#123; a: 1 &#125;let source1 = &#123; a: 2, b: 3, d: &#123; e: 1, f: 2 &#125; &#125;let source2 = &#123; a: 3, c: 4, d: &#123; g: 3 &#125; &#125;Object.assign(target, source1, source2)target // &#123; a: 3, b: 3, c: 4, d: &#123;g: 3&#125; &#125; Object.assign() 实行的是浅拷贝，如果源对象某个属性是对象，那么拷贝的是这个对象的引用： 12345let target = &#123; a: &#123; b: 1 &#125; &#125;let source = &#123; a: &#123; b: 2 &#125; &#125;Object.assign(target, source)target.a.b = 3source.a.b // 3 __proto__ 属性是用来读取和设置当前对象的原型，而由于其下划线更多的是表面其是一个内部属性，所以建议不在正式场合使用它，而是用下面的 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 Object.setPrototypeOf() 用于设置对象原型，Object.getPrototypeOf() 用于读取对象原型： 123let person = &#123; name: &#x27;布兰&#x27; &#125;Object.setPrototypeOf(person, &#123; name: &#x27;动物&#x27; &#125;)Object.getPrototypeOf(person) // &#123;name: &#x27;动物&#x27;&#125; 正则扩展 RegExp 构造函数，允许首参为正则表达式，第二个参数为修饰符，如果有第二个参数，则修饰符以第二个为准： 12let reg = new RegExp(/xYz\\d+/gi, i)reg.flags // &#x27;i&#x27; 正则方法调用变更：字符串对象的 match()、replace()、search()、split() 内部调用转为调用 RegExp 实例对应的 RegExp.prototype[Symbol.方法]； u 修饰符：含义为 Unicode 模式，用来正确处理大于 \\uFFFF 的 Unicode 字符。也就是说，如果待匹配的字符串中可能包含有大于 \\uFFFF 的字符，就必须加上 u 修饰符，才能正确处理。 1234567891011// 加上 u 修饰符才能让 . 字符正确识别大于 \\uFFFF 的字符/^.$/.test(&#x27;🤣&#x27;) // false/^.$/u.test(&#x27;🤣&#x27;) // true// 大括号 Unicode 字符表示法必须加上 u 修饰符/\\u&#123;61&#125;/.test(&#x27;a&#x27;) // false/\\u&#123;61&#125;/u.test(&#x27;a&#x27;) // true// 有 u 修饰符，量词才能正确匹配大于 \\uFFFF 的字符/🤣&#123;2&#125;/.test(&#x27;🤣🤣&#x27;) // false/🤣&#123;2&#125;/u.test(&#x27;🤣🤣&#x27;) // true RegExp.prototype.unicode 属性表示正则是否设置了 u 修饰符： 12/🤣/.unicode // false/🤣/u.unicode // true y 修饰符，与 g 修饰符类似也是全局匹配；不同的是 g 是剩余字符中匹配即可，而 y 则是必须在剩余的第一个字符开始匹配才行，所以 y 修饰符也叫黏连修饰符： 123456789let s = &#x27;aaa_aa_a&#x27;let r1 = /a+/glet r2 = /a+/yr1.exec(s) // [&quot;aaa&quot;]r2.exec(s) // [&quot;aaa&quot;]r1.exec(s) // [&quot;aa&quot;]r2.exec(s) // null RegExp.prototype.sticky 属性表示是否设置了 y 修饰符： 1;/abc/y.sticky // true RegExp.prototype.flags 属性会返回当前正则的所有修饰符： 1;/abc🤣/iuy.flags // &#x27;iuy&#x27; 函数扩展 函数参数默认值。参数不能有同名的，函数体内不能用 let 和 const 声明同参数名的变量： 1function printInfo(name = &#x27;布兰&#x27;, age = 12) &#123;&#125; 使用参数默认值的时候，参数不能有同名的： 12function f(x, x, y) &#123;&#125; // 不报错function f(x, x, y = 1) &#123;&#125; // 报错 函数体内不能用 let 和 const 声明同参数名的变量： 1234// 报错function f(x, y) &#123; let x = 0&#125; 函数的 length 属性会返回没有指定默认值的参数个数，且如果设置默认值的参数不是尾参数，则 length 不再计入后面的参数： 123456789;(function f(x, y) &#123;&#125; .length( // 2 function f(x, y = 1) &#123;&#125; ) .length( // 1 function f(x = 1, y) &#123;&#125; ).length) // 0 剩余（rest） 参数（…变量名）的形式，用于获取函数的剩余参数，注意 rest 参数必须放在最后一个位置，可以很好的代替 arguments 对象： 1234567function f(x, ...y) &#123; console.log(x) // 1 for (let val of y) &#123; coonsole.log(val) // 2 3 &#125;&#125;f(1, 2, 3) 严格模式：只要函数参数使用了默认值、解构赋值或者扩展运算符，那么函数体内就不能显示的设定为严格模式，因为严格模式的作用范围包含了函数参数，而函数执行的顺序是先执行参数，然后再执行函数体，执行到函数体里的 use strict 的时候，那么此时因为函数参数已经执行完成了，那函数参数还要不要受到严格模式的限制呢？这就出现矛盾了。规避限制的办法有两个：设置全局的严格模式或者在函数体外在包一个立即执行函数并且声明严格模式： 123456789// 解法一&#x27;use strict&#x27;function f(x, y = 2) &#123;&#125;// 解法二let f = (function () &#123; &#x27;use strict&#x27; return function (x, y = 2) &#123;&#125;&#125;)() 箭头函数语法比函数表达式更简洁，并且没有自己的 this、arguments，不能用作构造函数和用作生成器。几种箭头函数写法： 1234567let f1 = () =&gt; &#123;&#125; // 没有参数let f2 = (x) =&gt; &#123;&#125; // 1个参数let f3 = (x) =&gt; &#123;&#125; // 1个参数可以省略圆括号let f4 = (x, y) =&gt; &#123;&#125; // 2个参数以上必须加上圆括号let f5 = (x = 1, y = 2) =&gt; &#123;&#125; // 支持参数默认值let f6 = (x, ...y) =&gt; &#123;&#125; // 支持 rest 参数let f7 = (&#123; x = 1, y = 2 &#125; = &#123;&#125;) // 支持参数解构 箭头函数没有自己的 this： 1234567function Person() &#123; this.age = 0 setInterval(() =&gt; &#123; this.age++ &#125;, 1000)&#125;var p = new Person() // 1 秒后 Person &#123;age: 1&#125; 通过 call/apply 调用箭头函数的时候将不会绑定第一个参数的作用域： 12345678910111213141516let adder = &#123; base: 1, add: function (a) &#123; let f = (v) =&gt; v + this.base return f(a) &#125;, addThruCall: function (a) &#123; let f = (v) =&gt; v + this.base let b = &#123; base: 2, &#125; return f.call(b, a) &#125;,&#125;adder.add(1) // 输出 2adder.addThruCall(1) // 仍然输出 2 箭头函数没有自己的 arguments 对象，不过可以使用 rest 参数代替： 12345678910let log = () =&gt; &#123; console.log(arguments) // ReferenceError&#125;log(2, 3)// 剩余参数代替写法let restLog = (...arr) =&gt; &#123; console.log(arr) // [2, 3]&#125;restLog(2, 3) 箭头函数不能用作构造器，和 new 一起用会抛出错误： 123let Foo = () =&gt; &#123;&#125;let foo = new Foo()// TypeError: Foo is not a constructor 箭头函数返回对象字面量，需要用圆括号包起来： 1let func2 = () =&gt; (&#123; foo: 1 &#125;) 参考：Arrow_functions 尾调用和尾递归 首先得知道什么是尾调用：函数的最后一步调用另外一个函数： 123456789101112131415161718// 是尾调用function f(x) &#123; return g(x)&#125;// 以下都不是尾调用function f(x) &#123; let y = g(x) return y&#125;function f(x) &#123; let y = g(x) return g(x) + 1&#125;function f(x) &#123; g(x) // 因为最后一步是 return: undefined&#125; 尾调用有啥用？我们知道函数的相互调用是会生成“调用帧”的，而“调用帧”里存了各种信息比如函数的内部变量和调用函数的位置等，所有的“调用帧”组成了一个“调用栈”。如果在函数的最后一步操作调用了另外一个函数，因为外层函数里调用位置、内部变量等信息都不会再用到了，所有就无需保留外层函数的“调用帧”了，只要直接用内层函数的“调用帧”取代外层函数的“调用帧”即可： 123456789101112131415function f() &#123; let m = 1 let n = 2 return g(m + n)&#125;f()// 等同于function f() &#123; return g(3)&#125;f()// 等同于g(3) 这样一来就很明显的减少了调用栈中的帧数，内存占用就少了，所以这就是尾调用的优化作用。尾递归也是如此，递归如果次数多那就需要保留非常多的“调用帧”，所以经常会出现栈溢出错误，而使用了尾递归优化后就不会发生栈溢出的错误了： 123456789101112131415161718// 常规递归的斐波那契函数function Fibonacci(n) &#123; if (n &lt;= 1) &#123; return 1 &#125; return Fibonacci(n - 1) + Fibonacci(n - 2)&#125;Fibonacci(100) // 超时// 尾递归优化后的斐波那契函数function Fibonacci2(n, ac1 = 1, ac2 = 1) &#123; if (n &lt;= 1) &#123; return ac2 &#125; return Fibonacci2(n - 1, ac2, ac1 + ac2)&#125;sFibonacci2(100) // 573147844013817200000 Symbol Symbol 是一个新的原始类型，用来表示一个独一无二的值，可以通过 Symbol() 函数来创建一个 Symbol 类型的值，为了加以区分，可以传入一个字符串作为其描述： 123let s1 = Symbol(&#x27;foo&#x27;)let s2 = Symbol(&#x27;foo&#x27;)s1 === s2 // false Symbol 类型无法通过数学运算符进行隐式类型转换，但是可以通过 String() 显示转成字符串或者通过 Boolean() 显示转成布尔值： 1234let s = Symbol(&#x27;foo&#x27;)String(s) // &quot;Symbol(&#x27;foo&#x27;)&quot;s.toString() // &quot;Symbol(&#x27;foo&#x27;)&quot;Boolean(s) // true 引入 Symbol 最大的初衷其实就是为了让它作为对象的属性名而使用，这样就可以有效避免属性名的冲突了： 1234567let foo = Symbol(&#x27;foo&#x27;)let obj = &#123; [foo]: &#x27;foo1&#x27;, foo: &#x27;foo2&#x27;,&#125;obj[foo] // &#x27;foo1&#x27;obj.foo // &#x27;foo2&#x27; Symbol 属性的不可枚举性，不会被 for...in、for...of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 等枚举： 12345678910let person = &#123; name: &#x27;布兰&#x27;, [Symbol(&#x27;age&#x27;)]: 12,&#125;for (let x in person) &#123; console.log(x) // &#x27;name&#x27;&#125;Object.keys(person) // [&#x27;name&#x27;]Object.getOwnPropertyNames(person) // [&#x27;name&#x27;]JSON.stringify(person) // &#x27;&#123;&quot;name&quot;:&quot;布兰&quot;&#125;&#x27; 但是可以通过 Object.getOwnPropertySymbols() 获取到对象的所有 Symbol 属性名，返回一个数组： 12// 基于上面的代码Object.getOwnPropertySymbols(person) // [Symbol(age)] 静态方法： Symbol.for() 按照描述去全局查找 Symbol，找不到则在全局登记一个： 123let s1 = Symbol.for(&#x27;foo&#x27;)let s2 = Symbol.for(&#x27;foo&#x27;)s1 === s2 // true Symbol.for() 的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。 Symbol.keyFor() 根据已经在全局登记的 Symbol 查找其描述： 12let s = Symbol.for(&#x27;foo&#x27;)Symbol.keyFor(s) // &#x27;foo&#x27; Symbol 的内置值： Symbol.hasInstance：指向一个内部方法，当其他对象使用 instanceof 运算符判断是否为此对象的实例时会调用此方法； Symbol.isConcatSpreadable：指向一个布尔，定义对象用于 Array.prototype.concat() 时是否可展开； Symbol.species：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数； Symbol.match：指向一个函数，当实例对象被 String.prototype.match() 调用时会重新定义 match()的行为； Symbol.replace：指向一个函数，当实例对象被 String.prototype.replace() 调用时会重新定义 replace() 的行为； Symbol.search：指向一个函数，当实例对象被 String.prototype.search() 调用时会重新定义 search() 的行为；s Symbol.split：指向一个函数，当实例对象被 String.prototype.split() 调用时会重新定义 split() 的行为； Symbol.iterator：指向一个默认遍历器方法，当实例对象执行 for...of 时会调用指定的默认遍历器； Symbol.toPrimitive：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值； Symbol.toStringTag：指向一个函数，当实例对象被 Object.prototype.toString() 调用时其返回值会出现在 toString() 返回的字符串之中表示对象的类型； Symbol.unscopables：指向一个对象，指定使用 with 时哪些属性会被 with 环境排除； Set Set 是一种新的数据结构，类似数组，但是它没有键只有值，且值都是唯一的。可以通过构造函数生成一个新实例，接收一个数组或者可迭代数据结构作为参数： 12new Set([1, 2, 3]) // Set &#123;1, 2, 3&#125;new Set(&#x27;abc&#x27;) // Set &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125; Set 判断两个值是不是相等用的是 sameValueZero 算法，类似于 ===，唯一的区别是，在 Set 里 NaN 之间被认为是相等的： 123456let set = new Set()let a = NaNlet b = NaNset.add(a)set.add(b)set.size // 1 相同对象的不同实例也被 Set 认为是不相等的： 123456let set = new Set()let a = &#123; a: 1 &#125;let b = &#123; a: 1 &#125;set.add(a)set.add(b)set.size // 2 Set 是有顺序的，将按照插入的顺序进行迭代，可以使用 for...of 迭代： 123456let set = new Set([1, 3])set.add(5)set.add(7)for (let x of set) &#123; console.log(x)&#125; Set 实例属性和方法： Set.prototype.constructor：构造函数，默认就是 Set 函数； Set.prototype.size：返回 Set 实例的成员总数； Set.prototype.add(value)：添加某个值，返回 Set 结构本身； Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功； Set.prototype.has(value)：返回一个布尔值，表示该值是否为 Set 的成员； Set.prototype.clear()：清除所有成员，没有返回值； Set.prototype.keys()：返回键名的遍历器； Set.prototype.values()：返回键值的遍历器； Set.prototype.entries()：返回键值对的遍历器； Set.prototype.forEach()：使用回调函数遍历每个成员； 12345678let set = new Set([1, 3])set.add(5) // Set &#123;1, 3, 5&#125;set.size // 3set.delete(1) // true，1 已被删除set.has(1) // falseset.keys() // SetIterator &#123;3, 5&#125;set.clear()set.size // 0 Set 应用场景： 数组去重： 12;[...new Set([1, 3, 6, 3, 1])] // [1, 3, 6]Array.from(new Set([1, 3, 6, 3, 1])) // [1, 3, 6] 字符串去重： 1;[...new Set(&#x27;abcbacd&#x27;)].join(&#x27;&#x27;) // &#x27;abcd&#x27; 求两个集合的交集/并集/差集： 1234567891011let a = new Set([1, 2, 3])let b = new Set([4, 3, 2])// 并集let union = new Set([...a, ...b]) // Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter((x) =&gt; b.has(x))) // set &#123;2, 3&#125;// （a 相对于 b 的）差集let difference = new Set([...a].filter((x) =&gt; !b.has(x))) // Set &#123;1&#125; 遍历修改集合成员的值： 1234567let set = new Set([1, 2, 3])// 方法一let set1 = new Set([...set].map((val) =&gt; val * 2)) // Set &#123;2, 3, 6&#125;// 方法二let set2 = new Set(Array.from(set, (val) =&gt; val * 2)) // Set &#123;2, 4, 6&#125; WeakSet WeakSet 对象允许将弱保持对象存储在一个集合中： 12345let ws = new WeakSet()let foo = &#123;&#125;ws.add(foo) // WeakSet &#123;&#123;&#125;&#125;ws.has(foo) // truews.delete(foo) // WeakSet &#123;&#125; 和 Set 的区别： WeakSet 只能是对象的集合，而不能是任何类型的任意值； WeakSet 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 WeakSet 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 WeakSet 中没有存储当前对象的列表。正因为这样，WeakSet 是不可枚举的，也就没有 size 属性，没有 clear 和遍历的方法。 实例方法： WeakSet.prototype.add(value)：添加一个新元素 value； WeakSet.prototype.delete(value)：从该 WeakSet 对象中删除 value 这个元素； WeakSet.prototype.has(value)：返回一个布尔值, 表示给定的值 value 是否存在于这个 WeakSet 中； Map Map 是一种类似于 Object 的这种键值对的数据结构，区别是对象的键只能是字符串或者 Symbol，而 Map 的键可以是任何类型（原始类型、对象或者函数），可以通过 Map 构造函数创建一个实例，入参是具有 Iterator 接口且每个成员都是一个双元素数组 [key, value] 的数据结构： 12345678let map1 = new Map()map1.set(&#123;&#125;, &#x27;foo&#x27;)let arr = [ [&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12],]let map2 = new Map(arr) Map 中的键和 Set 里的值一样也必须是唯一的，遵循 sameValueZero 算法，对于同一个键后面插入的会覆盖前面的， 12345let map = new Map()let foo = &#123; foo: &#x27;foo&#x27; &#125;map.set(foo, &#x27;foo1&#x27;)map.set(foo, &#x27;foo2&#x27;)map.get(foo) // &#x27;foo2&#x27; 对于键名同为 NaN 以及相同对象而不同实例的处理同 Set 的值一样： 1234567891011121314let a = NaNlet b = NaNlet map = new Map()map.set(a, &#x27;a&#x27;)map.set(b, &#x27;b&#x27;)map.size // 1map.get(a) // &#x27;b&#x27;let c = &#123; c: &#x27;c&#x27; &#125;let d = &#123; c: &#x27;c&#x27; &#125;map.set(c, &#x27;c&#x27;)map.set(d, &#x27;d&#x27;)map.size // 3map.get(c) // &#x27;c&#x27; 实例属性和方法： Map.prototype.size：返回 Map 对象的键值对数量； Map.prototype.set(key, value)：设置 Map 对象中键的值。返回该 Map 对象； Map.prototype.get(key)： 返回键对应的值，如果不存在，则返回 undefined； Map.prototype.has(key)：返回一个布尔值，表示 Map 实例是否包含键对应的值； Map.prototype.delete(key)： 如果 Map 对象中存在该元素，则移除它并返回 true； Map.prototype.clear()： 移除 Map 对象的所有键/值对； Map.prototype.keys()：返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键； Map.prototype.values()：返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值； Map.prototype.entries()：返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组； Map.prototype.forEach(callbackFn[, thisArg])：按插入顺序遍历 Map； 123456789101112131415let map = new Map()map.set(&#123; a: 1 &#125;, &#x27;a&#x27;)map.set(&#123; a: 2 &#125;, &#x27;b&#x27;)for (let [key, value] of map) &#123; console.log(key, value)&#125;// &#123;a: 1&#125; &#x27;a&#x27;// &#123;a: 2&#125; &#x27;b&#x27;for (let key of map.keys()) &#123; console.log(key)&#125;// &#123;a: 1&#125;// &#123;a: 2&#125; WeakMap 类似于 Map 的结构，但是键必须是对象的弱引用，注意弱引用的是键名而不是键值，因而 WeakMap 是不能被迭代的； 12345let wm = new WeakMap()let foo = &#123; name: &#x27;foo&#x27; &#125;wm.set(foo, &#x27;a&#x27;) // Weakwm.get(foo) // &#x27;a&#x27;wm.has(foo) // true 虽然 wm 的键对 foo 对象有引用，但是丝毫不会阻止 foo 对象被 GC 回收。当引用对象 foo 被垃圾回收之后，wm 的 foo 键值对也会自动移除，所以不用手动删除引用。 实例方法： WeakMap.prototype.delete(key)：移除 key 的关联对象； WeakMap.prototype.get(key)：返回 key 关联对象, 或者 undefined(没有 key 关联对象时)； WeakMap.prototype.has(key)：根据是否有 key 关联对象返回一个 Boolean 值； WeakMap.prototype.set(key, value)：在 WeakMap 中设置一组 key 关联对象，返回这个 WeakMap 对象； Proxy Proxy 用来定义基本操作的的自定义行为，可以理解为当对目标对象 target 进行某个操作之前会先进行拦截（执行 handler 里定义的方法），必须要对 Proxy 实例进行操作才能触发拦截，对目标对象操作是不会拦截的，可以通过如下方式定义一个代理实例 1234567891011let proxy = new Proxy(target, handler)let instance = new Proxy( &#123; name: &#x27;布兰&#x27; &#125;, &#123; get(target, propKey, receiver) &#123; return `hello, $&#123;target.name&#125;` &#125;, &#125;)instance.name // &#x27;hello, 布兰&#x27; 如果 handle 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上： 1234let target = &#123;&#125;let proxy = new Proxy(target, &#123;&#125;)proxy.name = &#x27;布兰&#x27;target.name // &#x27;布兰&#x27; 目标对象被 Proxy 代理的时候，内部的 this 会指向代理的实例： 123456789const target = &#123; m: function () &#123; console.log(this === proxy) &#125;,&#125;const handler = &#123;&#125;const proxy = new Proxy(target, handler)target.m() // falseproxy.m() // true 静态方法： Proxy.revocable() 用以定义一个可撤销的 Proxy： 12345678let target = &#123;&#125;let handler = &#123;&#125;let &#123; proxy, revoke &#125; = Proxy.revocable(target, handler)proxy.foo = 123proxy.foo // 123revoke()proxy.foo // TypeError handle 对象的方法： get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v或proxy[&#39;foo&#39;] = v，返回一个布尔值。 has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。 ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc)、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args)。 Reflect Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。 设计的目的： 将 Object 属于语言内部的方法放到 Reflect 上； 修改某些 Object 方法的返回结果，让其变得更合理； 让 Object 操作变成函数行为； Proxy handles 与 Reflect 方法一一对应，前者用于定义自定义行为，而后者用于恢复默认行为； 静态方法： Reflect.apply(target, thisArgument, argumentsList) 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似； Reflect.construct(target, argumentsList[, newTarget]) 对构造函数进行 new 操作，相当于执行 new target(...args)； Reflect.defineProperty(target, propertyKey, attributes) 和 Object.defineProperty() 类似。如果设置成功就会返回 true； Reflect.deleteProperty(target, propertyKey) 作为函数的 delete 操作符，相当于执行 delete target[name]； Reflect.get(target, propertyKey[, receiver]) 获取对象身上某个属性的值，类似于 target[name]； Reflect.getOwnPropertyDescriptor(target, propertyKey) 类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符, 否则返回 undefined； Reflect.getPrototypeOf(target) 类似于 Object.getPrototypeOf()； Reflect.has(target, propertyKey) 判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同； Reflect.isExtensible(target) 类似于 Object.isExtensible()； Reflect.ownKeys(target) 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受 enumerable 影响)； Reflect.preventExtensions(target) 类似于 Object.preventExtensions()。返回一个 Boolean； Reflect.set(target, propertyKey, value[, receiver]) 将值分配给属性的函数。返回一个 Boolean，如果更新成功，则返回 true； Reflect.setPrototypeOf(target, prototype) 设置对象原型的函数. 返回一个 Boolean， 如果更新成功，则返回 true； Class 可以用 class 关键字来定义一个类，类是对一类具有共同特征的事物的抽象，就比如可以把小狗定义为一个类，小狗有名字会叫也会跳；类是特殊的函数，就像函数定义的时候有函数声明和函数表达式一样，类的定义也有类声明和类表达式，不过类声明不同于函数声明，它是无法提升的；类也有 name 属性 123456789101112131415// 类声明class Dog &#123; constructor(name) &#123; this.name = name &#125; bark() &#123;&#125; jump() &#123;&#125;&#125;Dog.name // &#x27;Dog&#x27;// 类表达式：可以命名（类的 name 属性取类名），也可以不命名（类的 name 属性取变量名）let Animal2 = class &#123; // xxx&#125;Animal2.name // &#x27;Animal2&#x27; JS 中的类建立在原型的基础上（通过函数来模拟类，其实类就是构造函数的语法糖），和 ES5 中构造函数类似，但是也有区别，比如类的内部方法是不可被迭代的： 123456789101112131415class Dog &#123; constructor() &#123;&#125; bark() &#123;&#125; jump() &#123;&#125;&#125;Object.keys(Dog.prototype) // []// 类似于function Dog2() &#123;&#125;Dog2.prototype = &#123; constructor() &#123;&#125;, bark() &#123;&#125;, jump() &#123;&#125;,&#125;Object.keys(Dog2.prototype) // [&#x27;constructor&#x27;, &#x27;bark&#x27;, &#x27;jump&#x27;] 基于原型给类添加新方法： 123Object.assign(Dog.prototype, &#123; wag() &#123;&#125;, // 摇尾巴&#125;) 类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，getter和 setter 都在严格模式下执行。 类内部的 this 默认指向类实例，所以如果直接调用原型方法或者静态方法会导致 this 指向运行时的环境，而类内部是严格模式，所以此时的 this 会是 undefined： 12345678910111213141516class Dog &#123; constructor(name) &#123; this.name = name &#125; bark() &#123; console.log(`$&#123;this.name&#125; is bark.`) &#125; static jump() &#123; console.log(`$&#123;this.name&#125; is jump.`) &#125;&#125;let dog = new Dog(&#x27;大黄&#x27;)let &#123; bark &#125; = doglet &#123; jump &#125; = Dogbark() // TypeError: Cannot read property &#x27;name&#x27; of undefinedjump() // TypeError: Cannot read property &#x27;name&#x27; of undefined 方法和关键字： constructor 方法是类的默认方法，通过 new 关键字生成实例的时候，会自动调用；一个类必须有constructor 方法，如果没有显示定义，则会自动添加一个空的；constructor 默认会返回实例对象： 123456class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 通过 get 和 set 关键字拦截某个属性的读写操作： 12345678class Dog &#123; get age() &#123; return 1 &#125; set age(val) &#123; this.age = val &#125;&#125; 用 static 关键字给类定义静态方法，静态方法不会存在类的原型上，所以不能通过类实例调用，只能通过类名来调用，静态方法和原型方法可以同名： 12345678910111213class Dog &#123; bark() &#123;&#125; jump() &#123; console.log(&#x27;原型方法&#x27;) &#125; static jump() &#123; console.log(&#x27;静态方法&#x27;) &#125;&#125;Object.getOwnPropertyNames(Dog.prototype) // [&#x27;constructor&#x27;, &#x27;bark&#x27;, &#x27;jump&#x27;]Dog.jump() // &#x27;静态方法&#x27;let dog = new Dog()dog.jump() // &#x27;原型方法&#x27; 公有字段和私有字段： 静态公有字段和静态方法一样只能通过类名调用；私有属性和私有方法只能在类的内部调用，外部调用将报错： 123456789101112class Dog &#123; age = 12 // 公有字段 static sex = &#x27;male&#x27; // 静态公有字段 #secret = &#x27;我是人类的好朋友&#x27; // 私有字段 #getSecret() &#123; // 私有方法 return this.#secret &#125;&#125;Dog.sex // &#x27;male&#x27;let dog = new Dog()dog.#getSecret() // SyntaxError 公共和私有字段声明是 JavaScript 标准委员会 TC39 提出的实验性功能（第 3 阶段）。浏览器中的支持是有限的，但是可以通过 Babel 等系统构建后使用此功能。 new.target 属性允许你检测函数、构造方法或者类是否是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是 undefined，子类继承父类的时候会返回子类： 123456789101112class Dog &#123; constructor() &#123; console.log(new.target.name) &#125;&#125;function fn() &#123; if (!new.target) return &#x27;new target is undefined&#x27; console.log(&#x27;fn is called by new&#x27;)&#125;let dog = new Dog() // &#x27;Dog&#x27;fn() // &#x27;new target is undefined&#x27;new fn() // &#x27;fn is called by new&#x27; 类的继承： 类可以通过 extends 关键字实现继承，如果子类显示的定义了 constructor 则必须在内部调用 super() 方法，内部的 this 指向当前子类： 12345678910111213141516171819class Animal &#123; constructor(name) &#123; this.name = name &#125; run() &#123; console.log(`$&#123;this.name&#125; is running.`) &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name) // 必须调用 this.name = name &#125; bark() &#123; console.log(`$&#123;this.name&#125; is barking.`) &#125;&#125;let dog = new Dog(&#x27;大黄&#x27;)dog.run() // &#x27;大黄 is running.&#x27; 通过 super() 调用父类的构造函数或者通过 super 调用父类的原型方法；另外也可以在子类的静态方法里通过 super 调用父类的静态方法： 123456789101112131415// 基于上面的代码改造class Dog extends Animal&#123; constructor(name)&#123; super(name) // 调用父类构造函数 this.name = name &#125; bark() &#123; super.run() // 调用父类原型方法 console.log(`$&#123;this.name&#125; is barking.`) &#125;&#125;let dog = new Dog()dog.bark()s// &#x27;大黄 is running.&#x27;// &#x27;大黄 is barking.&#x27; 子类的 __proto__ 属性，表示构造函数的继承，总是指向父类；子类 prototype 属性的 __proto__ 属性，表示方法的继承，总是指向父类的 prototype 属性： 12345class Animal &#123;&#125;class Dog extends Animal &#123;&#125;Dog.__proto__ === Animal // trueDog.prototype.__proto__ === Animal.prototype // true 子类原型的原型指向父类的原型： 1234// 基于上面的代码let animal = new Animal()let dog = new Dog()dog.__proto__.__proto__ === animal.__proto__ // true 使用 extends 还可以实现继承原生的构造函数，如下这些构造函数都可以被继承： String() Number() Boolean() Array() Object() Function() Date() RegExp() Error() 12345678910111213class MyString extends String &#123; constructor(name) &#123; super(name) this.name = name &#125; welcome() &#123; return `hello $&#123;this.name&#125;` &#125;&#125;let ms = new MyString(&#x27;布兰&#x27;)ms.welcome() // &#x27;hello 布兰&#x27;ms.length // 2ms.indexOf(&#x27;兰&#x27;) // 1 Module 浏览器传统加载模块方式： 12345678// 同步加载&lt;script src=&quot;test.js&quot;&gt;&lt;/script&gt;// defer异步加载：顺序执行，文档解析完成后执行；&lt;script src=&quot;test.js&quot; defer&gt;&lt;/script&gt;// async异步加载：乱序加载，下载完就执行。&lt;script src=&quot;test.js&quot; async&gt;&lt;/script&gt; 浏览器现在可以按照模块（加上 type=&quot;module&quot;）来加载脚本，默认将按照 defer 的方式异步加载；ES6 的模块加载依赖于 import 和 export 这 2 个命令；模块内部自动采用严格模式： 12// 模块加载&lt;script type=&quot;module&quot; src=&quot;test.js&quot;&gt;&lt;/script&gt; export 用于输出模块的对外接口，一个模块内只能允许一个 export default 存在，以下是几种输出模块接口的写法： 123456789101112131415161718// person.js// 写法一：单独导出export const name = &#x27;布兰&#x27;export const age = 12// 写法二：按需导出const name = &#x27;布兰&#x27;, age = 12export &#123; name, age &#125;// 写法三：重命名后导出const name = &#x27;布兰&#x27;, age = 12export &#123; name as name1, age as age1 &#125;// 写法四：默认导出const name = &#x27;布兰&#x27;export default name import 用于输入其他模块的接口： 1234567891011121314// 按需导入import &#123; name, age &#125; &#x27;./person.js&#x27;// 导入后重命名import &#123; name1 as name, age1 as age &#125; from &#x27;./person.js&#x27;// 默认导入import person from &#x27;./person.js&#x27;// 整体导入import * as person from &#x27;./person.js&#x27;// 混合导入import _, &#123; each &#125; from &#x27;lodash&#x27; import 导入的细节： 导入的变量名必须与导出模块的名字一致，可以使用 as 进行重命名； 导入的变量都是只读的，不能改写； import 命令具有提升效果，会提升到整个模块的头部，首先执行； import 是编译时导入，所以不能将其写到代码块（比如 if 判断块里）或者函数内部； import 会执行所加载的模块的代码，如果重复导入同一个模块则只会执行一次模块； import 和 export 的复合写法：export 和 import 语句可以结合在一起写成一行，相当于是在当前模块直接转发外部模块的接口，复合写法也支持用 as 重命名。以下例子中需要在 hub.js 模块中转发 person.js 的接口： 1234567891011121314151617// person.jsconst name = &#x27;布兰&#x27;, age = 12export &#123; name, age &#125;// 按需转发接口（中转模块：hub.js）export &#123; name, age &#125; from &#x27;./person.js&#x27;// 相当于import &#123; name, age &#125; from &#x27;./person.js&#x27;export &#123; name, age &#125;// person.jsconst name = &#x27;布兰&#x27;, age = 12export default &#123; name, age &#125;// 转发默认接口（中转模块：hub.js）export &#123; default &#125; from &#x27;./person.js&#x27;// 相当于import person from &#x27;./person.js&#x27;export default person ES6 模块和 CommonJS 模块的差异： CommonJS 模块输出的是一个值的拷贝（一旦输出一个值，模块内部的变化就影响不到这个值），ES6 模块输出的是值的引用（是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值）； CommonJS 模块是运行时加载，ES6 模块是编译时输出接口； CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段； Iterator 和 for…of Iterator 迭代器协议，为各种数据结构提供了一种统一按照某种顺序进行访问的机制。通常部署在一个可迭代数据结构内部或其原型上。一个对象要能够成为迭代器，它必须有一个 next() 方法，每次执行 next() 方法会返回一个对象，这个对象包含了一个 done 属性（是个布尔值，true 表示可以继续下次迭代）和一个 value 属性（每次迭代的值）： 1234567891011121314// 生成一个迭代器let makeIterator = (arr) =&gt; &#123; let index = 0 return &#123; next() &#123; return index &lt; arr.length ? &#123; value: arr[index++], done: false, &#125; : &#123; done: true &#125; &#125;, &#125;&#125; iterable 可迭代数据结构：内部或者原型上必须有一个 Symbol.iterator 属性（如果是异步的则是 Symbol.asyncIterator），这个属性是一个函数，执行后会生成一个迭代器： 1234567891011121314151617let obj = &#123; [Symbol.iterator]() &#123; return &#123; index: 0, next() &#123; if (this.index &lt; 3) &#123; return &#123; value: this.index++, done: false &#125; &#125; else &#123; return &#123; done: true &#125; &#125; &#125;, &#125; &#125;,&#125;for (let x of obj) &#123; console.log(x) // 0 1 2&#125; 内置的一些可迭代数据结构有：String、Array、TypedArray、Map 和 Set、arguments、NodeList： 12345let si = &#x27;hi&#x27;[Symbol.iterator]()si // StringIteratorsi.next() // &#123;value: &#x27;h&#x27;, done: false&#125;si.next() // &#123;value: &#x27;i&#x27;, done: false&#125;si.next() // &#123;value: undefined, done: true&#125; for...of：用于遍历可迭代数据结构： 遍历字符串：for...in 获取索引，for...of 获取值； 遍历数组：for...in 获取索引，for...of 获取值； 遍历对象：for...in 获取键，for...of 需自行部署 [Symbol.iterator] 接口； 遍历 Set：for...of 获取值， for (const v of set)； 遍历 Map：for...of 获取键值对，for (const [k, v] of map)； 遍历类数组：包含 length 的对象、arguments 对象、NodeList对象(无 Iterator 接口的类数组可用 Array.from() 转换)； 123456789101112131415161718192021222324// 迭代字符串for (let x of &#x27;abc&#x27;) &#123; console.log(x) // &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;&#125;// 迭代数组for (let x of [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]) &#123; console.log(x) // &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;&#125;// 遍历 Setlet set = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])for (let x of set) &#123; console.log(x) // &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;&#125;// 遍历 Maplet map = new Map([ [&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12],])for (let [key, value] of map) &#123; console.log(key + &#x27;: &#x27; + value) // &#x27;name: 布兰&#x27; &#x27;age: 12&#x27;&#125; for...of 和 for...in 对比 共同点：能够通过 break、continue 和 return 跳出循环；不同点： for...in 的特点：只能遍历键，会遍历原型上属性，遍历无顺序，适合于对象的遍历； for...of 的特点：能够遍历值（某些数据结构能遍历键和值，比如 Map），不会遍历原型上的键值，遍历顺序为数据的添加顺序，适用于遍历可迭代数据结构； PromisePromise 这块知识可以直接看我之前写的一篇文章：深入理解 Promise 非常完整。 Generator function* 会定义一个生成器函数，调用生成器函数不会立即执行，而是会返回一个 Generator 对象，这个对象是符合可迭代协议和迭代器协议的，换句话说这个 Generator 是可以被迭代的。 生成器函数内部通过 yield 来控制暂停，而 next() 将把它恢复执行，它的运行逻辑是如下这样的： 遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值作为返回的对象的 value 属性值； 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式； 如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值； 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined； 123456789function* gen() &#123; yield &#x27;hello&#x27; yield &#x27;world&#x27; return &#x27;end&#x27;&#125;let g = gen()g.next() // &#123;value: &#x27;hello&#x27;, done: false&#125;g.next() // &#123;value: &#x27;world&#x27;, done: false&#125;g.next() // &#123;value: &#x27;end&#x27;, done: true&#125; 在生成器函数内部可以使用 yield* 表达式委托给另一个 Generator 或可迭代对象，比如数组、字符串等；yield* 表达式本身的值是当迭代器关闭时返回的值（即 done 为 true 时）： 123456789101112function* inner() &#123; yield* [1, 2] return &#x27;foo&#x27;&#125;function* gen() &#123; let result = yield* inner() console.log(result)&#125;let g = gen()g.next()g.next()g.next() 实例方法： Generator.prototype.next()：返回一个包含属性 done 和 value 的对象。该方法也可以通过接受一个参数用以向生成器传值。如果传入了参数，那么这个参数会传给上一条执行的 yield 语句左边的变量： 123456789101112131415function* f() &#123; let a = yield 12 console.log(a) let b = yield a console.log(b)&#125;let g = f()console.log(g.next(&#x27;a&#x27;))console.log(g.next(&#x27;b&#x27;))console.log(g.next(&#x27;c&#x27;))// &#123;value: 12, done: false&#125;// &#x27;b&#x27;// &#123;value: &#x27;b&#x27;, done: false&#125;// &#x27;c&#x27;// &#123;value: undefined, done: true&#125; Generator.prototype.throw()：用来向生成器抛出异常，如果内部捕获了则会恢复生成器的执行（即执行下一条 yield 表达式），并且返回带有 done 及 value 两个属性的对象： 1234567891011121314151617function* gen() &#123; try &#123; yield &#x27;a&#x27; &#125; catch(e) &#123; console.log(e) &#125; yiele &#x27;b&#x27; yield &#x27;c&#x27;&#125;let g = gen()g.next()g.throw(&#x27;error a&#x27;)g.next()// &#123;value: &quot;a&quot;, done: false&#125;// &#x27;error a&#x27;// &#123;value: &quot;b&quot;, done: false&#125;// &#123;value: &quot;c&quot;, done: false&#125; 如果内部没有捕获异常，将中断内部代码的继续执行（类似 throw 抛出的异常，如果没有捕获，则后面的代码将不会执行），此时异常会抛到外部，可以被外部的 try...catch 块捕获，此时如果再执行一次 next()，会返回一个值为 done 属性为 true 的对象： 12345678910111213141516function* gen() &#123; yield &#x27;a&#x27; yield &#x27;b&#x27; yield &#x27;c&#x27;&#125;let g = gen()g.next()try &#123; g.throw(&#x27;error a&#x27;)&#125; catch (e) &#123; console.log(e)&#125;g.next()// &#123;value: &quot;a&quot;, done: false&#125;// &#x27;error a&#x27;// &#123;value: undefined, done: true&#125; Generator.prototype.return()：返回给定的值并结束生成器： 123456789function* gen() &#123; yield 1 yield 2 yield 3&#125;let g = gen()g.next() // &#123; value: 1, done: false &#125;g.return(&#x27;foo&#x27;) // &#123; value: &quot;foo&quot;, done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 应用： 将异步操作同步化，比如同时有多个请求，多个请求之间是有顺序的，只能等前面的请求完成了才请求后面的： 1234567891011121314151617function* main() &#123; let res1 = yield request(&#x27;a&#x27;) console.log(res1) let res2 = yield request(&#x27;b&#x27;) console.log(res2) let res3 = yield request(&#x27;c&#x27;) console.log(res3)&#125;function request(url) &#123; setTimeout(function () &#123; // 模拟异步请求 it.next(url) &#125;, 300)&#125;let it = main()it.next()// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; 给对象部署 Iterator 接口： 12345678910111213function* iterEntries(obj) &#123; let keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; let key = keys[i] yield [key, obj[key]] &#125;&#125;let obj = &#123; foo: 3, bar: 7 &#125;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value)&#125;// &#x27;foo&#x27; 3// &#x27;bar&#x27; 7 ES2016 Array.prototype.includes判断一个数组是否包含某个元素，之前一般是这么做的： 123456if (arr.indexOf(el) &gt;= 0) &#123;&#125;// 或者if (~arr.indexOf(el)) &#123;&#125; 而现在你可以这么做了： 12if (arr.includes(el)) &#123;&#125; indexOf 会返回找到元素在数组中的索引位置，判断的逻辑是是否严格相等，所以他在遇到 NaN 的时候不能正确返回索引，但是 includes 解决了这个问题： 123;[1, NaN, 3] .indexOf(NaN) // -1 [(1, NaN, 3)].includes(NaN) // true 求幂运算符（**）x ** y 是求 x 的 y 次幂，和 Math.pow(x, y) 功能一致： 123// x ** ylet squared = 2 ** 2 // 2 * 2 = 4let cubed = 2 ** 3 // 2 * 2 * 2 = 8 x **= y 表示求 x 的 y 次幂，并且把结果赋值给 x： 123// x **= ylet x = 2x **= 3 // x 最后等于 8 ES2017 Object.values()返回一个由对象自身所有可遍历属性的属性值组成的数组： 123456789const person = &#123; name: &#x27;布兰&#x27; &#125;Object.defineProperty(person, &#x27;age&#x27;, &#123; value: 12, enumrable: false, // age 属性将不可遍历&#125;)console.log(Object.values(person)) // [&#x27;布兰&#x27;]// 类似 str.split(&#x27;&#x27;) 效果console.log(Object.values(&#x27;abc&#x27;)) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] Object.entries()返回一个由对象自身所有可遍历属性的键值对组成的数组： 12const person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;console.log(Object.entries(person)) // [[&quot;name&quot;, &quot;布兰&quot;], [&quot;age&quot;, 12]] 利用这个方法可以很好的将对象转成正在的 Map 结构： 123const person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;const map = new Map(Object.entries(person))console.log(map) // Map &#123; name: &#x27;布兰&#x27;, age: 12 &#125; Object.getOwnPropertyDescriptors()Object.getOwnPropertyDescriptor() 会返回指定对象某个自身属性的的描述对象，而 Object.getOwnPropertyDescriptors() 则是返回指定对象自身所有属性的描述对象： 12345678910const person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;console.log(Object.getOwnPropertyDescriptor(person, &#x27;name&#x27;))// &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;console.log(Object.getOwnPropertyDescriptors(person))//&#123;// name: &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;,// age: &#123;configurable: false, enumerable: false, value: 12, writable: false&#125;//&#125; 配合 Object.create() 可以实现浅克隆： 12345const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ) String.prototype.padStart()str.padStart(length [, padStr]) 会返回一个新字符串，该字符串将从 str 字符串的左侧开始填充某个字符串 padStr（非必填，如果不是字符串则会转成字符串, 传入 undefined 和不传这个参数效果一致）直到达到指定位数 length 为止： 12345&#x27;abc&#x27;.padStart(5, 2) // &#x27;22abc&#x27;&#x27;abc&#x27;.padStart(5, undefined) // &#x27; abc&#x27;&#x27;abc&#x27;.padStart(5, &#123;&#125;) // &#x27;[oabc&#x27;&#x27;abc&#x27;.padStart(5) // &#x27; abc&#x27;&#x27;abcde&#x27;.padStart(2, &#x27;f&#x27;) // &#x27;abcde&#x27; String.prototype.padEnd()规则和 padStart 类似，但是是从字符串右侧开始填充： 1&#x27;abc&#x27;.padEnd(5, 2) // &#x27;abc22&#x27; 函数参数尾逗号允许函数在定义和调用的时候时候最后一个参数后加上逗号： 123function init(param1, param2) &#123;&#125;init(&#x27;a&#x27;, &#x27;b&#x27;) Async 函数 使用 async 可以声明一个 async 函数，结合 await 可以用一种很简介的方法写成基于 Promise 的异步行为，而不需要刻意的链式调用。await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 Promise 的异步操作被兑现或被拒绝之后才会恢复进程。async 函数有如下几种定义形式： 123456789101112131415161718// 函数声明async function foo() &#123;&#125;// 函数表达式let foo = async function() &#123;&#125;// 箭头函数let foo = async () =&gt; &#123;&#125;// 对象方法lef obj = &#123; async foo() &#123;&#125;&#125;// 类方法class Dog &#123; async bark() &#123;&#125;&#125; async 函数一定会返回一个 Promise 对象，所以它可以使用 then 添加处理函数。如果一个 async 函数的返回值看起来不是Promise，那么它将会被隐式地包装在一个 Promise 中： 123456async function foo() &#123; return &#x27;a&#x27;&#125;foo().then((res) =&gt; &#123; console.log(res) // &#x27;a&#x27;&#125;) 内部如果发生错误，或者显示抛出错误，那么 async 函数会返回一个 rejected 状态的 Promsie： 123456async function foo() &#123; throw new Error(&#x27;error&#x27;)&#125;foo().catch((err) =&gt; &#123; console.log(err) // Error: error&#125;) 返回的 Promise 对象必须等到内部所有 await 命令 Promise 对象执行完才会发生状态改变，除非遇到 return 语句或抛出错误；任何一个 await 命令返回的 Promise 对象变 为rejected 状态，整个 Async 函数都会中断后续执行： 12345678910111213141516async function fn() &#123; let a = await Promise.resolve(&#x27;success&#x27;) console.log(&#x27;a_&#x27; + a) let b = await Promise.reject(&#x27;fail&#x27;) console.log(&#x27;b_&#x27; + b) // 不会执行&#125;fn().then( (res) =&gt; &#123; console.log(res) // 不会执行 &#125;, (err) =&gt; &#123; console.log(err) &#125;)// &#x27;a_success&#x27;// &#x27;fail&#x27; 所以为了保证 async 里的异步操作都能完成，我们需要将他们放到 try...catch() 块里或者在 await 返回的 Promise 后跟一个 catch 处理函数： 1234567891011121314151617181920async function fn() &#123; try &#123; let a = await Promise.reject(&#x27;a fail&#x27;) console.log(&#x27;a_&#x27; + a) // 不会执行 &#125; catch (e) &#123; console.log(e) // &#x27;a fail&#x27; &#125; let b = await Promise.reject(&#x27;b fail&#x27;).catch((e) =&gt; &#123; console.log(e) // &#x27;b fail&#x27; &#125;) console.log(&#x27;b_&#x27; + b) // &#x27;bundefined&#x27;&#125;fn().then( (res) =&gt; &#123; console.log(res) // undefined &#125;, (err) =&gt; &#123; console.log(err) // 不会执行 &#125;) 如果 async 函数里的多个异步操作之间没有依赖关系，建议将他们写到一起减少执行时间： 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()])// 写法二let fooPromise = getFoo()let barPromise = getBar()let foo = await fooPromiselet bar = await barPromise await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。 共享内存和 Atomics 对象 SharedArrayBuffer Atomics ES2018 Promise.prototype.finally()Promise.prototype.finally() 用于给 Promise 对象添加 onFinally 函数，这个函数主要是做一些清理的工作，只有状态变化的时候才会执行该 onFinally 函数。 1234function onFinally() &#123; console.log(888) // 并不会执行&#125;new Promise((resolve, reject) =&gt; &#123;&#125;).finally(onFinally) finally() 会生成一个 Promise 新实例，finally 一般会原样后传父 Promise，无论父级实例是什么状态： 123456789let p1 = new Promise(() =&gt; &#123;&#125;)let p2 = p1.finally(() =&gt; &#123;&#125;)setTimeout(console.log, 0, p2) // Promise &#123;&lt;pending&gt;&#125;let p3 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p4 = p3.finally(() =&gt; &#123;&#125;)setTimeout(console.log, 0, p3) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 上面说的是一般，但是也有特殊情况，比如 finally 里返回了一个非 fulfilled 的 Promise 或者抛出了异常的时候，则会返回对应状态的新实例： 12345678910111213let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;))setTimeout(console.log, 0, p2) // Promise &#123;&lt;pending&gt;&#125;let p3 = p1.finally(() =&gt; Promise.reject(6))setTimeout(console.log, 0, p3) // Promise &#123;&lt;rejected&gt;: 6&#125;let p4 = p1.finally(() =&gt; &#123; throw new Error(&#x27;error&#x27;)&#125;)setTimeout(console.log, 0, p4) // Promise &#123;&lt;rejected&gt;: Error: error&#125; 参考：深入理解 Promise 异步迭代器想要了解异步迭代器最好的方式就是和同步迭代器进行对比。我们知道可迭代数据的内部都是有一个 Symbol.iterator 属性，它是一个函数，执行后会返回一个迭代器对象，这个迭代器对象有一个 next() 方法可以对数据进行迭代，next() 执行后会返回一个对象，包含了当前迭代值 value 和 标识是否完成迭代的 done 属性： 1234let iterator = [1, 2][Symbol.iterator]()iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: undefinde, done: true &#125; 上面这里的 next() 执行的是同步操作，所以这个是同步迭代器，但是如果 next() 里需要执行异步操作，那就需要异步迭代了，可异步迭代数据的内部有一个 Symbol.asyncIterator 属性，基于此我们来实现一个异步迭代器： 12345678910111213141516171819class Emitter &#123; constructor(iterable) &#123; this.data = iterable &#125; [Symbol.asyncIterator]() &#123; let length = this.data.length, index = 0 return &#123; next: () =&gt; &#123; const done = index &gt;= length const value = !done ? this.data[index++] : undefined return new Promise((resolve, reject) =&gt; &#123; resolve(&#123; value, done &#125;) &#125;) &#125;, &#125; &#125;&#125; 异步迭代器的 next() 会进行异步的操作，通常是返回一个 Promise，所以需要对应的处理函数去处理结果： 1234567891011let emitter = new Emitter([1, 2, 3])let asyncIterator = emitter[Symbol.asyncIterator]()asyncIterator.next().then((res) =&gt; &#123; console.log(res) // &#123; value: 1, done: false &#125;&#125;)asyncIterator.next().then((res) =&gt; &#123; console.log(res) // &#123; value: 2, done: false &#125;&#125;)asyncIterator.next().then((res) =&gt; &#123; console.log(res) // &#123; value: 3, done: false &#125;&#125;) 另外也可以使用 for await...of 来迭代异步可迭代数据： 12345678let asyncIterable = new Emitter([1, 2, 3])async function asyncCount() &#123; for await (const x of asyncIterable) &#123; console.log(x) &#125;&#125;asyncCount()// 1 2 3 另外还可以通过异步生成器来创建异步迭代器： 12345678910111213141516171819202122class Emitter &#123; constructor(iterable) &#123; this.data = iterable &#125; async *[Symbol.asyncIterator]() &#123; let length = this.data.length, index = 0 while (index &lt; length) &#123; yield this.data[index++] &#125; &#125;&#125;async function asyncCount() &#123; let emitter = new Emitter([1, 2, 3]) const asyncIterable = emitter[Symbol.asyncIterator]() for await (const x of asyncIterable) &#123; console.log(x) &#125;&#125;asyncCount()// 1 2 3 参考： Iteration_protocols for-await…of s 修饰符(dotAll 模式)正则表达式新增了一个 s 修饰符，使得 . 可以匹配任意单个字符： 123;/foo.bar/.test(&#x27;foo\\nbar&#x27;) / // false foo.bar / s.test(&#x27;foo\\nbar&#x27;) // true 上面这又被称为 dotAll 模式，表示点（dot）代表一切字符。所以，正则表达式还引入了一个 dotAll 属性，返回一个布尔值，表示该正则表达式是否处在 dotAll 模式： 1;/foo.bar/s.dotAll // true 具名组匹配正则表达式可以使用捕获组来匹配字符串，但是想要获取某个组的结果只能通过对应的索引来获取： 123456let re = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/let result = re.exec(&#x27;2015-01-02&#x27;)// result[0] === &#x27;2015-01-02&#x27;// result[1] === &#x27;2015&#x27;// result[2] === &#x27;01&#x27;// result[3] === &#x27;02&#x27; 而现在我们可以通过给捕获组 (?&lt;name&gt;...) 加上名字 name ，通过名字来获取对应组的结果： 12345let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/let result = re.exec(&#x27;2015-01-02&#x27;)// result.groups.year === &#x27;2015&#x27;// result.groups.month === &#x27;01&#x27;// result.groups.day === &#x27;02&#x27; 配合解构赋值可以写出非常精简的代码： 1234let &#123; groups: &#123; year, month, day &#125;,&#125; = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/.exec(&#x27;2015-01-02&#x27;)console.log(year, month, day) // 2015 01 02 具名组也可以通过传递给 String.prototype.replace 的替换值中进行引用。如果该值为字符串，则可以使用 $&lt;name&gt; 获取到对应组的结果： 123let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/let result = &#x27;2015-01-02&#x27;.replace(re, &#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;)// result === &#x27;02/01/2015&#x27; 参考：proposal-regexp-named-groups 后行断言后行断言： (?&lt;=y)x，x 只有在 y 后面才能匹配： 1;/(?&lt;=\\$)\\d+/.exec(&#x27;I have $100.&#x27;) // [&#x27;100&#x27;] 后行否定断言： (?&lt;!y)x，x 只有不在 y 后面才能匹配： 1;/(?&lt;!\\$)\\d+/.exec(&#x27;I have $100.&#x27;) // [&#x27;00&#x27;] Unicode 属性转义允许正则表达式匹配符合 Unicode 某种属性的所有字符，\\p&#123;...&#125; 是匹配包含，\\P&#123;...&#125; 是匹配不包含的字符，且必须搭配 /u 修饰符才会生效： 12/\\p&#123;Emoji&#125;+/u.exec(&#x27;😁😭笑死我了🤣😂不行了&#x27;) // [&#x27;😁😭&#x27;]/\\P&#123;Emoji&#125;+/u.exec(&#x27;😁😭笑死我了🤣😂不行了&#x27;) // [&#x27;笑死我了&#x27;] 这里可以查询到更多的 Unicode 的属性 Full_Properties 对象扩展运算符对象的扩展运算符可以用到解构赋值上，且只能应用到最后一个变量上： 12let &#123; x, ...y &#125; = &#123; x: 1, a: 2, b: 3 &#125;console.log(y) // &#123;a: 2, b: 3&#125; 对象扩展运算符不能解构原型上的属性： 1234let obj = &#123; x: 1 &#125;obj.__proto__ = &#123; y: 2 &#125;let &#123; ...a &#125; = objconsole.log(a.y) // undefined 应用一：可以实现浅拷贝，但是不会拷贝原始属性： 123456789101112let person = Object.create(&#123; name: &#x27;布兰&#x27; &#125;)person.age = 12// 浅拷贝写法一let &#123; ...pClone1 &#125; = personconsole.log(pClone1) // &#123; age: 12 &#125;console.log(pClone1.name) // undefined// 浅拷贝写法二let pClone2 = &#123; ...person &#125;console.log(pClone2) // &#123; age: 12 &#125;console.log(pClone2.name) // undefined 应用二：合并两个对象： 1234let ab = &#123; ...a, ...b &#125;// 等同于let ab = Object.assign(&#123;&#125;, a, b) 应用三：重写对象属性 1let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125; 应用四：给新对象设置默认值 1let aWithDefaults = &#123; x: 1, y: 2, ...a &#125; 应用五：利用扩展运算符的解构赋值可以扩展函数参数： 123456function baseFunction(&#123; a, b &#125;) &#123;&#125;function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123; // 使用 x 和 y 参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig)&#125; 参考： Object Spread Initializer Object Rest Destructuring 放松对标签模板里字符串转义的限制ECMAScript 6 入门 ES2019 允许省略 catch 里的参数异常被捕获的时候如果不需要做操作，甚至可以省略 catch(err) 里的参数和圆括号： 12try &#123;&#125; catch &#123;&#125; JSON.stringify()变动UTF-8 标准规定，0xD800 到 0xDFFF 之间的码点，不能单独使用，必须配对使用。所以 JSON.stringify() 对单个码点进行操作，如果码点符合 UTF-8 标准，则会返回对应的字符，否则会返回对应的码点： 12JSON.stringify(&#x27;\\u&#123;1f600&#125;&#x27;) // &quot;&quot;😀&quot;&quot;JSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;&quot;\\ud834&quot;&quot; Symbol.prototype.descriptionSymbol 实例新增了一个描述属性 description： 12let symbol = Symbol(&#x27;foo&#x27;)symbol.description // &#x27;foo&#x27; Function.prototype.toString()函数的 toString() 会原样输出函数定义时候的样子，不会省略注释和空格。 Object.fromEntries()Object.fromEntries() 方法是 Object.entries() 的逆操作，用于将一个键值对数组转为对象： 123let person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;let keyValueArr = Object.entries(person) // [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]let obj = Object.fromEntries(arr) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 常用可迭代数据结构之间的装换： 12345678910111213141516let person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;// 对象 -&gt; 键值对数组let keyValueArr = Object.entries(person) // [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]// 键值对数组 -&gt; Maplet map = new Map(keyValueArr) // Map &#123;&quot;name&quot;: &quot;布兰&quot;, &quot;age&quot;: 12&#125;// Map -&gt; 键值对数组let arr = Array.from(map) // [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]// 键值对数组 -&gt; 对象let obj = Array.from(arr).reduce( (acc, [key, val]) =&gt; Object.assign(acc, &#123; [key]: val &#125;), &#123;&#125;) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 参考：Object.fromEntries 字符串可直接输入行分隔符和段分隔符JavaScript 规定有 5 个字符，不能在字符串里面直接使用，只能使用转义形式。 U+005C：反斜杠（reverse solidus) U+000D：回车（carriage return） U+2028：行分隔符（line separator） U+2029：段分隔符（paragraph separator） U+000A：换行符（line feed） 但是由于 JSON 允许字符串里可以使用 U+2028 和 U+2029，所以使得 JSON.parse() 去解析字符串的时候可能会报错，所以 ES2019 允许模板字符串里可以直接这两个字符： 123JSON.parse(&#x27;&quot;\\u2028&quot;&#x27;) // &quot;&quot;JSON.parse(&#x27;&quot;\\u2029&quot;&#x27;) // &quot;&quot;JSON.parse(&#x27;&quot;\\u005C&quot;&#x27;) // SyntaxError String.prototype.trimStart消除字符串头部空格，返回一个新字符串；浏览器还额外增加了它的别名函数 trimLeft()： 1234let str = &#x27; hello world &#x27;let newStr = str.trimStart()console.log(newStr, newStr === str)// &#x27;hello world &#x27; false String.prototype.trimEnd消除字符串尾部空格，返回一个新字符串；浏览器还额外增加了它的别名函数 trimRight()： 1234let str = &#x27; hello world &#x27;let newStr = str.trimEnd()console.log(newStr, newStr === str)// &#x27; hello world&#x27; false Array.prototype.flat()arr.flat(depth) 按照 depth （不传值的话默认是 1）深度拍平一个数组，并且将结果以新数组形式返回： 12345678// depth 默认是 1const arr1 = [1, 2, [3, 4]]console.log(arr1.flat()) // [1, 2, 3, 4]// 使用 Infinity，可展开任意深度的嵌套数组；自动跳过空数组；const arr2 = [1, , [2, [3, [4]]]]console.log(arr2.flat(Infinity))// [1, 2, 3, 4] 用 reduce 实现拍平一层数组： 12345678const arr = [1, 2, [3, 4]]// 方法一let newStr = arr.reduce((acc, cur) =&gt; acc.concat(cur), [])// 方法二const flattened = (arr) =&gt; [].concat(...arr)flattened(arr) 参考：flat Array.prototype.flatMap()flatMap(callback) 使用映射函数 callback 映射每个元素，callback 每次的返回值组成一个数组，并且将这个数组执行类似 arr.flat(1) 的操作进行拍平一层后最后返回结果： 1234const arr1 = [1, 2, 3, 4]arr1.flatMap((x) =&gt; [x * 2])// 将 [[2], [4], [6], [8]] 数组拍平一层得到最终结果：[2, 4, 6, 8] 参考：flatMap ES2020 String.prototype.matchAll()String.prototype.matchAll() 方法，可以一次性取出所有匹配。不过，它返回的是一个 RegExpStringIterator 迭代器同是也是一个可迭代的数据结构，所以可以通过 for...of 进行迭代： 12345678let str = &#x27;test1test2&#x27;let regexp = /t(e)(st(\\d?))/glet iterable = str.matchAll(regexp)for (const x of iterable) &#123; console.log(x)&#125;// [&#x27;test1&#x27;, &#x27;e&#x27;, &#x27;st1&#x27;, &#x27;1&#x27;, index: 0, input: &#x27;test1test1&#x27;, groups: undefined]// [&#x27;test2&#x27;, &#x27;e&#x27;, &#x27;st2&#x27;, &#x27;2&#x27;, index: 5, input: &#x27;test1test2&#x27;, groups: undefined] 注意当使用 matchAll(regexp) 的时候，正则表达式必须加上 /g 修饰符。 也可以将这个可迭代数据转成数组形式： 12345// 方法一;[...str.matchAll(regexp)]// 方法二Array.from(str.matchAll(regexp)) 动态 import()标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。 比如按需加载一个模块可以这样： 123if (xxx) &#123; import(&#x27;./module.js&#x27;)&#125; import() 是异步导入的，结果会返回一个 Promise： 123import(&#x27;/module.js&#x27;).then((module) =&gt; &#123; // Do something with the module.&#125;) 动态 import() 的应用场景挺多的，比如 Vue 中的路由懒加载就是使用的动态导入组件。另外由于动态性不便于静态分析工具和 tree-shaking 工作，所以不能滥用。 BigIntBigInt 是一种内置对象，它提供了一种方法来表示大于 $2^{53}$ - 1 的整数。这原本是 Javascript 中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数。 为了区分 Number，定义一个 BigInt 需要在整数后面加上一个 n，或者用函数直接定义： 12const num1 = 10nconst num2 = BigInt(20) Number 和 BigInt 之间能进行比较，但他们之间是宽松相等；且由于他们表示的是不同类型的数字，所以不能直接进行四则运算： 1234510n == 10 // true10n === 10 // false10n &gt; 8 // true10 + Number(10n) // 2010 + 10n // TypeError Promise.allSettledPromise.allSettled(iterable) 当所有的实例都已经 settled，即状态变化过了，那么将返回一个新实例，该新实例的内部值是由所有实例的值和状态组合成的数组，数组的每项是由每个实例的状态和内部值组成的对象。 12345678910111213141516171819202122232425function init() &#123; return 3&#125;let p1 = Promise.allSettled([ new Promise((resolve, reject) =&gt; &#123; resolve(9) &#125;).then((res) =&gt; &#123;&#125;), new Promise((resolve, reject) =&gt; &#123; reject(6) &#125;), init(),])let p2 = p1.then( (res) =&gt; &#123; console.log(res) &#125;, (err) =&gt; &#123; console.log(err) &#125;)// [// &#123;status: &quot;fulfilled&quot;, value: undefined&#125;,// &#123;status: &quot;rejected&quot;, reason: 6&#125;,// &#123;status: &quot;fulfilled&quot;, value: 3&#125;// ] 只要所有实例中包含一个 pending 状态的实例，那么 Promise.allSettled() 的结果为返回一个这样 Promise &#123;&lt;pending&gt;&#125; 的实例。 globalThis在以前，从不同的 JavaScript 环境中获取全局对象需要不同的语句。在 Web 中，可以通过 window、self 或者 frames 取到全局对象，但是在 Web Workers 中，只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。 而现在只需要使用 globalThis 即可获取到顶层对象，而不用担心环境问题。 12// 在浏览器中globalThis === window // true import.metaimport.meta 是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 URL，import.meta 必须在一个模块里使用： 123456// 没有声明 type=&quot;module&quot;，就使用 import.meta 会报错;&lt;script type=&quot;module&quot; src=&quot;./js/module.js&quot;&gt;&lt;/script&gt;// 在module.js里console.log(import.meta)// &#123;url: &quot;http://localhost/3ag/js/module.js&quot;&#125; 如果需要在配置了 Webpack 的项目，比如 Vue 里使用 import.meta 需要加一个包且配置一下参数，否则项目编译阶段会报错。 包配置详情参考：@open-wc/webpack-import-meta-loader 比如我用的是 4.x 版本的 vue-cli，那我需要在 vue.config.js 里配置： 12345678910module.exports = &#123; chainWebpack: (config) =&gt; &#123; config.module .rule(&#x27;js&#x27;) .test(/\\.js$/) .use(&#x27;@open-wc/webpack-import-meta-loader&#x27;) .loader(&#x27;@open-wc/webpack-import-meta-loader&#x27;) .end() &#125;,&#125; 可选链操作符（?.）通常我们获取一个深层对象的属性会需要写很多判断或者使用逻辑与 &amp;&amp; 操作符，因为对象的某个属性如果为 null 或者 undefined 就有可能报错： 12345678910111213141516let obj = &#123; first: &#123; second: &#x27;布兰&#x27;, &#125;,&#125;// 写法一let name1 = &#x27;&#x27;if (obj) &#123; if (obj.first) &#123; name1 = obj.first.second &#125;&#125;// 写法二let name2 = obj &amp;&amp; obj.first &amp;&amp; obj.first.second ?. 操作符允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。如果某个属性为 null 或者 undefined 则结果直接为 undefined。有了可选链操作符就可以使得表达式更加简明了，对于上面例子用可选链操作符可以这么写： 1let name3 = obj?.first?.second 空值合并操作符（??）对于逻辑或 || 运算符，当对运算符左侧的操作数进行装换为 Boolean 值的时候，如果为 true，则取左边的操作数为结果，否则取右边的操作数为结果： 12let name = &#x27;&#x27; || &#x27;布兰&#x27;console.log(name) // &#x27;布兰&#x27; 我们都知道 &#39;&#39;、0、null、undefined、false、NaN 等转成 Boolean 值的时候都是 false，所以都会取右边的操作数。这个时候如果要给变量设置默认值，如果遇到本身值就可能是 &#39;&#39; 或 0 的情况那就会出错了，会被错误的设置为默认值了。 而 ?? 操作符就是为了解决这个问题而出现的，x ?? y 只有左侧的操作数为 null 或 undefined 的时候才取右侧操作数，否则取左侧操作数： 12let num = 0 ?? 1console.log(num) // 0 ES2021 如下这几个提案已经确定了会在 2021 年发布，所以把他们归到 ES2021 中。 String.prototype.replaceAll之前需要替换一个字符串里的全部匹配字符可以这样做： 1234567const queryString = &#x27;q=query+string+parameters&#x27;// 方法一const withSpaces1 = queryString.replace(/\\+/g, &#x27; &#x27;)// 方法二const withSpaces2 = queryString.split(&#x27;+&#x27;).join(&#x27; &#x27;) 而现在只需要这么做： 1const withSpace3 = queryString.replaceAll(&#x27;+&#x27;, &#x27; &#x27;) replaceAll 的第一个参数可以是字符串也可以是正则表达式，当是正则表达式的时候，必须加上全局修饰符 /g，否则报错。 参考：string-replaceall Promise.any()Promsie.any() 和 Promise.all() 一样接受一个可迭代的对象，然后依据不同的入参会返回不同的新实例： 传一个空的可迭代对象或者可迭代对象所有 Promise 都是 rejected 状态的，则会抛出一个 AggregateError 类型的错误，同时返回一个 rejected 状态的新实例： 1234let p1 = Promise.any([])let p2.catch(err =&gt; &#123;&#125;)setTimeout(console.log, 0, p1)// Promise &#123;&lt;rejected&gt;: AggregateError: All promises were rejected&#125; 只要可迭代对象里包含任何一个 fulfilled 状态的 Promise，则会返回第一个 fulfilled 的实例，并且以它的值作为新实例的值： 12345678let p = Promise.any([ 1, Promise.reject(2), new Promise((resolve, reject) =&gt; &#123;&#125;), Promise.resolve(3),])setTimeout(console.log, 0, p)// Promise &#123;&lt;fulfilled&gt;: 1&#125; 其他情况下，都会返回一个 pending 状态的实例： 1234567let p = Promise.any([ Promise.reject(2), Promise.reject(3), new Promise((resolve, reject) =&gt; &#123;&#125;),])setTimeout(console.log, 0, p)// Promise &#123;&lt;pending&gt;: undefined&#125; WeakRef我们知道一个普通的引用（默认是强引用）会将与之对应的对象保存在内存中。只有当该对象没有任何的强引用时，JavaScript 引擎 GC 才会销毁该对象并且回收该对象所占的内存空间。 WeakRef 对象允许你保留对另一个对象的弱引用，而不会阻止被弱引用的对象被 GC 回收。WeakRef 的实例方法 deref() 可以返回当前实例的 WeakRef 对象所绑定的 target 对象，如果该 target 对象已被 GC 回收则返回 undefined： 1234let person = &#123; name: &#x27;布兰&#x27;, age: 12 &#125;let wr = new WeakRef(person)console.log(wr.deref())// &#123; name: &#x27;布兰&#x27;, age: 12 &#125; 正确使用 WeakRef 对象需要仔细的考虑，最好尽量避免使用。这里面有诸多原因，比如：GC 在一个 JavaScript 引擎中的行为有可能在另一个 JavaScript 引擎中的行为大相径庭，或者甚至在同一类引擎，不同版本中 GC 的行为都有可能有较大的差距。GC 目前还是 JavaScript 引擎实现者不断改进和改进解决方案的一个难题。 参考： WeakRef 内存管理 逻辑赋值符逻辑赋值符包含 3 个： x &amp;&amp;= y：逻辑与赋值符，相当于 x &amp;&amp; (x = y) x ||= y：逻辑或赋值符，相当于 x || (x = y) x ??= y：逻辑空赋值符，相当于 x ?? (x = y) 看如下示例，加深理解： 123456789let x = 0x &amp;&amp;= 1 // x: 0x ||= 1 // x: 1x ??= 2 // x: 1let y = 1y &amp;&amp;= 0 // y: 0y ||= null // y: nully ??= 2 // y: 2 数值分隔符（_）对于下面一串数字，你一眼看上去不确定它到底是多少吧？ 1const num = 1000000000 那现在呢？是不是可以很清楚的看出来它是 10 亿： 1const num = 1_000_000_000 数值分隔符（_）的作用就是为了让数值的可读性更强。除了能用于十进制，还可以用于二级制，十六进制甚至是 BigInt 类型： 123let binarary = 0b1010_0001_1000_0101let hex = 0xa0_b0_c0let budget = 1_000_000_000_000n 使用时必须注意 _ 的两边必须要有类型的数值，否则会报错，以下这些都是无效的写法： 1234let num = 10_let binarary = 0b1011_let hex = 0x_0A0Blet budget = 1_n 参考文章 ECMAScript6 入门 1.5 万字概括 ES6 全部特性(已更新 ES2020) 近一万字的 ES6 语法知识点补充 深入理解 Promise for-await…of Iteration_protocols Object.fromEntries WeakRef 内存管理 jshistory-cn sameValueZero","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"深入理解Promise","slug":"promise","date":"2020-10-22T02:11:30.000Z","updated":"2020-10-22T02:16:34.031Z","comments":true,"path":"2020/10/22/promise/","link":"","permalink":"https://bubuzou.com/2020/10/22/promise/","excerpt":"从异步编程说起我们都知道 JavaScript 的代码执行的时候是跑在单线程上的，可以理解为只能按照代码的出现顺序，从上到下一行一行的执行，但是遇到了异步的行为，比如定时器（一定时间之后才去执行），那就需要等同步代码执行完成后的一段时间里再去执行异步代码。 对于同步行为，如下面的代码，我们能够很清楚的知道每一行会发生什么，这是因为后面的指令总是等到前面的指令执行完成后才去执行，所以这里的第二行里的变量 x 在内存里已经是定义过的。 12let x = 10;let y = x + 5;","text":"从异步编程说起我们都知道 JavaScript 的代码执行的时候是跑在单线程上的，可以理解为只能按照代码的出现顺序，从上到下一行一行的执行，但是遇到了异步的行为，比如定时器（一定时间之后才去执行），那就需要等同步代码执行完成后的一段时间里再去执行异步代码。 对于同步行为，如下面的代码，我们能够很清楚的知道每一行会发生什么，这是因为后面的指令总是等到前面的指令执行完成后才去执行，所以这里的第二行里的变量 x 在内存里已经是定义过的。 12let x = 10;let y = x + 5; 但是对于异步代码，我们就不好推断到底什么时候会执行完成了。比如举一个实际的例子，我们去动态加载某个脚本，会这样做： 12345function loadScript(src) &#123; let script = document.createElement(&#x27;script&#x27;) script.src = src document.head.append(script)&#125; 这个脚本加载完成的时候会去执行定义在脚本里的一些函数，比如初始化函数 init，那么我们可以会这样写： 1234567function loadScript(src) &#123; let script = document.createElement(&#x27;script&#x27;) script.src = src document.head.append(script)&#125;loadScript(&#x27;./js/script.js&#x27;)init() // 定义在 ./js/script.js 里的函数 但是实际执行后却发现，这样根本不行，因为加载脚本是需要花时间的，是一个异步的行为，浏览器执行 JavaScript 的时候并不会等到脚本加载完成的时候再去调用 init 函数。 以往，对于这种异步编程的做法通常就是通过给函数传递一个回调函数来处理，上面那个例子可以这样做： 123456789101112131415function loadScript(src, success, fail) &#123; let script = document.createElement(&#x27;script&#x27;) script.src = src script.onload = success script.onerror = fail document.head.append(script)&#125;loadScript(&#x27;./js/script.js&#x27;, success, fail)function success() &#123; console.log(&#x27;success&#x27;) init() // 定义在 ./js/script.js 中的函数&#125;function fail() &#123; console.log(&#x27;fail&#x27;)&#125; 上面这样做能够保证在脚本加载完成的时候，再去执行脚本里的函数。但是多考虑一个问题，如果 success 里又需要加载别的 js 文件呢，那岂不是需要多层嵌套了。是的，这样的多层嵌套会使得代码层次变得更加深入，难以阅读以及后期维护成本非常高，尤其是当里面加上了很多的判断逻辑的时候情况会更加糟糕，这就是所谓的 “回调地狱”，且又因为它的代码形状很像躺着的金字塔，所以有的人也喜欢叫它 “噩运金字塔”。 而为了避免这类 “回调地狱” 问题，目前最好的做法之一就是使用 Promise。 Promise正篇使用 Promise 可以很好的解决上面提到的 “回调地狱” 问题，直接来看结果： 123456789101112131415function loadScript(src) &#123; return new Promise(function(resolve, reject) &#123; let script = document.createElement(&#x27;script&#x27;); script.src = src; script.onload = () =&gt; resolve(script); script.onerror = () =&gt; reject(new Error(`Script load error for $&#123;src&#125;`)); document.head.append(script); &#125;);&#125;loadScript(&#x27;./scripts.js&#x27;).then(res =&gt; &#123; console.log(&#x27;success&#x27;, res); init()&#125;).catch(err =&gt; &#123; console.log(err);&#125;) 这里通过使用 Promise 实例的 then 和 catch 函数将多层嵌套的代码改成了同步处理流程，看起来效果还是不错的，那什么是 Promise 呢？ Promise 首先是一个对象，它通常用于描述现在开始执行，一段时间后才能获得结果的行为（异步行为），内部保存了该异步行为的结果。然后，它还是一个有状态的对象： pending：待定 fulfilled：兑现，有时候也叫解决（resolved） rejected：拒绝 一个 Promise 只有这 3 种状态，且状态的转换过程有且仅有 2 种： pending 到 fulfilled pending 到 rejected 可以通过如下的 Promise 对象构造器来创建一个 Promise： 1let promise = new Promise((resolve, reject) =&gt; &#123;&#125;) 传递给 new Promise 的是 executor 执行器。当 Promise 被创建的时候，executor 会立即同步执行。executor 函数里通常做了 2 件事情：初始化一个异步行为和控制状态的最终转换。 12345new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 1000)&#125;) 如上代码所示，setTimeout 函数用来描述一个异步行为，而 resolve 用来改变状态。executor 函数包含 2 个参数，他们都是回调函数，用于控制 Promise 的状态转换： resolve：用来将状态 pending 转换成 fulfilled reject：用来将状态 pending 转换成 rejected 一个 Promise 的状态一旦被转换过，则无法再变更： 12345678let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;第一次 resolve&#x27;) resolve(&#x27;第二次 resolve&#x27;) // 将被忽略 reject(&#x27;第一次 reject&#x27;) // 将被忽略 &#125;, 0)&#125;)setTimeout(console.log, 1000, p) // Promise &#123;&lt;fulfilled&gt;: &quot;第一次 resolve&quot;&#125; 可以看到执行了 2 次 resolve 函数和 1 次 reject 函数，但是 promise 的最终结果是取的第一次 resolve 的结果，印证了上面的结论。 由 new Promise 构造器返回的 Promise 对象具有如下内部属性： PromiseState：最初是 pending，resolve 被调用的时候变为 fulfilled，或者 reject 被调用时会变为 rejected； PromiseResult：最初是 undefined，resolve(value) 被调用时变为 value，或者在 reject(error) 被调用时变为 error。 比如上面例子中打印出来的 Promise 对象结果中，fulfilled 是其内部的 PromiseState，而 “第一次 resolve” 是其 PromiseResult。 1// Promise &#123;&lt;fulfilled&gt;: &quot;第一次 resolve&quot;&#125; Promise实例方法Promise.prototype.then()Promise.prototype.then() 将用于为 Promise 实例添加处理程序的函数。它接受 2 个可选的参数： onResolved：状态由 pending 转换成 fulfilled 时执行； onRejected：状态由 pending 转换成 rejected 时执行。 它可以写成这样： 123456789function onResolved(res) &#123; console.log(&#x27;resolved&#x27; + res) // resolved3&#125;function onRejected(err) &#123; console.log(&#x27;rejected&#x27; + err)&#125;new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;).then(onResolved, onRejected) 或者写成更简单的方式： 1234567new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;).then(res =&gt; &#123; console.log(&#x27;resolved&#x27; + res) // resolved3&#125;, err =&gt; &#123; console.log(&#x27;rejected&#x27; + err)&#125;) 因为状态的变化只有 2 种，所以 onResolved 和 onRejected 在执行的时候必定是互斥。 上面介绍到了 then() 的参数是可选的，当只有 onResolved 的时候可以这样写： 123new Promise((resolve, reject) =&gt; &#123; resolve()&#125;).then(res =&gt; &#123;&#125;) 当参数只有 onRejected 的时候，需要把第一个参数设置为 null： 123new Promise((resolve, reject) =&gt; &#123; reject()&#125;).then(null, err =&gt; &#123;&#125;) 如果给 then() 函数传递来了非函数参数，则会默认忽略。 Promise.prototype.catch()Promise.prototype.catch() 用于给 Promise 对象添加拒绝处理程序。只接受一个参数：onRejected 函数。实际上，下面这两种写法是等效的： 1234567function onRejected(err)&#123;&#125;new Promise((resolve, reject) =&gt; &#123; reject()&#125;).catch(onRejected)new Promise((resolve, reject) =&gt; &#123; reject()&#125;).then(null, onRejected) Promise.prototype.finally()Promise.prototype.finally() 用于给 Promise 对象添加 onFinally 函数，这个函数主要是做一些清理的工作，只有状态变化的时候才会执行该 onFinally 函数。 123456function onFinally() &#123; console.log(888) // 并不会执行 &#125;new Promise((resolve, reject) =&gt; &#123; &#125;).finally(onFinally) 因为 onFinally 函数是没有任何参数的，所以在其内部其实并不知道该 Promise 的状态是怎么样的。 链式调用链式调用里涉及到的知识点很多，我们不妨先看看下面这道题，你能正确输出其打印顺序嘛？ 1234567891011121314new Promise((resolve, reject) =&gt; &#123; resolve()&#125;).then(() =&gt; &#123; console.log(&#x27;A&#x27;) new Promise((resolve, reject) =&gt; &#123; resolve() &#125;).then(() =&gt; &#123; console.log(&#x27;B&#x27;) &#125;).then(() =&gt; &#123; console.log(&#x27;C&#x27;) &#125;)&#125;).then(() =&gt; &#123; console.log(&#x27;D&#x27;)&#125;) 这里我不给出答案，希望你能动手敲一敲代码，然后思考下为什么？容我讲完这部分知识，相信你能自己理解其中缘由。 从上面这串代码里，我们看到 new Promise 后面接了很多的 .then() 处理程序，这个其实就是 Promise 的链式调用，那它为什么能链式调用呢？ 基于onResolved生成一个新的Promise因为 Promise.prototype.then() 会返回一个新的 Promise，来看下： 123456let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.then(() =&gt; 6)setTimeout(console.log, 0, p1) // Promise &#123;&lt;fulfilled&gt;: 3&#125;setTimeout(console.log, 0, p2) // Promise &#123;&lt;fulfilled&gt;: 6&#125; 可以看到 p1 和 p2 的内部 PromiseResult 是不一样的，说明 p2 是一个新的 Promise 实例。 新产生的 Promise 会基于 onResolved 的返回值进行构建，构建的时候其实是把返回值传递给 Promise.resolve() 生成的新实例，比如上面那串代码里 p1.then(() =&gt; 6) 这里的 onResolved 函数返回了一个 6 ，所以新的 Promise 的内部值会是 6。 如果 .then() 没有提供 onResolved 这个处理程序，则 Promise.resolve() 会基于上一个实例 resolve 后的值来初始化一个新的实例： 12345let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.then()setTimeout(console.log, 0, p2) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 如果 onResolved 处理程序没有返回值，那么返回的新实例的内部值会是 undefined： 12345let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.then(() =&gt; &#123;&#125;)setTimeout(console.log, 0, p2) // Promise &#123;&lt;fulfilled&gt;: undefined&#125; 如果在 onResolved 处理程序里抛出异常，则会返回一个新的 rejected 状态的 Promise： 1234567let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.then(() =&gt; &#123; throw new Error(&#x27;这是一个错误&#x27;)&#125;)setTimeout(console.log, 0, p2) // Promise &#123;&lt;rejected&gt;: 这是一个错误&#125; 基于onRejected生成一个新的Promise基于 onRejected 的返回值也会返回一个新的 Promise，而且处理逻辑也是一样的，也是通过把返回值传递给 Promise.resolve() 产生一个新的实例： 1234567891011121314151617181920212223242526272829let p1 = new Promise((resolve, reject) =&gt; &#123; reject(3)&#125;)// 没有 `onRejected` 处理程序时，会原样向后传，不过是新实例let p2 = p1.then(() =&gt; &#123;&#125;) ssetTimeout(console.log, 0, p2) // Promise &#123;&lt;rejected&gt;: 3&#125;// 返回值为undefined时let p3 = p1.then(null, () =&gt; &#123;&#125;) setTimeout(console.log, 0, p3) // Promise &#123;&lt;fulfilled&gt;: undefined&#125; // 返回值有实际值的时候let p4 = p1.then(null, () =&gt; 6) setTimeout(console.log, 0, p4) // Promise &#123;&lt;fulfilled&gt;: 6&#125;// 当返回值是Promise时，会保留当前Promiselet p5 = p1.then(null, () =&gt; Promise.reject()) setTimeout(console.log, 0, p5) // Promise &#123;&lt;rejected&gt;: undefined&#125; // 当遇到一个错误的时候let p6 = p1.then(null, () =&gt; &#123; throw new Error(&#x27;error&#x27;)&#125;) setTimeout(console.log, 0, p6) // Promise &#123;&lt;rejected&gt;: error&#125; // 当返回值是一个错误时let p7 = p1.then(null, () =&gt; new Error(&#x27;error&#x27;)) setTimeout(console.log, 0, p7) // Promise &#123;&lt;fulfilled&gt;: Error: error&#125; 这里你会不会有个疑惑？实例 resolve() 的时候，状态由 pending 变成 rejected，从而调用 onRejected 进行处理，但是为什么有时候会返回一个 fulfilled 的新实例呢？试着想一下，如果 onRejected 返回了一个 pending 的或者 rejected 状态的新实例，那后续的链式调用就进行不下去了，看下面例子： 1234567891011new Promise((resolve, reject) =&gt; &#123; reject()&#125;).then(null, () =&gt; &#123; console.log(&#x27;A&#x27;)&#125;).then(() =&gt; &#123; console.log(&#x27;B&#x27;)&#125;).then(() =&gt; &#123; console.log(&#x27;C&#x27;)&#125;).catch(() =&gt; &#123; console.log(&#x27;D&#x27;)&#125;) 如果 A 处理函数这里返回了一个 pending 状态的新实例，那么后续所有的链式操作都无法执行；或者返回的是一个 rejected 状态的新实例，那么后续的 B 和 C 也就无法执行了，那居然都不能执行 B 和 C 所在处理程序，那定义来干嘛呢？链式操作就毫无链式可言。又，onRejected 的存在的根本意义无非就是用于捕获 Promise 产生的错误，从而不影响程序的正常执行，所以默认情况下理应返回一个 fulfilled 的新实例。 Promise.prototype.catch() 也会生成一个新的 Promise，其生成规则和 onRejected 是一样的。 finally生成一个新的Promise没想到吧，Promise.prototype.finally() 也能生成一个 Promise。finally 里的操作是和状态无关的，一般用来做后续代码的处理工作，所以 finally 一般会原样后传父 Promise，无论父级实例是什么状态。 123456789let p1 = new Promise(() =&gt; &#123;&#125;)let p2 = p1.finally(() =&gt; &#123;&#125;)setTimeout(console.log, 0, p2) // Promise &#123;&lt;pending&gt;&#125;let p3 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p4 = p3.finally(() =&gt; &#123;&#125;)setTimeout(console.log, 0, p3) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 上面说的是一般，但是也有特殊情况，比如 finally 里返回了一个非 fulfilled 的 Promise 或者抛出了异常的时候，则会返回对应状态的新实例： 12345678910111213let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)let p2 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;))setTimeout(console.log, 0, p2) // Promise &#123;&lt;pending&gt;&#125;let p3 = p1.finally(() =&gt; Promise.reject(6))setTimeout(console.log, 0, p3) // Promise &#123;&lt;rejected&gt;: 6&#125;let p4 = p1.finally(() =&gt; &#123; throw new Error(&#x27;error&#x27;)&#125;)setTimeout(console.log, 0, p4) // Promise &#123;&lt;rejected&gt;: Error: error&#125; 执行顺序先来看一段简单的代码： 123456789new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;A&#x27;) resolve(3) console.log(&#x27;B&#x27;)&#125;).then(res =&gt; &#123; console.log(&#x27;C&#x27;)&#125;)console.log(&#x27;D&#x27;)// 打印结果：A B D C 上面这串代码的输出顺序是：A B D C。从上面章节介绍的知识点我们知道，executor 执行器会在 new Promise 调用的时候立即同步执行的，所以先后打印 A B 是没问题的。当执行 resolve()/reject() 的时候，会将 Promise 对应的处理程序推入微任务队列，稍等这里提到的对应的处理程序具体是指什么？ resolve() 对应 .then() 里的第一个入参，即 onResolved 函数； reject() 对应 .then() 里的第二个入参，即 onRejected 函数；或者 Promise.prototype.catch() 里的回调函数； 所以当执行 resolve(3) 的时候（此时下面定义的这个箭头函数其实就是 onResolved 函数），onResolved 函数将被推入微任务队列，然后打印 D，此时所有同步任务执行完成，浏览器会去检查微任务队列，发现存在一个，所以最后会去调用 onResolved 函数，打印出 C。 123let onResolved = res =&gt; &#123; console.log(&#x27;C&#x27;)&#125; 其实除了 onResolved、onRejected 以及 Promise.prototype.catch() 里的处理程序外，Promise.prototype.finally() 的处理程序 onFinally 也是异步执行的： 12345678new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;A&#x27;) resolve(3)&#125;).finally(() =&gt; &#123; console.log(&#x27;B&#x27;)&#125;)console.log(&#x27;C&#x27;)// 打印结果：A C B Promise 链式调用的基础就是因为 onResolved、onRejected、catch() 的处理程序以及 onFinally 会产生一个新的 Promise 实例，且又因为他们都是异步执行的，所以在链式调用的时候，对于它们执行顺序会稀里糊涂琢磨不透就是这个原因。 题目一那下面我们就来看点复杂的例子，先来分析下这章开篇提到的题目： 123456789101112131415new Promise((resolve, reject) =&gt; &#123; resolve()&#125;).then(() =&gt; &#123; console.log(&#x27;A&#x27;) new Promise((resolve, reject) =&gt; &#123; resolve() &#125;).then(() =&gt; &#123; console.log(&#x27;B&#x27;) &#125;).then(() =&gt; &#123; console.log(&#x27;C&#x27;) &#125;)&#125;).then(() =&gt; &#123; console.log(&#x27;D&#x27;)&#125;)// 打印结果：A 为了方便分析，我们把上面的这串代码写得好看一点： 123456789101112131415161718new Promise(executor).then(onResolvedA).then(onResolvedD)function executor(resolve, reject) &#123; resolve()&#125;function onResolvedA() &#123; console.log(&#x27;A&#x27;) new Promise(executor).then(onResolvedB).then(onResolvedC)&#125;function onResolvedB() &#123; console.log(&#x27;B&#x27;)&#125;function onResolvedC() &#123; console.log(&#x27;C&#x27;)&#125;function onResolvedD() &#123; console.log(&#x27;D&#x27;)&#125; 执行过程： 执行 new Promise()，立即同步执行 executor 函数，调用 resolve()，此时会将 onResolvedA 推入微任务队列 1，截止目前所有同步代码执行完成； 检查微任务队列，执行 onResolvedA 函数，打印 A，执行 new Promise(executor)，调用 resolve() 函数，此时将 onResolvedB 推入微任务队列 2； 截止目前微任务队列 1 的代码全部执行完成，即 onResolvedA 函数执行完成。我们知道 onResolved 函数会基于返回值生成一个新的 Promise，而 onResolvedA 函数没有显示的返回值，所以其返回值为 undefined，那么经过 Promise.resolve(undefined) 初始化后会生成一个这样的新实例：Promise &#123;&lt;fulfilled&gt;: undefined&#125;；由于这个新的实例状态已经变成 fulfilled，所以会立即将其处理函数 onResolvedD 推入微任务队列 3； 开始执行微任务队列 2 里的内容，打印 B，同上一条原理，由于 onResolvedB 函数的返回值为 undefined，所以生成了一个 resolved 的新实例，则会立即将 onResolvedC 推入微任务队列 4； 执行微任务队列 3，打印 D； 执行微任务队列 4，打印 C； 至此全部代码执行完成，最终的打印结果为：A B D C。 题目二123456789101112131415new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;).then(res =&gt; &#123; console.log(&#x27;A&#x27;)&#125;).finally(() =&gt; &#123; console.log(&#x27;B&#x27;)&#125;)new Promise((resolve, reject) =&gt; &#123; resolve(2)&#125;).then(res =&gt; &#123; console.log(&#x27;C&#x27;)&#125;).finally(() =&gt; &#123; console.log(&#x27;D&#x27;)&#125;)// 打印结果：A C B D 应该很多人会和我当初一样好奇：为什么打印结果不是 A B C D 呢？这里涉及到一个知识点：如果给 Promise 实例添加了多个处理函数，当实例状态变化的时候，那么执行的过程就是按照添加时的顺序而执行的。 1234567891011new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;).then(onResolvedA).finally(onFinally)function onResolvedA() &#123; console.log(&#x27;A&#x27;)&#125;function onFinally() &#123; console.log(&#x27;B&#x27;)&#125;// 打印结果： A B 对于上面这串代码，其实 finally() 处理程序执行的时候已经不是通过 new Promise() 初始化的实例，而是执行完 onResolvedA 函数的时候生成的新实例，不信我们将上面代码中的函数 onResolvedA 稍微改动下： 123456789101112new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;).then(onResolvedA).finally(onFinally)function onResolvedA() &#123; console.log(&#x27;A&#x27;) return new Promise(() =&gt; &#123;&#125;)&#125;function onFinally() &#123; console.log(&#x27;B&#x27;)&#125;// 打印结果： A 由于 onResolvedA 返回了一个这样的 Promise &#123;&lt;pending&gt;&#125; 新实例，这个新实例的状态没有发生变化，所以不会执行 finally 处理程序 onFinally，所以不会打印 B。这个就说明了，链式调用的时候处理程序的执行是一步一步来的，只要前面的执行完了，生成了新的实例，然后根据新实例的状态变化，才去执行后续的处理程序。 所以拿最开始那道题来说： 123456789101112131415new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;).then(res =&gt; &#123; console.log(&#x27;A&#x27;)&#125;).finally(() =&gt; &#123; console.log(&#x27;B&#x27;)&#125;)new Promise((resolve, reject) =&gt; &#123; resolve(2)&#125;).then(res =&gt; &#123; console.log(&#x27;C&#x27;)&#125;).finally(() =&gt; &#123; console.log(&#x27;D&#x27;)&#125;)// 打印结果：A C B D 他的执行过程应该是这样的： 执行 resolve(1)，将处理程序 A 推入微任务队列 1； 执行 resolve(2)，将处理程序 C 推入微任务队列 2； 同步任务执行完成，执行微任务队列 1 里的内容，打印 A，A 所在函数执行完成后生成了一个 fulfilled 的新实例，由于新实例状态变化，所以会立即执行 finally() 处理程序 B 推入微任务队列 3； 执行微任务队列 2 的内容，打印 C，C 所在函数执行完成后，同上条原理会将处理程序 D 推入微任务队列 4； 执行微任务队列 3 的内容，打印 B； 执行微任务队列 4 的内容，打印 D； 代码全部执行完成，最终打印：A C B D。 题目就先做到这里，相信你和我一样，对 Promise 的执行过程应该有更深入的理解了。接下来我们将继续学习 Promise 的相关 API。 Promise与错误处理平时我们写代码遇到错误，都习惯用 try/catch 块来处理，但是对于 Promise 产生的错误，用这个是处理不了的，看下面这段代码： 12345678910111213try &#123; new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;A&#x27;) throw new Error() console.log(&#x27;B&#x27;) &#125;) &#125; catch(err) &#123; console.log(err)&#125;console.log(&#x27;C&#x27;)// A// C // Uncaught (in promise) Error 从执行结果我们可以看到，报错的信息出现在打印 C 之后，说明抛出错误这个动作是在异步任务中做的，所以 catch 捕获不到该错误就在情理之中了，否则就不会打印 C 了。可见，传统的 try/catch 语句并不能捕获 Promise 产生的错误，而需要使用 onRejected 处理程序： 123456789101112let p1 = new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;A&#x27;) throw new Error(&#x27;error&#x27;) console.log(&#x27;B&#x27;)&#125;)let p2 = p1.catch((err) =&gt; &#123; console.log(err)&#125;) setTimeout(console.log, 0, p2)// A// Error: error// Promise &#123;&lt;fulfilled&gt;: undefined&#125; onRejected 捕获了上面抛出的错误后，使得程序正常执行，最后还生成了一个 fulfilled 的新实例。 除了以上这种直接在 executor 里通过 throw 主动抛出一个错误外，还可以通过以下方式产出需要 onRejected 处理的错误： 1234567891011121314151617new Promise((resolve, reject) =&gt; &#123; init() // 被动出错，调用了不存在的函数&#125;)new Promise((resolve, reject) =&gt; &#123; reject()&#125;)new Promise((resolve, reject) =&gt; &#123; resolve()&#125;).then(() =&gt; Promise.reject())new Promise((resolve, reject) =&gt; &#123; resolve()&#125;).then(() =&gt; &#123; throw new Error()&#125;) 注意，如果只是产生了一个错误，却没有抛出来是不会报错的： 1234// 不会报错new Promise((resolve, reject) =&gt; &#123; reject()&#125;).then(() =&gt; new Error()) Promise 出现了错误就需要使用 onRejected 处理程序处理，否则程序就会报错，执行不下去了。 Promise APIPromise.resolve()并非所有的 Promise 的初始状态都是 pending，可以通过 Promise.resolve(value) 来初始化一个状态为 fulfilled，值为 value 的 Promise 实例： 12let p = Promise.resolve(3)console.log(p) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 这个操作和下面这种创建一个 fulfilled 的 Promise 在效果上是一样的： 12let p = new Promise(resolve =&gt; resolve(3))console.log(p) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 使用这个静态方法，理论上可以把任何一个值转换成 Promise： 123setTimeout(console.log, 0, Promise.resolve()) // Promise &#123;&lt;fulfilled&gt;: undefined&#125;setTimeout(console.log, 0, Promise.resolve(3, 6, 9)) // Promise &#123;&lt;fulfilled&gt;: 3&#125; 多余的参数将被忽略setTimeout(console.log, 0, Promise.resolve(new Error(&#x27;error&#x27;))) // Promise &#123;&lt;fulfilled&gt;: Error: error&#125; 这个被转换的值甚至可以是一个 Promise 对象，如果是这样，Promise.resolve 会将其原样输出： 12let p = Promise.resolve(3)setTimeout(console.log, 0, p === Promise.resolve(p)) // true Promise.reject()和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise，且会抛出一个错误，该错误只能通过拒绝处理程序捕获。 12345Promise .reject(3) .catch(err =&gt; &#123; console.log(err) // 3 &#125;) 对于初始化一个 rejected 状态的实例，以下两种写法都可以达到这个目的： 12let p1 = Promise.reject()let p2 = new Promise((resolve, reject) =&gt; reject()) 与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值： 12let p = Promise.reject(3)setTimeout(console.log, 0, p === Promise.reject(p)) // false Promise.all()Promise.all(iterable) 用来将多个 Promise 实例合成一个新实例。参数必须是一个可迭代对象，通常是数组。 1234Promise.all([ Promise.resolve(3), Promise.resolve(6)]) 可迭代对象里的所有元素都会通过 Promise.resolve() 转成 Promise： 1Promise.all([3, 6, 9]) 所有 Promise 都 resolve 后，Promise.all() 才会生成一个 fulfilled 的新实例。且新实例的内部值是由所有 Promise 解决后的值组成的数组： 1234567891011let p1 = Promise.all([ Promise.resolve(&#x27;3&#x27;), Promise.resolve(), 6])let p2 = p1.then(res =&gt; &#123; console.log(res)&#125;)setTimeout(console.log, 0, p1)// [&quot;3&quot;, undefined, 6]// Promise &#123;&lt;fulfilled&gt;: Array(3)&#125; 所有 Promise 中，只要出现一个 pending 状态的实例，那么合成的新实例也是 pending 状态的： 1234567let p1 = Promise.all([ 3, Promise.resolve(6), new Promise(() =&gt; &#123;&#125;)])setTimeout(console.log, 0, p1)// Promise &#123;&lt;pending&gt;&#125; 所有 Promise 中，只要出现一个 rejected 状态的实例，那么合成的新实例也是 rejected 状态的，且新实例的内部值是第一个拒绝 Promise 的内部值： 12345678910111213let p1 = Promise.all([ 3, Promise.reject(6), new Promise((resolve, reject) =&gt; &#123; reject(9) &#125;)])let p2 = p1.catch(err =&gt; &#123; console.log(err)&#125;)setTimeout(console.log, 0, p1)// 6// Promise &#123;&lt;rejected&gt;: 6&#125; Promise.race()Promise.race(iterable) 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。 12345678910111213141516let p1 = Promise.race([ 3, Promise.reject(6), new Promise((resolve, reject) =&gt; &#123; resolve(9) &#125;).then(res =&gt; &#123; console.log(res) &#125;)])let p2 = p1.then(res =&gt; &#123; console.log(err)&#125;)setTimeout(console.log, 0, p1)// 9// 3// Promise &#123;&lt;fulfilled&gt;: 3&#125; 来将上面这串代码变动下： 1234567891011121314151617181920212223242526function init()&#123; console.log(3) return 3&#125;let p1 = Promise.race([ new Promise((resolve, reject) =&gt; &#123; resolve(9) &#125;).then(res =&gt; &#123; console.log(res) return &#x27;A&#x27; &#125;), new Promise((resolve, reject) =&gt; &#123; reject(6) &#125;), init(),])let p2 = p1.then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)setTimeout(console.log, 0, p1)// 3// 9// 6// Promise &#123;&lt;rejected&gt;: 6&#125; 想要知道 Promise.race() 的结果，无非是要知道到底谁才是第一个状态变化的实例，让我们来具体分析下代码执行过程： 迭代第一个元素，执行同步代码 resolve(9)，由 new Promise 初始化的实例的状态已经变为了 fulfilled，所以第一个状态变化的实例已经出现了吗？其实并没有，因为迭代第一个元素的代码还没执行完成呢，然后会将 return &#39;A&#39; 所在函数的这段处理程序推入微任务队列 1； 迭代第二个元素，执行 reject(6)，所以由 new Promise 初始化的实例的状态已经变为 rejected，由于该实例没有处理函数，所以迭代第二个元素的代码已经全部执行完成，此时，第一个状态变化的实例已经产生； 迭代第三个元素，是一个函数，执行同步代码打印出 3，然后用 Promise.resolve 将函数返回值 3 转成一个 Promise &#123;&lt;fulfilled&gt;: 3&#125; 的新实例，这是第二个状态发生变化的实例； 此时所有迭代对象遍历完成，即同步代码执行完成，开始执行微任务队列 1 的内容，打印 res，其值是 9，然后处理程序返回了 ‘A’，此时根据之前提到的知识点，这里会新生成一个 Promise &#123;&lt;fulfilled&gt;: &#39;A&#39;&#125; 的实例，这是第三个状态发生变化的实例。此时，第一个迭代元素的代码已经全部执行完成，所以第一个迭代元素最终生成的实例是第三次状态发生变化的这个； 此时 p1 已经产生，它是 Promise &#123;&lt;rejected&gt;: 6&#125;，所以会将它的处理程序 console.log(err) 所在函数推入微任务队列 2； 执行微任务队列 2 的内容，打印 err，其值是 6； 所有微任务执行完成，开始执行 setTimeout 里的宏任务，打印 p1，至此全部代码执行完成。 Promise.allSettled()Promise.allSettled(iterable) 当所有的实例都已经 settled，即状态变化过了，那么将返回一个新实例，该新实例的内部值是由所有实例的值和状态组合成的数组，数组的每项是由每个实例的状态和内部值组成的对象。 12345678910111213141516171819202122function init()&#123; return 3&#125;let p1 = Promise.allSettled([ new Promise((resolve, reject) =&gt; &#123; resolve(9) &#125;).then(res =&gt; &#123;&#125;), new Promise((resolve, reject) =&gt; &#123; reject(6) &#125;), init()])let p2 = p1.then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)// [// &#123;status: &quot;fulfilled&quot;, value: undefined&#125;, // &#123;status: &quot;rejected&quot;, reason: 6&#125;, // &#123;status: &quot;fulfilled&quot;, value: 3&#125;// ] 只要所有实例中包含一个 pending 状态的实例，那么 Promise.allSettled() 的结果为返回一个这样 Promise &#123;&lt;pending&gt;&#125; 的实例。 Promise.allSettled() 是 ES2020 中新增的方法，所以有一些浏览器可能还暂时不支持。 对于不支持的浏览器，可以写 polyfill： 12345678910111213if(!Promise.allSettled) &#123; Promise.allSettled = function(promises) &#123; return Promise.all(promises.map(p =&gt; Promise.resolve(p) .then(value =&gt; (&#123; status: &#x27;fulfilled&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;rejected&#x27;, reason &#125;)) )); &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"详细设计一个文章页目录插件","slug":"article-catalog","date":"2020-10-14T02:19:26.000Z","updated":"2020-10-14T03:16:39.189Z","comments":true,"path":"2020/10/14/article-catalog/","link":"","permalink":"https://bubuzou.com/2020/10/14/article-catalog/","excerpt":"在说这个插件之前，可以先去 https://bubuzou.com/ 这个网站体验下这个插件的效果，好有个大概的印象。 通过阅读这篇文章，你可以收获什么？ 用 JS 直接操作 DOM 浏览器 BOM 相关知识 性能优化思考 插件设计思考 背景平时我们在用 Markdown 写的文章，如果放到自己的博客或者投稿到掘金等平台，其内容会被浏览器解析成 HTML。而 Markdown 里面的一级（#）、二级（##）、三级标题（###）分别对应于页面的文章标题、一级目录、二级目录。基于此，就可以很好的利用该生成的页面实现一个目录，便于更直观方便的的浏览文章内容，而这就是最初我想为博客里的文章页实现一个目录功能的理由。 这个插件是基于 Hexo 生成的网页来实现的，且目前只支持一级和二级目录，因为作为一篇文章来说有两个层级已经可以很好的将一块内容划分细说得很清楚了。","text":"在说这个插件之前，可以先去 https://bubuzou.com/ 这个网站体验下这个插件的效果，好有个大概的印象。 通过阅读这篇文章，你可以收获什么？ 用 JS 直接操作 DOM 浏览器 BOM 相关知识 性能优化思考 插件设计思考 背景平时我们在用 Markdown 写的文章，如果放到自己的博客或者投稿到掘金等平台，其内容会被浏览器解析成 HTML。而 Markdown 里面的一级（#）、二级（##）、三级标题（###）分别对应于页面的文章标题、一级目录、二级目录。基于此，就可以很好的利用该生成的页面实现一个目录，便于更直观方便的的浏览文章内容，而这就是最初我想为博客里的文章页实现一个目录功能的理由。 这个插件是基于 Hexo 生成的网页来实现的，且目前只支持一级和二级目录，因为作为一篇文章来说有两个层级已经可以很好的将一块内容划分细说得很清楚了。 需求分析位置 首先我打算将文章的目录放置在文章内容的右侧，且是悬浮固定在那里不随浏览器的滚动而滚动。因为我们都习惯从上到下从左到右的去浏览文章，所以我希望首先映入眼帘的是文章内容而不是文章目录；另外因为我的博客的首页和文章列表页都是左侧是浏览区域而右侧是操作区域，所以把目录放到右侧能保持整站的布局统一以及操作的便利性。 需要做什么 首先需要根据文章内容的二级和三级标题生成目录； 然后，页面从上到下滚动过程中，需要在右侧目录里高亮当前的标题，而高亮的原则是当前标题所在的位置到浏览器可视区域顶部的距离需要小于或等于一个固定值，如上图所示； 在合适的时候滚动目录列表，使得当前高亮的子目录会出现在滚动区域内部，且尽量处于滚动区域的中间区域； 当点击某个子目录的时候需要高亮当前点击的目录，且文章内容滚动到对应目录的位置，使得点击目录对应的文章标题所在的位置距离可视区域顶部的距离刚好等于一个固定值。 滚动目录的机制是怎样的对于的第三点提到在合适的时候滚动目录，那什么时候才算合适呢？目录能不能滚动，以及怎么滚动总共分为以下 5 种情况： 当目录能在滚动区域完全显示的时候，即滚动区域高度大于所有目录子项高度总和的时候，不进行目录滚动，如上面的图 ① ； 当目录不能在滚动区域完全显示的时候，目录需要滚动。所以需要做的就是在一个划定的区域内滚动目录，超出该区域的目录子项将会自动隐藏。通过滚动目录，我们可以实现目录列表的头尾两个目录子项都能很好的在划定区域里显示出来。随着页面的滚动，目录将从头滚到尾，那么滚动的范围是从第一个子目录贴着滚动区域的顶部到最后一个子目录贴着滚动区域的底部为止； 当页面在最顶部的时候，当前高亮的子目录肯定是第一个，随着页面的向下滚动，高亮的位置也在不断下移，当高亮位置移动到在目录滚动区域的上半部分之前，这段不进行目录滚动，如上面的图 ② 到 图 ③ 的变化过程； 当第一个子目录贴着滚动区域的顶部，且高亮位置在中位往下继续滚动的时候，需要进行目录滚动，滚动的距离是当前高亮目录所在位置距离滚动区域中间位置的高度差，如上面的图 ③ 到图 ④ 的变化过程； 如果这个高度差过于大，使得滚动后最后一个子元素不能贴着滚动区域底部的时候，则不按照这个高度差进行滚动，而真实需要滚动的距离是最后一个子目录到滚动区域底部的距离，如上面的图 ④ 到图 ⑤ 的变化过程。 功能实现由于文章页是由 Hexo 基于 Markdown 生成而来的，所以它有自己特定的 HTML 格式，它的格式大概是如下这样： 123456789101112131415&lt;h2 id=&quot;7种组件通信方式随你选&quot;&gt; &lt;a href=&quot;&quot; class=&quot;headerlink&quot; title=&quot;7种组件通信方式随你选&quot;&gt;&lt;/a&gt; 7种组件通信方式随你选&lt;/h2&gt;&lt;!-- 这里是部分文章内容 --&gt;&lt;h3 id=&quot;props-on-emit&quot;&gt; &lt;a href=&quot;&quot; class=&quot;headerlink&quot; title=&quot;props/@on+$emit&quot;&gt;&lt;/a&gt; props/@on+$emit&lt;/h3&gt;&lt;!-- 这里是部分文章内容 --&gt;&lt;h3 id=&quot;$attrs和$listeners&quot;&gt; &lt;a href=&quot;&quot; class=&quot;headerlink&quot; title=&quot;$attrs和$listeners&quot;&gt;&lt;/a&gt; $attrs和$listeners&lt;/h3&gt;&lt;!-- 这里是部分文章内容 --&gt; 可以看到所有的二级标题（H2）和三级标题（H3）都是在同一个父元素下面，且每个标题下面都包含了一个带有 headerlink 类名的链接，另外还有标题属性。 这个时候我们就能很容易的获取到所有的标题： 1let arContentAnchor = document.querySelectorAll(&#x27;.headerlink&#x27;) 上面这串代码的结果会返回一个 NodeList，有了它我们就可以去生成目录了。 生成目录 生成目录无非就是产生一串 HTML，除此之外还有哪些要做的呢？首先要确定下，目录都包含了哪些部分，如上图所示这里大概是包含了 3 部分：目录条、序号和标题。那么就可以先确定好 HTML 结构： 123456789101112&lt;div class=&quot;arCatalog&quot;&gt; &lt;div class=&quot;arCatalog-line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;arCatalog-body&quot;&gt; &lt;dl&gt; &lt;dd class=&quot;arCatalog-tack1 on&quot;&gt; &lt;span class=&quot;arCatalog-index&quot;&gt;1&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;7种组件通信方式随你选&lt;/a&gt; &lt;span class=&quot;arCatalog-dot&quot;&gt;&lt;/span&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt;&lt;/div&gt; 其中，arCatalog-line 表示目录条，arCatalog-body 是滚动区域，dl 是滚动列表，dd 是目录子项，arCatalog-index 是目录序号，链接里放的是子目录标题。有了 HTML ，接下来要做的就是把目录的样式写好，写完后样式比较多，所以就不在这里贴出来了。 生成目录到这里就完事了吗？并没有，由于浏览器可视区域是不固定的，所以我们需要计算出目录所在滚动区域的高度。 滚动高度 = n个目录子项 * 子项的实际高度 先说子项的实际高度，对于目录子项的样式上，我这里没有用内间距和外边距，而是通过 line-height 来控制他们之间的间隙，那么： 子项的实际高度 = 子项的行高 再说 n 个目录子项，那到底 n 是多少呢？在目录的 Y 轴方向上，除了有目录，还有顶部的菜单，以及为了美观还需要适当的留白，所以： n = (视口高度 - （顶部菜单高度 + 留白高度））/ 子项行高 所以，最终我们可以计算出滚动高度： 123456789101112131415let DEFAULT = &#123; lineHeight: 28, // 每个菜单的行高是 28 moreHeight: 10, // 菜单左侧的线比菜单多出的高度 surplusHeight: 180, // 除了菜单高度+留白高度 delay: 200, // 防抖的延迟时间 duration: 200, // 滚动的动画持续时间 toTopDistance: 80, // 距离视口顶部多少高度之内时候触发高亮 selector: &#x27;.headerlink&#x27;, // 文章内容中标题标签的 selector&#125;// maxCatalogCount 就是上面提到的 n 个目录子项中的 nlet maxCatalogCount = Math.floor((window.innerHeight - DEFAULT.surplusHeight) / DEFAULT.lineHeight) // 滚动区域高度let catalogHeight = arContentAnchor.length &gt; maxCatalogCount ? maxCatalogCount * DEFAULT.lineHeight : arContentAnchor.length * DEFAULT.lineHeight; 完整的生成目录的函数代码如下： 1234567891011121314151617181920212223242526272829303132333435363738// 生成目录function generateCatalog()&#123; let catalogHeight = arContentAnchor.length &gt; maxCatalogCount ? maxCatalogCount * DEFAULT.lineHeight : arContentAnchor.length * DEFAULT.lineHeight; let retStr = ` &lt;div class=&quot;arCatalog&quot;&gt; &lt;div class=&quot;arCatalog-line&quot; style=&quot;height: $&#123;catalogHeight + DEFAULT.moreHeight&#125;px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;arCatalog-body&quot; style=&quot;max-height: $&#123;catalogHeight&#125;px; height: $&#123;catalogHeight&#125;px&quot;&gt; &lt;dl style=&quot;margin-top: $&#123;marginTop&#125;px&quot;&gt;`; let h2Index = 0, h3Index = 1, acIndex = &#x27;&#x27;, tagName = &#x27;&#x27;, index = 0; for (let currNode of arContentAnchor) &#123; tagName = currNode.parentElement.tagName if ( tagName === &#x27;H3&#x27; ) &#123; acIndex = `$&#123;h2Index&#125;.$&#123;h3Index++&#125;` className = &#x27;arCatalog-tack2&#x27; &#125; else &#123; acIndex = ++h2Index h3Index = 1 className = &#x27;arCatalog-tack1&#x27; &#125; retStr += ` &lt;dd class=&quot;$&#123;className&#125; $&#123;index++ === lastOnIndex ? &#x27;on&#x27; : &#x27;&#x27;&#125;&quot;&gt; &lt;span class=&quot;arCatalog-index&quot;&gt;$&#123;acIndex&#125;&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;$&#123;currNode.title&#125;&lt;/a&gt; &lt;span class=&quot;arCatalog-dot&quot;&gt;&lt;/span&gt; &lt;/dd&gt;` &#125;; retStr += `&lt;/dl&gt;&lt;/div&gt;&lt;/div&gt;` document.getElementById(&#x27;arAnchorBar&#x27;).innerHTML = retStr&#125; 设置滚动监听事件给 window 加上滚动事件，用于监听当滚动的时候去做一些操作，这里的操作就是设置高亮和滚动目录。 12345678910window.addEventListener(&#x27;scroll&#x27;, function() &#123; setHighlight()&#125;, false)// 只有目录总数超过滚动区域可容纳最大目录数的时候，目录才需要滚动if (catalogLength &gt; maxCatalogCount) &#123; window.addEventListener(&#x27;scroll&#x27;, function() &#123; scrollCatalog() &#125;, false)&#125; 如上这样就能监听浏览器滚动事件，从而做一些事情啦。但是这样会导致函数被频繁调用，从而存在性能问题，其实我们更希望当滚动开始到滚动结束的时候，只执行一次函数即可，那这个直接上防抖即可： 12345678910// 防抖：触发高频事件 n 秒后只会执行一次，如果 n 秒内事件再次触发，则会重新计时。function debounce(fn, delay = 200) &#123; return function(args) &#123; const _this = this clearTimeout(fn.id) fn.id = setTimeout(function() &#123; fn.apply(_this, args) &#125;, delay) &#125;&#125; 然后我们只需要把 scroll 监听回调里的函数对应换成如下的即可： 12345678910window.addEventListener(&#x27;scroll&#x27;, function() &#123; debounce(setHighlight, DEFAULT.delay)() debounce(resetStatus, DEFAULT.delay)()&#125;, false)if (catalogLength &gt; maxCatalogCount) &#123; window.addEventListener(&#x27;scroll&#x27;, function() &#123; debounce(scrollCatalog, DEFAULT.delay)() &#125;, false)&#125; 高亮当前目录 这部分内容开始前，我们先来复习一个 API，该方法会返回元素的大小及其相对于视口的位置： 1Element.getBoundingClientRect() 需求分析的时候有提到，高亮的原则是当前标题所在的位置到浏览器可视区域顶部的距离需要小于或等于一个固定值： 1arContentAnchor[index].getBoundingClientRect().top &lt;= DEFAULT.toTopDistance 所以当遍历 arContentAnchor 这个列表，某项的位置小于固定值，且差值最小的时候，该项对应的目录就应该被设置为高亮： 1234567891011121314151617let curr = document.querySelector(&#x27;.arCatalog .on&#x27;)curr.classList.remove(&#x27;on&#x27;)let nextOnIndex = 0, currNode;while (nextOnIndex &lt; arContentAnchor.length) &#123; currNode = arContentAnchor[nextOnIndex] if (currNode.getBoundingClientRect().top &lt;= DEFAULT.toTopDistance) &#123; nextOnIndex++ &#125; else &#123; break &#125;&#125;nextOnIndex = nextOnIndex === arContentAnchor.length ? nextOnIndex - 1 : nextOnIndex;let catalogDd = document.querySelectorAll(&#x27;.arCatalog dd&#x27;)catalogDd[nextOnIndex].classList.add(&#x27;on&#x27;) 到此一切都看起来很美好，但是上面这段代码存在性能问题，只要页面一滚动就会从第一个目录到最后一个目录之间进行查找，知道找到那个符合要求的为止，这样的话遍历次数太多了。 我们知道页面滚动无非就是在当前这个位置的前提下，往上滚动或者向下滚动，如果我们把 nextOnIndex 记为滚动前的索引，在根据滚动方向进行加加减减不就可以很好的减少遍历次数嘛？想法貌似不错，来试一下。 首先我们要判断当前滚动是向上还是向下滚动，可以根据两次滚动前后的偏移量来判断： 向上滚动 = 滚动后偏移量 &lt; 滚动前偏移量 1234567891011let lastSH = window.pageYOffset// 获取最近一次页面的滚动方向function getScrollDirection() &#123; let sh = window.pageYOffset, ret = &#x27;bottom&#x27; if (sh &lt; lastSH) &#123; ret = &#x27;top&#x27; &#125; lastSH = sh return ret&#125; 知道了滚动方向，我们就可以很好的写出设置高亮的优化代码： 12345678910111213141516171819202122let curr = document.querySelector(&#x27;.arCatalog .on&#x27;)let nextOnIndex = onIndex;if (defaultDirec === &#x27;bottom&#x27;) &#123; while (nextOnIndex &lt; catalogLength) &#123; let currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top if ( currTop &gt; DEFAULT.toTopDistance &amp;&amp; nextOnIndex &gt; 0)&#123; nextOnIndex-- break &#125; nextOnIndex++ &#125;&#125; else &#123; while (nextOnIndex &gt;= 0) &#123; let currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top if ( currTop &lt;= DEFAULT.toTopDistance)&#123; break &#125; nextOnIndex-- &#125;&#125;nextOnIndex = nextOnIndex === arContentAnchor.length ? nextOnIndex - 1 : nextOnIndex &lt; 0 ? 0 : nextOnIndex catalogDd[nextOnIndex].classList.add(&#x27;on&#x27;) 优化后的遍历次数明显减少，而且遍历次数基本上是小于或等于滚动前后目录索引的差值。虽然经过优化后，已经明显的减少了遍历次数，但是我还想再优化一下。纳尼？ 很多文章页很长，所以有回到顶部这种功能，试想一下，如果当前页面已经滚动到最底部，这个时候来一下回到顶部，那刚刚写的优化代码会遍历几次？答案是：遍历次数将会是目录子项的总数。文章最开始提到的那个体验地址的那篇文章 34条我能告诉你的Vue之实操篇 有 43 个子目录，所以需要遍历 43 次，真的不能接受结果，所以再来优化一次。 二次优化主要是处理边际问题，即滚动到头尾部的时候加上判断，最终二次优化后的高亮当前目录函数如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 高亮当前目录function setHighlight()&#123; defaultDirec = getScrollDirection() if (hasStopSetHighlight) &#123; return &#125; let &#123; scrollTop, &#125; = document.scrollingElement; let curr = document.querySelector(&#x27;.arCatalog .on&#x27;) let onIndex = [].indexOf.call(catalogDd, curr), // 当前高亮索引 nextOnIndex = onIndex; // 滚动后高亮索引 curr.classList.remove(&#x27;on&#x27;) let scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight if (arContentAnchor[catalogLength - 1].getBoundingClientRect().top &lt;= DEFAULT.toTopDistance || window.innerHeight + window.pageYOffset === scrollHeight) &#123; // 尾部 lastOnIndex = catalogLength - 1 catalogDd[lastOnIndex].classList.add(&#x27;on&#x27;) &#125; else if (scrollTop &lt;= firstDdTop) &#123; // 顶部 catalogDd[0].classList.add(&#x27;on&#x27;) lastOnIndex = 0 &#125; else &#123; // 中间：使用缓存，直接从上一次索引（onIndex）位置开始查找 if (defaultDirec === &#x27;bottom&#x27;) &#123; while (nextOnIndex &lt; catalogLength) &#123; let currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top if ( currTop &gt; DEFAULT.toTopDistance &amp;&amp; nextOnIndex &gt; 0)&#123; nextOnIndex-- break &#125; nextOnIndex++ &#125; &#125; else &#123; while (nextOnIndex &gt;= 0) &#123; let currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top if ( currTop &lt;= DEFAULT.toTopDistance)&#123; break &#125; nextOnIndex-- &#125; &#125; nextOnIndex = nextOnIndex === catalogLength ? nextOnIndex - 1 : nextOnIndex &lt; 0 ? 0 : nextOnIndex lastOnIndex = nextOnIndex catalogDd[nextOnIndex].classList.add(&#x27;on&#x27;) &#125;&#125; 滚动目录 根据之前需求分析里的说明，我们可以知道当浏览器向下滚动的时候，会分成 3 种情况： 滚动后的高亮子目录处于于滚动区域上半部分，即中位线以上，此时目录不进行滚动，如上图 ①； 滚动后的高亮子目录处于滚动区域的下半部分，即中位线以下，此时目录的滚动距离将是滚动后高亮子目录的底部位置到中位线的高度差，如上图 ②； 滚动后的高亮目录处于中位线以下且最后一个子目录需要贴着滚动区域底部，此时目录的滚动距离将是滚动列表底部到滚动区域底部的高度差，如上图 ③。 1234567891011let catalogBody = document.querySelector(&#x27;.arCatalog-body&#x27;), initBodyTop = catalogBody..getBoundingClientRect().top, bodyMidBottom = initBodyTop + Math.ceil((maxCatalogCount / 2 )) * DEFAULT.lineHeight; // 中位线位置 if (curr.bottom + (maxCatalogCount / 2) * DEFAULT.lineHeight &lt;= bodyBCR.bottom) &#123; // 上半部分 // 不滚动&#125; else if (curr.bottom - bodyMidBottom &lt; list.bottom - bodyBCR.bottom) &#123; // 中位以下 marginTop += -Math.floor((curr.bottom - bodyMidBottom ) / DEFAULT.lineHeight) * DEFAULT.lineHeight&#125; else if (bodyBCR.bottom &lt;= list.bottom) &#123; // 当剩余滚动距离 marginTop = bodyBCR.bottom - initDlBottom&#125; 同理，当浏览器向上滚动的时候，也能很好的得出其滚动逻辑： 1234567if (bodyBCR.top + (maxCatalogCount / 2) * DEFAULT.lineHeight &lt;= curr.top) &#123; // 不滚动&#125; else if (bodyMidBottom - curr.top &lt; bodyBCR.top - list.top) &#123; marginTop += Math.floor((bodyMidBottom - curr.top) / DEFAULT.lineHeight) * DEFAULT.lineHeight&#125; else if (list.top &lt;= bodyBCR.top) &#123; marginTop = 0&#125; 最终的滚动目录函数完整代码： 1234567891011121314151617181920212223242526// 自动滚动目录树，使得当前高亮目录在可视范围内function scrollCatalog() &#123; let currentCatalog = document.querySelector(&#x27;.arCatalog .on&#x27;); let curr = currentCatalog.getBoundingClientRect(), list = catalogDl.getBoundingClientRect(); if (defaultDirec === &#x27;bottom&#x27;) &#123; // 向下滚动 if (curr.bottom + (maxCatalogCount / 2) * DEFAULT.lineHeight &lt;= bodyBCR.bottom) &#123; // 上半部分 // 不滚动 &#125; else if (curr.bottom - bodyMidBottom &lt; list.bottom - bodyBCR.bottom)&#123; // 中位以下 marginTop += -Math.floor((curr.bottom - bodyMidBottom ) / DEFAULT.lineHeight) * DEFAULT.lineHeight &#125; else if (bodyBCR.bottom &lt;= list.bottom) &#123; // 当剩余滚动距离 marginTop = bodyBCR.bottom - initDlBottom &#125; &#125; else &#123; // 向上滚动 if (bodyBCR.top + (maxCatalogCount / 2) * DEFAULT.lineHeight &lt;= curr.top) &#123; // 不滚动 &#125; else if (bodyMidBottom - curr.top &lt; bodyBCR.top - list.top) &#123; marginTop += Math.floor((bodyMidBottom - curr.top) / DEFAULT.lineHeight) * DEFAULT.lineHeight &#125; else if (list.top &lt;= bodyBCR.top) &#123; marginTop = 0 &#125; &#125; catalogDl.style.marginTop = marginTop + &#x27;px&#x27;&#125; 子目录点击事件当点击子目录的时候需要做 2 件事情，第一是滚动页面到对应的目录位置，然后是高亮当前点击的目录； 滚动页面到对应的目录位置： 12345678910// 给目录子项绑定事件let catalogDd = document.querySelectorAll(&#x27;.arCatalog dd&#x27;); catalogDd.forEach((curr, index) =&gt; &#123; curr.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() let currTop = arContentAnchor[index].getBoundingClientRect().top document.documentElement.scrollTop = document.body.scrollTop = currTop + window.pageYOffset - DEFAULT.toTopDistance &#125;, false)&#125;); 这样实现页面的滚动是没什么问题，就是体验不太好，突然从一个位置滚动到另外一个位置，显得突兀，能不能来点动画效果？类似 jQuery 的 animate() ？没问题，我们来尝试着实现一下。 用 JS 实现动画效果，一定离不开定时器，诸如 setTimeout、setInterval 之类，但是这次我不打算用他们，而是用 HTML5 中增加的 requestAnimationFrame，这是一个专门为浏览器实现动画而提供的 API。它虽然也是个定时器，但是相比于另外两个，他不需要传递时间，因为传递的回调函数里自带了参数 DOMHighResTimeStamp，这个参数表示回调函数被触发的时间。 除此之外，requestAnimationFrame 中的回调函数执行次数通常是每秒60次，即大概每 16.6 毫秒执行一次回调函数，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。好了，对于 requestAnimationFrame 的介绍就到这里，下面我们直接来说下动画实现滚动的核心原理： 每次滚动距离 = ( 滚动距离 / 动画持续时间 ) * 每次动画执行时间距离第一次执行时间的差值 + 当前滚动距离 直接来看完整的动画实现滚动的函数： 123456789101112131415161718192021// 滚动到目标位置function scrollToDest(destScrollTop) &#123; let startTime; let currScrollTop = window.pageYOffset; let duration = 200; function step(timestamp) &#123; if (!startTime) &#123; startTime = timestamp &#125; const elapsed = Math.round(timestamp - startTime) const distance = elapsed * ((Math.floor(destScrollTop) - currScrollTop) / duration) + currScrollTop document.documentElement.scrollTop = document.body.scrollTop = distance if (elapsed &lt; duration) &#123; window.requestAnimationFrame(step) &#125; &#125; window.requestAnimationFrame(step)&#125; 好了，现在有了动画函数，我们需要改写下子目录的点击事件，给滚动加上过渡效果，让人体验起来更加舒服： 123456789let catalogDd = document.querySelectorAll(&#x27;.arCatalog dd&#x27;);catalogDd.forEach((curr, index) =&gt; &#123; curr.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() let currTop = arContentAnchor[index].getBoundingClientRect().top scrollToDest(currTop + window.pageYOffset - DEFAULT.toTopDistance) &#125;, false)&#125;); 第一件事已经做好，接下来做第二件事，高亮当前点击某个子目录： 1234567891011121314// 给目录子项绑定事件let catalogDd = document.querySelectorAll(&#x27;.arCatalog dd&#x27;);catalogDd.forEach((curr, index) =&gt; &#123; curr.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() hasStopSetHighlight = true document.querySelector(&#x27;.arCatalog .on&#x27;).classList.remove(&#x27;on&#x27;) catalogDd[index].classList.add(&#x27;on&#x27;) lastOnIndex = index let currTop = arContentAnchor[index].getBoundingClientRect().top scrollToDest(currTop + window.pageYOffset - DEFAULT.toTopDistance) &#125;, false)&#125;); 如上即可，但是由于点击了某个子目录，页面会进行滚动，而页面滚动又会触发 setHighlight 函数对目录进行高亮，所以我这里的做法是用了一个全局变量 hasStopSetHighlight 用来控制当点击子目录的时候，不进行 setHighlight 设置高亮操作。 浏览器视口高度变了怎么办因为我们的滚动高度是根据浏览器视口高度计算出来的，如果浏览器视口高度变化了，那这个时候再去滚动页面，那肯定会出问题的。所以需要做的就是把和视口高度有关的逻辑抽离出来，统一放到一个函数里，当监听到视口高度变化的时候，再去执行这个函数。 先来写监听函数，同样用上了防抖函数处理： 123window.addEventListener(&#x27;resize&#x27;, function(e) &#123; debounce(initCatalog, DEFAULT.delay)()&#125;, false) 然后去把相关逻辑抽离出来： 1234567891011121314151617181920212223242526272829303132333435// 初始化function initCatalog() &#123; let tempHeight = window.innerHeight if (viewPortHeight !== tempHeight) &#123; viewPortHeight = tempHeight maxCatalogCount = Math.floor((viewPortHeight - DEFAULT.surplusHeight) / DEFAULT.lineHeight) generateCatalog() catalogLength = arContentAnchor.length lastSH = window.pageYOffset catalogBody = document.querySelector(&#x27;.arCatalog-body&#x27;) catalogDl = document.querySelector(&#x27;.arCatalog dl&#x27;) catalogDd = document.querySelectorAll(&#x27;.arCatalog dd&#x27;) bodyBCR = catalogBody.getBoundingClientRect() initBodyTop = bodyBCR.top initDlBottom = initDlBottom || catalogDl.getBoundingClientRect().bottom firstDdTop = firstDdTop || catalogDd[0].getBoundingClientRect().top, bodyMidBottom = initBodyTop + Math.ceil((maxCatalogCount / 2 )) * DEFAULT.lineHeight; // 给目录子项绑定事件 catalogDd.forEach((curr, index) =&gt; &#123; curr.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() hasStopSetHighlight = true document.querySelector(&#x27;.arCatalog .on&#x27;).classList.remove(&#x27;on&#x27;) catalogDd[index].classList.add(&#x27;on&#x27;) lastOnIndex = index let currTop = arContentAnchor[index].getBoundingClientRect().top scrollToDest(currTop + window.pageYOffset - DEFAULT.toTopDistance) &#125;, false) &#125;); &#125;&#125; 浏览器视口高度变化后，这里有个细节需要提一下，那就是滚动目录的 margin-top 以及高亮位置是希望变化的，所以我们需要使用全局变量进行提前保存起来，分别用到的全局变量是 marginTop 和 lastOnIndex。 组装上面的代码都是把不同的功能点提取到函数里进行操作，看起来比较散乱，所以我们需要看看一个完整的目录插件应该是什么样子？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * articleCatalog v2.0 * Copyright(c) 2016 by bulandent * Date: 2017-5-27 16:10:41 * Updated: 2020-10-10 17:40:04**/let articleCatalog = (function() &#123; if ( document.querySelectorAll(&#x27;.headerlink&#x27;).length === 0 || window.innerWidth &lt; 900 ) &#123; return function()&#123;&#125;; &#125; let DEFAULT = &#123; lineHeight: 28, // 每个菜单的行高是 28 moreHeight: 10, // 菜单左侧的线比菜单多出的高度 surplusHeight: 180, // 除了菜单高度+留白高度 delay: 200, // 防抖的延迟时间 duration: 200, // 滚动的动画持续时间 toTopDistance: 80, // 距离视口顶部多少高度之内时候触发高亮 selector: &#x27;.headerlink&#x27;, // 文章内容中标题标签的 selector &#125; return function(args) &#123; DEFAULT = Object.assign(DEFAULT, args) let arContentAnchor = document.querySelectorAll(DEFAULT.selector), catalogLength = arContentAnchor.length, maxCatalogCount = 0, // 视口内能容纳的最大目录个数 viewPortHeight = 0, // 当前视口的高度 marginTop = 0, // 菜单的初始滚动距离 defaultDirec = &#x27;bottom&#x27;, // 默认滚动方向 lastSH = 0, // 获取页面初始滚动距离 lastOnIndex = 0, // 上次高亮的目录索引 catalogBody = [], // .arCatalog-body catalogDl = null, // .arCatalog-body dl catalogDd = [], // .arCatalog-body dd initBodyTop = 0, // 目录可视区域的 top initDlBottom = 0, // 目录 dl 的 bottom firstDdTop = 0, // 第一个 dd 的 top bodyMidBottom = 0, // 目录可视区域的中间位置的 dd 的 bottom bodyBCR = null, // 目录可视区域的边界值 hasStopSetHighlight = false; // 在点击目录子项的时候直接高亮当前目录，而不通过 scroll 事件触发 setHighlight 函数 initCatalog() window.addEventListener(&#x27;scroll&#x27;, function() &#123; debounce(setHighlight, DEFAULT.delay)() &#125;, false) if (catalogLength &gt; maxCatalogCount) &#123; window.addEventListener(&#x27;scroll&#x27;, function() &#123; debounce(scrollCatalog, DEFAULT.delay)() &#125;, false) &#125; window.addEventListener(&#x27;resize&#x27;, function(e) &#123; debounce(initCatalog, DEFAULT.delay)() &#125;, false) // 此处声明初始化函数 initCatalog // 此处声明生成目录函数 generateCatalog // 此处声明设置高亮函数 setHighlight // 此处声明滚动目录函数 scrollCatalog // 此处声明动画实现滚动函数 scrollToDest // 此处声明防抖函数 debounce // 此处声明获取滚动方向函数 getScrollDirection function resetStatus() &#123; if (hasStopSetHighlight) &#123; hasStopSetHighlight = false &#125; &#125; &#125;&#125;()); 使用插件然后在实际页面里使用的时候，只需要引入 articleCatalog.js，然后直接用调用函数即可： 1articleCatalog() 当然调用的时候也支持传入一些参数，参数说明如下： 123456789articleCatalog(&#123; lineHeight: 28, &#x2F;&#x2F; 每个菜单的行高是 28 moreHeight: 10, &#x2F;&#x2F; 菜单左侧的线比菜单多出的高度 surplusHeight: 180, &#x2F;&#x2F; 除了菜单高度+留白高度 delay: 200, &#x2F;&#x2F; 防抖的延迟时间 duration: 200, &#x2F;&#x2F; 滚动的动画持续时间 toTopDistance: 80, &#x2F;&#x2F; 距离视口顶部多少高度之内时候触发高亮 selector: &#39;.headerlink&#39;, &#x2F;&#x2F; 文章内容中标题标签的 selector&#125;) 注意传入参数也是瞎传的，需要配合该插件的样式，否则容易程问题。比如明明页面中子目录的真实行高是 28px，你却传入 lineHeight: 24，那肯定是不行的。 使用这个插件是有前提的，那就是其文章页的 HTML 结构必须满足上面提到的那种结构才行，且只支持两级子目录。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"34条我能告诉你的Vue之实操篇","slug":"vue-operate","date":"2020-09-21T02:22:22.564Z","updated":"2021-09-06T09:58:02.807Z","comments":true,"path":"2020/09/21/vue-operate/","link":"","permalink":"https://bubuzou.com/2020/09/21/vue-operate/","excerpt":"这是我学习整理的关于 Vue.js 系列文章的第一篇，另外还有两篇分别是关于优化和原理的。希望读完这 3 篇文章，你能对 Vue 有个更深入的认识。 7 种组件通信方式随你选组件通信是 Vue 的核心知识，掌握这几个知识点，面试开发一点问题都没有。 props/@on+$emit用于实现父子组件间通信。通过 props 可以把父组件的消息传递给子组件： 12&lt;!-- parent.vue --&gt;&lt;child :title=&quot;title&quot;&gt;&lt;/child&gt;","text":"这是我学习整理的关于 Vue.js 系列文章的第一篇，另外还有两篇分别是关于优化和原理的。希望读完这 3 篇文章，你能对 Vue 有个更深入的认识。 7 种组件通信方式随你选组件通信是 Vue 的核心知识，掌握这几个知识点，面试开发一点问题都没有。 props/@on+$emit用于实现父子组件间通信。通过 props 可以把父组件的消息传递给子组件： 12&lt;!-- parent.vue --&gt;&lt;child :title=&quot;title&quot;&gt;&lt;/child&gt; 1234567// child.vueprops: &#123; title: &#123; type: String, default: &#x27;&#x27;, &#125;&#125; 这样一来 this.title 就直接拿到从父组件中传过来的 title 的值了。注意，你不应该在子组件内部直接改变 prop，这里就不多赘述，可以直接看官网介绍。 而通过 @on+$emit 组合可以实现子组件给父组件传递信息： 12&lt;!-- parent.vue --&gt;&lt;child @changeTitle=&quot;changeTitle&quot;&gt;&lt;/child&gt; 12// child.vuethis.$emit(&#x27;changeTitle&#x27;, &#x27;bubuzou.com&#x27;) $attrs和$listenersVue_2.4 中新增的 $attrs/$listeners 可以进行跨级的组件通信。$attrs 包含了父级作用域中不作为 prop 的属性绑定（class 和 style 除外），好像听起来有些不好理解？没事，看下代码就知道是什么意思了： 12&lt;!-- 父组件 index.vue --&gt;&lt;list class=&quot;list-box&quot; title=&quot;标题&quot; desc=&quot;描述&quot; :list=&quot;list&quot;&gt;&lt;/list&gt; 1234567// 子组件 list.vueprops: &#123; list: [],&#125;,mounted() &#123; console.log(this.$attrs) // &#123;title: &quot;标题&quot;, desc: &quot;描述&quot;&#125;&#125; 在上面的父组件 index.vue 中我们给子组件 list.vue 传递了 4 个参数，但是在子组件内部 props 里只定义了一个 list，那么此时 this.$attrs 的值是什么呢？首先要去除 props 中已经绑定了的，然后再去除 class 和 style，最后剩下 title 和 desc 结果和打印的是一致的。基于上面代码的基础上，我们在给 list.vue 中加一个子组件： 12&lt;!-- 子组件 list.vue --&gt;&lt;detail v-bind=&quot;$attrs&quot;&gt;&lt;/detial&gt; 12345// 孙子组件 detail.vue// 不定义props，直接打印 $attrsmounted() &#123; console.log(this.$attrs) // &#123;title: &quot;标题&quot;, desc: &quot;描述&quot;&#125;&#125; 在子组件中我们定义了一个 v-bind=&quot;$attrs&quot; 可以把父级传过来的参数，去除 props、class 和 style 之后剩下的继续往下级传递，这样就实现了跨级的组件通信。 $attrs 是可以进行跨级的参数传递，实现父到子的通信；同样的，通过 $listeners 用类似的操作方式可以进行跨级的事件传递，实现子到父的通信。$listeners 包含了父作用域中不含 .native 修饰的 v-on 事件监听器，通过 v-on=&quot;$listeners&quot; 传递到子组件内部。 12345&lt;!-- 父组件 index.vue --&gt;&lt;list @change=&quot;change&quot; @update.native=&quot;update&quot;&gt;&lt;/list&gt;&lt;!-- 子组件 list.vue --&gt;&lt;detail v-on=&quot;$listeners&quot;&gt;&lt;/detail&gt; 12345// 孙子组件 detail.vuemounted() &#123; this.$listeners.change() this.$listeners.update() // TypeError: this.$listeners.update is not a function&#125; provide/inject 组合拳provide/inject 组合以允许一个祖先组件向其所有子孙后代注入一个依赖，可以注入属性和方法，从而实现跨级父子组件通信。在开发高阶组件和组件库的时候尤其好用。 123456789101112131415161718192021222324// 父组件 index.vuedata() &#123; return &#123; title: &#x27;bubuzou.com&#x27;, &#125;&#125;provide() &#123; return &#123; detail: &#123; title: this.title, change: (val) =&gt; &#123; console.log( val ) &#125; &#125; &#125;&#125;// 孙子组件 detail.vueinject: [&#x27;detail&#x27;],mounted() &#123; console.log(this.detail.title) // bubuzou.com this.detail.title = &#x27;hello world&#x27; // 虽然值被改变了，但是父组件中 title 并不会重新渲染 this.detail.change(&#x27;改变后的值&#x27;) // 执行这句后将打印：改变后的值&#125; provide 和 inject 的绑定对于原始类型来说并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。这也就是为什么在孙子组件中改变了 title，但是父组件不会重新渲染的原因。 EventBus以上三种方式都是只能从父到子方向或者子到父方向进行组件的通信，而我就比较牛逼了 😀，我还能进行兄弟组件之间的通信，甚至任意 2 个组件间通信。利用 Vue 实例实现一个 EventBus 进行信息的发布和订阅，可以实现在任意 2 个组件之间通信。有两种写法都可以初始化一个 eventBus 对象： 通过导出一个 Vue 实例，然后再需要的地方引入： 123// eventBus.jsimport Vue from &#x27;vue&#x27;export const EventBus = new Vue() 使用 EventBus 订阅和发布消息： 1234567import &#123; EventBus &#125; from &#x27;../utils/eventBus.js&#x27;// 订阅处EventBus.$on(&#x27;update&#x27;, (val) =&gt; &#123;&#125;)// 发布处EventBus.$emit(&#x27;update&#x27;, &#x27;更新信息&#x27;) 在 main.js 中初始化一个全局的事件总线： 12// main.jsVue.prototype.$eventBus = new Vue() 使用： 12345// 需要订阅的地方this.$eventBus.$on(&#x27;update&#x27;, (val) =&gt; &#123;&#125;)// 需要发布信息的地方this.$eventBus.$emit(&#x27;update&#x27;, &#x27;更新信息&#x27;) 如果想要移除事件监听，可以这样来： 1this.$eventBus.$off(&#x27;update&#x27;, &#123;&#125;) 上面介绍了两种写法，推荐使用第二种全局定义的方式，可以避免在多处导入 EventBus 对象。这种组件通信方式只要订阅和发布的顺序得当，且事件名称保持唯一性，理论上可以在任何 2 个组件之间进行通信，相当的强大。但是方法虽好，可不要滥用，建议只用于简单、少量业务的项目中，如果在一个大型繁杂的项目中无休止的使用该方法，将会导致项目难以维护。 Vuex 进行全局的数据管理Vuex 是一个专门服务于 Vue.js 应用的状态管理工具。适用于中大型应用。Vuex 中有一些专有概念需要先了解下： State：用于数据的存储，是 store 中的唯一数据源； Getter：类似于计算属性，就是对 State 中的数据进行二次的处理，比如筛选和对多个数据进行求值等； Mutation：类似事件，是改变 Store 中数据的唯一途径，只能进行同步操作； Action：类似 Mutation，通过提交 Mutation 来改变数据，而不直接操作 State，可以进行异步操作； Module：当业务复杂的时候，可以把 store 分成多个模块，便于维护； 对于这几个概念有各种对应的 map 辅助函数用来简化操作，比如 mapState，如下三种写法其实是一个意思，都是为了从 state 中获取数据，并且通过计算属性返回给组件使用。 123456789computed: &#123; count() &#123; return this.$store.state.count &#125;, ...mapState(&#123; count: state =&gt; state.count &#125;), ...mapState([&#x27;count&#x27;]),&#125;, 又比如 mapMutations， 以下两种函数的定义方式要实现的功能是一样的，都是要提交一个 mutation 去改变 state 中的数据： 123456methods: &#123; increment() &#123; this.$store.commit(&#x27;increment&#x27;) &#125;, ...mapMutations([&#x27;increment&#x27;]),&#125; 接下来就用一个极简的例子来展示 Vuex 中任意 2 个组件间的状态管理。1、 新建 store.js 1234567891011121314151617import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125;, decrement(state) &#123; state.count-- &#125;, &#125;,&#125;) 2、 创建一个带 store 的 Vue 实例 12345678910import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./utils/store&#x27;new Vue(&#123; router, store, render: (h) =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 3、 任意组件 A 实现点击递增 1234567891011121314&lt;template&gt; &lt;p @click=&quot;increment&quot;&gt;click to increment：&#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapState, mapMutations &#125; from &#x27;vuex&#x27; export default &#123; computed: &#123; ...mapState([&#x27;count&#x27;]), &#125;, methods: &#123; ...mapMutations([&#x27;increment&#x27;]), &#125;, &#125;&lt;/script&gt; 4、 任意组件 B 实现点击递减 1234567891011121314&lt;template&gt; &lt;p @click=&quot;decrement&quot;&gt;click to decrement：&#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapState, mapMutations &#125; from &#x27;vuex&#x27; export default &#123; computed: &#123; ...mapState([&#x27;count&#x27;]), &#125;, methods: &#123; ...mapMutations([&#x27;decrement&#x27;]), &#125;, &#125;&lt;/script&gt; 以上只是用最简单的 vuex 配置去实现组件通信，当然真实项目中的配置肯定会更复杂，比如需要对 State 数据进行二次筛选会用到 Getter，然后如果需要异步的提交那么需要使用 Action，再比如如果模块很多，可以将 store 分模块进行状态管理。对于 Vuex 更多复杂的操作还是建议去看Vuex 官方文档，然后多写例子。 Vue.observable 实现 mini vuex这是一个 Vue2.6 中新增的 API，用来让一个对象可以响应。我们可以利用这个特点来实现一个小型的状态管理器。 123456789101112131415// store.jsimport Vue from &#x27;vue&#x27;export const state = Vue.observable(&#123; count: 0,&#125;)export const mutations = &#123; increment() &#123; state.count++ &#125; decrement() &#123; state.count-- &#125;&#125; 1234567891011121314&lt;!-- parent.vue --&gt;&lt;template&gt; &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt; import &#123; state &#125; from &#x27;../store&#x27; export default &#123; computed: &#123; count() &#123; return state.count &#125;, &#125;, &#125;&lt;/script&gt; 123456789// child.vueimport &#123; mutations &#125; from &#x27;../store&#x27;export default &#123; methods: &#123; handleClick() &#123; mutations.increment() &#125;, &#125;,&#125; $refs/$children/$parent/$root通过给子组件定义 ref 属性可以使用 $refs 来直接操作子组件的方法和属性。 1&lt;child ref=&quot;list&quot;&gt;&lt;/child&gt; 比如子组件有一个 getList 方法，可以通过如下方式进行调用，实现父到子的通信： 1this.$refs.list.getList() 除了 $refs 外，其他 3 个都是自 Vue 实例创建后就会自动包含的属性，使用和上面的类似。 6 类可以掌握的修饰符表单修饰符表单类的修饰符都是和 v-model 搭配使用的，比如：v-model.lazy、v-model.trim 以及 v-model.number 等。 .lazy：对表单输入的结果进行延迟响应，通常和 v-model 搭配使用。正常情况下在 input 里输入内容会在 p 标签里实时的展示出来，但是加上 .lazy 后则需要在输入框失去焦点的时候才触发响应。 12&lt;input type=&quot;text&quot; v-model.lazy=&quot;name&quot; /&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt; .trim：过滤输入内容的首尾空格，这个和直接拿到字符串然后通过 str.trim() 去除字符串首尾空格是一个意思。 .number：如果输入的第一个字符是数字，那就只能输入数字，否则他输入的就是普通字符串。 事件修饰符Vue 的事件修饰符是专门为 v-on 设计的，可以这样使用： @click.stop=&quot;handleClick&quot;，还能串联使用：@click.stop.prevent=&quot;handleClick&quot;。 1234&lt;div @click=&quot;doDiv&quot;&gt; click div &lt;p @click=&quot;doP&quot;&gt;click p&lt;/p&gt;&lt;/div&gt; .stop：阻止事件冒泡，和原生 event.stopPropagation() 是一样的效果。如上代码，当点击 p 标签的时候，div 上的点击事件也会触发，加上 .stop 后事件就不会往父级传递，那父级的事件就不会触发了。 .prevent：阻止默认事件，和原生的 event.preventDefault() 是一样的效果。比如一个带有 href 的链接上添加了点击事件，那么事件触发的时候也会触发链接的跳转，但是加上 .prevent 后就不会触发链接跳转了。 .capture：默认的事件流是：捕获阶段-目标阶段-冒泡阶段，即事件从最具体目标元素开始触发，然后往上冒泡。而加上 .capture 后则是反过来，外层元素先触发事件，然后往深层传递。 .self：只触发自身的事件，不会传递到父级，和 .stop 的作用有点类似。 .once：只会触发一次该事件。 .passive：当页面滚动的时候就会一直触发 onScroll 事件，这个其实是存在性能问题的，尤其是在移动端，当给他加上 .passive 后触发的就不会那么频繁了。 .native：现在在组件上使用 v-on 只会监听自定义事件 (组件用 $emit 触发的事件)。如果要监听根元素的原生事件，可以使用 .native 修饰符，比如如下的 el-input，如果不加 .native 当回车的时候就不会触发 search 函数。 1&lt;el-input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.enter.native=&quot;search&quot;&gt;&lt;/el-input&gt; 串联使用事件修饰符的时候，需要注意其顺序，同样 2 个修饰符进行串联使用，顺序不同，结果大不一样。@click.prevent.self 会阻止所有的点击事件，而 @click.self.prevent 只会阻止对自身元素的点击。 鼠标按钮修饰符 .left：鼠标左键点击； .right：鼠标右键点击； .middle：鼠标中键点击； 键盘按键修饰符Vue 提供了一些常用的按键码： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 另外，你也可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符，比如可以通过如下的代码来查看具体按键的键名是什么： 1&lt;input @keyup=&quot;onKeyUp&quot; /&gt; 123onKeyUp(event) &#123; console.log(event.key) // 比如键盘的方向键向下就是 ArrowDown&#125; .exact 修饰符.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; .sync 修饰符.sync 修饰符常被用于子组件更新父组件数据。直接看下面的代码： 12&lt;!-- parent.vue --&gt;&lt;child :title.sync=&quot;title&quot;&gt;&lt;/child&gt; 12// child.vuethis.$emit(&#x27;update:title&#x27;, &#x27;hello&#x27;) 子组件可以直接通过 update:title 的形式进行更新父组件中声明了 .sync 的 prop。上面父组件中的写法其实是下面这种写法的简写： 1&lt;child :title=&quot;title&quot; @update:title=&quot;title = $event&quot;&gt;&lt;/child&gt; 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 如果需要设置多个 prop，比如： 1&lt;child :name.sync=&quot;name&quot; :age.sync=&quot;age&quot; :sex.sync=&quot;sex&quot;&gt;&lt;/child&gt; 可以通过 v-bind.sync 简写成这样： 1&lt;child v-bind.sync=&quot;person&quot;&gt;&lt;/child&gt; 12345person: &#123; name: &#x27;bubuzou&#x27;, age: 21, sex: &#x27;male&#x27;,&#125; Vue 内部会自行进行解析把 person 对象里的每个属性都作为独立的 prop 传递进去，各自添加用于更新的 v-on 监听器。而从子组件进行更新的时候还是保持不变，比如： 1this.$emit(&#x27;update:name&#x27;, &#x27;hello&#x27;) 6 种方式编写可复用模块今天需求评审了一个需求，需要实现一个详情页，这个详情页普通用户和管理员都能进去，但是展示的数据有稍有不同，但绝大部分是一样的；最主要的区别是详情对于普通用户是纯展示，而对于管理员要求能够编辑，然后管理员还有一些别的按钮权限等。需求看到这里，如果在排期的时候把用户的详情分给开发 A 做，而把管理员的详情分给 B 去做，那这样做的结果就是开发 A 写了一个详情页，开发 B 写了一个详情页，这在开发阶段、提测后的修改 bug 阶段以及后期迭代阶段，都需要同时维护这 2 个文件，浪费了时间浪费了人力，所以你可以从中意识到编写可复用模块的重要性。 而 Vue 作者尤大为了让开发者更好的编写可复用模块，提供了很多的手段，比如：组件、自定义指令、渲染函数、插件以及过滤器等。 组件组件是 Vue 中最精髓的地方，也是我们平时编写可复用模块最常用的手段，但是由于这块内容篇幅很多，所以不在这里展开，后续会写相关的内容进行详述。 使用混入 mixins什么是混入呢？ 从代码结构上来看，混入其实就是半个组件，一个 Vue 组件可以包括 template、script 和 style 三部分，而混入其实就是 script 里面的内容。一个混入对象包含任意组件选项，比如 data、methods、computed、watch 、生命周期钩子函数、甚至是 mixins 自己等，混入被设计出来就是旨在提高代码的灵活性、可复用性。 什么时候应该使用混入呢？当可复用逻辑只是 JS 代码层面的，而无 template 的时候就可以考虑用混入了。比如需要记录用户在页面的停留的时间，那我们就可以把这段逻辑抽出来放在 mixins 里： 12345678910111213// mixins.jsexport const statMixin = &#123; methods: &#123; enterPage() &#123;&#125;, leavePage() &#123;&#125;, &#125;, mounted() &#123; this.enterPage() &#125;, beforeDestroyed() &#123; this.leavePage() &#125;,&#125; 然后在需要统计页面停留时间的地方加上： 1234import &#123; statMixin &#125; from &#x27;../common/mixins&#x27;export default &#123; mixins: [statMixin],&#125; 使用混入的时候要注意和组件选项的合并规则，可以分为如下三类： data 将进行递归合并，对于键名冲突的以组件数据为准： 1234567891011121314151617181920// mixinA 的 datadata() &#123; obj: &#123; name: &#x27;hello&#x27;, &#125;,&#125;// component Aexport default &#123; mixins: [mixinA], data()&#123; obj: &#123; name: &#x27;bubuzou&#x27;, age: 21 &#125;, &#125;, mounted() &#123; console.log( this.obj ) // &#123; name: &#x27;bubuzou&#x27;, &#x27;age&#x27;: 21 &#125; &#125;&#125; 对于生命周期钩子函数将会合并成一个数组，混入对象的钩子将先被执行： 12345678910111213141516171819202122// mixin Aconst mixinA = &#123; created() &#123; console.log( &#x27;第一个执行&#x27; ) &#125;&#125;// mixin Bconst mixinB = &#123; mixins: [mixinA] created() &#123; console.log( &#x27;第二个执行&#x27; ) &#125;&#125;// component Aexport default &#123; mixins: [mixinB] created() &#123; console.log( &#x27;最后一个执行&#x27; ) &#125;&#125; 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 自定义指令除了 Vue 内置的一些指令比如 v-model、v-if 等，Vue 还允许我们自定义指令。在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。比如我们可以通过自定义一个指令来控制按钮的权限。我们期望设计一个如下形式的指令来控制按钮权限： 1&lt;button v-auth=&quot;[&#x27;user&#x27;]&quot;&gt;提交&lt;/button&gt; 通过在按钮的指令里传入一组权限，如果该按钮只有 admin 权限才可以提交，而我们传入一个别的权限，比如 user，那这个按钮就不应该显示了。接下来我们去注册一个全局的指令： 123456789101112131415161718// auth.jsconst AUTH_LIST = [&#x27;admin&#x27;]function checkAuth(auths) &#123; return AUTH_LIST.some((item) =&gt; auths.includes(item))&#125;function install(Vue, options = &#123;&#125;) &#123; Vue.directive(&#x27;auth&#x27;, &#123; inserted(el, binding) &#123; if (!checkAuth(binding.value)) &#123; el.parentNode &amp;&amp; el.parentNode.removeChild(el) &#125; &#125;, &#125;)&#125;export default &#123; install &#125; 然后我们需要在 main.js 里通过安装插件的方式来启用这个指令： 12import Auth from &#x27;./utils/auth&#x27;Vue.use(Auth) 使用渲染函数这里将使用渲染函数实现上面介绍过的的权限按钮。使用方式如下，把需要控制权限的按钮包在权限组件 authority 里面，如果有该权限就显示，没有就不显示。 123&lt;authority :auth=&quot;[&#x27;admin&#x27;]&quot;&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/authority&gt; 然后我们用渲染函数去实现一个 authority 组件： 1234567891011121314151617181920&lt;script&gt;const AUTH_LIST = [&#x27;admin&#x27;, &#x27;user&#x27;, &#x27;org&#x27;]function checkAuth(auths) &#123; return AUTH_LIST.some(item =&gt; auths.includes(item))&#125;export default &#123; functional: true, props: &#123; auth: &#123; type: Array, required: true &#125; &#125;, render(h, context) &#123; const &#123; props, scopedSlots&#125; = context return checkAuth(props.auth) ? scopedSlots.default() : null &#125;&#125;&lt;/script&gt; 全局注册这个组件： 123// main.jsimport Authority from &#x27;./components/authority&#x27;Vue.component(&#x27;authority&#x27;, Authority) 使用过滤器Vue 提供了自定义过滤器的功能，主要应用场景是想要将数据以某种格式展示出来，而原始数据又不符合这种格式的时候。比如有一组关于人的数据，如下： 1234567891011121314[ &#123; &quot;name&quot;: &quot;张茂&quot;, &quot;population&quot;: &quot;young&quot; &#125;, &#123; &quot;name&quot;: &quot;王丽&quot;, &quot;population&quot;: &quot;middle&quot; &#125;, &#123; &quot;name&quot;: &quot;郝鹏程&quot;, &quot;population&quot;: &quot;child&quot; &#125;] 其中有一项是关于按照年龄划分的群体类型 population，而它是用 code 进行标识的，我们希望在展示的时候能够显示成对应的中文意思，比如 young 显示成青年。那我们就可以定义一个如下的局部过滤器： 12345678910111213export default &#123; filters: &#123; popuFilters(value) &#123; if (!value) &#123; return &#x27;未知&#x27; &#125; let index = [&#x27;child&#x27;, &#x27;lad&#x27;, &#x27;young&#x27;, &#x27;middle&#x27;, &#x27;wrinkly&#x27;].indexOf(value) return ( (index &gt; 0 &amp;&amp; [&#x27;儿童&#x27;, &#x27;少年&#x27;, &#x27;青年&#x27;, &#x27;中年&#x27;, &#x27;老年&#x27;][index]) || &#x27;未知&#x27; ) &#125;, &#125;,&#125; 使用过滤器的时候只要在 template 中这样使用即可： 1&lt;p&gt;&#123;&#123; item.population | popuFilters &#125;&#125;&lt;/p&gt; 自定义插件在某些情况下，我们封装的内容可能不需要使用者对其内部代码结构进行了解，其只需要熟悉我们提供出来的相应方法和 api 即可，这需要我们更系统性的将公用部分逻辑封装成插件，来为项目添加全局功能，比如常见的 loading 功能、弹框功能等。 开发 Vue 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象。可以通过如下 4 种方式来自定义插件： 123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或 property Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive(&#x27;my-directive&#x27;, &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; 然后需要在入口文件，比如 main.js 中注册插件： 12import MyPlugin from &#x27;./plugins/plugins.js&#x27;Vue.use(MyPlugin) 3 种方式手写优雅代码平时写项目的时候我们都是在第一时间完成需求功能的开发、提测修改 bug 等，然后开开心心的等待着发布生产以为没啥事情了。其实回过头来细细的看我们平时写的代码，可能会发现很多地方都是值得优化的，比如对于很多重复性很强的代码，比如对于某些写得很繁杂的地方。优雅的代码可以化机械为自动、化繁为简，看人开了如沐春风，心情大好。这里列了几个在 Vue 中一定会遇到的问题，然后通过优雅的方式进行解决。 自动化导入模块在开发一个稍微大点的项目的时候，会习惯将路由按照模块来划分，然后就可能会出现如下这种代码： 123456789101112131415161718192021222324252627// router.jsimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;// 导入了一大堆路由文件import mediator from &#x27;./mediator&#x27;import judges from &#x27;./judges&#x27;import disputeMediation from &#x27;./disputeMediation&#x27;import onlineMediation from &#x27;./onlineMediation&#x27;import useraction from &#x27;./useraction&#x27;import organcenter from &#x27;./organcenter&#x27;import admin from &#x27;./admin&#x27;let routeList = []routeList.push( mediator, judges, disputeMediation, onlineMediation, useraction, organcenter, admin)export default new Router(&#123; mode: &#x27;history&#x27;, routes: routeList,&#125;) 其实真实的远远不止这么点，就我本地项目而言就有 20 几个路由文件，写了一大堆的导入代码，显得很臃肿，更无奈的是每当需要新增一个路由模块，还得再次 import 再次 push，那么有没有什么办法可以解决这个问题呢？答案自然是有的。 利用 webpack 的 require.context 就可以很优雅的解决这个问题，使用语法如下： 123456require.context( directory, // 搜索的目录 (useSubdirectories = true), // 是否搜索子目录 (regExp = /^\\.\\/.*$/), // 匹配的目标文件格式 (mode = &#x27;sync&#x27;) // 同步还是异步) 有了这个语法，我们就能很容易的写出下面的代码： 123456789101112131415161718import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;let routeList = []let importAll = require.context(&#x27;@/publicResource/router&#x27;, false, /\\.js$/)importAll.keys().map((path) =&gt; &#123; // 因为 index.js 也在 @/publicResource/router 目录下，所以需要排除 if (!path.includes(&#x27;index.js&#x27;)) &#123; //兼容处理：.default 获取 ES6 规范暴露的内容; 后者获取 commonJS 规范暴露的内容 let router = importAll(path).default || importAll(path) routeList(router) &#125;&#125;)export default new Router(&#123; mode: &#x27;history&#x27;, routes: routeList,&#125;) 其实不仅仅只是用在导入路由模块这里，对于项目里任何需要导入大量本地模块的地方都可以使用这种方式来解决。 模块化注册插件相信写 Vue 的同学们都知道 element-ui 这个组件库，在使用这个组件库的时候大部分都是只使用某些个别的组件，所以基本上都是按需引入需要的组件，然后就有如下一堆 Vue.use() 的代码： 123456789101112131415161718// main.jsimport Vue from &#x27;vue&#x27;import &#123; Input, Radio, RadioGroup, Checkbox, CheckboxGroup, Select, // 还有很多组件&#125; from &#x27;element-ui&#x27;Vue.use(Input)Vue.use(Radio)Vue.use(RadioGroup)Vue.use(Checkbox)Vue.use(CheckboxGroup)Vue.use(Select) 这样写是没任何问题的，就是看着不够简洁舒服，那更优雅的做法是把这块逻辑抽到一个文件里，然后通过注册插件的方式来使用他们： 1234567891011121314151617181920212223// elementComponent.jsimport &#123; Input, Radio, RadioGroup, Checkbox, CheckboxGroup, Select, // 还有很多组件&#125; from &#x27;element-ui&#x27;const components = &#123; Input, Radio, RadioGroup, Checkbox, CheckboxGroup, Select,&#125;function install(Vue) &#123; Object.keys(components).forEach((key) =&gt; Vue.use(components[key]))&#125;export default &#123; install &#125; 然后在 main.js 里使用这个插件： 1234// main.jsimport Vue from &#x27;vue&#x27;import elementComponent from &#x27;./config/elementComponent&#x27;Vue.use(elementComponent) 优雅导出请求接口不知道大伙是如何定义请求接口的，就我目前这个项目而言，是这么做的： 1234567891011121314151617// api.jsimport http from &#x27;./config/httpServer.js&#x27;/* 登入页面获取公钥 */export const getPublicKey = (data) =&gt; &#123; return http(&#123; url: &#x27;/userGateway/user/getPublicKey&#x27; &#125;, data)&#125;// 用户登录export const login = (data) =&gt; &#123; return http(&#123; url: &#x27;/userGateway/userSentry/login&#x27; &#125;, data)&#125;// 验证码登录export const loginByCode = (data) =&gt; &#123; return http(&#123; url: &#x27;/userGateway/userSentry/loginByCode&#x27; &#125;, data)&#125; 在组件中使用接口： 123456789101112&lt;script&gt;import &#123; getPublicKey &#125; from &#x27;./config/api.js&#x27;export default &#123; mounted() &#123; getPublicKey().then(res =&gt; &#123; // xxx &#125;).catch(err =&gt; &#123; // xxx &#125;) &#125;&#125;&lt;/script&gt; 这一切都很正常，但，我们这个项目总共有 200 多个接口，按照上面这种定义方式的话，一个接口定义加上空行需要占用 5 行，所以如果把全部接口都定义到这个 api.js 里需要占用 1000 行左右，看了实在让人心很慌呀。所以觉得应该这个地方应该可以优化一下。 1/userGateway/user/getPublicKey 上面这是一个后端给接口路径，斜杆把这个路径划分成 3 个子串，而最后一个子串必定是唯一的，所以我们可以从中做文章。于是乎就有了下面的代码： 1234567891011121314151617// api.jsconst apiList = [ &#x27;/userGateway/user/getPublicKey&#x27;, // 登入页面获取公钥 &#x27;/userGateway/userSentry/login&#x27;, // 用户登录 &#x27;/userGateway/userSentry/loginByCode&#x27;, // 验证码登录]let apiName, API = &#123;&#125;apiList.forEach((path) =&gt; &#123; // 使用正则取到接口路径的最后一个子串，比如: getPublicKey apiName = /(?&lt;=\\/)[^/]+$/.exec(path)[0] API[apiName] = (data) =&gt; &#123; return http(&#123; url: path &#125;, data) &#125;&#125;)export &#123; API &#125; 这样大概就把定义一个接口需要占用 5 行缩小到只需要 1 行了，大大减小了文件内容。在浏览这个文件的时候，我的鼠标滚轮也不会一直在滚滚滚了。 如果是这样定义接口的话，那在使用的时候还需要做点变化的： 123456789101112&lt;script&gt;import &#123; API &#125; from &#x27;./config/api.js&#x27;export default &#123; mounted() &#123; API.getPublicKey().then(res =&gt; &#123; // xxx &#125;).catch(err =&gt; &#123; // xxx &#125;) &#125;&#125;&lt;/script&gt; 4 种$event 传参方式在进行实际项目开发的时候经常会需要通过事件传递参数，这里总结了 4 种应用场景。 用于组件通信比如子组件通过 $emit 来调用父组件方法的时候，可以在父组件中用 $event 接收到从子组件传递过来的参数： 12&lt;!-- 子组件 --&gt;&lt;button @click=&quot;$emit(&#x27;changeText&#x27;, &#x27;18px&#x27;)&quot;&gt;点击加大字号&lt;/button&gt; 12&lt;!-- 父组件 --&gt;&lt;blog-post @changeText=&quot;changeText(&#x27;article&#x27;, $event)&quot;&gt;&lt;/blog-post&gt; 123changeText(type, value) &#123; console.log(type, value) // &#x27;article&#x27; &#x27;18px&#x27;&#125; 如果子组件传递过来的参数有多个，这个时候用 $event 就不太行了，此时可以用 arguments 代替： 12&lt;!-- 子组件 --&gt;&lt;button @click=&quot;$emit(&#x27;changeText&#x27;, &#x27;red&#x27;, &#x27;18px&#x27;)&quot;&gt;点击改变样式&lt;/button&gt; 12&lt;!-- 父组件 --&gt;&lt;blog-post @changeText=&quot;changeText(...arguments, &#x27;article&#x27;)&quot;&gt;&lt;/blog-post&gt; 123changeText(...value) &#123; console.log( value ) // [&#x27;red&#x27;, &#x27;18px&#x27;, &#x27;article&#x27;]&#125; 传递原生 DOM 事件对象比如我们需要获取到当前的点击元素，就可以通过给点击事件传递 $event 参数： 1&lt;button @click=&quot;submit(&#x27;first&#x27;, $event)&quot;&gt;提交&lt;/button&gt; 123submit(type, event) &#123; const target = event.target.tagName&#125; 用于第三方类库事件回调比如有一个组件里使用了好几个 element-ui 的分页组件，每个分页都有一个 current-change 事件，用来处理当分页改变之后的事情，这样的话我们就需要写多个回调函数，但是如果用以下方式，我们就也可以只写一个函数，通过 type 来判断是哪个分页的回调，而 $event 则用来传递 current-change 回调默认的参数： 12345678&lt;!-- 页面列表的分页 --&gt;&lt;el-pagination @current-change=&quot;changePage(&#x27;main&#x27;, $event)&quot;&gt; &lt;/el-pagination&gt;&lt;!-- 弹窗A列表的分页 --&gt;&lt;el-pagination @current-change=&quot;changePage(&#x27;modalA&#x27;, $event)&quot;&gt; &lt;/el-pagination&gt;&lt;!-- 弹窗B列表的分页 --&gt;&lt;el-pagination @current-change=&quot;changePage(&#x27;modalB&#x27;, $event)&quot;&gt; &lt;/el-pagination&gt; 1234changePage(type, page) &#123; const types = [&#x27;main&#x27;, &#x27;modalA&#x27;, &#x27;modalB&#x27;] types[type] &amp;&amp; (this[types[type]].pageIndex = page) &amp;&amp; this.getList(type)&#125; 使用箭头函数处理对于第三种场景，使用第三方类库组件的时候，需要给事件回调增加额外的参数，如果默认的回调参数只有 1 个那么我们就可以使用上面的那种方式，但是如果回调参数有多个的话，用 $event 就不好处理了，可以使用箭头函数。比如文件上传的时候，有个 on-change 属性，当文件变化的时候就会触发回调，正常情况下我们这样写是没问题的： 123&lt;el-upload :on-change=&quot;changeFile&quot;&gt; &lt;el-button&gt;上传&lt;/el-button&gt;&lt;/el-upload&gt; 1changeFile(file, fileList) &#123;&#125; 但是如果一个组件里有多个文件上传，而我们又不想写多个 changeFile，那就需要传递额外的参数 type 了 ： 123&lt;el-upload :on-change=&quot;(file, fileList) =&gt; changeFile(&#x27;org&#x27;, file, fileList)&quot;&gt; &lt;el-button&gt;上传&lt;/el-button&gt;&lt;/el-upload&gt; 1changeFile(type, file, fileList) &#123;&#125; 3 种深入 watch 的用法立即执行watch 是 Vue 中的侦听器，可以侦听一个 Vue 实例上的数据，当数据变动的时候，就会触发该侦听器。所以他的应用场景就是：当某个数据变动后需要做什么的时候就可以使用 watch 啦。对于 watch，平常我们写得最多的估计是如下这种写法： 12345watch: &#123; list: function(val) &#123; this.getMsg() &#125;&#125; 如果我们希望组件初始化的时候就执行一次 getMsg 方法，可以直接在 mounted 里调用： 123mounted() &#123; this.getMsg()&#125; 其实，还有一种更加简便的写法，通过给 watch 设置 immediate: true ，即可： 12345678watch: &#123; list: &#123; handler(val) &#123; // 注意别写错成 handle this.getMsg() &#125;, immediate: true &#125;&#125; 深度监听侦听器对于属性变更后会自动调用一次，但是仅限于该属性本身，如果变更的是属性的属性，则不会触发侦听回调，如果想要实现这个功能可以给 watch 加上 ‘deep: true’ 即可： 123456789watch: &#123; obj: &#123; handler(val) &#123; // do something &#125;, deep: true &#125;&#125;,mounted() &#123; this.obj.name = &#x27;bubuzou&#x27; // 将触发 handler&#125; 多个 handlers实际上，watch 可以设置为数组，支持类型为 String、Object 和 Function。触发后，多个处理函数都将被调用。 1234567891011121314151617watch: &#123; obj: [ &#x27;print&#x27;, &#123; handler: &#x27;print&#x27;, deep: true &#125;, function(val, oldValue) &#123; console.log(val) &#125; ]&#125;,methods: &#123; print() &#123; console.log(this.obj) &#125;&#125; 5 个其他开发小技巧掌握 Vue 的开发小技巧，在一些特定的场景下真的很管用，这里列了一些常用的小技巧。 函数式组件实现零时变量我们在使用插槽的时候，知道有一个叫做插槽 prop 的知识，今天我们用他和函数式组件结合在一块，实现一个零时变量的组件： 12345678910// tempvar.vue&lt;script&gt;export default &#123; functional: true, render(h, context) &#123; const &#123; props, scopedSlots&#125; = context return scopedSlots.default &amp;&amp; scopedSlots.default(props || &#123;&#125;) &#125;&#125;&lt;/script&gt; 定义好了函数式组件，我们就可以在需要的地方引入且使用他： 1234567891011121314151617181920212223&lt;template&gt; &lt;tempvar :var1=&quot;`hello $&#123;user.name&#125;`&quot; :var2=&quot;user.age ? user.age : &#x27;18&#x27;&quot;&gt; &lt;template v-slot=&quot;&#123;var1, var2&#125;&quot;&gt; 姓名： &#123;&#123; var1 &#125;&#125; 年龄：&#123;&#123; var2 &#125;&#125; &lt;/template&gt; &lt;/tempvar&gt;&lt;/template&gt;&lt;script&gt; import tempvar from &#x27;@/components/tempvar.vue&#x27; export default &#123; data() &#123; return &#123; user: &#123; name: &#x27;bubuzou&#x27;, age: 12, &#125;, &#125; &#125; components: &#123; tempvar &#125; &#125;&lt;/script&gt; 可能细心的小伙伴发现了，要把名字前加个 hello、默认年龄设置为 18 用计算属性就可以了呀？为啥还要搞那么复杂，专门用一个函数式组件去实现呢？其实这个小技巧还是很有必要存在的，当许多组件都有这种数据的重新计算的时候，如果没有使用这个技巧，那么就需要写很多很多的计算属性，而有了函数式组件 tempvar 后，只需要在组件里引入他，然后写插槽就好了。就相当于把写计算属性的功夫花在了写插槽上了。总而言之，两种方式都可以实现类似的属性计算功能，该怎么选，随你喜欢啦。 调试 template（不推荐）在开发调试的时候经常会需要通过 console.log 来打印出某个数据对象来查看其内部的结构或者字段值，但是这样做肯定不必在 template 里将其输出更直接。比如有这样一个数据： 1234obj: &#123; name: &#x27;bubuzou&#x27;, age: 21,&#125; 在模板中展示： 1&lt;p&gt;&#123;&#123; obj &#125;&#125;&lt;/p&gt; 页面渲染完成后会看到： 1&#123; &quot;name&quot;: &quot;bubuzou&quot;, &quot;age&quot;: 21 &#125; 对于这样的渲染结果虽然没什么问题，但是如果这个 obj 是层级很深且字段很多的数据，显示出来就会一堆数据砸在一块，丝毫没有阅读体验。 因此基于这个背景，我们可以将 console.log 挂载在 Vue 的实例原型上： 12// main.jsVue.prototype.$log = window.console.log 然后就可以开开心心在模板中使用他了： 1&lt;p&gt;&#123;&#123; $log( obj ) &#125;&#125;&lt;/p&gt; 这样会在浏览器控制台输出当前的数据对象，在显示效果上和 console.log 直接打印别无二致。 但说了这么多，使用 Vue 进行开发调试还是强烈推荐官方的vue-devtools 工具，谁用谁知道。 监听子组件的钩子函数通常如果我们想在子组件钩子函数触发的时候通知父组件，我们可以这样做： 12&lt;!-- parent.vue --&gt;&lt;child @mounted=&quot;doSomething&quot;&gt;&lt;/child&gt; 12// child.vuethis.$emit(&#x27;mounted&#x27;) 其实还有一种更加简单的写法，那就是使用 hookEvent： 1&lt;child @hook:mounted=&quot;doSomething&quot;&gt;&lt;/child&gt; 钩子函数除了以上用法，还可以通过动态注册做一些别的事情，比如组件销毁前进行资源的释放： 12345678910mounted() &#123; let setIntervalId = setInterval(() =&gt; &#123; console.log(888); &#125;, 1000) this.$once(&quot;hook:beforeDestroy&quot;, () =&gt; &#123; clearInterval(setIntervalId) setIntervalId = null &#125;)&#125; 路由参数解耦参数解耦，啥意思呢？别着急，我们先来看比如对于这么一串路由： 1234567const router = [ &#123; path: &#x27;/home/:type/:id&#x27;, name: &#x27;Home&#x27;, component: Home, &#125;,] 当前页面的路径是 http://xxx/detail/preview/21?sex=male，平时我们写代码的时候或多或少的会写出这种代码，在组件里使用 $route 给组件传参数： 123456789mounted() &#123; if (this.$route.params.type === &#x27;preview&#x27;) &#123; this.isPreview = true &#125; else &#123; this.isPreview = false &#125; this.id = this.$route.params.id this.sex = this.$route.query.sex&#125; 这样子写本身没什么问题，就是会使得组件和路由高度耦合，让组件只能在含有特定 URL 的页面中使用，限制了组件的通用性。其实，我们可以通过 props 传参，来解耦路由参数，将上面的路由配置改成如下： 123456789101112const router = [ &#123; path: &#x27;/home/:type/:id&#x27;, name: &#x27;Home&#x27;, component: Home, props: (route) =&gt; (&#123; type: route.params.type, id: route.params.id, sex: route.query.sex, &#125;), &#125;,] 然后在组件 props 加上参数： 1props: [&#x27;type&#x27;, &#x27;id&#x27;, &#x27;sex&#x27;] 组件里使用参数的时候就不需要用 this.$route，而是可以直接 this.type 即可。这样一来，这个组件就可以在任何地方使用了。 深度作用选择器当给 style 加上 scoped，页面渲染完成后会给 html 和 css 选择器加上哈希值用于表示唯一性： 123&lt;div class=&quot;home&quot; data-v-fae5bece&gt; &lt;button data-v-fae5bece class=&quot;el-button el-button-primary&quot;&gt;提交&lt;/button&gt;&lt;/div&gt; 123.home .el-button[data-v-fae5bece] &#123; font-size: 20px;&#125; 对于在 style 中被加了 scoped 的组件，其样式将只能作用于组件内部，不会对其子组件造成影响。比如有这样一个组件： 1234567891011&lt;!-- 父组件 --&gt;&lt;div class=&quot;home&quot;&gt; &lt;el-button type=&quot;primary&quot;&gt;父按钮&lt;/button&gt; &lt;child&gt;&lt;/child&gt;&lt;/div&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.home .el-button &#123; font-size: 20px;&#125;&lt;/style&gt; 1234&lt;!-- 子组件 --&gt;&lt;div class=&quot;child&quot;&gt; &lt;el-button type=&quot;primary&quot;&gt;子按钮&lt;/button&gt;&lt;/div&gt; 当页面渲染出来后，会是如下结果： 123456&lt;div class=&quot;home&quot; data-v-fae5bece&gt; &lt;button data-v-fae5bece class=&quot;el-button el-button-primary&quot;&gt;父按钮&lt;/button&gt; &lt;div class=&quot;child&quot; data-v-fae5bece&gt; &lt;button class=&quot;el-button el-button-primary&quot;&gt;子按钮&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 根据上面的 html，我们可以看到 .home .el-button[data-v-fae5bece] 这个选择器作用不到子按钮这个 button。 在实际项目中，我们有时候需要让父组件的样式能作用到子组件，即使父组件的 style 上加了 scoped，那这个时候就需要用到深度作用选择器 &gt;&gt;&gt;，比如在刚刚的例子上可以给父组件样式加上深度作用选择器。 深度作用选择器会被 Vue Loader 处理，且只能在有预处理器的地方使用。由于某些预处理器比如 Sass 不能正确解析 &gt;&gt;&gt;，所以我们可以使用它的别名：/deep/ 或 ::v-deep 来替代。 1234567&lt;style lang=&quot;scss&quot; scoped&gt;.home &#123; /deep/ .el-button &#123; font-size: 20px; &#125;&#125;&lt;/style&gt; 加上深度作用选择器后，选择器会由原来的： 12.home .el-button[data-v-fae5bece] &#123;&#125; 变成如下的： 12.home[data-v-fae5bece] .el-button &#123;&#125; 参考文章 vue 篇之事件总线（EventBus） 《Vue 开发实战》 感谢阅读如果本文对你有帮助的话，给本文点个在看吧","categories":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/tags/vue/"}]},{"title":"小程序升级WePY2踩坑记","slug":"wepy2","date":"2020-08-06T13:39:57.000Z","updated":"2021-09-09T02:01:11.004Z","comments":true,"path":"2020/08/06/wepy2/","link":"","permalink":"https://bubuzou.com/2020/08/06/wepy2/","excerpt":"最近有个小程序项目需要迭代，但是迭代任务不多，时间比较充裕。而这个小程序最早是在 18 年的时候开发的，用的开发框架是 WePY 的 1.7.2 版本，去年也就是 19 年的时候 WePY 框架进行了升级，到了 2.0 版本。升级之后的 WePY，用 WePY 官方文档的话来说：通过优化细节，引入 Promise、Async Functions 等让开发小程序项目变得更加简单，高效。基于这些背景，我和小伙伴一拍即合，决定对我们的项目进行框架升级，体验下到底 WePY2 能给我们带来什么。 本文将以项目改动为出发点，基于当前这个项目的结构和编码方式来考虑到底升级 WePY2 后，哪里需要改，怎么改以及有哪些需要注意的地方，通过对比 2 个版本的写法差异这个思路来写，不会去太较真 WePY2 相对于 WePY1 实现或原理上的区别。下面我将一条一条的列出来需要改动的点。 本篇文章记录的是我和小伙伴这次升级框架遇到的需要改动的地方和坑，所使用的是 wepy 的 2.1.0 版本，后续如果版本升级后，本篇记录到的坑如果已经被修复了，请自行忽略本文所述的问题。另外下文中所说到的 2.x 版本都是指 wepy_v2.1.0。","text":"最近有个小程序项目需要迭代，但是迭代任务不多，时间比较充裕。而这个小程序最早是在 18 年的时候开发的，用的开发框架是 WePY 的 1.7.2 版本，去年也就是 19 年的时候 WePY 框架进行了升级，到了 2.0 版本。升级之后的 WePY，用 WePY 官方文档的话来说：通过优化细节，引入 Promise、Async Functions 等让开发小程序项目变得更加简单，高效。基于这些背景，我和小伙伴一拍即合，决定对我们的项目进行框架升级，体验下到底 WePY2 能给我们带来什么。 本文将以项目改动为出发点，基于当前这个项目的结构和编码方式来考虑到底升级 WePY2 后，哪里需要改，怎么改以及有哪些需要注意的地方，通过对比 2 个版本的写法差异这个思路来写，不会去太较真 WePY2 相对于 WePY1 实现或原理上的区别。下面我将一条一条的列出来需要改动的点。 本篇文章记录的是我和小伙伴这次升级框架遇到的需要改动的地方和坑，所使用的是 wepy 的 2.1.0 版本，后续如果版本升级后，本篇记录到的坑如果已经被修复了，请自行忽略本文所述的问题。另外下文中所说到的 2.x 版本都是指 wepy_v2.1.0。 初始化一个 WePY2 的 demo由于本地还有其他项目用的是 WePY_v1.7.2，所以我们不能把 WePY2 的 CLI 工具安装在全局环境中，只能安装在当前项目中。官方推荐是直接用 1.7.x 的 CLI 去初始化 2.0.x 的项目: 1wepy init standard#2.0.x zzodr 这样就能够在本地初始化一个 wepy2 的项目模板，但是 @wepy/core 是 2.0.0-alpha.16 版本的，将它更新到最新的 2.1.0 版本，这里也一起更新下整个旧项目和新模板所用到的依赖，下面直接贴出来： 123456789101112131415161718192021222324252627&#123; &quot;dependencies&quot;: &#123; &quot;@wepy/core&quot;: &quot;^v2.1.0&quot;, &quot;@wepy/use-intercept&quot;: &quot;^2.1.0&quot;, &quot;@wepy/use-promisify&quot;: &quot;^2.1.0&quot;, &quot;@wepy/x&quot;: &quot;^2.0.2&quot;, &quot;miniprogram-slide-view&quot;: &quot;0.0.3&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.1.0&quot;, &quot;@babel/preset-env&quot;: &quot;^7.1.0&quot;, &quot;@wepy/babel-plugin-import-regenerator&quot;: &quot;0.0.2&quot;, &quot;@wepy/cli&quot;: &quot;^2.1.0&quot;, &quot;@wepy/compiler-babel&quot;: &quot;^2.0.1&quot;, &quot;@wepy/compiler-sass&quot;: &quot;^2.1.0&quot;, &quot;@wepy/plugin-define&quot;: &quot;^2.1.0&quot;, &quot;babel-eslint&quot;: &quot;^7.2.1&quot;, &quot;cross-env&quot;: &quot;^5.1.3&quot;, &quot;eslint&quot;: &quot;^3.18.0&quot;, &quot;eslint-config-standard&quot;: &quot;^7.1.0&quot;, &quot;eslint-friendly-formatter&quot;: &quot;^2.0.7&quot;, &quot;eslint-plugin-html&quot;: &quot;^2.0.1&quot;, &quot;eslint-plugin-promise&quot;: &quot;^3.5.0&quot;, &quot;eslint-plugin-standard&quot;: &quot;^2.0.1&quot;, &quot;wepy-eslint&quot;: &quot;^1.5.3&quot; &#125;&#125; 接下来操作主要是删除模板里的代码，然后把项目的结构和代码搬过去。 wpy 文件代码结构调整WePy 单文件组件主要由 &lt;script&gt;、&lt;template&gt;、&lt;style&gt;、&lt;config&gt; 四部分组成（也包括小程序 &lt;wxs&gt; 标签）。所以需要把 WePY 1.7.2 中定义在 &lt;script&gt; 中的 config 配置需要独立到外层的 &lt;config&gt; 中。1.7.2 写法： 123456789&lt;template&gt;&lt;/template&gt;&lt;script&gt; export default class Home extends wepy.page &#123; config = &#123; navigationBarTitleText: &#x27;首页&#x27;, &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 2.x 写法： 1234&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;config&gt; &#123; navigationBarTitleText: &#x27;首页&#x27; &#125; &lt;/config&gt;&lt;style&gt;&lt;/style&gt; 程序/页面/组件注册方式调整注册方式将不再使用继承的方式，而是改成直接调用对应的实例方法。1.7.2 写法： 123export default class APP extends wepy.app &#123;&#125; // 注册程序export default class HOME extends wepy.page &#123;&#125; // 注册页面export default class LIST extends wepy.component &#123;&#125; // 注册组件 2.x 写法： 123wepy.app(&#123;&#125;) // 注册程序wepy.page(&#123;&#125;) // 注册页面wepy.component(&#123;&#125;) // 注册组件 代码结构由类结构变成对象结构由于注册方式的改变，那么自然的代码结构也要有所调整。1.7.2 写法： 123456export default class HOME extends wepy.page &#123; data = &#123;&#125; methods = &#123;&#125; onLoad() &#123;&#125; onShow() &#123;&#125;&#125; 2.x 写法： 123456wepy.page(&#123; data: &#123;&#125;, methods: &#123;&#125;, onLoad() &#123;&#125;, onShow() &#123;&#125;,&#125;) 上面仅仅只是以页面做为例子，wepy.app() 和 wepy.component() 也要对应调整。 自定义方法和组件事件处理函数需要移到 methods 里在 WePY 1.7.2 中注册的页面或者组件函数有这么几种类型： 生命周期函数，比如 onLoad、onShow 等； wxml 事件处理函数，即在 wxml 中绑定的事件，这类函数需要定义在 methods，比如：bindtap、bindchange 等； 组件间事件处理函数，响应组件之间通过 $broadcast、$emit、$invoke 所传递的事件函数，这类函数需要定义在 events 对象里； 自定义函数，即用于被其他函数直接调用的函数，需要定义在和 methods 同级的位置。 而在 WePY 2 中需要将组件处理函数和自定义函数都放到 methods 里。下面假设 HOME 页面有一个子组件 child，且子组件里会执行这句 this.$emit(&#39;updateList)，基于这个背景看下 2 个版本下的写法差异： 1.7.2 写法： 12345678910111213141516171819202122&lt;template&gt; &lt;view&gt; &lt;view bindtap=&quot;tapBox&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default class HOME extends wepy.page &#123; data = &#123;&#125; onLoad() &#123;&#125; // 生命周期函数 onShow() &#123;&#125; // 生命周期函数 events = &#123; updateList: () =&gt; &#123;&#125;, // 组件间事件处理函数 &#125; methods = &#123; tapBox() &#123; // wxml事件处理函数 this.getMsg() &#125;, &#125; getMsg() &#123;&#125; // 自定义函数 &#125;&lt;/script&gt; 2.x 写法： 1234567891011121314151617181920&lt;template&gt; &lt;view&gt; &lt;view @tap=&quot;tapBox&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; wepy.page(&#123; data: &#123;&#125;, onLoad() &#123;&#125;, // 生命周期函数 onShow() &#123;&#125;, // 生命周期函数 methods: &#123; tapBox() &#123; // wxml事件处理函数 this.getMsg() &#125;, updateList() &#123;&#125;, // 组件间事件处理函数 getMsg() &#123;&#125;, // 自定义函数 &#125;, &#125;)&lt;/script&gt; 组件引入方式变更在 2.x 版本中组件引入不再通过 import 进行导入，而是直接定义在页面的配置 &lt;config&gt; 中。1.7.2 写法： 12345678910111213&lt;template&gt; &lt;view&gt; &lt;child&gt;&lt;/child&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import Child from &#x27;./components/child.wpy&#x27; export default class HOME extends wepy.page &#123; components = &#123; child: Child, &#125; &#125;&lt;/script&gt; 2.x 写法： 123456789&lt;template&gt; &lt;view&gt; &lt;child&gt;&lt;/child&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; wepy.page(&#123;&#125;)&lt;/script&gt;&lt;config&gt; &#123; usingComponents: &#123; &#x27;child&#x27;: &#x27;./components/child.wpy&#x27;, &#125; &#125; &lt;/config&gt; 另外，2.x 中已经再不支持在 app.wpy 里定义全局组件，而 1.7.2 中是可以的。 生命周期函数调整在 2.x 中生命周期函数基本和原生保持一致，和 1.7.2 相比，只是需要把组件中的 onLoad 改成了 ready 即可，其他无需变动。 级别 1.7.2 2.x app onLaunch onLaunch app onShow onShow page onLoad onLoad page onShow onShow page onReady onReady component - created component - attached component onLoad ready 2.x 生命周期执行顺序： app onLaunch -&gt; app onShow -&gt; component created -&gt; component attached -&gt; page onLoad -&gt; page onShow -&gt; component ready -&gt; page onReady -&gt; page onUnload -&gt; component detached page onHide 在当前页面通过 wx.navigateTo 打开新页面的时候会执行，而如果是在当前页面点击返回上一个页面或者 wx.redirectTo 并不会执行。 不再支持请求拦截器（坑）在 1.7.2 中可以在 wepy.app 的构造函数里通过配置拦截器可以对请求进行拦截，请求被拦截后可以加上更多的请求参数以及请求响应后可以进行统一的错误处理，功能还是挺好用的。但是在 2.x 中这个功能至少从文档上是没看到，虽然源码里提供了一个 use-intercept拦截器的包，但是经过我几番尝试之后还是报错，所以就打算弃用拦截器了，直接在请求里进行参数增加和错误处理。request.js 这里贴一份大概的代码： 123456789101112131415161718192021222324import wepy from &#x27;@wepy/core&#x27;import &#123; HOST &#125; from &#x27;./constants&#x27;export default function (url, data, handler = toast, header = &#123;&#125;) &#123; // 头参数添加 header[&#x27;Content-Type&#x27;] = &#x27;application/json&#x27; header[&#x27;cType&#x27;] = &#x27;WECHAT&#x27; return wepy.wx .request(&#123; // 这里 wepy.wx.request 这种写法，需要在app.wpy里配置promisify， method: &#x27;POST&#x27;, data: data || &#123;&#125;, header, url: `$&#123;HOST&#125;$&#123;url&#125;`, &#125;) .then((data) =&gt; &#123; // 请求成功处理代码放这儿 return Promise.reject(data) &#125;) .catch((err) =&gt; &#123; // 错误处理代码放这儿 return Promise.reject(err) &#125;)&#125; 其中 wepy.wx.request 这种写法需要在 app.wpy 里配置 promisify，可以参考这里 use-promisify 标签属性的值必须被双引号包裹在 1.7.2 中对单引号和双引号没有强制要求，但是在 2.x 中必须是双引号，不然编译会报错。1.7.2 写法： 12345&lt;template&gt; &lt;view&gt; &lt;view class=&quot;title&quot; bindtap=&quot;change&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 2.x 写法： 12345&lt;template&gt; &lt;view&gt; &lt;view class&#x3D;&quot;title&quot; bindtap&#x3D;&quot;change&quot;&gt;&lt;&#x2F;view&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt; 调用原生事件需要传入参数$wx小程序原生事件会传递一个 event 参数。而 WePY 的事件分发器在处理事件时会有一个 $event 参数。 $event 参数是对 event 进行了一层包装，目地是为了无侵入地对齐 Web Event 标准属性。而其中 $event.$wx === event。 因此，WePY 中响应事件获得的事件参数均是指 $event。如果想拿到原生事件参数，请使用 $event.$wx。1.7.2 写法： 123456789101112131415&lt;template&gt; &lt;view&gt;&lt;input bindinput=&quot;setInput&quot; value=&quot;&#123;&#123;name&#125;&#125;&quot; /&gt;&lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default class HOME extends wepy.page &#123; data = &#123; name: &#x27;&#x27;, &#125; methods = &#123; setInput(e) &#123; this.name = e.detail.value &#125;, &#125; &#125;&lt;/script&gt; 2.x 写法，只需要将 bindinput=&quot;setInput&quot; 改成 @input=&quot;setInput($wx)&quot; 即可。 模板语法修改2.x 的模板语法继承了 WXML 的基本模板语法，并支持大部分 Vue 模板语法。对于标签：2.x 支持绝大部分的 HTML 标签，经过编译后会转成标准的 WXML 模板语法。但是对于 1.7.2 中的有一个标签 &lt;repeat&gt; 不再支持，需要将其替换成 &lt;view&gt; 并且用 v-for 进行循环渲染。 下面是一些常用的模板语法对于 2 个版本之间写法的对比：1.7.2 写法 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;view&gt; &lt;!-- 属性绑定 --&gt; &lt;view id=&quot;&#123;&#123; id &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;!-- 数据绑定 --&gt; &lt;view&gt;&#123;&#123; name &#125;&#125;&lt;/view&gt; &lt;!-- 事件绑定 --&gt; &lt;view bindtap=&quot;change(&#123;&#123; index &#125;&#125;)&quot;&gt;&lt;/view&gt; &lt;!-- class绑定 --&gt; &lt;view class=&quot;change &#123;&#123;hasData ? &#x27;has-data&#x27; : &#x27;&#x27; &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;!-- style绑定 --&gt; &lt;view style=&quot;&#123;&#123; &#x27;color:&#x27; + color + &#x27;;&#x27; + &#x27;font-size:&#x27; + fontSize + &#x27;;&#x27; &#125;&#125;&quot; &gt;&lt;/view&gt; &lt;!-- 条件判断 --&gt; &lt;view wx:if=&quot;&#123;&#123; flag1 &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;view wx:elif=&quot;&#123;&#123; flag2 &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;view wx:else&gt;&lt;/view&gt; &lt;!-- 显示判断 --&gt; &lt;view hidden=&quot;&#123;&#123; !isShow &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;!-- 列表渲染，默认是：item、index --&gt; &lt;view wx:for=&quot;&#123;&#123; array &#125;&#125;&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 2.x 写法： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;view&gt; &lt;!-- 属性绑定 --&gt; &lt;view :id=&quot;id&quot;&gt;&lt;/view&gt; &lt;!-- 数据绑定 --&gt; &lt;view&gt;&#123;&#123; name &#125;&#125;&lt;/view&gt; &lt;!-- 事件绑定 --&gt; &lt;view @tap=&quot;change( index )&quot;&gt;&lt;/view&gt; &lt;!-- class绑定 --&gt; &lt;view class=&quot;change&quot; :class=&quot;&#123; &#x27;has-data&#x27;: hasData &#125;&quot;&gt;&lt;/view&gt; &lt;!-- style绑定 --&gt; &lt;view :style=&quot;&#123;&#x27;color&#x27;: color, &#x27;font-size&#x27;: fontSize &#125;&quot;&gt;&lt;/view&gt; &lt;!-- 条件判断 --&gt; &lt;view v-if=&quot;flag1&quot;&gt;&lt;/view&gt; &lt;view v-else-if=&quot;flag2&quot;&gt;&lt;/view&gt; &lt;view v-else&gt;&lt;/view&gt; &lt;!-- 显示判断 --&gt; &lt;view v-show=&quot;isShow&quot;&gt;&lt;/view&gt; &lt;!-- 列表渲染，默认是：item、index --&gt; &lt;view v-for=&quot;(item, index) in array&quot; :key=&quot;index&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 对于 v-for 循环列表的时候这里有一个（坑）不得不提一下，github issues直接看下面的代码： 1234&lt;view v-for=&quot;item in array&quot;&gt; &lt;view&gt;&#123;&#123; index &#125;&#125;&lt;/view&gt; &lt;view @tap=&quot;tapItem(index)&quot;&gt;&lt;/view&gt;&lt;/view&gt; 对于上面的代码，&lt;view&gt;&#123;&#123; index &#125;&#125;&lt;/view&gt; 可以正常显示索引值 index，但是 tapItem 传的参数却是 undefined，这所以我们需要显示的声明索引 v-for=&quot;(item, index) in array&quot; 即可。 表单双向绑定调整2.x 中直接用 v-model 进行表单绑定，而不需要再定义一个函数对其进行赋值操作。1.7.2 写法： 1234567891011121314&lt;template&gt; &lt;input value=&quot;&#123;&#123; name &#125;&#125;&quot; bindtap=&quot;setInput&quot; /&gt;&lt;/template&gt;&lt;script&gt;export default class HOME extends wepy.page &#123; data = &#123; name: &#x27;&#x27;, &#125; methods = &#123; bindtap(e) &#123; this.name = e.detail.value &#125; &#125;&#125; 2.x 写法： 123456789&lt;template&gt; &lt;input v-model=&quot;name&quot; /&gt;&lt;/template&gt;&lt;script&gt;wepy.page(&#123; data: &#123; name: &#x27;&#x27;, &#125;&#125;) 全局数据属性获取方式调整我们有时候需要在 app.wpy 里定义全局数据属性 globalData： 12345export default class APP extends wepy.app &#123; globalData = &#123; isBack: false, &#125;&#125; 在 2.x 中定义方式没变，但是获取方式有所调整： 12345// 1.7.2 获取方式console.log(this.$parent.globalData.isBack)// 2.x 获取方式console.log(this.$app.$options.globalData.isBack) 全局样式对组件无效2.x 中对组件的实现方式保留了很多原生小程序的特性，比如这一条，组件样式 中明确说明：除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项），虽然可以通过更改组件样式隔离选项使得组件可以被全局样式作用到，但有时候也会带来弊端，比如在标签的属性 class 前面加上 ~，可以使组件获取全局样式，但是这样一来也带来一个问题，就是定义在组件里的该 class 样式会失效 😭。这样的升级真的让写样式很难受，所以为了让样式写得尽量方便简单，我还是老老实实的把组件的样式就定义在组件里，不从全局拿样式了。 组件通信不再支持$broadcast父组件给子组件传递数据可以通过设置静态或者动态的 prop 属性或者通过广播 $broadcast 来让所有子组件都收到父组件的信息，而子组件给父组件通信可以通过在父级自定义事件，在子组件中通过 $emit 来通信。但是在 2.x 中不再支持父级给子组件进行事件广播了，而是可以通过给子组件加上 ref 属性后，通过 this.$refs 来直接操作子组件函数来达成通信的目的，如下代码：parent.wpy: 12345678910&lt;template&gt; &lt;child ref=&quot;child&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt; wepy.page(&#123; onLoad() &#123; this.$refs.child.getList() &#125;, &#125;)&lt;/script&gt; child.wpy： 1234567&lt;script&gt;wepy.component(&#123; methods: &#123; getList() &#123;&#125; &#125;&#125;)&lt;/script&gt; 组件 prop 不再支持双向绑定在 1.7.2 中可以通过可以通过设置 prop 给子组件传参，如果设置的时候加上 .sync 那么当父组件参数更新的时候，传递给子组件的也会自动更新，而如果在子组件的 prop 里加上 twoWay: true 则子组件数据可以绑定到父组件。从而实现组件数据的双向绑定。功能还是挺好用的，但遗憾的是在 2.x 中已经不再支持通过 twoWay: true 的方式从子组件绑定数据到父组件，父到子是可以的，但是不再需要设置 sync。那子组件需要更新父组件的数据，只能通过自定义事件，然后在子组件通过 $emit 进行更新数据了。1.7.2 写法：父页面： 123&lt;template&gt; &lt;child :title.sync=&quot;title&quot;&gt;&lt;/child&gt;&lt;/tempalte&gt; 子组件： 12export default class CHILD extends wepy.component &#123; props = &#123; title: &#123; type:String, default: &#x27;&#x27;, twoWay: true &#125; &#125; &#125; 2.x 写法：父页面： 123456789101112131415&lt;template&gt; &lt;child :title=&quot;title&quot; @changeTitle=&quot;changeTitle&quot;&gt;&lt;/child&gt;&lt;/tempalte&gt;&lt;script&gt; export default class HOME extends wepy.page &#123; data = &#123; title: &#x27;最开始的标题&#x27;, &#125; events = &#123; changeTitle(val) &#123; this.title = val &#125; &#125; &#125;&lt;/script&gt; 子组件： 12wepy.page(&#123; props: &#123; title: &#123; type: String, default: &#x27;&#x27;, &#125; &#125;, onLoad()&#123;this.$emit(&#x27;changeTitle&#x27;, &#x27;改变之后的标题&#x27;) &#125; &#125;) 组件插槽 slot 代码插入后层级错乱问题（坑）这个问题已经提到 github issues 中，且已经被作者标记为 bug。原始代码：parent.wpy 父页面： 123456&lt;template&gt; &lt;view&gt;parent&lt;/view&gt; &lt;child&gt; &lt;view&gt;child view&lt;/view&gt; &lt;/child&gt;&lt;/template&gt; child.wpy 子组件： 123456&lt;template&gt; &lt;view&gt; &lt;view&gt;child&lt;/view&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/view&gt;&lt;/template&gt; 期望的编译后（正确）的 template 是： 1234567&lt;template&gt; &lt;view&gt;parent&lt;/view&gt; &lt;view&gt; &lt;view&gt;child&lt;/view&gt; &lt;view&gt;child view&lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 而实际 2.x 编译后的 template 是会将对应的内容插入到子组件与根元素并列那级： 1234567&lt;template&gt; &lt;view&gt;parent&lt;/view&gt; &lt;view&gt; &lt;view&gt;child&lt;/view&gt; &lt;/view&gt; &lt;view&gt;child view&lt;/view&gt;&lt;/template&gt; 针对老项目里用到 slot 的地方，我只能改写代码来避开这个坑了。 资源引入调整资源引入方式调整主要是介绍组件引入和图片引入两种。首先来看组件引入： 12345678910&lt;config&gt;&#123; usingComponents: &#123; &#x27;load-more&#x27;: &#x27;/components/loadMore&#x27;, // 绝对路径 &#x27;btn&#x27;: &#x27;../btn&#x27;, // 相对路径 &#x27;list&#x27;: &#x27;~@/components/list&#x27;, // 通过wepy.config.js配置别名@指向src，实际上也是绝对路径 &#x27;van-icon&#x27;: &#x27;module:van-icon&#x27;, // 模块引入 &#125;&#125;&lt;/config&gt; 对于图片引入，存在两种方式：一种是静态的，程序在编译的时候就知道需要把哪些图片加载出来，另一种是动态的，只有在程序执行的时候才知道要加载哪些图片。对于第一种方式，通过相对路径、绝对路径或者 @ 都可以引入到图片： 1234567&lt;template&gt; &lt;view&gt; &lt;image src=&quot;../bg.png&quot;&gt;&lt;/image&gt; &lt;image src=&quot;/images/icon.png&quot;&gt;&lt;/image&gt; &lt;image src=&quot;@/images/nodata.png&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/template&gt; 对于第二种方式，需要将动态的图片放置在某个固定的位置，比如 /src/images/static，然后再 wepy.config.js 里配置 static: [&#39;/src/images/static&#39;] 这样在编译的时候就会把这个路径下的文件都拷贝到输出后的目录，从而能够准确引用这些动态图片。wepy.config.js 配置： 123module.exports = &#123; static: [&#x27;src/images/static&#x27;],&#125; 页面： 12345678910111213141516&lt;template&gt; &lt;view&gt; &lt;image :src=&quot;&#x27;../images/static/&#x27; + fileType + &#x27;.png&#x27;&quot;&gt;&lt;/image&gt; &lt;image :src=&quot;imgSrc&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; wepy.page(&#123; data: &#123; imgSrc: &#x27;&#x27;, &#125;, onLoad() &#123; this.imgSrc = &#x27;/images/static/icon.png&#x27; &#125;, &#125;)&lt;/script&gt; 静态图片特殊处理：单独放到一个目录里，然后再 WePY.config.js 里配置 static scss 里如果引入.wxss 文件会直接终止编译进程下面的代码是一个页面的 scss 样式里，引入了 wxss 文件，最终会导致编译进程终止。 1234&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt; @import &quot;./btn.scss&quot;; @import &quot;./styles/common.wxss&quot;;&lt;/style&gt; 解决办法： 123456&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt; @import &quot;./btn.scss&quot;;&lt;/style&gt;&lt;style lang=&quot;wxss&quot; type=&quot;text/wxss&quot;&gt; @import &quot;./styles/common.wxss&quot;;&lt;/style&gt; scss 样式里存在特殊字符会导致编译报错（坑）这里的特殊字符其实也是正常的需求，比如引入了字体图标，那可能会有这种样式 content: &#39;\\6499&#39;, 然后因为有反斜杠会直接导致报错编译错误。解决思路是把这种带有特殊字符的样式放到 wxss 里，然后通过另外一个 style 引入进来，编译器进行编译的时候会对 scss 样式进行编译处理，但是对于 wxss 会直接拷贝到输入目录，而不进行编译处理，所以能绕过这个坑。 123456789&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt; @import &quot;./btn.scss&quot;;&lt;/style&gt;&lt;style lang=&quot;wxss&quot; type=&quot;text/wxss&quot;&gt; .icon-success::after &#123; content: &#x27;\\e8921&#x27;; color: green; &#125;&lt;/style&gt; 数据绑定机制调整1.7.2 中用脏检查进行数据绑定，通过 $apply() 方法使得数据能够及时更新，页面重新渲染。在 2.x 中使用了 Vue Observer 实现数据绑定，告别 $apply()，但是遇到一个问题，某个数组项的某个属性更新后，数组虽然是更新了，但是不能够触发页面进行重新渲染，即使使用 splice 也不行。不过可以通过浅拷贝一个引用类型，重新赋值，从而触发页面重新渲染。 12345678910111213141516171819202122232425wepy.page(&#123; data: &#123; list: [ &#123; name: &#x27;aaa&#x27;, hasBorder: true, &#125;, &#123; name: &#x27;bbb&#x27;, hasBorder: false, &#125;, ], &#125;, methods: &#123; handleClick() &#123; this.list[1].hasBorder = true // 不会重新渲染页面 this.list.splice(1, 1, &#123; // 也不会重新渲染页面 name: &#x27;bbb&#x27;, hasBorder: true, &#125;) this.list = [...this.list] // 浅拷贝，使得this.list的引用地址变化了，使得页面重新渲染 &#125;, &#125;,&#125;)","categories":[{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"wepy","slug":"wepy","permalink":"https://bubuzou.com/tags/wepy/"}]},{"title":"JavaScript中的数据类型","slug":"js-datatype","date":"2020-07-29T06:11:02.000Z","updated":"2024-06-12T09:26:58.318Z","comments":true,"path":"2020/07/29/js-datatype/","link":"","permalink":"https://bubuzou.com/2020/07/29/js-datatype/","excerpt":"JavaScript 中有哪些数据类型？计算机世界中定义的数据类型其实就是为了描述现实世界中存在的事实而定义的。比如我们用人来举例： 有没有人在房间里？这里的有和没有就是是或者非的概念，在 JS 中对应 Boolean 类型，true 表示是，false 表示非； 有几个人在房间里？这里的几个表示的是一个量级概念，在 JS 中对应 Number 类型，包含整数和浮点数，还有一些特殊的值，比如：-Infinity 表示负无穷大、+Infinity 表示正无穷大、NaN 表示不是一个数字； 房间里的这些人都是我的朋友。这是一句陈述语句，这种文本类的信息将会以字符串形式进行存储，在 JS 中对应 String 类型； 房间里没有人。这里的没有代表无和空的概念，在 JS 中 null 和 undefined 都可以表示这个意思； 现实世界中所有人都是独一无二的，这在 JS 中对应 Symbol 类型，表示唯一且不可改变； Number 所表示的整数是有范围的，超出范围的数据就没法用 Number 表示了，于是 ES10 中提出了一种新的数据类型 BigInt，能表示任何位数的整数； 以上提到的 Boolean、Number、String、null、undefined、Symbol 和 BigInt 等 7 种类型都是 JavaScript 中的原始类型，还有一种是非原始类型叫做对象类型；比如：一个人是对象，这个人有名字、性别、年龄等； 12345let person = &#123; name: &#x27;bubuzou&#x27;, sex: &#x27;male&#x27;, age: 26,&#125;","text":"JavaScript 中有哪些数据类型？计算机世界中定义的数据类型其实就是为了描述现实世界中存在的事实而定义的。比如我们用人来举例： 有没有人在房间里？这里的有和没有就是是或者非的概念，在 JS 中对应 Boolean 类型，true 表示是，false 表示非； 有几个人在房间里？这里的几个表示的是一个量级概念，在 JS 中对应 Number 类型，包含整数和浮点数，还有一些特殊的值，比如：-Infinity 表示负无穷大、+Infinity 表示正无穷大、NaN 表示不是一个数字； 房间里的这些人都是我的朋友。这是一句陈述语句，这种文本类的信息将会以字符串形式进行存储，在 JS 中对应 String 类型； 房间里没有人。这里的没有代表无和空的概念，在 JS 中 null 和 undefined 都可以表示这个意思； 现实世界中所有人都是独一无二的，这在 JS 中对应 Symbol 类型，表示唯一且不可改变； Number 所表示的整数是有范围的，超出范围的数据就没法用 Number 表示了，于是 ES10 中提出了一种新的数据类型 BigInt，能表示任何位数的整数； 以上提到的 Boolean、Number、String、null、undefined、Symbol 和 BigInt 等 7 种类型都是 JavaScript 中的原始类型，还有一种是非原始类型叫做对象类型；比如：一个人是对象，这个人有名字、性别、年龄等； 12345let person = &#123; name: &#x27;bubuzou&#x27;, sex: &#x27;male&#x27;, age: 26,&#125; 为什么要区分原始类型和对象类型？他们之间有什么区别？原始类型的不可变性在回答这个问题之前，我们先看一下变量在内存中是如何存储的： 123let name1 = &#x27;bubuzou&#x27;let name2 = name1.concat(&#x27;.com&#x27;)console.log(name1) // &#x27;bubuzou&#x27; 执行完上面这段代码，我们发现变量 name1 的值还是不变，依然是 bubuzou。这就说明了字符串的不可变性。但是你看了下面的这段代码，你就会产生疑问了： 123let name1 = &#x27;bubuzou&#x27;name1 += &#x27;.com&#x27;console.log(name1) // &#x27;bubuzou.com&#x27; 你说字符串是不可变的，那现在不是变了嘛？其实这只是变量的值变了，但是存在内存中的字符串依然不变。这就涉及到变量在内存中的存储了。在 JavaScript 中，变量在内存中有 2 种存储方式：存在栈中和存在堆中。那么栈内存和堆内存有啥区别呢？ 栈内存： 顺序存储结构，特点是先进后出。就像一个兵乒球盒子一样，兵乒球从外面一个个的放入盒子里，最先取出来的一定是最后放入盒子的那个。 存储空间固定 可以直接操作其保存的值，执行效率高 堆内存： 无序的存储结构 存储空间可以动态变化 无法直接操作其内部的存储，需要通过引用地址操作 了解完变量在内存中的存储方式有 2 种，那我们继续以上面那串代码为例，画出变量的存储结构图：然后我们可以描述下当计算机执行这段代码时候的发生了什么？首先定义了一个变量 name1 并且给其赋值 bubuzou 这个时候就会在内存中开辟一块空间用来存储字符串 bubuzou，然后变量指向了这个内存空间。然后再执行第二行代码 let name2 = name1.concat(&#39;.com&#39;) 这里的拼接操作其实是产生了一个新字符串 bubuzou.com，所以又会为这个新字符串创建一块新内存，并且把定义的变量 name2 指向这个内存地址。 所以我们看到其实整个操作 bubuzou 这个字符串所在的内存其实是没有变化的，即使在第二段代码中执行了 name1 += &#39;.com&#39; 操作，其实也只是变量 name1 指向了新的字符串 bubuzou.com 而已，旧的字符串 bubuzou 依然存在内存中，不过一段时间后由于该字符串没有被变量所引用，所以会被当成垃圾进行回收，从而释放掉该块内存空间。 从而我们得出结论：原始类型的值都是固定的，而对象类型则是由原始类型的键值对组合成一个复杂的对象；他们在内存中的存储方式是不一样的，原始类型的值直接存在栈内存中，而对象类型的实际值是存在堆内存中的，在栈内存中保存了一份引用地址，这个地址指向堆内存中的实际值，所以对象类型又习惯被叫做引用类型。 想一个问题为什么引用类型的值要存储到堆内存中？能不能存到栈内存中呢？答案一：因为引用类型大小不固定，而栈的大小是固定的，堆空间的大小是可以动态变化的，所以引用类型的值适合存在堆中；答案二：在代码执行过程中需要频繁的切换执行上下文的时候，如果把引用类型的值存到栈中，将会造成非常大的内存开销。 比较当我们对两个变量进行比较的时候，不同类型的变量是有不同表现的： 1234567891011let str1 = &#x27;hello&#x27;let str2 = &#x27;hello&#x27;console.log(str1 === str2) // truelet person1 = &#123; name: &#x27;bubuzou&#x27;,&#125;let person2 = &#123; name: &#x27;bubuzou&#x27;,&#125;console.log(person1 === person2) // false 我们定义了 2 个字符串变量和 2 个对象变量，他们都长一模一样，但是字符串变量会相等，对象变量却不相等。这是因为在 JavaScript 中，原型类型进行比较的时候比较的是存在栈中的值是否相等；而引用类型进行比较的时候，是比较栈内存中的引用地址是否相等。如上几个变量在内存中的存储模型如图所示： 复制变量进行复制的时候，原始类型和引用类型变量也是有区别的，来看下面的代码： 1234let str1 = &#x27;hello&#x27;let str2 = str1str2 = &#x27;world&#x27;console.log(str1) // &#x27;hello&#x27; let str1 = &#39;hello&#39;: 复制前，定义了一个变量 str1，并且给其赋值 hello，这个时候 hello 这个字符串就会在栈内存中被分配一块空间进行存储，然后变量 str1 会指向这个内存地址； let str2 = str1：复制后，把 str1 的值赋值给 str2，这个时候会在栈中新开辟一块空间用来存储 str2 的值； str2 = &#39;world&#39;：给 str2 赋值了一个新的字符串 world，那么将新建一块内存用来存储 world，同时 str2 原来的值 hello 的内存空间因为没有变量所引用，所以一段时间后建被当成垃圾回收； console.log( str1 )：因为 str1 和 str2 的栈内存地址是不一样的，所以即使 str2 的值被改变，也不会影响到 str1。 然后我们继续往下，看下引用类型的复制： 1234567let person1 &#x3D; &#123; name: &#39;bubuzou&#39;, age: 20&#125;let person2 &#x3D; person1person2.name &#x3D; &#39;bubuzou.com&#39;console.log( person1.name) &#x2F;&#x2F; &#39;bubuzou.com&#39; 原始类型进行复制的时候是变量的值进行重新赋值，而如上图所示：引用类型进行复制的时候是把变量所指向的引用地址进行赋值给新的变量，所以复制后 person1 和 person2 都指向堆内存中的同一个值，所以当改变 person2.name 的时候， person1.name 也会被改变就是这个原因。 值传递和引用传递先说一下结论，在 JavaScript 中，所有函数的参数传递都是按值进行传递的。看如下代码： 123456let name = &#x27;bubuzou&#x27;function changeName(name) &#123; name = &#x27;bubuzou.com&#x27;&#125;changeName(name)console.log(name) // &#x27;bubuzou&#x27; 定义了一个变量 name，并赋值为 bubuzou，函数调用的时候传入 name，这个时候会在函数内部创建一个局部变量 name 并且把全局变量的值 bubuzou 传递给他，这个操作其实是在内存里新建了一块空间用来存放局部变量的值，然后又把局部变量的值改成了 bubuzou.com，这个时候其实内存中会有 3 块地址空间分别用来存放全局变量的值 bubuzou、局部变量原来的值 bubuzou、和局部变量新的值 bubuzou.com；一旦函数调用结束，局部变量将被销毁，一段时间后由于局部变量新旧值没有变量引用，那这两块空间将被回收释放；所以这个时候全局 name 的值依然是 bubuzou。 再来看看引用类型的传参，会不会有所不同呢？ 12345678let person = &#123; name: &#x27;bubuzou&#x27;,&#125;function changePerosn(person) &#123; person.name = &#x27;bubuzou.com&#x27;&#125;changePerosn(person)console.log(person.name) // &#x27;bubuzou.com&#x27; 引用类型进行函数传参的时候，会把引用地址复制给局部变量，所以全局的 person 和函数内部的局部变量 person 是指向同一个堆地址的，所以一旦一方改变，另一方也将被改变，所以至此我们是不是可以下结论说：当函数进行传参的时候如果参数是引用类型那么就是引用传递嘛？ 将上面的例子改造下： 1234567891011let person = &#123; name: &#x27;bubuzou&#x27;,&#125;function changePerosn(person) &#123; person.name = &#x27;bubuzou.com&#x27; person = &#123; name: &#x27;hello world&#x27;, &#125;&#125;changePerosn(person)console.log(person.name) // &#x27;bubuzou.com&#x27; 如果 person 是引用传递的话，那就会自动指向值被改为 hello world 的新对象；事实上全局变量 person 的引用地址自始至终都没有改变，倒是局部变量 person 的引用地址发生了改变。 null 和 undefined 傻傻分不清？null 在 JavaScript 中自成一种原始类型，只有一个值 null，表示无、空、值未知等特殊值。可以直接给一个变量赋值为 null： 1let s = null undefined 和 null 一样也是自成一种原始类型，表示定义了一个变量，但是没有赋值，则这个变量的值就是 undefined: 12let sconsole.log(s) // undefined 虽然可以给变量直接赋值为 undefined 也不会报错，但是原则上如果一个变量值未定，或者表示空，则直接赋值为 null 比较合适，不建议给变量赋值 undefined。null 和 undefined 在进行逻辑判断的时候都是会返回 false 的： 123let a = null, bconsole.log(a ? &#x27;a&#x27; : b ? &#x27;b&#x27; : &#x27;c&#x27;) // &#x27;c&#x27; null 在转成数字类型的时候会变成 0，而 undefined 会变成 NaN: 1234let a = null, bconsole.log(+null) // 0console.log(+b) // NaN 认识新的原始类型 SymbolSymbol 值表示唯一标识符，是 ES6 中新引进的一种原始类型。可以通过 Symbol() 来创建一个重要的值，也可以传入描述值；其唯一性体现在即使是传入一样的描述，他们两者之间也是不会相等的： 123let a = Symbol(&#x27;bubuzou&#x27;)let b = Symbol(&#x27;bubuzou&#x27;)console.log(a === b) // false 全局的 Symbol那还是不是任意 2 个描述一样的 Symbol 都是不相等的呢？答案是否定的。可以通过 Symbol.for() 来查找或新建一个 Symbol： 123let a = Symbol.for(&#x27;bubuzou&#x27;)let b = Symbol.for(&#x27;bubuzou&#x27;)console.log(a === b) // true 使用 Symbol.for() 可以在根据传入的描述在全局范围内进行查找，如果没找到则新建一个 Symbol，并且返回；所以当执行第二行代码 Symbol.for(&#39;bubuzou&#39;) 的时候，就会找到全局的那个描述为 bubuzou 的 Symbol，所以这里 a 和 b 是会绝对相等的。 居然可以通过描述找到 Symbol， 那是否可以通过 Symbol 来找到描述呢？答案是肯定的，但是必须是全局的 Symbol，如果没找到则会返回 undefined: 123let a = Symbol.for(&#x27;bubuzou&#x27;)let desc = Symbol.keyFor(a)console.log(desc) // &#x27;bubuzou&#x27; 但是对于任何一个 Symbol 都有一个属性 description，表示这个 Symbol 的描述： 12let a = Symbol(&#x27;bubuzou&#x27;)console.log(a.description) // &#x27;bubuzou&#x27; Symbol 作为对象属性我们知道对象的属性键可以是字符串，但是不能是 Number 或者 Boolean；Symbol 被设计出来其实最大的初衷就是用于对象的属性键： 12345let age = Symbol(&#x27;20&#x27;)let person = &#123; name: &#x27;bubuzou&#x27;, [age]: &#x27;20&#x27;, // 在对象字面量中使用 `Symbol` 的时候需要使用中括号包起来&#125; 这里给 person 定义了一个 Symbol 作为属性键的属性，这个相比于用字符串作为属性键有啥好处呢？最明显的好处就是如果这个 person 对象是多个开发者进行开发维护，那么很容易再给 person 添加属性的时候出现同名的，如果是用字符串作为属性键那肯定是冲突了，但是如果用 Symbol 作为属性键，就不会存在这个问题了，因为它是唯一标识符，所以可以使对象的属性受到保护，不会被意外的访问或者重写。 注意一点，如果用 Symbol 作为对象的属性键的时候，for in 、Object.getOwnPropertyNames、或 Object.keys() 这里循环是无法获取 Symbol 属性键的，但是可以通过 Object.getOwnPropertySymbols() 来获取；在上面的代码基础上： 123456for (let o in person) &#123; console.log(o) // &#x27;name&#x27;&#125;console.log(Object.keys(person)) // [&#x27;name&#x27;]console.log(Object.getOwnPropertyNames(person)) // [&#x27;name&#x27;]console.log(Object.getOwnPropertySymbols(person)) // [Symbol(20)] 你可能不知道的 Number 类型JavaScript 中的数字涉及到了两种类型：一种是 Number 类型，以 64 位的格式 IEEE-754 存储，也被称为双精度浮点数，就是我们平常使用的数字，其范围是 $2^{52}$ 到 -$2^{52}$；第二种类型是 BigInt，能够表示任意长度的整数，包括超出 $2^{52}$ 到 -$2^{52}$ 这个范围外的数。这里我们只介绍 Number 数字。 常规数字和特殊数字对于一个常规的数字，我们直接写即可，比如: 1let age = 20 但是还有一种位数特别多的数字我们习惯用科学计数法的表示方法来写： 12let billion = 1000000000let b = 1e9 以上两种写法是一个意思， 1e9 表示 1 x $10^9$；如果是 1e-3 表示 1 / $10^3$ = 0.001。在 JavaScript 中也可以用数字表示不同的进制，比如：十进制中的 10 在 二、八和十六进制中可以分别表示成 0b1010、0o12 和 0xa；其中的 0b 是二进制前缀，0o 是八进制前缀，而 ox 是十六进制的前缀。 我们也可以通过 toString(base) 方法来进行进制之间的转换， base 是进制的基数，表示几进制，默认是 10 进制的，会返回一个转换数值的字符串表示。比如： 1234let num = 10console.log(num.toString(2)) // &#x27;1010&#x27;console.log(num.toString(8)) // &#x27;12&#x27;console.log(num.toString(16)) // &#x27;a&#x27; 数字也可以直接调用方法，10..toString( 2 ) 这里的 2 个 . 号不是写错了，而是必须是 2 个，否则会报 SyntaxError 错误。第一个点表示小数点，第二个才是调用方法。点符号首先会被认为是数字常量的一部分，其次再被认为是属性访问符，如果只写一个点的话，计算机无法知道这个是表示一个小数呢还是去调用函数。数字直接调用函数还可以有以下几种写法： 123;(10).toString(2) // 将10用括号包起来;(10.0).toString(2) // 将10写成10.0的形式;(10).toString(2) // 空格加上点符号调用 Number 类型除了常规数字之外，还包含了一些特殊的数字： NaN：表示不是一个数字，通常是由不合理的计算导致的结果，比如数字除以字符串 1 / &#39;a&#39;;NaN 和任何数进行比较都是返回 false，包括他自己： NaN == NaN 会返回 false;如何判断一个数是不是 NaN 呢？有四种方法： 方法一：通过 `isNaN()` 函数，这个方法会对传入的字符串也返回 `true`，所以判断不准确，不推荐使用： &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;isNaN&lt;/span&gt;( &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;isNaN&lt;/span&gt;( &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt; ) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 方法二：通过 `Number.isNaN()`，推荐使用： &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.isNaN( &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.isNaN( &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt; ) &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 方法三：通过 `Object.is(a, isNaN)`: &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.is( &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;/&lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NaN&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.is( &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NaN&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 方法四：通过判断 `n !== n`，返回 `true`， 则 `n` 是 `NaN` : &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; s = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( s !== s ) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; +Infinity：表示正无穷大，比如 1/0 计算的结果, -Infinity 表示负无穷大，比如 -1/0 的结果。 +0 和 -0，JavaScript 中的数字都有正负之分，包括零也是这样，他们会绝对相等： 1console.log(+0 === -0) // true 为什么 0.1 + 0.2 不等于 0.31console.log(0.1 + 0.2 == 0.3) // false 有没有想过为什么上面的会不相等？因为数字在 JavaScript 内部是用二进制进行存储的，其遵循 IEEE 754 标准的，用 64 位来存储一个数字，64 位又被分隔成 1、11 和 52 位来分别表示符号位、指数位和尾数位。比如十进制的 0.1 转成二进制后是多少？我们手动计算一下，十进制小数转二进制小数的规则是“乘 2 取整，顺序排列”，具体做法是：用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。 123456780.1 * 2 &#x3D; 0.2 &#x2F;&#x2F; 第1步：整数为0，小数0.20.2 * 2 &#x3D; 0.4 &#x2F;&#x2F; 第2步：整数为0，小数0.40.4 * 2 &#x3D; 0.8 &#x2F;&#x2F; 第3步：整数为0，小数0.80.8 * 2 &#x3D; 1.6 &#x2F;&#x2F; 第4步：整数为1，小数0.60.6 * 2 &#x3D; 1.2 &#x2F;&#x2F; 第5步：整数为1，小数0.20.2 * 2 &#x3D; 0.4 &#x2F;&#x2F; 第6步：整数为0，小数0.40.4 * 2 &#x3D; 0.8 &#x2F;&#x2F; 第7步：整数为0，小数0.8... 我们这样依次计算下去之后发现得到整数的顺序排列是 0001100110011001100.... 无限循环，所以理论上十进制的 0.1 转成二进制后会是一个无限小数 0.0001100110011001100...，用科学计数法表示后将是 1.100110011001100... x $2^{-4}$ ，但是由于 IEEE 754 标准规定了一个数字的存储位数只能是 64 位，有效位数是 52 位，所以将会对 1100110011001100.... 这个无限数字进行舍入总共 52 位作为有效位，然后二进制的末尾取舍规则是看后一位数如果是 1 则进位，如果是 0 则直接舍去。那么由于 1100110011001100.... 这串数字的第 53 位刚好是 1 ，所以最终的会得到的数字是 1100110011001100110011001100110011001100110011001101，即1.100110011001100110011001100110011001100110011001101 x $2^{-4}$。十进制转二进制也可以用 toString 来进行转化: 1console.log((0.1).toString(2)) // &#x27;0.0001100110011001100110011001100110011001100110011001101&#x27; 我们发现十进制的 0.1 在转化成二进制小数的时候发生了精度的丢失，由于进位，它比真实的值更大了。而 0.2 其实也有这样的问题，也会发生精度的丢失，所以实际上 0.1 + 0.2 不会等于 0.3: 1console.log(0.1 + 0.2) // 0.30000000000000004 那是不是没办法判断两个小数是否相等了呢？答案肯定是否定的，想要判断 2 个小数 n1 和 n2 是否相等可以如下操作： 方法一：两小数之差的绝对值如果比 Number.EPSILON 还小，那么说明两数是相等的。 Number.EPSILON 是 ES6 中的误差精度，实际值可以认为等于 $2^{-52}$。 123if (Math.abs(n1 - n2) &lt; Number.EPSILON) &#123; console.log(&#x27;n1 和 n2 相等&#x27;)&#125; 方法二：通过 toFixed(n) 对结果进行舍入，toFixed() 将会返回字符串，我们可以用 一元加 + 将其转成数字： 12let sum = 0.1 + 0.2console.log(+sum.toFixed(2) === 0.3) // true 数值的转化对数字进行操作的时候将常常遇到数值的舍入和字符串转数字的问题，这里我们巩固下基础。先来看舍入的： Math.floor()，向下舍入，得到一个整数: 12Math.floor(2.2) // 2Math.floor(2.8) // 2 Math.ceil()，向上舍入，得到一个整数： 12Math.ceil(2.2) // 3Math.ceil(2.8) // 3 Math.round()，对第一位小数进行四舍五入： 123Math.round(2.26) // 2Math.round(2.46) // 2Math.round(2.5) // 3 Number.prototype.toFixed(n)，和 Math.round() 一样会进行四舍五入，将数字舍入到小数点后 n 位，并且以字符串的形式返回： 123;(12).toFixed(2) // &#x27;12.00&#x27;;(12.14).toFixed(1) // &#x27;12.1&#x27;;(12.15).toFixed(1) // &#x27;12.2&#x27; 为什么 6.35.toFixed(1) 会等于 6.3 ？因为 6.35 其实是一个无限小数： 1;(6.35).toFixed(20) // &quot;6.34999999999999964473&quot; 所以在 6.35.toFixed(1) 求值的时候会得到 6.3。 再来看看字符串转数字的情况： Number(n) 或 +n，直接将 n 进行严格转化： 123456Number(&#x27; &#x27;) // 0console.log(+&#x27;&#x27;) // 0Number(&#x27;010&#x27;) // 10console.log(+&#x27;010&#x27;) // 10Number(&#x27;12a&#x27;) // NaNconsole.log(+&#x27;12a&#x27;) // NaN parseInt()，非严格转化，从左到右解析字符串，遇到非数字就停止解析，并且把解析的数字返回： 1234parseInt(&#x27;12a&#x27;) // 12parseInt(&#x27;a12&#x27;) // NaNparseInt(&#x27;&#x27;) // NaNparseInt(&#x27;0xA&#x27;) // 10，0x开头的将会被当成十六进制数 parseInt() 默认是用十进制去解析字符串的，其实他是支持传入第二个参数的，表示要以多少进制的 基数去解析第一个参数： 12parseInt(&#x27;1010&#x27;, 2) // 10parseInt(&#x27;ff&#x27;, 16) // 255 如何判断一个数是不是整数？介绍两种方法： 方法一：通过 Number.isInteger(): 12Number.isInteger(12.0) // trueNumber.isInteger(12.2) // false 方法二：typeof num == &#39;number&#39; &amp;&amp; num % 1 == 0 123function isInteger(num) &#123; return typeof num == &#x27;number&#x27; &amp;&amp; num % 1 == 0&#125; 引用类型除了原始类型外，还有一个特别重要的类型：引用类型。高程里这样描述他：引用类型是一种数据结构， 用于将数据和功能组织在一起。到目前为止，我们看到最多的引用类型就是 Object，创建一个 Object 有两种方式： 方式一：通过 new 操作符： 123let person = new Object()person.name = &#x27;bubuzou&#x27;person.age = 20 方式二：通过对象字面量，这是我们最喜欢用的方式： 1234let person = &#123; name: &#x27;bubuzou&#x27;, age: 20,&#125; 内置的引用类型除了 Object 外，在 JavaScript 中还有别的内置的引用类型，比如： Array 数组 Date 日期 RegExp 正则表达式 Function 函数 他们的原型链的顶端都会指向 Object: 12let d = new Date()console.log(d.__proto__.__proto__.constructor) // ƒ Object() &#123; [native code] &#125; 包装类型先来看一个问题，为什么原始类型的变量没有属性和方法，但是却能够调用方法呢？ 12let str = &#x27;bubuzou&#x27;str.substring(0, 3) // &#x27;bub&#x27; 因为 JavaScript 为了更好地操作原始类型，设计出了几个对应的包装类型，他们分别是： Boolean Number String 上面那串代码的执行过程其实是这样的： 创建 String 类型的一个实例; 在实例上调用指定的方法; 销毁这个实例 用代码体现一下： 123let str = new String(&#x27;bubuzou&#x27;)str.substring(0, 3)str = null 原始类型调用函数其实就是自动进行了装箱操作，将原始类型转成了包装类型，然后其实原始类型和包装类型是有本质区别的，原始类型是原始值，而包装类型是对象实例： 12345let str1 = &#x27;bubuzou&#x27;let str2 = new String(&#x27;bubuzou&#x27;)console.log(str1 === str2) // fasleconsole.log(typeof str1) // &#x27;string&#x27;console.log(typeof str2) // &#x27;object&#x27; 居然有装箱操作，那肯定也有拆箱操作，所谓的拆箱就是包装类型转成原始类型的过程，又叫 ToPromitive，来看下面的例子： 12345678910let obj = &#123; toString: () =&gt; &#123; return &#x27;bubuzou&#x27; &#125;, valueOf: () =&gt; &#123; return 20 &#125;,&#125;console.log(+obj) // 20console.log(`$&#123;obj&#125;`) // &#x27;bubuzou&#x27; 在拆箱操作的时候，默认会尝试调用包装类型的 toString() 和 valueOf() 方法，对于不同的 hint 调用顺序会有所区别，如果 hint 是 string 则优先调用 toString()，否则的话，则优先调用 valueOf()。默认情况下，一个 Object 对象具有 toString() 和 valueOf() 方法： 123let obj = &#123;&#125;console.log(obj.toString()) // &#x27;[object Object]&#x27;console.log(obj.valueOf()) // &#123;&#125;，valueOf会返回对象本身 类型装换Javascript 是弱类型的语音，所以对变量进行操作的时候经常会发生类型的转换，尤其是隐式类型转换，可能会让代码执行结果出乎意料之外，比如如下的代码你能理解其执行结果嘛？ 1234;[] + &#123;&#125; // &#x27;[object Object]&#x27;&#123;&#125;;+[] // 0 类型转换规则所以我们需要知道类型转换的规则，以下整理出一个表格，列出了常见值和类型以及转换之后的结果，仅供参考。 转换前的值 转换前类型 toBoolean toNumber toString true Boolean - 1 “true” false Boolean - 0 “false” null Null false 0 “null” undefined Undefined false NaN “undefined” 123 Number true - “123” Infinity Number true - “Infinity” 0 Number false - “0” NaN Number false - “NaN” “” String false 0 - “ “ String true 0 - “0” String true 0 - “123” String true 123 - “123abc” String true NaN - Symbol() Symbol true TypeError TypeError {} Object true NaN “[object Object]” [] Object true 0 “” [“0”] Object true 0 “0” [“0”, “a”] Object true NaN “0,a” [“0”, undefined, “a”] Object true Nan “0,,a” 显示类型转换我们平时写代码的时候应该尽量让写出来的代码通俗易懂，让别人能阅读后知道你是要做什么，所以在对类型进行判断的时候应该尽量显示的处理。比如将字符串转成数字，可以这样： 123Number(&#x27;21&#x27;) // 21Number(&#x27;21.8&#x27;) + // 21.8 &#x27;21&#x27; // 21 将数字显示转成字符串可以这样： 12String(21) // &#x27;21&#x27;;(21).toString() // &#x27;21&#x27; 显示转成布尔类型可以这样： 1234Boolean(&#x27;21&#x27;) // trueBoolean(undefined) // false!!NaN // false!!&#x27;21&#x27; // true 除了以上之外，还有一些关于类型转换的冷门操作，有时候也挺管用的：直接用一元加操作符获取当前时间的毫秒数： 1;+new Date() // 1595517982686 用 ~ 配合 indexOf() 将操作结果直接转成布尔类型： 1234let str = &#x27;bubuzou.com&#x27;if (~str.indexOf(&#x27;.com&#x27;)) &#123; console.log(&#x27;str如果包含了.com字符串，则会打印这句话&#x27;)&#125; 使用 ~~ 对字符或数字截取整数，和 Math.floor() 有稍许不同： 12345~~21.1 // 21~~-21.9 // -21~~&#x27;1.2a&#x27; // 0Math.floor(21.1) // 21Math.floor(-21.9) // -22 隐式类型转换隐式类型转换发生在 JavaScript 的运行时，通常是由某些操作符或语句引起的，有下面这几种情况： 隐式转成布尔类型： if (..)语句中的条件判断表达式。 for ( .. ; .. ; .. )语句中的条件判断表达式(第二个)。 while (..) 和 do..while(..) 循环中的条件判断表达式。 ? :中的条件判断表达式。 逻辑运算符 || (逻辑或)和 &amp;&amp; (逻辑与)左边的操作数(作为条件判断表达式) 1234567if (42) &#123; console.log(42)&#125;while (&#x27;bubuzou&#x27;) &#123; console.log(&#x27;bubuzou&#x27;)&#125;const c = null ? &#x27;存在&#x27; : &#x27;不存在&#x27; // &#x27;不存在&#x27; 上例中的非布尔值会被隐式强制类型转换为布尔值以便执行条件判断。需要特别注意的是 || 和 &amp;&amp; 操作符。|| 的操作过程是只有当左边的值返回 false 的时候才会对右边进行求值且将它作为最后结果返回，类似 a ? a : b 这种效果: 12const a = &#x27;a&#x27; || &#x27;b&#x27; // &#x27;a&#x27;const b = &#x27;&#x27; || &#x27;c&#x27; // &#x27;c&#x27; 而 &amp;&amp; 的操作过程是只有当左边的值返回 true 的时候才对右边进行求值且将右边的值作为结果返回，类似 a ? b : a 这种效果： 12const a = &#x27;a&#x27; &amp;&amp; &#x27;b&#x27; // &#x27;b&#x27;const b = &#x27;&#x27; &amp;&amp; &#x27;c&#x27; // &#x27;&#x27; 数学操作符 - * / 会对非数字类型的会优先转成数字类型，但是对 + 操作符会比较特殊： 当一侧为 String 类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。 当一侧为 Number 类型，另一侧为原始类型，则将原始类型转换为 Number 类型。 当一侧为 Number 类型，另一侧为引用类型，将引用类型和 Number 类型转换成字符串后拼接。 1234542 + &#x27;bubuzou&#x27; // &#x27;42bubuzou&#x27;42 + null // 4242 + true // 4342 + [] // &#x27;42&#x27;42 + &#123;&#125; // &#x27;42[object Object]&#x27; 宽松相等和严格相等宽松相等（==）和严格相等（===）在面试的时候经常会被问到，而回答一般是 == 是判断值是否相等，而 === 除了判断值会不会相等之外还会判断类型是否相等，这个答案不完全正确，更好的回答是：== 在比较过程中允许发生隐式类型转换，而 === 不会。 那 == 是怎么进行类型转换的呢？ 数字和字符串比，字符串将转成数字进行比较： 1220 == &#x27;20&#x27; // true20 === &#x27;20&#x27; // false 别的类型和布尔类型比较，布尔类型将首先转成数字进行比较，true 转成数字 1, false 转成数字 0，注意这个是非常容易出错的一个点： 123456&#x27;bubuzou&#x27; == true // false&#x27;0&#x27; == false // truenull == false // false,undefined == false // false[] == true // false[&#x27;1&#x27;] == true // true 所以写代码进行判断的时候一定不要写成 x == true 或 x == false 这种，而应该直接 if (x) 判断。 null 和 undefined: null == undefined 比较结果是 true，除此之外，null、undefined 和其他任何结果的比较值都为 false。可以认为在 == 的情况下，null 和 undefined 可以相互的进行隐式类型转换。 1234567null == undefined // truenull == &#x27;&#x27; // falsenull == 0 // falsenull == false // falseundefined == &#x27;&#x27; // falseundefined == 0 // falseundefined == false // false 原始类型和引用类型比较，引用类型会首先进行 ToPromitive 转成原始类型然后进行比较，规则参考上面介绍的拆箱操作： 1234&#x27;42&#x27; == [42] // true&#x27;1,2,3&#x27; == [1, 2, 3] // true&#x27;[object Object]&#x27; == &#123;&#125; // true0 == [undefined] // true 特殊的值 12345NaN == NaN // false+0 == -0 // true[] == ![] // true，![]的优先级比==高，所以![]先转成布尔值变成false；即变成[] == false，false再转成数字0，[]转成数字0，所以[] == ![]0 == &#x27;\\n&#x27; // true 类型检测用 typeof 检测原始类型JavaScript 中有 null、undefined、boolean、number、string、Symbol 等六种原始类型，我们可以用 typeof 来判断值是什么原始类型的，会返回类型的字符串表示： 12345typeof undefined // &#x27;undefined&#x27;typeof true // &#x27;boolean&#x27;typeof 42 // &#x27;number&#x27;typeof &#x27;42&#x27; // &#x27;string&#x27;typeof Symbol() // &#x27;symbol&#x27; 但是原始类型中有一个例外，typeof null 会得到 ‘object’，所以我们用 typeof 对原始值进行类型判断的时候不能得到一个准确的答案，那如何判断一个值是不是 null 类型的呢？ 12let o = null!o &amp;&amp; typeof o === &#x27;object&#x27; // 用于判断 o 是否是 null 类型 undefined 和 undeclared 有什么区别？前者是表示在作用域中定义了但是没有赋值的变量，而后者是表示在作用域中没有定义的变量；分别表示 undefined 未定义、undeclared 未声明。 typeof 能够对原始类型进行判断，那是否也能判断引用类型呢？ 12345typeof [] // &#x27;object&#x27;typeof &#123;&#125; // &#x27;object&#x27;typeof new Date() // &#x27;object&#x27;typeof new RegExp() // &#x27;object&#x27;typeof new Function() // &#x27;function&#x27; 从上面的结果我们可以得到这样一个结论： typeof 对引用类型判断的时候只有 function 类型可以正确判断，其他都无法正确判断具体是什么引用类型。 用 instanceof 检测引用类型我们知道 typeof 只能对部分原始类型进行检测，对引用类型毫无办法。JavaScript 提供了一个操作符 instanceof，我们来看下他是否能检测引用类型： 12[] instanceof Array // true[] instanceof Object // true 我们发现数组即是 Array 的实例，也是 Object 的实例，因为所以引用类型原型链的终点都是 Object，所以 Array 自然是 Object 的实例。那么我们得出结论：instanceof 用于检测引用类型好像也不是很靠谱的选择。 用 toString 进行类型检测我们可以使用 Object.prototype.toString.call() 来检测任何变量值的类型： 12345678910111213141516171819Object.prototype.toString.call(true) // &#x27;[object Boolean]&#x27;Object.prototype.toString.call(undefined) // &#x27;[object Undefined]&#x27;Object.prototype.toString.call(null) // &#x27;[object Null]&#x27;Object.prototype.toString.call(20) // &#x27;[object Number]&#x27;Object.prototype.toString.call(&#x27;bubuzou&#x27;) // &#x27;[object String]&#x27;Object.prototype.toString.call(Symbol()) // &#x27;[object Symbol]&#x27;Object.prototype.toString.call([]) // &#x27;[object Array]&#x27;Object.prototype.toString.call(&#123;&#125;) // &#x27;[object Object]&#x27;Object.prototype.toString.call(function () &#123;&#125;) // &#x27;[object Function]&#x27;Object.prototype.toString.call(new Date()) // &#x27;[object Date]&#x27;Object.prototype.toString.call(new RegExp()) // &#x27;[object RegExp]&#x27;Object.prototype.toString.call(JSON) // &#x27;[object JSON]&#x27;Object.prototype.toString.call(MATH) // &#x27;[object MATH]&#x27;Object.prototype.toString.call(window)( // &#x27;[object Window]&#x27; function a() &#123; Object.prototype.toString.call(arguments) // &#x27;[object Arguments]&#x27; &#125;)() 参考文章 【JS 进阶】你真的掌握变量和类型了吗 你不知道的 JS 中卷-第四章 JS 中的栈内存堆内存 IEEE 754","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"使用nvm来管理Node版本","slug":"nvm","date":"2020-03-26T13:11:58.000Z","updated":"2021-09-06T09:57:30.299Z","comments":true,"path":"2020/03/26/nvm/","link":"","permalink":"https://bubuzou.com/2020/03/26/nvm/","excerpt":"使用 nvm 来管理 Node 版本nvm 是 Node.js 的版本管理工具，可以创建不同版本 Node 的隔离环境，从而避免不同版本包之间的干扰。官方 github 卸载全局安装的 Node最近在做项目的时候，发现编译速度特别慢，而升级 Node 版本之后速度会明显提升。所以这才有使用 nvm 来管理 Node 的故事。 目前本地全局安装的 Node 版本是 9.11.1， 这个版本还是 18 年 4 月左右更新的，是相当的跟不上节奏了。这里可以查看 Node 历史版本。 安装 nvm 之前最好是将现有的全局 Node 进行卸载，否则会发生冲突。","text":"使用 nvm 来管理 Node 版本nvm 是 Node.js 的版本管理工具，可以创建不同版本 Node 的隔离环境，从而避免不同版本包之间的干扰。官方 github 卸载全局安装的 Node最近在做项目的时候，发现编译速度特别慢，而升级 Node 版本之后速度会明显提升。所以这才有使用 nvm 来管理 Node 的故事。 目前本地全局安装的 Node 版本是 9.11.1， 这个版本还是 18 年 4 月左右更新的，是相当的跟不上节奏了。这里可以查看 Node 历史版本。 安装 nvm 之前最好是将现有的全局 Node 进行卸载，否则会发生冲突。 终端下查看 Node 的全局安装目录： 12ccp:~ ccp$ which node&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node Mac 环境下全局的 Node 会被安装在 /usr/local/bin/ 目录下，接下来我们要打开这个目录； 打开访达，然后按下快捷键 ⇧ + ⌘ + G，输入上面的目录，即可打开对应的目录； 接下来依次检查并且删除这些目录下的 node 和 node_modules 相关文件和文件夹： /usr/local/lib /usr/local/include 打开 /usr/local/bin 并删除 node 可执行文件; 如果你是使用的 brew install node 安装的 Node，那么你还需要在终端中执行 brew uninstall node 命令来卸载。 过程中，你可能还需要在终端中执行一些指令： 12345678sudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npmsudo rm &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1&#x2F;node.1sudo rm &#x2F;usr&#x2F;local&#x2F;lib&#x2F;dtrace&#x2F;node.dsudo rm -rf ~&#x2F;.npmsudo rm -rf ~&#x2F;.node-gypsudo rm &#x2F;opt&#x2F;local&#x2F;bin&#x2F;nodesudo rm &#x2F;opt&#x2F;local&#x2F;include&#x2F;nodesudo rm -rf &#x2F;opt&#x2F;local&#x2F;lib&#x2F;node_modules 至此，全局安装的 Node 才算卸载干净。 安装 nvm 在终端里执行如下脚本： 1curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.35.3&#x2F;install.sh | bash 然后在终端输入命令 command -v nvm，如果显示 nvm 则表示安装成功；否则如果显示 nvm: command not found，则需要做如下操作： 在 .nvm 同级目录下创建 .bash_profile 文件，终端键入如下命令： 1touch ~&#x2F;.bash_profile 把以下代码贴到上面的文件中： 12export NVM_DIR&#x3D;~&#x2F;.nvmsource ~&#x2F;.nvm&#x2F;nvm.sh nvm 安装后，可以用 nvm ls 来查看，如果会显示安装的 Node 版本列表，则显示安装成功。有了 nvm 后，在用 npm install xxx -g 进行全局安装的时候会把包安装对应版本的 Node 下，如果是 Mac 则目录 user/.nvm/versions/node/v12.16.1/bin 下可以看到对应的全局命令。 nvm 常用命令 nvm ls-remote 查看 Node 远程版本库 nvm install node 将安装最新版本的 Node nvm install v12.7.0 将安装 12.7.0 版本的 Node nvm uninstall v12.7.0 卸载 12.7.0 版本的 Node nvm ls 查看已经安装的 Node 版本 nvm use v12.7.0 切换 12.7.0 为当前使用的版本 nvm alias default v12.7.0 将 12.7.0 设置为 Node 的默认版本 nvm which v12.7.0 查看 12.7.0 版本的 Node 的安装目录，比如：/Users/ccp/.nvm/versions/node/v12.7.0/bin/node nvm --help 查看更多命令用法 其他相关命令 command -v nvm 查看 nvm 是否安装成功 node -v 查看当前使用的 Node 版本 which node 查看当前 Node 的安装目录 其他问题 由于 Node 版本的升级，所以当编译项目的时候可能会报依赖包的错误，这个时候就需要升级依赖包，将项目的 node_modules 目录删了，重新执行 npm install。 升级 Node 后，由于内存 2048M 的限制，编译项目的时候很有可能会报 JS stack trace 内存溢出的错误，这个时候可以用 increase-memory-limit 来解决。","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"node","slug":"node","permalink":"https://bubuzou.com/tags/node/"}]},{"title":"Vue-Test-Utils + Jest 单元测试入门与实践","slug":"Vue-Test-Utils+Jest","date":"2019-10-23T17:41:11.000Z","updated":"2021-09-06T09:58:22.520Z","comments":true,"path":"2019/10/24/Vue-Test-Utils+Jest/","link":"","permalink":"https://bubuzou.com/2019/10/24/Vue-Test-Utils+Jest/","excerpt":"介绍Vue-Test-Utils 是 Vue.js 官方的单元测试实用工具库，它提供了一系列的 API 来使得我们可以很便捷的去写 Vue 应用中的单元测试。 主流的单元测试运行器有很多，比如 Jest、Mocha 和 Karma 等，这几个在 Vue-Test-Utils 文档里都有对应的教程，这里我们只介绍 Vue-Test-Utils + Jest 结合的示例。 Jest 是一个由 Facebook 开发的测试框架。Vue 对其进行描述：是功能最全的测试运行器。它所需的配置是最少的，默认安装了 JSDOM，内置断言且命令行的用户体验非常好。不过你需要一个能够将单文件组件导入到测试中的预处理器。我们已经创建了 vue-jest 预处理器来处理最常见的单文件组件特性，但仍不是 vue-loader 100% 的功能。","text":"介绍Vue-Test-Utils 是 Vue.js 官方的单元测试实用工具库，它提供了一系列的 API 来使得我们可以很便捷的去写 Vue 应用中的单元测试。 主流的单元测试运行器有很多，比如 Jest、Mocha 和 Karma 等，这几个在 Vue-Test-Utils 文档里都有对应的教程，这里我们只介绍 Vue-Test-Utils + Jest 结合的示例。 Jest 是一个由 Facebook 开发的测试框架。Vue 对其进行描述：是功能最全的测试运行器。它所需的配置是最少的，默认安装了 JSDOM，内置断言且命令行的用户体验非常好。不过你需要一个能够将单文件组件导入到测试中的预处理器。我们已经创建了 vue-jest 预处理器来处理最常见的单文件组件特性，但仍不是 vue-loader 100% 的功能。 环境配置通过脚手架 vue-cli 来新建项目的时候，如果选择了 Unit Testing 单元测试且选择的是 Jest 作为测试运行器，那么在项目创建好后，就会自动配置好单元测试需要的环境，直接能用 Vue-Test-Utils 和 Jest 的 API 来写测试用例了。 但是新建项目之初没有选择单元测试功能，需要后面去添加的话，有两种方案： 第一种配置： 直接在项目中添加一个 unit-jest 插件，会自动将需要的依赖安装配置好。 1vue add @vue&#x2F;unit-jest 第二种配置： 这种配置会麻烦一点，下面是具体的操作步骤。 安装依赖 安装 Jest 和 Vue Test Utils 1npm install --save-dev jest @vue&#x2F;test-utils 安装 babel-jest 、 vue-jest 和 7.0.0-bridge.0 版本的 babel-core 1npm install --save-dev babel-jest vue-jest babel-core@7.0.0-bridge.0 安装 jest-serializer-vue 1npm install --save-dev jest-serializer-vue 配置 JestJest 的配置可以在 package.json 里配置；也可以新建一个文件 jest.config.js， 放在项目根目录即可。这里我选择的是配置在 jest.config.js 中： 12345678910111213module.exports = &#123; moduleFileExtensions: [&#x27;js&#x27;, &#x27;vue&#x27;], transform: &#123; &#x27;^.+\\\\.vue$&#x27;: &#x27;&lt;rootDir&gt;/node_modules/vue-jest&#x27;, &#x27;^.+\\\\.js$&#x27;: &#x27;&lt;rootDir&gt;/node_modules/babel-jest&#x27;, &#125;, moduleNameMapper: &#123; &#x27;^@/(.*)$&#x27;: &#x27;&lt;rootDir&gt;/src/$1&#x27;, &#125;, snapshotSerializers: [&#x27;jest-serializer-vue&#x27;], testMatch: [&#x27;**/__tests__/**/*.spec.js&#x27;], transformIgnorePatterns: [&#x27;&lt;rootDir&gt;/node_modules/&#x27;],&#125; 各配置项说明： moduleFileExtensions 告诉 Jest 需要匹配的文件后缀 transform 匹配到 .vue 文件的时候用 vue-jest 处理， 匹配到 .js 文件的时候用 babel-jest 处理 moduleNameMapper 处理 webpack 的别名，比如：将 @ 表示 /src 目录 snapshotSerializers 将保存的快照测试结果进行序列化，使得其更美观 testMatch 匹配哪些文件进行测试 transformIgnorePatterns 不进行匹配的目录 配置 package.json写一个执行测试的命令脚本： 12345&#123; &quot;script&quot;: &#123; &quot;test&quot;: &quot;jest&quot; &#125;&#125; 第一个测试用例为了保证环境的一致性，我们从创建项目开始一步一步演示操作步骤。 用 vue-cli 创建一个项目当前我用到的是 3.10.0 版本的 vue-cli。开始创建项目： 1vue create first-vue-jest 选择 Manually select features 进行手动选择功能配置： 12345678Vue CLI v3.10.0┌───────────────────────────┐│ Update available: 4.0.4 │└───────────────────────────┘? Please pick a preset: VUE-CLI3 (vue-router, node-sass, babel, eslint) default (babel, eslint)❯ Manually select features 勾选 Babel、Unit Testing： 12345678910? Check the features needed for your project: ◉ Babel ◯ TypeScript ◯ Progressive Web App (PWA) Support ◯ Router ◯ Vuex ◯ CSS Pre-processors ◯ Linter &#x2F; Formatter ◉ Unit Testing ◯ E2E Testing 选择 Jest: 123? Pick a unit testing solution: Mocha + Chai❯ Jest 选择 In dedicated config files 将各配置信息配置在对应的 config 文件里： 123? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)❯ In dedicated config files In package.json 输入 n，不保存预设： 1? Save this as a preset for future projects? (y&#x2F;N) n 项目创建完成后，部分文件的配置信息如下： babel.config.js: 123module.exports = &#123; presets: [&#x27;@vue/cli-plugin-babel/preset&#x27;],&#125; jest.config.js， 这个文件的配置默认是预设插件的，可以按实际需求改成上面提到的配置 Jest 里的配置一样。 123module.exports = &#123; preset: &#x27;@vue/cli-plugin-unit-jest&#x27;,&#125; package.json: 123456789101112131415161718192021&#123; &quot;name&quot;: &quot;first-vue-jest&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;test:unit&quot;: &quot;vue-cli-service test:unit&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;core-js&quot;: &quot;^3.1.2&quot;, &quot;vue&quot;: &quot;^2.6.10&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;^4.0.0&quot;, &quot;@vue/cli-plugin-unit-jest&quot;: &quot;^4.0.0&quot;, &quot;@vue/cli-service&quot;: &quot;^4.0.0&quot;, &quot;@vue/test-utils&quot;: &quot;1.0.0-beta.29&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot; &#125;&#125; 执行测试命令用上面的步骤创建的项目完成项目后，我们可以在 package.json 的 scripts 项中看到有个 test:unit ，执行它： 12cd first-vue-jestnpm run test:unit 然后终端里会看到输出结果，PASS 表示测试用例通过了，这个是官方提供单元测试例子。下面我们来写点自己的东西。 实现一个 ToDoList 看上面的原型图，有这么几点明确的需求： 在头部右侧输入框输入要做的事情，敲回车后，内容跑到待完成列表里，同时清空输入框 输入框为空的时候敲回车，不做任何变化 待完成列表支持编辑功能，已完成列表不能进行编辑 每个列表项的右侧都有删除按钮，用 - 号表示，点击后删除该项 待完成列表有标记为已完成的按钮，用 √ 号表示，点击后当前项移动到已完成列表 已完成列表有标记为未完成的按钮，用 x 号表示，点击后当前项移动到未完成列表 列表序号从 1 开始递增 当待完成列表为空的时候，不显示待完成字样 当已完成列表为空的时候，不显示已完成字样 先把上面的页面写好写页面之前先把创建项目的时候生成的 HelloWorld.vue 和对应的测试文件 example.spec.js 删除；同时修改 App.vue 文件，引入 ToDoList 组件： 123456789101112131415&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;ToDoList&gt;&lt;/ToDoList&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ToDoList from &#x27;./components/ToDoList&#x27;export default &#123; components: &#123; ToDoList &#125;&#125;&lt;/script&gt; 在 src/compoents 下新建一个文件 ToDoList.vue，样式较多就不贴出来了，具体可以去看本项目源码： 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;todolist&quot;&gt; &lt;header&gt; &lt;h5&gt;ToDoList&lt;/h5&gt; &lt;input class=&quot;to-do-text&quot; v-model=&quot;toDoText&quot; @keyup.enter=&quot;enterText&quot; placeholder=&quot;输入计划要做的事情&quot;/&gt; &lt;/header&gt; &lt;h4 v-show=&quot;toDoList.length &gt; 0&quot;&gt;待完成&lt;/h4&gt; &lt;ul class=&quot;wait-to-do&quot;&gt; &lt;li v-for=&quot;(item, index) in toDoList&quot; :keys=&quot;item&quot;&gt; &lt;p&gt; &lt;i&gt;&#123;&#123;index + 1&#125;&#125;&lt;/i&gt; &lt;input :value=&quot;item&quot; @blur=&quot;setValue(index, $event)&quot; type=&quot;text&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;span class=&quot;move&quot; @click=&quot;removeToComplete(item, index)&quot;&gt;√&lt;/span&gt; &lt;span class=&quot;del&quot; @click=&quot;deleteWait(index)&quot;&gt;-&lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h4 v-show=&quot;completedList.length &gt; 0&quot;&gt;已完成&lt;/h4&gt; &lt;ul class=&quot;has-completed&quot;&gt; &lt;li v-for=&quot;(item, index) in completedList&quot; :keys=&quot;item&quot;&gt; &lt;p&gt; &lt;i&gt;&#123;&#123;index + 1&#125;&#125;&lt;/i&gt; &lt;input :value=&quot;item&quot; disabled=&quot;true&quot; type=&quot;text&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;span class=&quot;move&quot; @click=&quot;removeToWait(item, index)&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;del&quot; @click=&quot;deleteComplete(index)&quot;&gt;-&lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;export default &#123; data() &#123; return &#123; toDoText: &#x27;&#x27;, toDoList: [], completedList: [] &#125; &#125;, methods: &#123; setValue(index, e) &#123; this.toDoList.splice(index, 1, e.target.value) &#125;, removeToComplete(item, index) &#123; this.completedList.splice(this.completedList.length, 0, item) this.toDoList.splice(index, 1) &#125;, removeToWait(item, index) &#123; this.toDoList.splice(this.toDoList.length, 0, item) this.completedList.splice(index, 1) &#125;, enterText() &#123; if (this.toDoText.trim().length &gt; 0) &#123; this.toDoList.splice(this.toDoList.length, 0, this.toDoText) this.toDoText = &#x27;&#x27; &#125; &#125;, deleteWait(index) &#123; this.toDoList.splice(index, 1) &#125;, deleteComplete(index) &#123; this.completedList.splice(index, 1) &#125; &#125;&#125;;&lt;/script&gt; 页面写完，原型上的需求也大概开发完成，页面大概长如下样子： 修改目录配置接下来就是开始编写单元测试文件了，写之前我们先把测试文件目录修改下为 __tests__，同时修改 jest.config.js 为如下配置，注意其中的 testMatch 已经修改为匹配 __tests__ 目录下的所有 .js 文件了。 12345678910111213module.exports = &#123; moduleFileExtensions: [&#x27;js&#x27;, &#x27;vue&#x27;], transform: &#123; &#x27;^.+\\\\.vue$&#x27;: &#x27;&lt;rootDir&gt;/node_modules/vue-jest&#x27;, &#x27;^.+\\\\.js$&#x27;: &#x27;&lt;rootDir&gt;/node_modules/babel-jest&#x27;, &#125;, moduleNameMapper: &#123; &#x27;^@/(.*)$&#x27;: &#x27;&lt;rootDir&gt;/src/$1&#x27;, &#125;, snapshotSerializers: [&#x27;jest-serializer-vue&#x27;], testMatch: [&#x27;**/__tests__/**/*.spec.js&#x27;], transformIgnorePatterns: [&#x27;&lt;rootDir&gt;/node_modules/&#x27;],&#125; 编写测试文件在 __tests__/unit/ 目录下新建文件 todolist.spec.js，我们约定测试某个 vue 文件，那么它的单元测试文件习惯命名成 *.spec.js 或 *.test.js。 123456789import &#123; shallowMount &#125; from &#x27;@vue/test-utils&#x27;import ToDoList from &#x27;@/components/ToDoList&#x27;describe(&#x27;test ToDoList&#x27;, () =&gt; &#123; it(&#x27;输入框初始值为空字符串&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) expect(wrapper.vm.toDoText).toBe(&#x27;&#x27;) &#125;)&#125;) 上面这个测试文件简要说明： shallowMount 将会创建一个包含被挂载和渲染的 Vue 组件的 Wrapper，只存根当前组件，不包含子组件。 describe(name, fn) 这边是定义一个测试套件，test ToDoList 是测试套件的名字，fn 是具体的可执行的函数 it(name, fn) 是一个测试用例，输入框初始值为空字符串 是测试用例的名字，fn 是具体的可执行函数；一个测试套件里可以保护多个测试用例。 expect 是 Jest 内置的断言风格，业界还存在别的断言风格比如 Should、Assert 等。 toBe 是 Jest 提供的断言方法， 更多的可以到Jest Expect 查看具体用法。 123456789it(&#x27;待完成列表初始值应该为空数组&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) expect(wrapper.vm.toDoList.length).toBe(0)&#125;)it(&#x27;已完成列表初始值应该为空数组&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) expect(wrapper.vm.completedList).toEqual([])&#125;) 待完成和已完成列表，居然是列表，所以存放数据的字段必须是 Array 类型，空列表就是空数组。如果第二个测试用例改成： 1expect(wrapper.vm.completedList).toBe([]) 将会报错，因为 toBe 方法内部是调用 Object.is(value1, value2) 来比较 2 个值是否相等的，和 == 或 === 的判断逻辑不一样。显然 Object.is([], []) 会返回 false。 12345678910111213141516171819202122it(&#x27;输入框值变化的时候，toDoText应该跟着变化&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.find(&#x27;.to-do-text&#x27;).setValue(&#x27;晚上要陪妈妈逛超市&#x27;) expect(wrapper.vm.toDoText).toBe(&#x27;晚上要陪妈妈逛超市&#x27;)&#125;)it(&#x27;输入框没有值，敲入回车的时候，无变化&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) const length = wrapper.vm.toDoList.length const input = wrapper.find(&#x27;.to-do-text&#x27;) input.setValue(&#x27;&#x27;) input.trigger(&#x27;keyup.enter&#x27;) expect(wrapper.vm.toDoList.length).toBe(length)&#125;)it(&#x27;输入框有值，敲入回车的时候，待完成列表将新增一条数据，同时清空输入框&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) const length = wrapper.vm.toDoList.length const input = wrapper.find(&#x27;.to-do-text&#x27;) input.setValue(&#x27;晚上去吃大餐&#x27;) input.trigger(&#x27;keyup.enter&#x27;) expect(wrapper.vm.toDoList.length).toBe(length + 1) expect(wrapper.vm.toDoText).toBe(&#x27;&#x27;)&#125;) setValue 可以设置一个文本控件的值并更新 v-model 绑定的数据。 .to-do-text 是一个 CSS 选择器；Vue-Test-Utils 提供了 find 方法来通过查找选择器，来返回一个 Wrapper；选择器可以是 CSS 选择器、可以是 Vue 组件也可以是一个对象，这个对象包含了组件的 name 或 ref 属性，比如可以这样用：wrapper.find(&#123; name: &#39;my-button&#39; &#125;) wrapper.vm 是一个 Vue 实例，只有 Vue 组件的包裹器才有 vm 这个属性；通过 wrapper.vm 可以访问所有 Vue 实例的属性和方法。比如：wrapper.vm.$data、wrapper.vm.$nextTick()。 trigger 方法可以用来触发一个 DOM 事件，这里触发的事件都是同步的，所以不必将断言放到 $nextTick() 里去执行；同时支持传入一个对象，当捕获到事件的时候，可以获取到传入对象的属性。可以这样写：wrapper.trigger(&#39;click&#39;, &#123;name: &quot;bubuzou.com&quot;&#125;) 1234567it(&#x27;待完成列表支持编辑功能，编辑后更新toDoList数组&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;toDoList: [&#x27;跑步半小时&#x27;]&#125;) wrapper.find(&#x27;.wait-to-do li&#x27;).find(&#x27;input&#x27;).setValue(&#x27;绕着公园跑3圈&#x27;) wrapper.find(&#x27;.wait-to-do li&#x27;).find(&#x27;input&#x27;).trigger(&#x27;blur&#x27;) expect(wrapper.vm.toDoList[0]).toBe(&#x27;绕着公园跑3圈&#x27;)&#125;) 先用 setData 给 toDoList 设置一个初始值，使其渲染出一个列表项；然后找到这个列表项，用 setValue 给其设置值，模拟了编辑；列表项的输入框是用 :value=&quot;item&quot; 绑定的 value, 所以 setValue 无法触发更新；只能通过 trigger 来触发更新 toDoList 的值。 123456789101112131415161718192021222324252627282930313233343536373839it(&#x27;待完成列表点击删除，同时更新toDoList数组&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;toDoList: [&#x27;睡前看一小时书&#x27;]&#125;) expect(wrapper.vm.toDoList.length).toBe(1) wrapper.find(&#x27;.wait-to-do li&#x27;).find(&#x27;.del&#x27;).trigger(&#x27;click&#x27;) expect(wrapper.vm.toDoList.length).toBe(0)&#125;)it(&#x27;点击待完成列表中某项的已完成按钮，数据对应更新&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;toDoList: [&#x27;中午饭后吃一个苹果&#x27;]&#125;) expect(wrapper.vm.toDoList.length).toBe(1) expect(wrapper.vm.completedList.length).toBe(0) wrapper.find(&#x27;.wait-to-do li&#x27;).find(&#x27;.move&#x27;).trigger(&#x27;click&#x27;) expect(wrapper.vm.toDoList.length).toBe(0) expect(wrapper.vm.completedList.length).toBe(1)&#125;)it(&#x27;点击已完成列表中某项的未完成按钮，数据对应更新&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;completedList: [&#x27;唱了一首歌&#x27;]&#125;) expect(wrapper.vm.toDoList.length).toBe(0) expect(wrapper.vm.completedList.length).toBe(1) wrapper.find(&#x27;.has-completed li&#x27;).find(&#x27;.move&#x27;).trigger(&#x27;click&#x27;) expect(wrapper.vm.toDoList.length).toBe(1) expect(wrapper.vm.completedList.length).toBe(0)&#125;)it(&#x27;列表序号从1开始递增&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;toDoList: [&#x27;早上做作业&#x27;, &#x27;下午去逛街&#x27;]&#125;) expect(wrapper.vm.toDoList.length).toBe(2) expect(wrapper.find(&#x27;.wait-to-do&#x27;).html()).toMatch(&#x27;&lt;i&gt;1&lt;/i&gt;&#x27;) expect(wrapper.find(&#x27;.wait-to-do&#x27;).html()).toMatch(&#x27;&lt;i&gt;2&lt;/i&gt;&#x27;)&#125;)it(&#x27;当待完成列表为空的时候，不显示待完成字样&#x27;, () =&gt; &#123; const wrapper = shallowMount(ToDoList) wrapper.setData(&#123;toDoList: []&#125;) expect(wrapper.find(&#x27;h4&#x27;).isVisible()).toBeFalsy() wrapper.setData(&#123;toDoList: [&#x27;明天去爬北山&#x27;]&#125;) expect(wrapper.find(&#x27;h4&#x27;).isVisible()).toBeTruthy()&#125;) 一个测试用例中可以写多个 expect 以保证断言的准确性。 异步测试最后我们为了模拟异步测试，所以加一个需求，即页面加载的时候会去请求远程待完成列表的数据。在项目根目录新建 __mocks__ 目录，同时新建 axios.js: 12345678910111213141516const toToList = &#123; success: true, data: [&#x27;上午去图书馆看书&#x27;, &#x27;下去出去逛街&#x27;]&#125;export const get = (url) =&gt; &#123; if (url === &#x27;toToList.json&#x27;) &#123; return new Promise((resolve, reject) =&gt; &#123; if (toToList.success) &#123; resolve(toToList) &#125; else &#123; reject(new Error()) &#125; &#125;) &#125;&#125; 修改 ToDoList.vue，导入 axios 和增加 mounted： 12345678910111213&lt;script&gt;import * as axios from &#x27;../../__mocks__/axios&#x27;export default &#123; mounted () &#123; axios.get(&#x27;toToList.json&#x27;).then(res =&gt; &#123; this.toDoList = res.data &#125;).catch(err =&gt; &#123; &#125;) &#125;,&#125;;&lt;/script&gt; 测试用例编写为： 123456it(&#x27;当页面挂载的时候去请求数据，请求成功后应该会返回2条数据&#x27;, (done) =&gt; &#123; wrapper.vm.$nextTick(() =&gt; &#123; expect(wrapper.vm.toDoList.length).toBe(2) done() &#125;)&#125;) 对于异步的代码，写断言的时候需要放在 wrapper.vm.$nextTick() 里，且手动调用 done()。 配置测试覆盖率测试用例写了部分，如果我们看下覆盖率如何，就需要要配置测试覆盖率。在 jest.config.js 里新增配置： 12collectCoverage: true,collectCoverageFrom: [&quot;**/*.&#123;js,vue&#125;&quot;, &quot;!**/node_modules/**&quot;], 在 package.json 的 scripts 中新增一条配置: 1&quot;test:cov&quot;: &quot;vue-cli-service test:unit --coverage&quot; 然后我们在终端运行： npm run test:cov，结果如下： 运行测试覆盖率命名后会在项目根目录生成 coverage 目录，浏览器打开里面的 index.html ：","categories":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"}],"tags":[{"name":"jest","slug":"jest","permalink":"https://bubuzou.com/tags/jest/"},{"name":"单元测试","slug":"单元测试","permalink":"https://bubuzou.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"Git常用操作，一文打尽","slug":"git-all-actions","date":"2019-09-24T08:29:10.000Z","updated":"2021-09-06T09:57:05.177Z","comments":true,"path":"2019/09/24/git-all-actions/","link":"","permalink":"https://bubuzou.com/2019/09/24/git-all-actions/","excerpt":"创建版本库 git clone url 克隆远程版本库 git init 初始化本地版本库","text":"创建版本库 git clone url 克隆远程版本库 git init 初始化本地版本库 配置 git config --global user.name &#39;chengcp&#39; 配置global级别的用户名 git config --global user.email &#39;1326895569@qq.com&#39; 配置global级别的邮箱 git config --global -l 查看global级别的配置列表 git config --global --unset user.name 删除用户名 git config --global alias.last &#39;log -1 HEAD&#39; 配置last别名，使用git last将显示最近的一次提交记录 添加和删除文件 git add file1 file2 添加指定文件到暂存区 git add dir 添加指定目录到暂存区 git add . 添加当前目录的所有文件到暂存区 git mv oldname newname 对一个已经追踪过的文件进行改名，同时加入暂存区 git rm file1 file2 删除工作区文件，同时将这次删除放入暂存区 git rm --cached file 停止追踪指定文件，但该文件会保留在工作区；tracked变成untracked 提交 git commit file1 file 2 -m message 提交暂存区指定文件到本地仓库 git commit -m message 提交暂存区所有文件到本地仓库 git commit -a -m message 自动暂存所有已经追踪过的文件，且提交到本地仓库 git commit --amend -m message 使用一次新的提交，替代上次提交 分支 git branch 查看所有本地分支 git branch –r 查看所有远程分支 git branch –a 查看所有远程和本地分支 git branch –v 查看本地所有分支最新一次提交信息 git branch [branch] 新建分支 git checkout –b [branch] 新建一个分支，并且切换过去 git branch [branch] [commit] 基于某次提交，建立一个分支 git branch --track [branch] [remote-branch] 建立一个分支，并且与远程分支建立追踪关系 git branch --set-upstream [branch] [remote-branch] 在现有的本地分支和远程分支之间建立追踪关系 git branch –m [old-branch] [new-branch] 重命名分支 git merge [branch] 把指定分支合并到当前分支 git chery-pick [commit] [commit] 选择提交，合并进当前分支 git branch –d [branch] 删除本地分支 git push origin –d [branch] 删除远程分支 git checkout [branch] 切换分支 git checkout - 切换到上一个最近使用过的分支 标签 git tag 列出所有标签 git show [tag] 查看指定标签信息 git tag [tag] 给最近一次提交打一个标签 git tag [tag] [commit] 在某次提交上打一个标签 git tag –d [tag] 删除本地指定标签 git push origin –d tag [tag] 删除远程的标签 git push origin [tag] 推送指定标签 git push origin --tags 推送所有标签 查看信息 git status 查看文件状态 git help [command] 获取帮助文档 git [command] --help 获取帮助文档 git log 查看当前分支的提交记录 git log –all 查看所有分支的提交记录 git log -5 --oneline --graph 查看最近 5 次提交记录，以单行、树状图形式显示 git reflog 查看本地所有变更记录 git diff 查看工作区和暂存区的差异 git diff -- file 某个文件在工作区和暂存区的差异 git diff HEAD 工作区和最新一次提交的差异 git diff --cached 暂存区和 HEAD 的差异 git diff branch_a branch_b – file 某文件在两个分支间的差异 远程操作 git remote -v 查看所有远程仓库 git ls-remote origin 查看远程仓库引用列表 git remote show origin 查看远程仓库信息 git fetch origin 拉取远程仓库最新提交 git pull origin master 拉取远程master，并且合并到本地当前分支 git remote add upstream url 添加一个新的远程仓库，命名为upstream git push origin master 推送到远程origin的master分支 git push origin --all 推送所有分支到远程仓库 git remote prune origin 删除远程仓库中不存在的分支 撤销 git reset --soft HEAD 回滚到指定版本，保留工作区和暂存区 git reset --mixed HEAD 回滚到指定版本，保留工作区，清空暂存区；--mixed是默认参数，即等同于git reset HEAD git reset --hard HEAD 回滚到指定版本，清空工作区和暂存区 git reset HEAD -- file 清空暂存区中某个文件的修改 git checkout -- file 检出暂存区的文件到工作目录 git checkout . 检出暂存区的所有文件到工作目录 git revert HEAD~ 2 回滚到 2 个祖先提交的版本，同时产生新的提交记录 git revert --continue 冲突解决，且把修改提交到暂存区后执行回滚，生成一个新的提交 git revert –abort 取消回滚，回到之前的状态 储藏 git stash 将工作区和暂存区的变更保存到储藏堆栈中，同时工作区和暂存区恢复到HEAD一样 git stash list 查看储藏列表 git stash pop 应用最近的一次储藏，并且从储藏栈中移除该条记录 git stash apply stash@&#123;0&#125; 应用最近的一次储藏，不移除记录；等同于 git stash apply git stash pop --index 应用最近一次储藏，--index表示暂存区的变更也会更新，否则只更新工作区变更 git stash drop stash@&#123;0&#125; 移除储藏记录","categories":[{"name":"git","slug":"git","permalink":"https://bubuzou.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://bubuzou.com/tags/git/"}]},{"title":"vue-quill-editor插入图片路径太长问题解决","slug":"vue-quill-editor","date":"2019-07-26T02:49:08.000Z","updated":"2021-09-06T09:58:10.131Z","comments":true,"path":"2019/07/26/vue-quill-editor/","link":"","permalink":"https://bubuzou.com/2019/07/26/vue-quill-editor/","excerpt":"最近做项目的时候有一个发布新闻的需求，新闻编辑的时候要求能发布带格式的文本内容和能展示支持图片。由于项目是用 vue 开发的，所以找编辑器的时候选了 vue-quill-editor 。编辑器长如下的样子：","text":"最近做项目的时候有一个发布新闻的需求，新闻编辑的时候要求能发布带格式的文本内容和能展示支持图片。由于项目是用 vue 开发的，所以找编辑器的时候选了 vue-quill-editor 。编辑器长如下的样子： 现在的问题但是这个编辑器会把插入的图片会转成 base64 位的编码，使得编辑器内容保存进数据库的时候会超出限制长度，从而报错。 从问题来源着手首先要明白导致这个问题的原因是 vue-quill-editor 编辑器默认把上传的图片给转成 base64 编码，那是不是有这么一个配置参数可以设置上传后图片的格式呢？经过一番文档的查找，貌似是没有。但是提供了一个 handlers 可以自定义图片上传的方式，那就从这里下文章。大概意思是点击这个图片按钮的时候，会出发一个回调，可以在回调里触发自己的文件上传开关。这里我用的文件上传是 element-ui 的 el-upload。 安装vue-quill-editor1npm install vue-quill-editor --save 配置vue-quill-editor配置 html 123456789&lt;quill-editor v-model=&quot;ruleForm.content&quot; ref=&quot;myQuillEditor&quot; :options=&quot;editorOption&quot; class=&quot;ql-editor&quot; :class=&quot;operationType.includes(&#x27;check&#x27;) ? &#x27;disabled&#x27; : &#x27;&#x27;&quot; :disabled=&quot;operationType.includes(&#x27;check&#x27;)&quot;&gt;&lt;/quill-editor&gt; 导入vue-quill-editor 且设置components： 123456import &#123; quillEditor &#125; from &#x27;vue-quill-editor&#x27;export default &#123; components: &#123; quillEditor, &#125;,&#125; 设置options: 123456789101112131415161718192021222324252627282930editorOption:&#123; modules: &#123; toolbar: &#123; container: [ [&#x27;bold&#x27;, &#x27;italic&#x27;, &#x27;underline&#x27;, &#x27;strike&#x27;], [&#x27;blockquote&#x27;, &#x27;code-block&#x27;], [&#123; &#x27;list&#x27;: &#x27;ordered&#x27; &#125;, &#123; &#x27;list&#x27;: &#x27;bullet&#x27; &#125;], [&#123; &#x27;script&#x27;: &#x27;sub&#x27; &#125;, &#123; &#x27;script&#x27;: &#x27;super&#x27; &#125;], [&#123; &#x27;indent&#x27;: &#x27;-1&#x27; &#125;, &#123; &#x27;indent&#x27;: &#x27;+1&#x27; &#125;], [&#123; &#x27;size&#x27;: [&#x27;small&#x27;, false, &#x27;large&#x27;, &#x27;huge&#x27;] &#125;], [&#123; &#x27;header&#x27;: [1, 2, 3, 4, 5, 6, false] &#125;], [&#123; &#x27;color&#x27;: [] &#125;, &#123; &#x27;background&#x27;: [] &#125;], [&#123; &#x27;align&#x27;: [] &#125;], [&#x27;clean&#x27;], [&#x27;link&#x27;, &#x27;image&#x27;] ], handlers: &#123; image: function(value) &#123; if (value) &#123; // 触发element-ui的文件上传 document.querySelector(&quot;.avatar-uploader input&quot;).click(); &#125; else &#123; this.quill.format(&quot;image&quot;, false); &#125; &#125;, &#125; &#125; &#125;, placeholder: &#x27;请输入&#x27;,&#125;, 引入相关style： 12345&lt;style lang=&quot;scss&quot;&gt; @import &#x27;~quill/dist/quill.core.css&#x27;; @import &#x27;~quill/dist/quill.snow.css&#x27;; @import &#x27;~quill/dist/quill.bubble.css&#x27;;&lt;/style&gt; 配置el-uploadtemplate： 12345678910111213&lt;el-upload ref=&quot;quillUploader&quot; class=&quot;avatar-uploader&quot; :action=&quot;serverUrl&quot; :show-file-list=&quot;false&quot; :auto-upload=&quot;false&quot; :on-change=&quot;onChangeQuill&quot; :before-upload=&quot;beforeUpload&quot; :limit=&quot;20&quot; :multiple=&quot;true&quot; :accept=&quot;acceptFile&quot;&gt;&lt;/el-upload&gt; onChange的时候执行文件上传，这里的文件上传用的是腾讯的对象存储服务，cosUtils封装了一些对象存储的一些工具方法，你们可以自行替换成自己后端的上传接口。下面这段代码的大概意思是文件上传到对象存储服务器成功之后，拿到具体的图片地址，插入到编辑器光标所在的位置，这个时候图片就显示出来了。 123456789101112131415onChangeQuill(file, fileList) &#123; let fileName = file.uid + file.name cosUtils.putObject(fileName, file.raw, &#x27;operate/&#x27;, (err, data) =&gt; &#123; // 新闻图片存到operate/目录下 console.log(err || data) if (!err) &#123; let quill = this.$refs.myQuillEditor.quill let length = quill.getSelection().index // 图片上传到对象存储后的具体地址 let imgSrc = `https://huzhouhuanzi-xxxxxxx.cos.ap-shanghai.myqcloud.com/operate/$&#123;fileName&#125;` quill.insertEmbed(length, &quot;image&quot;, imgSrc) // 调整光标到最后 quill.setSelection(length + 1) &#125; &#125;)&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"}],"tags":[{"name":"图像","slug":"图像","permalink":"https://bubuzou.com/tags/%E5%9B%BE%E5%83%8F/"},{"name":"upload","slug":"upload","permalink":"https://bubuzou.com/tags/upload/"},{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/tags/vue/"}]},{"title":"小程序根据打包命令区分不同环境的API","slug":"wepy-plugins-preprocess","date":"2019-06-26T23:52:40.000Z","updated":"2019-06-27T04:23:15.051Z","comments":true,"path":"2019/06/27/wepy-plugins-preprocess/","link":"","permalink":"https://bubuzou.com/2019/06/27/wepy-plugins-preprocess/","excerpt":"一般来讲项目都会有开发版、测试版和生产版这三个版本，不同版本对应不同的API域名，比如可能会是这样子： 123const HOST_DEV = &#x27;https://dev-bubuzouapi.com/&#x27; // 开发环境APIconst HOST_TEST = &#x27;https://test-bubuzouapi.com/&#x27; // 测试环境APIconst HOST = &#x27;https://bubuzouapi.com/&#x27; // 生产环境API 前端项目里要如何区分用什么时候用哪个API呢？比较笨的方法是，比如这次我要打一个测试环境给测试用，那我必须手动的把 HOST_TEST 这个变量的值设置到请求的 url 里。如果下次需要打其他环境的包，那我就需要再次手动更改 url 为别的值，这样显得很不方便。","text":"一般来讲项目都会有开发版、测试版和生产版这三个版本，不同版本对应不同的API域名，比如可能会是这样子： 123const HOST_DEV = &#x27;https://dev-bubuzouapi.com/&#x27; // 开发环境APIconst HOST_TEST = &#x27;https://test-bubuzouapi.com/&#x27; // 测试环境APIconst HOST = &#x27;https://bubuzouapi.com/&#x27; // 生产环境API 前端项目里要如何区分用什么时候用哪个API呢？比较笨的方法是，比如这次我要打一个测试环境给测试用，那我必须手动的把 HOST_TEST 这个变量的值设置到请求的 url 里。如果下次需要打其他环境的包，那我就需要再次手动更改 url 为别的值，这样显得很不方便。 wepy-plugin-preprocess如果你的小程序用的是 wepy 框架来构建的话，你可以用 wepy-plugin-preprocess 这个插件来对 js 进行一个预处理，可以使得每次设置到请求里的 url 的值是根据打包命令来的。 wepy-plugin-preprocess 是依赖于 preprocess 这个包的，这个包里定义了一些用于预处理的指令，比如 @if VAR=&#39;value&#39;、@ifdef VAR、@include 这种，想要了解更多用法，请点击这里。 安装插件： 1npm install wepy-plugin-preprocess --save-dev 配置wepy.config.js文件123456789let ENV = process.env.NODE_ENVmodule.exports = &#123; plugins: &#123; preprocess: &#123; filter: /\\.js$/, context: &#123; ENV &#125; &#125; &#125;,&#125; 设置package.json文件想要区分不同的环境，就需要配置几个不同环境的打包命令。 1234567&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;cross-env NODE_ENV=dev wepy build --watch&quot;, &quot;test&quot;: &quot;cross-env NODE_ENV=test wepy build --no-cache&quot;, &quot;prod&quot;: &quot;cross-env NODE_ENV=prod wepy build --no-cache&quot;, &#125;&#125; 定义常量文件常量文件里可以定义一些项目里用到的常量，比如这里会定义 API 域名。然后把常量导出去，需要用的地方再导入即可使用这些常量。 1234567891011121314/* @if ENV=&#x27;dev&#x27; **const HOST = exports.HOST = &#x27;https://dev-bubuzouapi.com/&#x27; // 开发环境APIconst HOST_SOCKET = exports.HOST_SOCKET = &#x27;wss://dev-bubuzouapi.com/&#x27; // 开发环境socket/* @endif *//* @if ENV=&#x27;test&#x27; **const HOST = exports.HOST = &#x27;https://test-bubuzouapi.com/&#x27; // 测试环境APIconst HOST_SOCKET = exports.HOST_SOCKET = &#x27;wss://test-bubuzouapi.com/&#x27; // 测试环境socket/* @endif *//* @if ENV=&#x27;prod&#x27; **const HOST = exports.HOST = &#x27;https://bubuzouapi.com/&#x27; // 生产环境APIconst HOST_SOCKET = exports.HOST_SOCKET = &#x27;wss://bubuzouapi.com/&#x27; // 生产环境socket/* @endif */ 通过命令切换api域名切换成开发环境： 1npm run dev // 编译完成后请求的域名就是&#x27;https://dev-bubuzouapi.com/&#x27; 切换成测试环境： 1npm run test 切换成生产环境： 1npm run prod","categories":[{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"element-ui文件上传一次请求上传多个文件","slug":"once-request-to-upload-multiple-files","date":"2019-03-26T08:48:21.000Z","updated":"2021-09-06T09:57:44.075Z","comments":true,"path":"2019/03/26/once-request-to-upload-multiple-files/","link":"","permalink":"https://bubuzou.com/2019/03/26/once-request-to-upload-multiple-files/","excerpt":"最近在做项目的时候有一个需求，需要导入 word 文档，并且需要支持多选。element-ui 的 upload 组件支持多选文件，只需要配置参数 multiple 为 true 即可。但是这个组件默认会将多选的文件分多次进行上传，于是就会存在多次的上传请求，由于后台的接口要求是一次请求能够上传多个文件，且我们也知道请求多了会对服务器造成更大的压力，因而基于多种原因，这个 upload 的上传行为得进行改造一番。","text":"最近在做项目的时候有一个需求，需要导入 word 文档，并且需要支持多选。element-ui 的 upload 组件支持多选文件，只需要配置参数 multiple 为 true 即可。但是这个组件默认会将多选的文件分多次进行上传，于是就会存在多次的上传请求，由于后台的接口要求是一次请求能够上传多个文件，且我们也知道请求多了会对服务器造成更大的压力，因而基于多种原因，这个 upload 的上传行为得进行改造一番。 先来看下改造前后的结果改造前的结果：同时上传 2 个文件，会发出 2 次对接口的请求，每次请求里包含了一个文件。 改造后的结果：同时上传 2 个文件，会发出一次接口请求，接口入参里包含 2 个文件。 方法一：通过配置 file-list（推荐使用）html 部分： 1234567891011121314&lt;el-upload class=&quot;upload-demo list-uploadbtn&quot; ref=&quot;upload&quot; :action=&quot;curBastUrl&quot; :auto-upload=&quot;false&quot; :on-remove=&quot;updataRemove&quot; :before-upload=&quot;beforeUpload&quot; :on-change=&quot;updatachange&quot; :file-list=&quot;fileList&quot; :multiple=&quot;true&quot;&gt; &lt;el-button size=&quot;small&quot;&gt;点击上传&lt;/el-button&gt;&lt;/el-upload&gt;&lt;el-button type=&quot;primary&quot; @click=&quot;submitUpload&quot;&gt;确 定&lt;/el-button&gt; js 部分： 12345678910111213141516submitUpload() &#123; // 导入 let formData = new FormData(); // 用FormData存放上传文件 this.fileList.forEach(file =&gt; &#123; formData.append(&#x27;file&#x27;, file.raw) &#125;) formData.append(&#x27;categoryDirectory&#x27;, this.filedata.categoryDirectory) // importCase是上传接口 importCase(formData).then((res) =&gt; &#123; //手动上传无法触发成功或失败的钩子函数，因此这里手动调用 this.updataSuccess(res.data) &#125;, (err) =&gt; &#123; &#125;)&#125; 关键代码说明： auto-upload 设置为 false 用于关闭组件的自动上传； file-list 配置一个数组用于接收上传的文件列表； multiple 设置为 true 表示支持多选文件； action 配置为完整的上传接口 url，不配置会报错 不用配置 data、on-success、on-error等参数，因为手动上传不会用到这些配置信息； 最后通过点击按钮手动调用上传函数 submitUpload ，创建一个 FormData 把 fileList 的文件存进去。 方法二：通过配置 http-requesthtml 部分： 1234567891011121314&lt;el-upload class=&quot;upload-demo list-uploadbtn&quot; ref=&quot;upload&quot; :action=&quot;curBastUrl&quot; :auto-upload=&quot;false&quot; :http-request=&quot;uploadFile&quot; :on-remove=&quot;updataRemove&quot; :before-upload=&quot;beforeUpload&quot; :on-change=&quot;updatachange&quot; :multiple=&quot;true&quot;&gt; &lt;el-button size=&quot;small&quot;&gt;点击上传&lt;/el-button&gt;&lt;/el-upload&gt;&lt;el-button type=&quot;primary&quot; @click=&quot;submitUpload&quot;&gt;确 定&lt;/el-button&gt; js 部分： 123456789101112131415161718submitUpload() &#123; // 导入 let tempData = this.filedata this.filedata = new FormData() // 用FormData存放上传文件 this.$refs.upload.submit() // 会循环调用uploadFile方法，多个文件调用多次 this.filedata.append(&#x27;categoryDirectory&#x27;, tempData.categoryDirectory) // importCase是上传接口 importCase(this.filedata).then((res) =&gt; &#123; //手动上传无法触发成功或失败的钩子函数，因此这里手动调用 this.updataSuccess(res.data) &#125;, (err) =&gt; &#123; &#125;)&#125;uploadFile(file) &#123; this.filedata.append(&#x27;file&#x27;, file.file)&#125; 关键代码说明： http-request 自定义上传方法； 最后通过点击按钮手动调用上传函数 submitUpload ，创建一个 FormData, 调用 upload 组件的 submit 方法的时候会循环调用 http-request 配置的方法，从而往 FormData 里存放文件。","categories":[{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"}],"tags":[{"name":"upload","slug":"upload","permalink":"https://bubuzou.com/tags/upload/"},{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/tags/vue/"},{"name":"element","slug":"element","permalink":"https://bubuzou.com/tags/element/"}]},{"title":"JS中类数组的遍历以及性能探究","slug":"traverse-of-array-like","date":"2017-08-28T04:08:21.000Z","updated":"2019-07-26T08:05:11.771Z","comments":true,"path":"2017/08/28/traverse-of-array-like/","link":"","permalink":"https://bubuzou.com/2017/08/28/traverse-of-array-like/","excerpt":"类数组在 JS 中我们都知道有一种数据类型叫数组，平常也用得很多，这里看到数组的介绍。但什么是类数组呢？在 JS 中存在一些对象，它们都带有 length 属性，却又不具备数组的那些方法，这些对象我们它叫做类数组。那么类数组有哪些呢？ jQuery对象 12var aList = $(&#x27;.tagcloud&#x27;).find(&#x27;a&#x27;);console.log( aList.length ); // &gt;= 0 如上通过jQuery获取的元素集合就是一个典型的类数组。","text":"类数组在 JS 中我们都知道有一种数据类型叫数组，平常也用得很多，这里看到数组的介绍。但什么是类数组呢？在 JS 中存在一些对象，它们都带有 length 属性，却又不具备数组的那些方法，这些对象我们它叫做类数组。那么类数组有哪些呢？ jQuery对象 12var aList = $(&#x27;.tagcloud&#x27;).find(&#x27;a&#x27;);console.log( aList.length ); // &gt;= 0 如上通过jQuery获取的元素集合就是一个典型的类数组。 NodeList 12var h2s = document.querySelectorAll(&#x27;h2&#x27;);console.log( h2s.constructor ); // ƒ NodeList() &#123; [native code] &#125; NodeList是节点集合，既包括了元素节点也包含了文本节点，比如node.childNodes也是一个 NodeList. HTMLCollection 12var h4s = document.getElementsByTagName(&#x27;h4&#x27;);console.log( h4s instanceof HTMLCollection ); // true HTMLCollection 是元素集合，更多详细信息可以看这里 类数组虽然没有数组的那些方法，但是可以通过 call 方法将其转成数组： 1234var h2s = document.querySelectorAll(&#x27;h2&#x27;);console.log( h2s.constructor ); // ƒ NodeList() &#123; [native code] &#125;var temp = Array.prototype.slice.call(h2s, null);console.log( temp instanceof Array ); // true 遍历类数组数组或者类数组的遍历方式很多，下面我们一一来介绍。 普通 for 循环 123for ( var i = 0; i &lt; arr.length; i++ ) &#123; &#125; 最普通也是最经典的 for 循环，大多数开发都喜欢用的方式。 优化版 for 循环 123for ( var i = 0, l = arr.length; i &lt; l; i++ ) &#123; &#125; 优化后的for循环，把数组长度的取值放到了定义变量的时候，避免了每次判断都要去取数组长度，从而节约了一定时间。 弱化版for循环 123for ( var i = 0; arr[i] != null; i++ ) &#123; &#125; 这种循环方式和上面两种都差不了多少，只不过是没有使用length判断，而使用变量本身判断。 forEach循环 123arr.forEach(function( item ) &#123; &#125;); JS数组自带的遍历方法。 新版forEach 123Array.prototype.forEach.call(arr, function( ele ) &#123; &#125;); 借用了原型的call方法来遍历类数组。 for in循环 123for ( var temp in arr ) &#123; &#125; for of循环 123for ( let v of arr ) &#123; &#125; ES6中新提出的一种循环方式。 map循环 123arr.map(function(e, i) &#123; &#125;); while循环 1234var flag = 0;while ( flag++ &lt; arr.length ) &#123; &#125; 性能测试这里测试里主要是通过控制外循环次数、数组的长度和循环体的复杂度来达到模拟性能测试的目的。 12345678// 核心代码var t4 = new Date().getTime();for ( var j = 0; j &lt; count; j++ ) &#123; // 外循环 arr.forEach(function( cha ) &#123; // 内循环 contextFn( cha ); // 循环体 &#125;);&#125;console.log( new Date().getTime() - t4) ); 内循环里是分别替换到不同的遍历方式，通过设置循环次数和数组长度来测试了一些数据，也可以来这里看demo 从上面的测试结果大致可以看出速度最快的遍历方式应该是优化后的 for 循环了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://bubuzou.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"良好的CSS编码习惯","slug":"css-coding-standards","date":"2017-07-18T07:28:21.000Z","updated":"2021-09-06T09:56:35.356Z","comments":true,"path":"2017/07/18/css-coding-standards/","link":"","permalink":"https://bubuzou.com/2017/07/18/css-coding-standards/","excerpt":"一个 css 文件的核心内容是由许许多多的 css 规则组成的，而每个规则又包含了两部分：选择器和声明；声明块里可能又包含多个声明，每个声明又是由属性和值组成的。这个大概就是 css 的代码结构。 这么多的规则就像一个小镇上的房子一样，如果房子建造之初，毫无规划胡乱建造，那等房子建造起来的时候，从远远望去就会非常地错杂不堪，难以入目，给人的心里埋下了非常糟糕的印象；又可能后期，由于发展的需要，要给小镇加修道路或者新建个学校，由于房子与房子之间连接得很混乱，所以这给后期重建镇子的人带来了很大的困难。 同样，在 css 的世界里，代码的排列布局也是非常重要的。良好的代码书写习惯能够让代码看起来更加干净简洁，给阅读者一种赏心悦目的感觉；好的代码便于开发发现错误，提高工作效率。所以作为一名好前端，很有必要养成一个良好的 css 编码习惯。","text":"一个 css 文件的核心内容是由许许多多的 css 规则组成的，而每个规则又包含了两部分：选择器和声明；声明块里可能又包含多个声明，每个声明又是由属性和值组成的。这个大概就是 css 的代码结构。 这么多的规则就像一个小镇上的房子一样，如果房子建造之初，毫无规划胡乱建造，那等房子建造起来的时候，从远远望去就会非常地错杂不堪，难以入目，给人的心里埋下了非常糟糕的印象；又可能后期，由于发展的需要，要给小镇加修道路或者新建个学校，由于房子与房子之间连接得很混乱，所以这给后期重建镇子的人带来了很大的困难。 同样，在 css 的世界里，代码的排列布局也是非常重要的。良好的代码书写习惯能够让代码看起来更加干净简洁，给阅读者一种赏心悦目的感觉；好的代码便于开发发现错误，提高工作效率。所以作为一名好前端，很有必要养成一个良好的 css 编码习惯。 文件命名web 项目中的所有资源文件名称应遵循相同的命名约定。css 文件也不例外，来看下面的例子： 12345678910111213&#x2F;* Not recommended *&#x2F;MyScript.jsmyCamelCaseName.cssi_love_underscores.html1001-scripts.jsmy-file-min.css&#x2F;* Recommended *&#x2F;my-script.jsmy-camel-case-name.cssi-love-underscores.htmlthousand-and-one-scripts.jsmy-file.min.css 一般来说资源文件的名字习惯如下命名： 以字母开头，避免数字开头 全部用小写，这样的话不容易在引用的时候因为大小写而出错 用-来分隔单词，而不是下划线 对于压缩过的文件，比如 css 或者 js 文件，使用 .min 代替 -min 设置编码在 css 文件的最顶部设置编码格式为 utf-8 ，否则有可能使得 css 文件出现乱码。 1@charset &quot;utf-8&quot;; 格式化css 文件里包含了许许多多的 css 规则，而每条 css 规则又由两部分组成，分别是选择器和声明块；声明块里包含了多个声明，而声明又是属性和值组成的。格式化里将要介绍的就是它们的结构和摆放位置，包括缩进、空格、换行以及个别声明的书写习惯等。 缩进css 代码的缩进让代码结构更加清晰，css 代码缩进需要遵循以下几点： 一个制表符( Tab 键)相当于 4 个空格(空格键)，css 的缩进占位一般是一个制表符的宽度。 缩进占位里不要混杂着制表符和空格，建议设置好编辑器的一个制表符等于 4 个空格宽度。 声明需要缩进；在 media query 里的所有 css 规则也需要缩进。 12345@media screen and (max-width: 640px) &#123; body &#123; background-color: #f8f8f8; &#125;&#125; 空格在 css 的世界里为了让代码看起来不那么拥挤，所以需要在适当的地方使用空格： 选择器和声明块的左大括号{之间。 声明中属性的冒号之后，属性值之前。 对于只有一条声明的声明块，声明的左右两边与左右大括号之间。 对于一个属性中有多个属性值，且放在同一行的时候，用来分隔各个属性值的逗号的后面。 对于一些特别的属性值里存在逗号分隔的情况，比如 rgba(248, 248, 248, .5)，需要在每个逗号后加上空格 12345678.heavy &#123; font-weight: 700;&#125;body &#123; font-family: Georgia, serif; background-color: rgba(248, 248, 248, 0.5);&#125; 换行和空行换行和空行的目的也是为了 css 代码的美观性和结构更加清晰： 每个 css 规则之间需要一个空行。 单行注释的前面需要一个空行。 一个规则里存在多个选择器的时候，每个选择器的逗号后换行。 一个声明块里有多个声明的时候，每条声明后都需要换行；只有一条声明的时候，声明和选择器同行。 对于逗号分隔且非常长的属性值，可以考虑换行并且缩进一个制表符。 media query 声明的第一行空行，这样就不会和第一条声明杂在一起，显得拥挤。 1234567891011121314151617181920.modal &#123; width: 500px; margin: 0 auto;&#125;.modal a,.modal span &#123; color: #41b883;&#125;/* common */.shadow &#123; box-shadow: 1px 1px 1px #000, 2px 2px 1px 1px #ccc inset;&#125;@media screen and (max-width: 640px) &#123; .modal .modal-con a &#123; font-size: 12px; &#125;&#125; 选择器选择器这块主要是介绍命名、书写习惯以及为了更高的匹配效率而建议的写法等。 ID 和 Class 的命名规范ID 和 Class 的主要习惯于如下命名方式： 全部字母用小写，避免使用驼峰命名法。 使用短横线-来作为连接单词之间的字符，避免使用下划线_。 1234.post-title &#123; font-size: 20px; color: #41b883;&#125; 命名尽可能语义化，让人一目了然。 1234567891011121314151617/* Not recommended */.fw-800 &#123; font-weight: 800;&#125;.red &#123; color: red;&#125;/* Recommended */.heavy &#123; font-weight: 800;&#125;.important &#123; color: red;&#125; 尽可能避免使用 ID 选择器在 css 的世界里不太欢迎 ID 选择器，因为 ID 是作为某个元素的唯一标识而设定的，但是元素的样式是可以被重复定义，层层覆盖的。所以建议不要使用 ID 选择器，取而代之的是多用类选择器。 123456789/* Not recommended */#article p &#123; line-height: 28px;&#125;/* Recommended */.article p &#123; line-height: 28px;&#125; 避免使用标签进行双重限定这是什么意思呢？看了下面的例子你就知道了。 123456789/* Not recommended */p.desc &#123; color: #666;&#125;/* Recommended */.desc &#123; color: #666;&#125; 尽可能的精确，但是最好不要超过 3 级css 的选择判定也存在效率问题，所以书写的时候尽量要精确；选择器的嵌套层级最好不要超过 3 级，否则显得很冗长，效率上也未必更高。 123456789/* Not recommended */.content .title &#123; font-size: 2rem;&#125;/* Recommended */.content &gt; .content-body &gt; .title &#123; font-size: 2rem;&#125; 属性选择器记得使用双引号属性选择器记得使用双引号，避免单引号和不用引号 123456789/* Not recommended */input[type=&#x27;text&#x27;] &#123; line-height: 1.2;&#125;/* Recommended */input[type=&#x27;text&#x27;] &#123; line-height: 1.2;&#125; 声明块作为 css 规则中的第二部分，声明块中自然也有许多需要注意的地方。比如声明的顺序、属性和值的写法以及一些个例等。 声明的顺序在 css 中存在好几百个属性，如果需要一个 css 规则里几乎可以写满这些属性。如果这些声明毫无顺序章法可言，那么在需要修改的时候就会非常的头痛了，一大块声明杂在一个规则里，你就需要慢慢地找慢慢地看了。但是如果你的声明都是按照一定的逻辑顺序来书写，那么声明的层次就非常清晰。声明的时候一般比较重要的属性会优先书写。 如果包含了 content属性，则应该最优先书写，即写到声明块的最上面。 定位相关的属性，比如position、top、left、z-index、display、float、visibility和overflow、flex等。 布局相关的属性，比如display、float、visibility、overflow、flex和clear等。 盒模型相关的属性，比如width、height、margin、padding、border以及box-sizing等。 文本排版印刷相关的属性，比如font、line-height、vertical-align、text-align和white-space、text-decoration等。 视觉感官上相关的属性，比如color、background、list-style、transform、transition和animation等。 12345678910111213141516171819202122232425262728.box &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Layout */ display: block; float: right; /* Box-model */ width: 100px; height: 100px; border: 1px solid #e5e5e5; border-radius: 3px; /* Typography */ font: normal 13px &#x27;Helvetica Neue&#x27;, sans-serif; line-height: 1.5; text-align: center; /* Visual */ color: #333; background-color: #f5f5f5;&#125; 尽可能的使用简写属性在 css 中存在一些属性是可以拆分成其他独立属性的，比如background、border、font、list-style、margin 和 padding 等。这些属性在 css 里被称为复合属性，又因为一个属性包含了多个独立属性，所以在书写的时候使得代码更加简洁，所以又喜欢称其为简写属性，这里的简写也可以理解为动词。 12345678910/* Not recommended */.box &#123; margin: 0; margin-top: 10px;&#125;/* Recommended */.box &#123; margin: 10px 0 0;&#125; 每条声明都以分号结尾在 css 里，如果声明不以分号结尾是会出问题的，但是也有一个例外，那就是声明块的最后一个声明是可以不用分号结尾的。但是如果改变了声明的顺序或者新增了声明，那原来的那条没有带分号的声明就有可能不是最后一条声明了，肯定就出问题了，所以为了避免这种不必要的错误发生，我们要习惯给每个声明都加上分号。 12345678910111213/* Not recommended */.post-content h6 &#123; position: relative; margin: 1em 0; color: #4e4a4a;&#125;/* Recommended */.post-content h6 &#123; position: relative; margin: 1em 0; color: #4e4a4a;&#125; 双引号在 css 的世界里很多地方是很有必要用引号的，为了避免混淆，建议需要引号的地方都使用双引号，而不用单引号。 对于 font-family 属性，如果属性值是带空格的英文比如 Helvetica Neue 或者是中文，那么建议加上双引号，比如content 属性。对于 URI 资源的引用，有使用到url()引入资源的时候，不用带引号。比如引入背景图片、字体定义的时候引入字体包等。 12345.tip:before &#123; content: &#x27;!&#x27;; font-family: Dosis, &#x27;Source Sans Pro&#x27;, &#x27;Helvetica Neue&#x27;, Arial, sans-serif; background: url(../img/tip.png) no-repeat center;&#125; 尽量不要使用 !importantcss规则的定义顺序很重要，同层级的声明，定义文件后面的会覆盖定义在前面的，但是如果使用了 !important 来限定声明，则可以将优先级提升到最高，这是非常霸道的规则。有时候因为使用了 !important，使得脚本程序改变不了样式渲染的结果，非常可恶。所以建议不要使用这个属性，取而代之的是，如果真的需要提高某个选择器的优先级，可以通过增加样式的层级来达到这个目的。 12345678910/* Not recommended */.heavy &#123; font-weight: 700 !important;&#125;/* Recommended */.heavy p,.heavy a &#123; font-weight: 700;&#125; 值和单位 所有属性和值尽量都用小写。 属性值为 0 的时候，不要带单位。 123456789/* Not recommended */.info-item &#123; padding: 0px 10px;&#125;/* Recommended */.info-item &#123; padding: 0 10px;&#125; 当可能的时候尽量使用三位的十六进制计数法，比如表示颜色的时候。 123456789/* Not recommended */.pink-color &#123; color: #ff33aa;&#125;/* Recommended */.pink-color &#123; color: #f3a;&#125; font-weight使用数值化表示方法，用 400 代替 normal、700 代替 bold。 123456789/* Not recommended */.heavy &#123; font-weight: bold;&#125;/* Recommended */.heavy &#123; font-weight: 700;&#125; line-height尽量不要带单位，除非必须用 px 来标定。 123456789/* Not recommended */.content p &#123; line-height: 1.2em;&#125;/* Recommended */.content p &#123; line-height: 1.2;&#125; 当属性值是介于 0 到 1 之间的小数时，可以直接把 0 省略。 123456789/* Not recommended */.pannel &#123; opacity: 0.8;&#125;/* Recommended */.pannel &#123; opacity: 0.8;&#125; 注释文件或模块注释文件顶部（@charset之后）最好是需要一块注释，大概介绍的是这个文件是关于什么内容的，作者是谁，最后更新时间等。当然如果一个 css 文件非常大，涉及到很多组件模块相关的代码，那可能每个模块都需要一个注释。 123456/** * @name: bubuzou.css * @description: hexo-theme-bubuzou的主题样式 * @author: typeR(zgrlbq@126.com) * @update: 2017-7-21 16:21:02 */ 单行注释星号与内容之间必须保留一个空格。如果是单条声明需要注释，则写到声明的分号后分隔一个空格开始注释。 12345/* This is a comment about this selector */.another-selector &#123; position: absolute; top: 0; /* I should explain why this is so important */&#125; 多行注释星号要一列对齐，星号与内容之间必须保留一个空格。多行的注释和规则之间最好加一个空格，才不会显得那么拥挤。 1234567/** * Description of left, whether or not it has media queries, etc. */.left &#123; float: left;&#125; 参考文章 Web Styleguide - Style guide to harmonize HTML, Javascript and CSS / Sass coding style CSS Coding Standards css-syntax CSS 样式书写规范","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"jpg、gif、png和svg用于web上，我们该如何选择最合适的图像格式？","slug":"jpeg-gif-png-svg-on-web","date":"2017-06-29T03:19:21.000Z","updated":"2021-09-06T09:57:20.533Z","comments":true,"path":"2017/06/29/jpeg-gif-png-svg-on-web/","link":"","permalink":"https://bubuzou.com/2017/06/29/jpeg-gif-png-svg-on-web/","excerpt":"要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：jpg、gif、png和svg。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？logo应该是选择 svg 还是 png ？而截图是选 jpg 还是 png 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。 在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。 先来看几个概念 有损(Lossless)和无损(Lossy)：一般我们聊到图片的时候经常会听到别人提到有损或者无损的字眼，那么什么是有损和无损呢？无损就是图片在压缩保存后虽然占用的存储更小了，但是图像的呈现质量依然如旧；而有损则是相反，图像随着一次又一次的压缩后，质量会变得越来越差。 索引色(Indexed color)和直接色(Direct color)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过 256 种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。 光栅格式(raster)和矢量格式(vector)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 Photoshop 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。","text":"要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：jpg、gif、png和svg。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？logo应该是选择 svg 还是 png ？而截图是选 jpg 还是 png 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。 在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。 先来看几个概念 有损(Lossless)和无损(Lossy)：一般我们聊到图片的时候经常会听到别人提到有损或者无损的字眼，那么什么是有损和无损呢？无损就是图片在压缩保存后虽然占用的存储更小了，但是图像的呈现质量依然如旧；而有损则是相反，图像随着一次又一次的压缩后，质量会变得越来越差。 索引色(Indexed color)和直接色(Direct color)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过 256 种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。 光栅格式(raster)和矢量格式(vector)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 Photoshop 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。 JPEGJEPG由联合图像专家小组（Joint Photographic Experts Group）于 1992 年创建，并以创建者命名。JPEG是一种有损光栅图像格式，这意味着每次压缩保存 JPEG 时，一些信息将发生不可逆转地丢失；且存储的颜色无限制，这就对存储照片这种颜色非常丰富复杂的图像就很友好了。 因为 JPEG 压缩在亮度和色彩上面的优越性，所以 JPEG 非常适合用于照片、色彩梯度明显的图像比如渐变和阴影这些地方。 JPEG 的压缩可以用 Photoshop 里存储为 web 格式的时候可以直接选择压缩品质，一般用于 web 的 JPG 图片选择 50%-60% 质量的即可，因为它兼顾不错的图像质量和较小的文件尺寸。另外也可以用在线压缩工具 TinyJPG。 下面这个图，我用的是 50%的品质压缩出来的 JPG，很明显质量要比 GIF 的要好很多，而且文件尺寸也小不少。 JPEG 和 JPG 的区别：JPEG 更多的指的是 .jpg 图像格式的一种压缩算法，而 JPG 就是一种图像存储的格式。 PNG可移植网络图形（Portable Network Graphics）也是一种自 1995 年以来就一直存在的光栅图像格式。它与 JPEG 不同，因为它是一种无损格式，并且是目前网络上最常见的无损格式。这意味着由于它的压缩算法，当文件被保存和压缩时，不会丢失任何信息。 PNG 格式PNG其实可以细分为好几个格式的，有PNG 8、PNG 24和PNG 32。那么怎么区分一个 PNG 图片是什么格式的呢？ 打开上面这张图片的属性面板，从详细信息里看到有一个属性叫做位深度，它的值是 24，那么就表示他是 PNG 24 格式的图片。同样，PNG 8 和 PNG 32 的位深度分别是 8 和 32。 位深度表示图像能够存储颜色的最大数值。8 位就是 2 的 8 次方（2^8=256）种颜色，所以 PNG 8 最多只能存储 256 种颜色。PNG 24 和 PNG 32又叫真彩色，最多存储 2 的 24 次方种颜色，可以达到人眼分辨的极限了；PNG 32中剩余的 8 位存储的是Alpha 通道的透明色。 然后如何生成这些不同格式的图片呢？自然是用专业的图像处理软件啦，比如可以用 Photoshop 或者 Fireworks。这里以 Photoshop 为例子，文件-&gt;存储为 Web 所用格式， 可以看到下拉这里只有 PNG-8 和 PNG-24，而没有 PNG-32 呢？是因为 Photoshop不支持这个格式嘛？并不是。 在 Photoshop 里导出 PNG-32 格式的图片是通过选择 PNG-24格式，并且勾选下面的透明度，这样生成的图片位数才是 32 位的，如果不勾选透明度的话就是 PNG-24 格式。由此看来 PNG-24 是不支持透明的，PNG-32 是支持透明的。 PNG 透明度从 Fireworks 8的优化面板里可以看到 PNG 格式存在三种透明格式：不透明、索引透明和 Alpha透明。 PNG 8透明度 从上面那个图里可以看出 PNG 8 是支持这三种不透明格式的。但是 Photoshop 只支持导出不透明和索引透明格式。在Photoshop 中如果选择 PNG 8，且勾选了透明度，那么导出的图片就是 PNG 8 索引透明，否则就是 PNG 8 不透明。 用 Photoshop 和 Fireworks 8 导出 PNG 8 的各种格式如下所示： 根据以上图片我们可以得出结论： Photoshop 导出的 PNG 8 图片都带有锯齿。 PNG 8 索引透明都带有锯齿，且 Fireworks 8 导出的 PNG 8索引透明的锯齿是白色的。 再来看看这些格式在不同浏览器下的表现情况： 根据以上图片我们可以得出结论： PNG 8 索引透明和 Alpha 透明都兼容IE 6；但美中不足的是，PNG 8Alpha透明在 IE 6下会产生锯齿。 其他格式的图片在各个浏览器下的表现一致。 Fireworks 8导出的 PNG 8索引透明带有白色锯齿，但是如果图片是放到白色的背景的容器下，那么这个白色锯齿就完全看不出来了，表现得和正常效果一样。 PNG 24 和 PNG 32 PNG 24 是不透明的；PNG 32 是支持透明的，且是 Alpha 透明。来看下它们在不同浏览器下的表现： PNG 32 图片的透明区域在 IE 6 下将不再透明，而是颜色值为 f0f0f0 的灰色填充，在更高级版本的 IE 下是正常的。PNG 32 图片不会有锯齿。 PNG 压缩本文前面提到了 JPEG 在照片片这类颜色丰富的图像上的优秀表现，所以现在将它和 PNG 的 3 种格式进行对比。主要是对比压缩前后的存储体积以及表现效果等方面。用的是免费的在线压缩工具 TinyPNG，这个工具可以压缩 JPEG 和 PNG 格式。 从上图这个图中，我们可以从不同角度得出一些结论： PNG 8 格式的图片颜色过度处理得很突兀，能看到很明显的波浪褶皱，这就是因为它最多只能存储 256 种颜色导致的，所以PNG 8不适合用于存储颜色复杂的图像。相反，由于其相对于 PNG 24 或者 PNG 32 有先天的存储体积小优势，所以它非常适合应用于图标、颜色简单的或透明的图像上。 对比 100%质量的 JPG、55%质量的 JPG、PNG 24 和 PNG 32，肉眼上看他们的图像表现效果都差不多，但是各自所占用的存储空间却是差得有些离谱。压缩前，当属 55%质量的 JPG 占用存储最小；压缩后，PNG 24 和 PNG 32 一样，会比 55%质量的 JPG 小一些，但是由于 PNG 32 支持透明，所以对于颜色丰富的图像建议用 PNG 32 格式导出，然后用压缩工具压缩一下即可。 对比压缩前后的 PNG 24 和 PNG 32 两者的存储体积相差巨大，但是表现效果却相差无几，所以用于 web 上的 PNG 24 或 PNG 32 图像一定要记得压缩，这对于客户端的性能优化将提供非常大的帮助。 GIF图形交换格式（Graphics Interchange Format）也是一种光栅格式，最多只能存储 256 种颜色，支持透明度，而且在 IE 6 下也支持得很好，唯一美中不足的是除了 Fireworks 8 导出的 GIF 不透明格式外，所有的其他 GIF 格式的图片都存在锯齿。 但是 GIF 也不是一无是处，最大的优点就是支持简单的动画。如下面简单的交通灯动画： SVG可伸缩矢量图形（Scalable Vector Graphics），顾名思义它是矢量的，而非光栅格式。区别于光栅格式的依靠像素点来存储图像，矢量图是通过 XML 格式来数据化的记录图像的信息。所以 SVG 相对于光栅格式的图像具有以下优势： 任意伸缩图像，而不会破坏图像的清晰度和细节。 完全支持 DOM，以及 JavaScript 能够很好的访问到它。 总体来讲，SVG的文件会比 GIF 或 JPG 的会小很多。 就像其它矢量格式，SVG 图片能不丢失任何细节地放大到任何大小。打个比方，同一个图标，可以以多种尺寸使用，并且在任何屏幕分辨率（比如 Retina 显示器）中都将看起来很清晰，而不需要存成多个文件。比如下面这个这个图对比，右边的是矢量图，左边的是其他格式图片： SVG 用途SVG 在线条艺术，LOGO，图标，插画和数据可视化方面用途广泛。但它不适用于写实图像和有许多细节的复杂图片。在一些情况下，SVG 和 PNG 都能很好地达到同一个目的。对于线条艺术，SVG 通常能生成较小的文件。但是这不是必然的，实际情况会根据矢量图像究竟有多少个锚点，它甚至可能会生成比 PNG 更大的文件。 SVG 真正出色的地方是数据可视化。由于可以使用JavaScript 来操纵和创建矢量动画，诸如 D3 之类的库提供了无限的可能性。LOGO, 图标和数据可视化是 SVG 使用的优秀范例。 SVG 压缩比较好的 SVG 方法应该是通过清除 SVG 矢量图形中不必要的锚点、元素和属性来减少文件大小。锚点绘制了矢量图像，因此，你需要确保已移除的锚点不会影响矢量图形的最终形状。如果您使用 Adobe Illustrator 编辑 SVG，请确保使用导 -&gt; 导出为，而不是文件 -&gt; 另存为进行保存，因为这样才能生成一个最小化的文件。 清理不必要的节点是缩减 SVG 尺寸的一种途径。元素标签是包含在 SVG 文件内的所有内容，包括开始和结束标签。矢量编辑软件，如 Adobe Illustrator 和 Sketch 可能会到处含有非必要元素和属性的 SVG 。SVG 压缩器可用于删除这种多余的信息。Compresso 和 SVGOMG 等在线工具可以完成此工作。 参考文章 在网页上使用 JPG、PNG 和 SVG：新手指南 PNG 使用技巧 PNG vs. GIF vs. JPEG vs. SVG - When best to use? JPG vs PNG vs GIF vs SVG – What is the Difference?","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://bubuzou.com/tags/svg/"},{"name":"图像","slug":"图像","permalink":"https://bubuzou.com/tags/%E5%9B%BE%E5%83%8F/"}]},{"title":"CSS自定义属性","slug":"css-custom-property","date":"2017-05-04T04:20:21.000Z","updated":"2021-09-06T09:56:39.527Z","comments":true,"path":"2017/05/04/css-custom-property/","link":"","permalink":"https://bubuzou.com/2017/05/04/css-custom-property/","excerpt":"CSS 自定义属性，很多人又把它称之为 CSS 变量，是由用户自己定义的用来指定 CSS 属性值的变量。来看一个简单的例子： 123456:root &#123; --color-red: red;&#125;.red &#123; color: var(--color-red);&#125; 上面这个例子中，首先在 :root(文档根元素即 html )处定义了一个全局变量，变量名称叫 color-red。然后在 red 元素里使用了这个变量，那么该元素颜色将变成红色。","text":"CSS 自定义属性，很多人又把它称之为 CSS 变量，是由用户自己定义的用来指定 CSS 属性值的变量。来看一个简单的例子： 123456:root &#123; --color-red: red;&#125;.red &#123; color: var(--color-red);&#125; 上面这个例子中，首先在 :root(文档根元素即 html )处定义了一个全局变量，变量名称叫 color-red。然后在 red 元素里使用了这个变量，那么该元素颜色将变成红色。 变量申明与使用参照上面的例子，你可能很容易看出 CSS 变量的声明方式：使用 --* 声明一个变量。这里的 * 表示变量名称。变量名称的组成可以是数组[0-9]、字母[a-zA-Z]、下划线_或者连字符-组合而成，更厉害的是变量名称甚至可以是中文，另外变量名称是区分大小写字母的。CSS 变量的取值可以是单值 10px、复合属性的值 1px solid #ddd，计算值 calc( 10px * 2 )，甚至属性值里又可以引用变量 var(--size) 10px。 12345678/* 变量申明，注意观察变量名称和属性值的定义 */:root &#123; --10: 10px; --marginTop: 20px; --color-red: red; --特殊的内间距: 10px 0 20px; --padv: calc(var(--10) * 2) 0;&#125; 变量的使用方式：使用 var(--*) 使用变量，其实比较完整的使用规则是这样的：var( &lt;–变量名称&gt; [, &lt;默认值&gt; ]? )，比如下面这样： 123div &#123; padding: var(--size, 10px 0);&#125; 这个表示，当 --size 这个变量未定义的时候，则使用默认值 10px 0，注意这个地方不能加分号。 还有一种情况是，假如定义了一个变量，但是变量值是不合法的，这个时候就会取属性的缺省值。比如： 12345body &#123; --color: 20px; background-color: #369; background-color: var(--color, #cd0000);&#125; 看上面的例子，此时的 body 的背景颜色到底是什么呢？A. transparent、B. 20px、C. #369、D. #cd0000答案是 A，因为这个时候变量 color 的值用在这里是不合法的，所以会取 background-color 的缺省值即默认替代值transparent，也不会用 #cd0000 再来看个例子： 1234body &#123; --size: 20; font-size: var(--size) px;&#125; 乍看上面这个例子，body 的字号是 20px，其实不然。var(--size)px 会解析完成后会变成 20 px，这个值是不合法的，所以会取缺省值 16px。注意到这个问题，稳妥的做法还是在变量申明的时候带上单位。或者使用 calc() 来计算： 1234body &#123; --size: 20; font-size: calc(var(--size) * 1px);&#125; CSS 变量作用域居然是变量，那么自然的有作用域这一说法，在 CSS 变量中，也是存在作用域的。全局作用域，直接将变量定义在根元素上： 123:root &#123; --color-red: red;&#125; 局部作用域是会直接在某个元素上定义变量，且这个变量只在该元素及后代元素中有效： 123456body &#123; color: var(--color-red);&#125;div.red &#123; --color-red: red;&#125; 上面的例子中，body 的颜色不会被设置成红色。另外值得一提的是，变量的申明和变量的使用与定义在文件里的先后位置无关。 当存在多个变量的时候，变量的覆盖规则由 CSS 选择器的权重决定，但并无 !important 这种用法，因为没有必要，!important设计初衷是干掉 JS 的 style 设置，但对于变量的定义则没有这样的需求。 123456:root &#123; --color: red;&#125;div &#123; --color: blue;&#125; 此时有一个 div 元素，那么其颜色值会是蓝色的。 来实践一下先来看一个例子： 12345678div &#123; border: 1px solid #d2d2d2;&#125;div &#123; border-width: 1px; border-style: solid; border-color: #d2d2d2;&#125; 上面这两种设置的边框效果都是一样的，区别是一个用的是复合属性，一个是独立属性。在 CSS 里存在许许多多的属性值是由多个值组成的属性，比如 border、animation 等。如果要单独地修改这些多个属性值里的某一个，复合属性就可以直接修改它的独立属性，但是对于那种不是复合属性却有多个属性值的 CSS 属性就头大了，比如 box-shadow，特别是在 OOCSS 的世界里，这种情况就更尴尬了。但是现在有了 CSS 自定义属性，问题就可以迎刃而解了。比如，box-shadow: 1px 2px 3px 4px #ddd，这里可以把这 5 个值分别用 5 个全局变量表示： 1234567:root &#123; --box-shadow-offset-x: 1px; --box-shadow-offset-y: 2px; --box-shadow-blur: 3px; --box-shadow-spread: 4px; --box-shadow-color: #ddd;&#125; 当需要单独地修改某个值的时候，直接用 js 修改全局变量的值即可： 1document.documentElement.style.setProperty( &#x27;--box-shadow-offset-x&#x27;, &#x27;3px&#x27; ); 是不是很方便，是不是很好玩，戳我给你看一个例子。 CSS 变量存在的意义在构建大型站点时，作者通常会面对可维护性的挑战。在这些网页中， 所使用的 CSS 的数量是非常庞大的，并且在许多场合大量的信息会重复使用。例如，在网页中维护一个配色方案，意味着一些颜色在 CSS 文件中多次出现，并被重复使用。当你修改配色方案时，不论是调整某个颜色或完全修改整个配色，都会成为一个复杂的问题，不容出错，而单纯查找替换是远远不够的。 如果使用了 CSS 框架，这种情况会变得尤其糟糕，此时如果要修改颜色，则需要对框架本身进行修改。在这些场合使用 LESS 或 Sass 类似的预处理器是非常有帮助的，但是这种通过添加额外步骤的方式，可能会增加系统的复杂性。CSS 变量为我们带来一些预处理器的便利，并且不需要额外的编译。 这些变量的第二个优势就是名称本身就包含了语义的信息。CSS 文件变得易读和理解。main-text-color 比文档中的#00ff00 更容易理解，特别是同样的颜色出现在不同的文件中的时候。 兼容性CSS 自定义属性在 IE 上完全不支持啊，在其他浏览器上支持性还是不错的。戳我 参考文章 小 tips:了解 CSS/CSS3 原生变量 var 使用 CSS 变量 Now that CSS Custom Properties are a Thing, All Value Parts Can Be Changed Individually","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"理解 Flexbox：你需要知道这些","slug":"flexbox","date":"2017-04-18T08:48:21.000Z","updated":"2024-06-12T09:26:57.091Z","comments":true,"path":"2017/04/18/flexbox/","link":"","permalink":"https://bubuzou.com/2017/04/18/flexbox/","excerpt":"flexbox 顾名思义 flexible box 弹性盒子，是 css3 中定义的一种新的布局方式。通过在某元素上使用 display: flex; 即可把该元素定义为 flex 容器 ( flex container )，而容器的所有子元素就是 flex 项目 ( flex item )。再介绍 flex 语法之前，先来看看一个重要的东西。 flex 轴线","text":"flexbox 顾名思义 flexible box 弹性盒子，是 css3 中定义的一种新的布局方式。通过在某元素上使用 display: flex; 即可把该元素定义为 flex 容器 ( flex container )，而容器的所有子元素就是 flex 项目 ( flex item )。再介绍 flex 语法之前，先来看看一个重要的东西。 flex 轴线 在 flex 容器里，存在两条轴，main axis 和 cross axis，又分别叫做主轴和交叉轴。主轴之所以叫做主轴而不叫做 x 轴，是因为主轴不一定是在水平线上的，也有可能是垂直方向上，比如当 flex-direction: column; 的时候，主轴就是在垂直方向上。另外主轴和交叉轴都是有方向的，flex 项目就是沿着主轴方向进行布局。主轴默认方向是从左到右，交叉轴则是从上到下。 css3 里关于 flexbox 定义了 2 类的样式，分别是作用于 flex 容器上的和作用于 flex 项目上的。 flex 容器能作用到 flex 容器上的样式有这么几个：flex-direction，flex-wrap，flex-flow，justify-content，align-items 和 align-content。看到这么几个东西，别被它们吓坏了，多读几遍你就能猜个八九不离十它们是干嘛用的了。下面我们一一来介绍这些样式。 flex-direction相信你也大概知道了这个样式的作用了，对了就是和方向有关的。flex-direction 这个样式就是用来控制 main axis 的方向的，默认值 row，表示水平从左到右。 row，默认的属性值，水平方向，从左到右 column，垂直方向，从上到下 row-reverse，水平方向，从右到左 column-reverse，垂直方向，从下到上 1234ul &#123; display: flex; flex-direction: row; /* column || row-reverse || column-reverse */&#125; 来一张图，你就更好理解了： flex-wrapflex-wrap 规定了 flex 项目在主轴上是按照一行还是多行显示。 nowrap，默认属性，单行显示，会尽力的压缩每个 flex 项目直到刚好容下里面的内容，实在压缩不了的时候 flex 项目就可能会溢出容器。 wrap，允许多行显示，当一行显示不下的时候，会变成多行显示。 wrap-reverse，多行显示，且行的显示顺序是从下到上，即第一行显示在容器的底部。 1234ul &#123; display: flex; flex-wrap: nowrap; /* wrap || wrap-reverse */&#125; flex-flowflex-flow 是一个复合属性，是由 flex-direction 和 flex-wrap 组成的属性。如果只定义了一个属性，那么另外一个属性取默认值。且属性书写顺序没有特别要求。 row nowrap，这是默认属性值 1234ul &#123; display: flex; flex-flow: row wrap;&#125; justify-contentjustify-content 规定了 flex 项目在主轴的对齐方式。比如当 flex-direction 被设置为 column 时，justify-content 定义的是垂直方向上的对齐方式。 flex-start, 默认属性值，flex项目将向着主轴起始位置对齐 flex-end, flex 项目将向着主轴结束位置对齐 center, flex 项目将在主轴上居中对齐 space-between, flex 项目将在主轴上以相同的间距贴着轴的两端对齐 space-around, flex 项目将在主轴上以相同的间距靠着两端对齐，且第一个头尾项目和轴的两端之间存在间距，间距是两个项目间距的一半 1234ul &#123; display: flex; justify-content: center;&#125; align-items居然有主轴上的对齐方式，那么肯定也有相关的属性是用来定义交叉轴上的对齐规则的。和 justify-content 一样，align-items 也有 5 个属性定义，其中 flex-start，flex-end 和 center 是一样的，就不多介绍了。来说说两个不同的： stretch，默认属性值，flex 项目在交叉轴上的尺寸如果没有指定或者是被设置为 auto，那么它将在这个方向上尽量延伸，直到靠着容器边界，但是同时延伸的程度也会受到 max-height 或者 max-width 的影响 baseline，flex项目在交叉轴上的对齐方式将是由每个项目内容的基线决定 1234ul &#123; display: flex; align-items: flex-start;&#125; align-content理解了 justify-content 和 align-items 的对齐方式，再来看 align-content 就容易理解多了。它只作用于容器，且只能是存在多个行的容器。注意这里的行是相对于交叉轴来说的。属性值有 6 个：flex-start，flex-end，center，stretch，space-between 和 space-around，这些对齐方式上面都介绍过了，大同小异。其中默认值是stretch。结合下图来加深理解： 12345ul &#123; display: flex; flex-wrap: wrap; align-content: space-around;&#125; flex 项目上面介绍了定义在 flex 容器上的 css 属性，规范了整个容器里所有项目的全局呈现。这样不够灵活多变，不足以表现某些需要特别显示的项目，所以针对这一现状，w3c 社区又推出了一套作用于 flex 项目上的 css 属性。他们分别是：align-self，order，flex-grow，flex-shrink，flex-basis 和 flex 等 css 属性。 align-selfalign-self 规定了单个 flex 项目在交叉轴上的对齐方式，属性值可以是下面一个：flex-start，flex-end，center，stretch，baseline和 auto，其中 auto 为默认属性值，如果被设置为了 auto，那么该 flex 项目最终的对齐方式将是由容器的 align-items决定。 123456ul &#123; display: flex;&#125;ul li &#123; align-self: center;&#125; orderorder 定义了 flex 项目在容器里的排列顺序。取值可以是负整数、0、正整数，默认取值是 0。数值越大越靠近轴向的末端，数值相同则按照 html 里的顺序排列。 123456ul &#123; display: flex;&#125;ul li &#123; order: 2;&#125; flex-growflex-grow 规定了 flex 项目的伸展性，其值只能是 0 或者正整数，默认值是 0。如果一个 flex 项目同时设置了width 和值为正整数的 flex-grow 属性，则 width 属性将失效。取值如果是 0 表示不进行伸展；如果是正整数，则会进行伸展，且伸展的尺寸将和数值的大小有关，值越大，伸展得越大。伸展的具体计算数值是该项目占所有可伸展项目总和的比与这些所有可伸展项目占的尺寸的乘积。 flex-shrink与伸展相对应的属性是 flex-shrink，定义了项目的收缩性，值也只能是 0 或者正整数，默认值是 1。如果是 0 表示不进行收缩，如果是正整数则表示进行收缩。如果一个项目同时显示设置了尺寸和收缩值为 1，那么该项目将进行收缩，定义的尺寸将失效。项目能够进行收缩的前提是必须产生溢出，即所有项目所占尺寸之和必须大于容器尺寸。这个时候容器里所有可收缩的项目就需要通过收缩来消化掉这部分溢出的尺寸。而每个项目具体的收缩量则由其设置的收缩比例决定，数值越大，收缩得越厉害。比如一个容器的尺寸是 400px，只有 2 个项目且尺寸都是 300px，收缩比例是 1 比 3，那么容器将溢出 200px，所以第一个项目需要收缩 50px，第二个项目需要收缩 150px，那么收缩完成后它们占据的尺寸分别是 250px 和 150px。 flex-basisflex-basis 定义了项目在伸缩之前的初始尺寸，可以是长度设置（px、rem 和 em 等）；可以是用百分比基于父级来计算尺寸；也可以是默认的 auto，表示其尺寸由内容决定。除了 auto 外，如果尺寸溢出容器了，那么设置了 flex-basis 的项目间，则会根据每项设置的基准值，按比率伸缩剩余空间。 flexflex 是一个复合属性，是由flex-grow、flex-shrink 和 flex-basis 组成的。 flex-grow ，用来指定扩展比率，在 flex 属性中该值如果被省略则默认为 1 flex-shrink，用来指定收缩比率，在收缩的时候收缩比率会以伸缩基准值加权，在 flex 属性中该值如果被省略则默认为 1 flex-basis，用来指定伸缩基准值，即在根据伸缩比率计算出剩余空间的分布之前，表示尺寸的起始数值。在 flex 属性中该值如果被省略则默认为 0%。在 flex 属性中该值如果被指定为 auto，则伸缩基准值的计算值是自身的 width 设置，如果自身的宽度没有定义，则长度取决于内容。 一些缩写说明： flex: 1, 则其计算值为1 1 0% flex: auto, 则其计算值为1 1 auto flex: none, 则其计算值为0 0 auto flex: 0 auto 或者flex: initial, 则其计算值为0 1 auto 兼容性flex 布局在现代浏览器中兼容性还是比较令人满意的。可以去 caniuse 里看看，或者直接看这个用 flex 布局写的案例 catty-music 参考文章 理解 Flexbox：你需要知道的一切","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"CSS居中完整篇","slug":"css-center-skill","date":"2017-04-13T13:20:21.000Z","updated":"2021-09-06T09:56:29.954Z","comments":true,"path":"2017/04/13/css-center-skill/","link":"","permalink":"https://bubuzou.com/2017/04/13/css-center-skill/","excerpt":"水平居中 inline 或 inline-* 元素 此类元素需要水平居中，则父级元素必须是块级元素(block level)，且父级元素上需要这样设置样式： 123.parent &#123; text-align: center;&#125; 块级元素 块级元素水平居中，需要设置 margin-left 和 margin-right 为 auto，且需要显示设置宽度，不然就占满整行，就无所谓水平居中了。 1234.block &#123; width: 300px; margin: 0 auto;&#125;","text":"水平居中 inline 或 inline-* 元素 此类元素需要水平居中，则父级元素必须是块级元素(block level)，且父级元素上需要这样设置样式： 123.parent &#123; text-align: center;&#125; 块级元素 块级元素水平居中，需要设置 margin-left 和 margin-right 为 auto，且需要显示设置宽度，不然就占满整行，就无所谓水平居中了。 1234.block &#123; width: 300px; margin: 0 auto;&#125; 同一行多个块级元素 如果是在同一行里需要居中多个块级元素，可以尝试下面的两种方法： 12345678910111213141516/* 方法一 */.parent &#123; text-align: center;&#125;.parent div &#123; display: inline-block;&#125;/* 方法二 */.parent &#123; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center;&#125; 垂直居中垂直居中在 CSS 中比较不好处理。 单行文本 通过设置上下内间距一致达到垂直居中的效果： 1234.single-line &#123; padding-top: 10px; padding-bottom: 10px;&#125; 通过设置 height 和 line-height 一致达到垂直居中： 1234.single-line &#123; height: 100px; line-height: 100px;&#125; 多行文本 通过使用表格来垂直居中，但是这种方法显得很累赘： 123456789&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; 通过表格使得多行文本自动垂直居中通过表格使得多行文本自动垂直居中通过表格使得多行文本自动垂直居中 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 通过设置 vertical-align 属性和将元素设置为 table-cell，且父元素要设置为 table 元素，这个和上面那种原理其实是一样的： 1234567.parent &#123; display: table;&#125;.parent div &#123; display: table-cell; vertical-align: middle;&#125; 通过伸缩盒来垂直居中： 1234567.flex-vertically &#123; -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex;&#125; 块级元素垂直居中 知道块元素的高度，那么使用绝对定位和负的 margin 即可实现垂直居中： 123456789.parent &#123; position: relative;&#125;.parent div &#123; position: absolute; top: 50%; height: 50px; margin-top: -25px;&#125; 块级元素高度是可变的，这个时候就需要用 transform 的 Y 轴平移来实现了： 12345678.parent &#123; position: relative;&#125;.parent div &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 也可以使用 flexbox: 12345.parent &#123; display: flexbox; justify-content: center; flex-direction: column;&#125; 如果对于块级元素高度不是固定的，且不由内容决定，那么还可以这么设置： 12345678.parent &#123; position: relative;&#125;.parent div &#123; position: absolute; top: 30%; bottom: 30%;&#125; 水平垂直居中水平垂直居中就是把上面介绍的方法相结合就可以了。 知道宽高的盒子 123456789101112.parent &#123; position: realtive;&#125;.parent div &#123; width: 300px; height: 300px; posotion: absoltue; left: 50%; top: 50%; margin-left: -150px; margin-top: -150px;&#125; 不知道宽高的盒子 123456789.parent &#123; position: realtive;&#125;.parent div &#123; posotion: absoltue; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; 使用 flexbox 12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"chrome开发者工具实用小技巧","slug":"chrome-devtools","date":"2017-03-30T10:20:21.000Z","updated":"2021-09-06T09:56:13.784Z","comments":true,"path":"2017/03/30/chrome-devtools/","link":"","permalink":"https://bubuzou.com/2017/03/30/chrome-devtools/","excerpt":"chrome 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 chrome 开发者工具都有哪些很常用或实用的功能。写这篇文章的时候，chrome 的版本如下：","text":"chrome 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 chrome 开发者工具都有哪些很常用或实用的功能。写这篇文章的时候，chrome 的版本如下： Elements 面板篇 在 Elements 面板中，使用 Ctrl + F 打开搜索输入框，可以输入常规字符串或选择器来选择 HTML 元素。 在元素前面的小黑三角上用 Alt + 鼠标左键即可展开收起当前元素下的所有子元素。 css 数值使用快捷键调整： Up / Down：增加减少 1 Ctrl + Up / Ctrl + Down：增加减少 100 Shift + Up / Shift + Down：增加减少 10 Alt + Up / Alt + Down： 增加减少 0.1 Up / Down 等同于鼠标滚轮 查看事件监听器。选中一个元素，然后点击 Event Listeners 面板，可以看到当前元素绑定的所有事件。然后找到任一事件类型下的 handler，右键单击选择 Show function definition 即可在 Source 面板中打开且定位到当前事件的处理函数的所在位置。 点击颜色方格会打开 chrome 的调色板。如下图第 1 块是着色和阴影选择器。第 2 块像笔那个按钮( toggle color picker )是取色器，蓝色的时候表示激活状态，就可以在页面任何一处进行取色；右边绿色圆形的是当前的颜色值，点击会将当前颜色值的代码复制到剪贴板；再右边的两块条分别表示色调选择器和不透明度选择器。第 3 块是表示当前颜色的显示模式，后边的按钮可以切换显示模式。第 4 块，Color Palettes 里分 3 小块，分别是：Material Design，一组符合 Material Design 规范的颜色；Page Colors，一组从页面的 CSS 自动生成的颜色；Custom，自定义颜色。第 5 块颜色面板，长按颜色块可以弹出 10 个当前颜色由浅至深的小色块，这个功能对于精确定制网页主题颜色非常有帮助。第 6 块是自定义颜色，这里可以添加删除自定义颜色，并且会永久保存在 chrome 的 DevTools 里，不会因为刷新或关闭浏览器而消失。第 7 块是生成了一些和页面相关的颜色值。 可视化 Shadow DOM。在 dom 元素列表中，都是我们写的看得见的元素。其实在构建 dom 的时候，也存在一部分东西是我们没写的，但是实际存在而被浏览器隐藏起来的元素。如果想看到这些元素就可以通过勾选 Settings -&gt; Preferences -&gt; Elements 下的 Show user agent shadow DOM 来显示这样构建的元素。这样一来就可以很好的这些元素的样式了。 给元素添加状态。元素有 4 种用户行为状态：:active、:hover、:focus、:visited。可以通过 2 中方式主动触发用户行为。选中一个元素，然后右键点击选中一个状态即可，如果有设置对于的样式，就可以看到区别。另外一种方式是在 Styles面板中进行设置。 使用 Tab 键可以在 CSS 样式规则中进行遍历选定，选定的目标包括：选择器、属性和属性值。如果想跳回上一个目标，使用 Shift + Tab。但是再使用快捷键切换选定之前需要先让光标在 Styles 面板，处于输入状态即可。 Console 面板篇 使用 $0-$4 选择元素。$0 返回最后一次选择的元素，$1 返回仅在最后一次之前选择的元素，以此类推。$(selector) 返回带有指定 CSS 选择器的第一个 DOM 元素的引用。$$(selector) 返回 CSS 选择所有匹配的元素数组。 如果页面使用了类 `Jquery` 库，则 `$(selector)` 功能将被覆盖， `$` 将与该库的实现对应。 一些实用的方法: console.log()、console.info()、console.warn()、console.error()打印不同的状态信息 使用 CSS 设置控制台输出样式，利用 CSS 格式说明符%c。 copy(object)，将指定对象的字符串表示复制到剪贴板。 getEventListeners(object)，返回一个在指定元素上绑定的所有事件监听器的数组。但是这里看不了事件的处理函数，也没有像 Event Listeners 面板那边 show function definition 那样的功能。 inspect(elem)， 跳转到 Elements 面板的指定元素节点 console.time(str) 和 console.timeEnd(str) 返回这中间间隔的时间。下图的 4.24e+3ms 是数字的科学计数法表示，表示的实际值是：4.24*10*10*10ms，即 4.24 秒。 Sources 面板篇 Ctrl + Shift + F，根据文件内容查找所有站内资源文件，返回找出匹配的文件内容。这个功能很好用。比如我在别人的站点看到一个效果，但是不知道写到哪个文件里了，这个时候我就可以根据关键的 className 或者 id 把这个文件找出来。 Ctrl + P，根据文件名查找所有站内资源文件。 漂亮打印。对于 Sources 里的资源文件，可以将杂乱的或是压缩过的内容按照一定的缩进和换行规则进行打印输出。 在 Sources 面板中找到图片资源，然后在图片上右键即可获取图片的 Data URI。 使用 console.dir( ele ) 将 DOM 元素格式化为 JavaScript 对象 在 Sources 面板编辑文件小技巧 使用 Ctrl + p 打开输入框输入 :20:30 回车后，光标位置将跳转到当前文件的第 20 行第 30 列 使用使用 Alt + - 和 Alt + = 可以在上一个鼠标位置和下一个鼠标位置之间跳转 使用 Ctrl + 鼠标左键可以添加多个光标输入位置 使用 Alt + 鼠标拖动可以拉出一块矩形选区 参考文章 chrome-devtools","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://bubuzou.com/tags/chrome/"}]},{"title":"background属性","slug":"background-property","date":"2017-03-10T01:20:21.000Z","updated":"2021-09-06T09:55:58.255Z","comments":true,"path":"2017/03/10/background-property/","link":"","permalink":"https://bubuzou.com/2017/03/10/background-property/","excerpt":"一个元素可以使用 background 来设置他的背景特性，background 是一个复合的属性，包括了 8 个子属性。 background-colorbackground-color 用于定义元素的背景颜色，值可以是具体的十六进制颜色值 #dedd6f，可以是 rgb 颜色值rgb(222, 221, 111) ，或者直接用颜色对应的英文表示 gray ，甚至是用关键字 transparent 来表示透明的颜色。 123456789.yellow &#123; background-color: #dedd6f;&#125;.gray &#123; background-color: gray;&#125;.tran &#123; background-color: transparent;&#125;","text":"一个元素可以使用 background 来设置他的背景特性，background 是一个复合的属性，包括了 8 个子属性。 background-colorbackground-color 用于定义元素的背景颜色，值可以是具体的十六进制颜色值 #dedd6f，可以是 rgb 颜色值rgb(222, 221, 111) ，或者直接用颜色对应的英文表示 gray ，甚至是用关键字 transparent 来表示透明的颜色。 123456789.yellow &#123; background-color: #dedd6f;&#125;.gray &#123; background-color: gray;&#125;.tran &#123; background-color: transparent;&#125; background-imagebackground-image 用来定义元素的背景图像，可以通过 url(...) 来引入图片，也可以设置为 none 表示背景为空，还可以设置多张背景且中间用逗号隔开，写到前面的图片将会覆盖写到后面的。 1234567891011.url &#123; background-image: url(../images/cow.png);&#125;.none &#123; background-image: none;&#125;.muliple &#123; background-image: url(../images/penguin.jpg), url(../images/cow.png); background-repeat: no-repeat; background-size: 81%;&#125; background-repeatbackground-repeat 定义了背景图像将以何种方式进行平铺。必须先指定 background-image 属性。如果设置 2 个属性，那么第一个用于横向，第二个作用于纵向。如果提供一个参数，则用于横向和纵向。其中，repeat-x 和 repeat-y 只能单独使用。 repeat-x：横向平铺 repeat-y：纵向平铺 repeat：横向和纵向都平铺 no-repeat：不平铺 round：背景图像自动缩放直至适应填充满整个容器 space: 背景图像按照相同的间距平铺直至适应填充满整个容器或某个方向 123456789101112131415161718192021222324.repeat-x &#123; background-repeat: repeat-x;&#125;.repeat-y &#123; background-repeat: repeat-y;&#125;.repeat &#123; background-repeat: repeat;&#125;.no-repeat &#123; background-repeat: no-repeat;&#125;.round &#123; background-repeat: round;&#125;.space &#123; background-repeat: space;&#125;.round-space &#123; background-repeat: round space;&#125;.space-round &#123; background-repeat: space round;&#125; background-sizebackground-size 定义了背景图像的尺寸，可以用关键字来定义。contain 按照图片比例将背景图像等比缩放到完全适应容器，而 cover 是图像缩放到完全覆盖区域为止。也可以用长度值或者百分比值来设置。如果设置了 2 个参数，则分别表示横向和纵向。如果只设置了一个值，那表示横向宽度，纵向为 auto. 12345678910111213.contain &#123; background-size: contain;&#125;.cover &#123; background-size: cover;&#125;.size-demo .w100 &#123; background-size: 100px; background-image: url(../images/cow.png);&#125;.rate5080 &#123; background-size: 50% 80%;&#125; background-positionbackground-positioin 定义了背景图像在容器里的显示位置，可以用关键字 top、left、right、bottom、center 等来表示，当用 1 个参数的时候设置的时候，另一个方向默认是 center。当用 2 个关键字来设置的时候，和书写顺序无关。另外还可以用具体数值和百分比来设置，用这些方式来设置的时候第一个参数表示横向，第二个是纵向。如果只有一个参数，则表示横向，纵向默认是居中。 123456789101112.position-demo .top &#123; background-position: top;&#125;.position-demo .bottom-right &#123; background-position: bottom right;&#125;.position-demo .w20h40 &#123; background-position: 20px 40px;&#125;.position-demo .p20 &#123; background-position: 20%;&#125; background-attachmentbackground-attachment 控制背景图像在可视区或元素内如何滚动。fixed 是相对可视区域进行定位，背景图像相对于可视区域进行定位，不随元素滚动而滚动。scroll 背景图像将在元素区域内固定，不会随着元素内容的滚动而滚动。local 背景图像相对于元素内容占据的区域进行定位，当元素内容滚动的时候，背景图像随之滚动。 12345678910.attachment-demo .fixed &#123; background-attachment: fixed; background-position: bottom;&#125;.attachment-demo .scroll &#123; background-attachment: scroll;&#125;.attachment-demo .local &#123; background-attachment: local;&#125; background-originbackground-origin 规定了背景图像相对于盒模型的哪个区域来定位，对背景颜色无效。content-box 相对于内容区域定义，padding-box 相对于内边距区域定位，border-box 相对边框区域定位 123456789.origin-demo .content &#123; background-origin: content-box;&#125;.origin-demo .padding &#123; background-origin: padding-box;&#125;.origin-demo .border &#123; background-origin: border-box;&#125; background-clipbackground-clip 指定背景向外裁剪的区域。padding-box 从 padding 区域（不含 padding ）开始向外裁剪背景。border-box 从 border 区域（不含 border ）开始向外裁剪背景。content-box 从 content 区域开始向外裁剪背景。 123456789.clip-demo .content &#123; background-clip: content-box;&#125;.clip-demo .padding &#123; background-clip: padding-box;&#125;.clip-demo .border &#123; background-clip: border-box;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"}]},{"title":"高阶函数","slug":"higher-order-functions","date":"2016-12-06T02:12:21.000Z","updated":"2019-04-16T12:19:18.329Z","comments":true,"path":"2016/12/06/higher-order-functions/","link":"","permalink":"https://bubuzou.com/2016/12/06/higher-order-functions/","excerpt":"高阶函数是指满足下列条件之一的函数： 函数可以作为参数进行传递函数可以作为返回值进行输出JavaScript 语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当做参数传递，还是让函数的执行结果返回给另外一个函数，这两种情形都有很多应用场景。 函数作为参数传递把函数当做参数进行传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来就可以分离业务代码中变化和不变的部分。","text":"高阶函数是指满足下列条件之一的函数： 函数可以作为参数进行传递函数可以作为返回值进行输出JavaScript 语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当做参数传递，还是让函数的执行结果返回给另外一个函数，这两种情形都有很多应用场景。 函数作为参数传递把函数当做参数进行传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来就可以分离业务代码中变化和不变的部分。 回调函数 在 ajax 异步请求的应用中，回调函数的使用非常频繁。当我们想在 ajax 请求返回之后做些事情，但又并不知道请求返回的确切时间时，最常见的方案是把 callback 函数当做参数传入发起的 ajax 请求的方法中，待请求完成之后执行callback 函数： 1234567var getUserInfo = function( userId, callback ) &#123; $.ajax( &#x27;http://bubuzou.com/getUserInfo?&#x27; + userId, function( data ) &#123; if ( typeof callback === &#x27;function&#x27;) &#123; callback( data ); &#125; &#125;); &#125;; 再来看一个例子，假设有这样一个需求，需要创建 100 个 div元素，同时把他们隐藏起来，那么可以看到下面这种实现： 123456789var appendDiv = function() &#123; for( var i = 0; i &lt; 100; i++ ) &#123; var div = document.createElement( &#x27;div&#x27; ); div.innerHTML = i; document.body.appendChild( div ); div.style.display = &#x27;none&#x27;; &#125;&#125;;appendDiv(); 把 div.style.display = &#39;none&#39;的逻辑硬编码在 appendDiv 里显然是不合理的，appendDiv 未免有点个性化，成为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏。于是我们把这段代码抽离出来，用回调函数的形式传入 appendDiv 方法： 12345678910111213var appendDiv = function( callback ) &#123; for( var i = 0; i &lt; 100; i++ ) &#123; var div = document.createElement( &#x27;div&#x27; ); div.innerHTML = i; document.body.appendChild( div ); if ( typeof callback === &#x27;function&#x27;) &#123; callback( div ); &#125; &#125;&#125;; appendDiv(function( node ) &#123; node.style.display = &#x27;none&#x27;;&#125;); Array.prototype.sort Array.prototype.sort 接受一个函数作为参数，这个函数里面封装了数组元素的排序顺序。我们的目的是对数组进行排序，这是不变的部分；但用什么规则去排序这是可变的部分。 1234// 从小到大排序[3, 9, 8, 5].sort(function(a, b) &#123; return a - b;&#125;); 函数作为返回值输出 判断数据的类型 判断一个数据是否是数组，在以往的实现当中，可以基于鸭子类型的概念来判断，比如这个数据有没有 length 属性，有没有sort 方法等。但更好的方法是用 Object.prototype.toString 来计算。根据Object.prototype.toString.call( [1, 2, 3] ) 总是返回 ’[object Array]’ ，Object.prototype.toStrng.call( ‘str’ ) 也总是返回 ’[object Array]’ 得出， 它总是会返回一个类似结构的字符串。于是用循环语句来批量注册类型判断的函数： 123456789101112131415161718192021222324252627282930 var Type = &#123;&#125;; for ( var i = 0, type; type = [&#x27;String&#x27;, &#x27;Array&#x27;, &#x27;Number&#x27;][i++]; ) &#123; (function( type ) &#123; Type[ &#x27;is&#x27; + type ] = function( obj ) &#123; return Object.prototype.toString.call( obj ) === &#x27;[object &#x27; + type + &#x27;]&#x27;; &#125; &#125;)( type ); &#125; Type.isArray( [] ); // true Type.isString( &#x27;&#x27; ); // true ```` - getSingle 下面是一个单例模式的例子： ``` js var getSingle = function( fn ) &#123; var ret; return function() &#123; return ret || ( ret = fn.apply( this, arguments )); &#125;; &#125;; // 来看看这个单例的效果 var getScript = getSingle(function() &#123; return document.createElement( &#x27;script&#x27; ); &#125;); var script1 = getScript(); var script2 = getScript(); console.log( script1 === script2 ); // true 高阶函数实现AOPAOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来后，再通过“动态植入”的方式掺入业务逻辑模块中。这样做的好处是首先保证了业务逻辑模块的纯洁和高内聚性，其实是可以很方便的复用这些日志统计等功能模块。在 JavaScript 中，我们可以通过Function.prototype 来实现 AOP: 123456789101112131415161718192021222324Function.prototype.before = function( beforeFn) &#123; var _self = this; return function() &#123; beforeFn.apply( this, arguments ); return _self.apply( this, arguments ); &#125;&#125;;Function.prototype.after = function( afterFn ) &#123; var _self = this; return function() &#123; var ret = _self.apply( this, arguments ); afterFn.apply( this, arguments ); return ret; &#125;&#125;;var func = function() &#123; console.log( 2 );&#125;;func = func.before(function() &#123; console.log( 1 );&#125;).after(function() &#123; console.log( 3 );&#125;);func(); // 换行打印：1 2 3 高阶函数的其他应用 currying currying 的概念最早由俄国数学家 Moses Schoofinkel 发明，而后由著名的数理逻辑学家 Haskell Curry 将其丰富和发展，currying 由此得名。 currying 又称部分求值。这里我们讨论的是函数柯里化( function currying )。一个柯里化函数首先会接受一些参数，接受了这些参数会后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正求值的时候，之前传入的所有参数都会被一次性用于求值。来看一个例子： 假设我们要编写一个计算每月开销的函数。在每天结束之前，我们都要记录几天花掉了多少钱。 12345678var monthCost = 0;var cost = function( money ) &#123; monthCost += money;&#125;;cost( 100 ); 第一天cost( 200 ); 第二天cost( 300 ); 第三天console.log( monthCost ); // 600 通过这段代码，我们可以看到每天都花了多少钱，但是如果我们只想知道每个月的消费如何的话，那就没必要计算每天的花费了。 123456789101112131415161718var cost = (function() &#123; var args = []; return function() &#123; if ( arguments.length === 0 ) &#123; var money = 0; for ( var i = 0, l = args.length; i &lt; l; i++ ) &#123; money += args[i]; &#125; return money; &#125; else &#123; [].push.apply( args, arguments ); &#125; &#125;&#125;)();cost( 100 );cost( 200 );cost( 300 );console.log( cost() ); // 600 接下来编写一个通用的柯里化函数： 12345678910111213141516171819202122232425var currying = function( fn ) &#123; var args = []; return function() &#123; if ( arguments.length === 0 ) &#123; return fn.apply( this, args ); &#125; else &#123; [].push.apply( args, arguments ); return arguments.callee; &#125; &#125;&#125;;var cost = (function() &#123; var money = 0; return function() &#123; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; money += arguments[i]; &#125; return money; &#125;&#125;)();var cost = currying( cost );cost( 100 );cost( 200 );cost( 300 );console.log( cost() ); // 600 uncurrying uncurrying 是反柯里化，大概意思是扩大函数的应用范围，将本来只有特定对象才能使用的方法，扩展到更多的对象。 比如我们常常让类数组对象去借用 Array.prototype 的方法： 1234(function() &#123; Array.prototype.push.call( arguments, 4 ); console.log( arguments ); // [1, 2, 3, 4] &#125;)(1, 2, 3); uncurrying第一种实现： 123456789101112131415161718192021222324Function.prototype.uncurrying = function() &#123; var self = this; return function() &#123; var obj = Array.prototype.shift.call( arguments ); return self.apply( obj, arguments ); &#125;;&#125;;for ( var i = 0, fn, ary = [&#x27;push&#x27;, &#x27;shift&#x27;, &#x27;forEach&#x27;]; fn = ary[i++]; ) &#123; Array[ fn ] = Array.prototype[ fn ].uncurrying(); &#125;var obj = &#123; &quot;length&quot;: 3, &quot;0&quot;: 1, &quot;1&quot;: 2, &quot;2&quot;: 3&#125;;Array.push( obj, 4);console.log( obj.length ); // 4var first = Array.shift( obj ); console.log( first ); // 1console.log( obj ); // &#123;0:2, 1:3, 2:4, length: 3&#125;Array.forEach( obj, function( i, n ) &#123; console.log( n ); // 分别输出：0, 1, 2&#125;); uncurrying的第二种实现： 123456Function.prototype.uncurrying = function() &#123; var self = this; return function() &#123; return Function.prototype.call.apply( self, arguments ); &#125;&#125;; 函数节流 在 JavaScript 中，大部分的函数都是由用户主动调动触发的。但是也存在少数情况，这些情况下函数的触发并不是又用户直接控制的。这个时候函数就有可能被频繁地调用，而造成大的性能问题。以下几个场景函数将被频繁调用：给 window 绑定了onresize 事件的时候，如果存在 DOM 相关的操作，那这个时候是非常耗性能的，严重的时候浏览器可能会卡顿；mousemove 事件，如果给某个元素绑定了拖拽事件，那么该函数也会被频繁的触发；在比如上传一个文件的时候，可能需要频繁的通知进度信息等。 函数节流就是为了避免函数被频繁地调用而存在的一种解决方案，从而优化性能。通常是用 setTimeout 来实现： 123456789101112131415161718192021222324var throttle = function( fn, interval ) &#123;var _self = fn, timer, firstTime = true; return function() &#123; var args = arguments, _me = this; if ( firstTime ) &#123; _self.apply( _me, args ); return firstTime = false; &#125; if ( timer ) &#123; return false; &#125; timer = setTimeout(function() &#123; clearTimeout( timer ); timer = null; _self.apply( _me, args ); &#125;, interval || 500 ); &#125;&#125;;window.onresize = throttle(function() &#123; console.log( 1 );&#125;, 500); 分时函数 上面我们介绍了一种解决函数被频繁调用的方法。但是有时候，用户确实有这种需求，比如需要在短时间内把 1000 个 qq 好友渲染到列表上，这个时候就可能会很卡。但是如果把 1000ms 创建 1000 个节点，改成每 200ms 创建 8 个节点。这个时候就避免这种问题。 分时函数接受 3 个参数：第一个是创建节点的时候需要用到的数据，第二个是封装了创建节点的函数，第三个是每一批创建的节点数量。 12345678910111213141516171819var timeChunk = function( ary, fn, count ) &#123; var obj, t, start; start = function() &#123; for ( var i = 0; i &lt; Math.min( count || 1, ary.length ); i++ ) &#123; var obj = ary.shift(); fn( obj ); &#125; &#125;; return function() &#123; t = setInterval(function() &#123; if ( ary.length === 0 ) &#123; // 如果全部节点都已经创建好 clearInterval( t ); &#125; start(); &#125;, 200); &#125;;&#125;; 分时函数有了，现在我们来测试一下。假设有 1000 个好友，利用 timeChunk 函数，每批往页面上渲染 8 个： 12345678910var ary = [];for ( var i = 0; i &lt;= 1000; i++ ) &#123; ary.push( i );&#125;var renderFriendList = timeChunk( ary, function( n ) &#123; var div = document.createElement( &#x27;div&#x27; ); div.innerHTML = n; document.body.appendChild( div );&#125;, 8);renderFriendList(); 惰性加载函数 在 web 开发的过程中，因为浏览器之间的实现差异，一些嗅探工作总是避免不了的。比如我们需要一个能在各个浏览器都能通用的事件绑定函数 addEvent，常见的写法如下： 12345678var addEvent = function( elem, type, handler ) &#123; if ( window.addEventListener ) &#123; return elem.addEventListener( type, handler, false ); &#125; if ( window.attachEvent ) &#123; return elem.attachEvent( &#x27;on&#x27; + type, handler ); &#125;&#125;; 这种写法的缺点是每次调用函数都必须执行里面的if判断，虽然开销不大，但是有办法能避免这种操作： 123456789101112var addEvent = (function() &#123; if ( window.addEventListener ) &#123; return function( elem, type, handler ) &#123; elem.addEventListener( type, handler, false ); &#125; &#125; if ( window.attachEvent ) &#123; return function( elem, type, handler ) &#123; elem.attachEvent( &#x27;on&#x27; + type, handler ); &#125; &#125;&#125;)(); 把嗅探的操作提前到代码加载之前，在代码加载的时候就即可进行一次判断，以便让 addEvent返回一个正确的事件绑定函数。 但是这种写法还是存在缺点的，如果我们从头到尾都不需要进行事件绑定，那么前面那次的嗅探动作就显得多余了。 第三种方案是惰性载入函数方案，第一次进入 addEvent 函数的时候会重写事件绑定函数，在下次进去的时候就会直接执行事件绑定了。 12345678910111213var addEvent = function( elem, type, handler ) &#123; if ( window.addEventListener ) &#123; addEvent = function( elem, type, handler ) &#123; elem.addEventListener( type, handler, false ); &#125; &#125; if ( window.attachEvent ) &#123; addEvent = function( elem, type, handler ) &#123; elem.attachEvent( &#x27;on&#x27; + type, handler ); &#125; &#125; addEvent( elem, type, handler );&#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"闭包","slug":"closure","date":"2016-11-30T13:20:21.000Z","updated":"2019-01-08T01:38:23.670Z","comments":true,"path":"2016/11/30/closure/","link":"","permalink":"https://bubuzou.com/2016/11/30/closure/","excerpt":"对于 JavaScript 的程序员来说，闭包是一个难懂又必须征服的概念。在介绍闭包前，先来看看和闭包息息相关的变量作用域和变量的生存周期。 变量的作用域变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字 var 来声明此变量，那么它就是局部变量，如果没有 var 那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用 var 将变量声明在函数的外面。 12345var name = &#x27;bubuzou.com&#x27;; // 全局变量function func() &#123; var name = &#x27;bubuzou&#x27;; // 局部变量 age = 12; // 全局变量，建议少用这种全局变量的定义方式&#125;","text":"对于 JavaScript 的程序员来说，闭包是一个难懂又必须征服的概念。在介绍闭包前，先来看看和闭包息息相关的变量作用域和变量的生存周期。 变量的作用域变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字 var 来声明此变量，那么它就是局部变量，如果没有 var 那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用 var 将变量声明在函数的外面。 12345var name = &#x27;bubuzou.com&#x27;; // 全局变量function func() &#123; var name = &#x27;bubuzou&#x27;; // 局部变量 age = 12; // 全局变量，建议少用这种全局变量的定义方式&#125; 在 JavaScript 中，函数可以用来创造函数作用域。函数内部可以看到外面的变量，而外面看不到函数里的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，直到搜索到全局变量为止。 123456789101112var a = 1;var func1 = function()&#123; var b = 2; var func2 = function()&#123; var c = 3; console.log( b ); // 2 console.log( a ); // 1 &#125; func2(); console.log( c ); // 报错：c is not defined&#125;;func1(); 那么能不能从函数外部来访问局部变量呢？答案是可以。 1234567var func = function() &#123; var number = 6; return function() &#123; return number; &#125; &#125;;console.log( func()() ); // 6 变量的生存周期全局变量的生存周期是永久的，除非我们主动的销毁这个全局变量。而对于局部变量来说，当退出函数时，这些局部变量就失去了生存的环境，所以会随着函数调用的结束而被销毁。那么是否可以让局部变量在函数调用结束的时候不被销毁呢？来看下面这个例子： 1234567891011var func = function() &#123; var a = 1; return function() &#123; a++; console.log( a ); &#125; &#125;;var f = func();f(); // 2f(); // 3f(); // 4 从上面这个输出结果，我们可以看到局部变量 a 并没有随着 f() 的调用而被销毁。这是因为全局变量 f 保存着对 func 里面匿名函数的引用。而这个匿名函数是可以访问到局部变量 a 的，所以自然 a 也被保存下来了。所以这种情况下局部变量的生存周期就得以延续。上面这个匿名函数其实就是一个闭包。再来看一个闭包的经典应用。 1234567// 假设有5个divvar nodes = document.getElementsByTagName( &#x27;div&#x27; );for ( var i = 0, l = nodes.length; i &lt; l; i++ ) &#123; nodes[i].onclick = function() &#123; console.log( i ); &#125;&#125; 当真正执行这段代码的时候，发现无论点击那个 div，最后打印的结果都是 4。这是因为 onclick 事件是异步触发的，当事件触发的时候，for 循环早已经结束，此时变量 i 的值已经是 4。解决方案可以是用闭包把每次的 i 都保存起来： 1234567for ( var i = 0, l = nodes.length; i &lt; l; i++ ) &#123; (function( i ) &#123; nodes[i].onclick = function() &#123; console.log( i ); &#125; &#125;)( i );&#125; 同理，我们编写一段代码用来判断对象类型： 12345678910var Type = &#123;&#125;;for ( var i = 0, type; type = [ &#x27;String&#x27;, &#x27;Array&#x27;, &#x27;Number&#x27; ][ i++ ]; ) &#123; (function( type ) &#123; Type[ &#x27;is&#x27; + type ] = function( obj ) &#123; return Object.prototype.toString.call( obj ) === &#x27;[object &#x27; + type + &#x27;]&#x27;; &#125; &#125;)( type );&#125;Type.isArray( [] ); // trueType.isString( &#x27;str&#x27; ); // true 什么是闭包官方的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因为这些变量也是该表达式的一部分。这个概念不好理解，我们可以简单得理解成闭包就是能够访问函数内部变量的函数。 闭包的作用 可以在函数外部访问在函数内部定义的局部变量 延续局部变量的生存周期 封装变量 闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的函数： 12345678var mult = function() &#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return a;&#125;;mult(2, 3, 4); // 24 mult 函数接受一些 Number 类型的参数，并且返回他们的乘积。现再我们觉得对于那些相同参数来说，每次再进行计算是一种浪费，所以我们决定加入缓存机制来提高函数性能： 123456789101112var cache = &#123;&#125;;var mult = function() &#123; var args = Array.prototype.join.call( arguments, &#x27;&#x27; ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return cache[ args ] = a;&#125;; 我们看到 cache 这个变量仅仅在 mult 函数中被使用，所以为了避免 cache 污染全局变量，我们将它放到 mult 函数里面 1234567891011121314var mult = (function() &#123; var cache = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call( arguments, &#x27;&#x27; ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return cache[ args ] = a; &#125;&#125;)(); 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有利于代码的复用，如果这些小函数有一个良好的命名，那么它们本身就起到了一个很好的注释作用。 1234567891011121314151617var mult = (function() &#123; var cache = &#123;&#125;; var calculate = function() &#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return a; &#125;; return function() &#123; var args = Array.prototype.join.call( arguments, &#x27;&#x27; ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; return cache[ args ] = calculate.apply( null, arguments ); &#125;&#125;)(); 闭包与内存管理局部变量本来应该在函数退出的时候就被结束引用，但如果局部变量被封装在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上来看，闭包确实会使一些数据无法被及时销毁。如果将来需要回收这些变量，我们可以手动把这些变量设为 null。跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域中保存着一些 DOM 节点，这个时候就有可能造成内存泄露。在 IE9 之前的浏览器中，由于 BOM 和 DOM 中的对象是使用 C++ 对象以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数的垃圾收集机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。但我们只要把循环引用中的对象设为 null 即可解决这个问题。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"this、call和apply","slug":"this-call-apply","date":"2016-11-28T11:22:14.000Z","updated":"2021-01-07T00:52:53.664Z","comments":true,"path":"2016/11/28/this-call-apply/","link":"","permalink":"https://bubuzou.com/2016/11/28/this-call-apply/","excerpt":"this跟别的语言不同的是，JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this的指向除去不常用的 eval 和 with 语句的情况，具体到实际应用中，this 的指向大致可分为以下4种： 作为对象的方法调用 当作为对象的方法进行调用的时候，this 指向该对象： 12345678var obj = &#123; name: &#x27;bubuzou&#x27;, getName: function() &#123; console.log( this === obj ); // true console.log( this.name ); // &#x27;bubuzou&#x27; &#125;&#125;;obj.getName();","text":"this跟别的语言不同的是，JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this的指向除去不常用的 eval 和 with 语句的情况，具体到实际应用中，this 的指向大致可分为以下4种： 作为对象的方法调用 当作为对象的方法进行调用的时候，this 指向该对象： 12345678var obj = &#123; name: &#x27;bubuzou&#x27;, getName: function() &#123; console.log( this === obj ); // true console.log( this.name ); // &#x27;bubuzou&#x27; &#125;&#125;;obj.getName(); 作为普通函数调用 当函数不作为对象的属性进行调用的时候，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的JavaScript 里，这个全局对象是 window 对象。 123456789101112131415window.name = &#x27;bubuzou.com&#x27;;var getName = function() &#123; return this.name; &#125;;console.log( getName() ); // &#x27;bubuzou.com&#x27;// 或者window.name = &#x27;bubuzou.com&#x27;;var myObject = &#123; name: &#x27;bubuzou&#x27;, getName: function() &#123; return this.name; &#125;&#125;;var getName = myObject.getName;console.log( getName() ); // &#x27;bubuzou.com&#x27; 再来看一个实际的应用： 12345678910window.id = &#x27;bubuzou&#x27;;document.getElementById( &#x27;div&#x27; ).onclick = function() &#123; var that = this; console.log( this.id ); // &#x27;div&#x27; var callback = function() &#123; console.log( this.id ); // &#x27;bubuzou&#x27; console.log( that.id ); // &#x27;div&#x27; &#125;; callback();&#125;; 在 `ECMAScript 5` 的 `strict` 模式下，这种情况的 `this` 已经被规定不会指向全局对象了，而是 `undefined` 1234(function func() &#123; &quot;use strict&quot; console.log( this ); // undefined&#125;)(); 构造器调用 JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。除了宿主提供的一些内置函数外，大多数的 JavaScript 函数都可以当做内置构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就是指向返回的这个对象。 12345var MyClass = function() &#123; this.name = &#x27;bubuzou.com&#x27;&#125;;var obj = new MyClass();console.log( obj.name ); // &#x27;bubuzou.com&#x27; 但是使用构造器调用需要注意一个问题，如果构造器显示的返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们所期待的 this: 12345678var MyClass = function() &#123; this.name = &#x27;bubuzou.com&#x27;; return &#123; name: &#x27;bubuzou&#x27; &#125;&#125;; var obj = new MyClass();console.log( obj.name ); // &#x27;bubuzou&#x27; Function.prototype.call 或 Function.prototype.apply 调用 跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 调用可以动态地改变传入函数的 this： 1234567891011var obj1 = &#123; name: &#x27;bubuzou.com&#x27;, getName: function() &#123; return this.name; &#125;&#125;;var obj2 = &#123; name: &#x27;bubuzou&#x27;&#125;;console.log( obj1.getName() ); // &#x27;bubuzou.com&#x27;console.log( obj1.getName.call( obj2 ) ); // &#x27;bubuzou&#x27; 丢失的thisdocument.getElementById 这个方法名有点长，所以我们会尝试用一个简单点的来替代： 1234var getId = function( id ) &#123; return document.getElementById( id );&#125;;getId( &#x27;div&#x27; ); 我们也许思考过为什么不能用下面的这个更简单的方式： 12var getId = document.getElementById;getId( &#x27;div&#x27; ); 当我们执行上面这段代码的时候，在 Chrome 浏览器中会抛出异常。这是因为许多浏览器引擎的 document.getElementById 方法的内部实现中需要用到 this。而这个 this 本来期望指向 document，当getElementById 方法作为 document 的属性来调用的时候，内部的 this 确实是指向 document 的。但当用getId 来引用 document.getElementById 之后，再调用 getId，此时就成了普通函数调用，函数内部的 this 指向了 window，而是不是原来的 document，所以会抛出异常。不过我们可以尝试用 apply 把 document 当做 this 传入 getId 函数： 1234567document.getElementById = (function( func ) &#123; return function() &#123; return func.apply( document, arguments ); &#125;&#125;)( document.getElementById );var getId = document.getElementById;console.log( getId( &#x27;div&#x27; ).id ); // &#x27;div&#x27; call和apply的区别两者的作用一模一样，区别只是传入的参数形式不一样。apply接受2个参数，第一个参数是指定了函数体内的 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以是一个数组也可以是一个类数组。 call 的参数就不固定了，但是第一个参数和 apply 是一样的，从第二个参数开始往后，每个参数被依次传入函数。 12345var func = function( a, b, c ) &#123; console.log( [a, b, c] ); &#125;;func.apply( null, [1, 2, 3] ); // [1, 2, 3]func.call( null, 1, 2, 3 ); // [1, 2, 3] 当调用一个函数的时候，JavaScript 的解释器并不会计较形参和实参在数量、类型和顺序上的区别，从这个意义上来说，apply 比 call 的使用率更高。但是如果我们明确指定参数的个数，也可以用 call 来传送参数。 如果第一个参数是 `null`，那么函数体内的 `this` 会指向默认的宿主对象，在浏览器中是 `window`，但如果是在严格模式下，则还是为 `null` call和apply的用途 改变 this 指向 call 和 apply 最常见的用途是改变函数内部的 this 指向： 123456789window.name = &#x27;bubuzou&#x27;;var obj = &#123; name: &#x27;bubuzou.com&#x27;&#125;;var getName = function() &#123; console.log( this.name );&#125;;getName(); // &#x27;bubuzou&#x27;getName.apply( obj ); // &#x27;bubuzou.com&#x27; Function.prototype.bind 大部分高级的浏览器都实现内置的 Function.prototype.bind ，用来指定函数内部的 this 指向，即使没有原生的Function.prototype.bind 实现，我们来模拟实现一个也不是难事： 12345678910111213Function.prototype.bind = function( context ) &#123; var self = this; return function() &#123; return self.apply( context, arguments ); &#125;&#125;;var obj = &#123; name: &#x27;bubuzou.com&#x27; &#125;;var func = function() &#123; console.log( this.name );&#125;.bind( obj );func(); // &#x27;bubuzou.com&#x27; 这是一个简化版的实现，我们可以实现得更复杂一点，使得可以往 func 函数中预先填入一些参数： 12345678910111213141516Function.prototype.bind = function() &#123; var self = this, context = [].shift.call( arguments ), args = [].slice.call( arguments ); return function() &#123; return self.apply( context, [].concat.call( args, [].slice.call( arguments ))); &#125;&#125;;var obj = &#123; name: &#x27;bubuzou.com&#x27;&#125;;var func = function( a, b, c, d ) &#123; console.log( this.name ); // &#x27;bubuzou.com&#x27; console.log( [a, b, c, d] ); // [1, 2, 3, 4]&#125;.bind(obj, 1, 2);func(3, 4); 借用其他对象的方法 我们知道，杜鹃既不会筑巢，也不会孵雏，而是把自己的蛋寄托给云雀等其他鸟类，让他们代为孵化和养育。同样，在JavaScript中也存在类似的借用现象。借用的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果： 1234567891011var A = function( name ) &#123; this.name = name;&#125;;var B = function() &#123; A.apply( this, arguments );&#125;;B.prototype.getName = function() &#123; return this.name;&#125;;var b = new B( &#x27;bubuzou.com&#x27; );console.log( b.getName() ); // &#x27;bubuzou.com&#x27; 借用方法的第二种运用场景跟我们的关系更加密切。函数的参数列表 arguments 是一个类数组对象，所以不能像数组一样，进行排序操作或往集合里添加一个新的元素。在这种情况下，我们通常会借用 Array.prototype 对象上的方法。比如像往arguments 里添加一个元素： 1234(function() &#123; Array.prototype.push.call( arguments, 3); console.log( arguments ); // [1, 2, 3]&#125;)(1, 2); 先来看一个例子: 1234var a = &#123;&#125;;Array.prototype.push.call( a, &#x27;first&#x27; );console.log( a.length ); // 1console.log( a[0] ); // &#x27;first&#x27; 上面这段代码在低版本IE浏览器中执行的时候，必须显式地给对象a设置length属性: 123var a = &#123; length: 0&#125;; 然而并不是所有的对象都可以传入Array.prototype.push，必须满足以下2个条件: 对象本身可以存取属性 如果不是一个 object 类型的对象而是 number 类型，我们来看看会怎么样： 1234var a = 1;Array.prototype.push.call( a, &#x27;first&#x27; );console.log( a.length ); // undefinedconsole.log( a[0] ); // undefined 对象的 length 属性可以读写 函数的 length 就是只有一个只读的属性，表示形参的个数，我们尝试把一个函数当做 this 传入Array.prototype.push: 123var func = function()&#123;&#125;;Array.prototype.push.call( func, &#x27;first&#x27; );console.log( func.length ); // 报错：Cannot assign to read only property &#x27;length&#x27; of function","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"数组","slug":"js-array","date":"2016-11-17T09:29:04.000Z","updated":"2019-03-29T01:20:52.341Z","comments":true,"path":"2016/11/17/js-array/","link":"","permalink":"https://bubuzou.com/2016/11/17/js-array/","excerpt":"数组字面量数组字面量提供了一种非常方便的创建数组的方法。一个数组表达式是在一对方括号内包围零个或多个用逗号分隔的值的表达式。数组的第一个值的属性名是 0。 123456var empty = [];var numbers = [&#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;];empty[1]; // undefinednumbers[1]; // &#x27;one&#x27;empty.length; // 0numbers.length; // 8 在大多数语言中，一个数组的所有元素都要求是相同的类型。js 允许数组包含任意混合类型的值： 12var misc = [&#x27;string&#x27;, 98.6, true, false, null];misc.length; // 5","text":"数组字面量数组字面量提供了一种非常方便的创建数组的方法。一个数组表达式是在一对方括号内包围零个或多个用逗号分隔的值的表达式。数组的第一个值的属性名是 0。 123456var empty = [];var numbers = [&#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;];empty[1]; // undefinednumbers[1]; // &#x27;one&#x27;empty.length; // 0numbers.length; // 8 在大多数语言中，一个数组的所有元素都要求是相同的类型。js 允许数组包含任意混合类型的值： 12var misc = [&#x27;string&#x27;, 98.6, true, false, null];misc.length; // 5 长度每个数组都有一个 length 属性。和大多数的语言不同，js 中数组的 length 是没有上限的。如果用大于或等于 length 的数字作为下标来存储一个元素，那么 length 的值会被增大以便容纳新的值，不会发生数组越界的错误。可以直接设置 length 的值，如果 length 大于当前的 length 值，则更大的那些下标的值都是 undefined；如果更小，那么将会把所有下标大于等于新 length 的属性给删除。通过把下标指定为一个数组的当前 length，可以附加一个新元素到该数组的末尾。 1234567var arr = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;];arr.length; // 3arr.length = 6;arr; // [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, undefined, undefined, undefined]arr.length = 2;arr; // [&#x27;one&#x27;, &#x27;two&#x27;]arr[arr.length] = &#x27;last&#x27;; // [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;last&#x27;]; 删除由于 js 的数组其实就是对象，所以 delete 运算符可以删除数组的元素： 123var arr = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;];delete arr[1]; arr; // [&#x27;one&#x27;, undefined, &#x27;three&#x27;] 遗憾的是删除后的数组直接留了一个空位值是 undefined，幸运的是可以通过数组的 splice 方法来进行调整。splice 方法接受 2 个参数，第一个是数组的序号，第二个是删除的元素个数，并且返回一个数组，这个数组包含了所有的删除元素。 12arr.splice(1, 1); // [undefined]arr; // [&#x27;one&#x27;, &#x27;three&#x27;] 枚举因为 js 数组其实就是对象，所以 for in 语句可以用来遍历一个数组的所有属性。但是用 for in语句无法保证顺序。所以遍历还是用常规的 for 循环 1234var numbers = [1, 2, 3, 4, 5];for ( var i = 0, l = numbers.length; i &lt; l; i++ ) &#123; console.log( numbers[i] ); // 1, 2, 3, 4, 5&#125; 判断是否是数组1typeof [1, 2, 3]; // &#x27;object&#x27; js 本身对于数组和对象的区别是混乱的。typeof 运算符报告数组的类型是 object，没有任何意义。js 没有一个好的机制来区别是数组还是对象，但是我们可以自己实现一个 is_array 函数来弥补这个缺陷： 12345var isArray = function( obj ) &#123; return obj &amp;&amp; typeof obj === &#x27;object&#x27; &amp;&amp; obj.constructor === Array;&#125;; 上面这个判断基本在常规页面就能很好的区分出数组还是对象了。但是也有特例，比如在不同的窗口(window)或帧(frame)就会失败。这个时候可以用下面这个替换： 123var isArray = function( obj ) &#123; return Object.prototype.toString.apply( obj ) === &#x27;[object Array]&#x27;;&#125;; 判断某个对象是否是数组，还可以用原型链的方法： 123var isArray = function( obj ) &#123; return obj.__prototype__ === Array.prototype;&#125; 方法 array.concat(item1[, item2, item2, ...]) concat 产生一个新数组，参数 item 可以是一个任意类型的值，也可以是一个数组，如果是数组，那么数组的所有元素都会被添加到新数组里。 123var a = [&#x27;a&#x27;,&#x27;b&#x27;];var b = [&#x27;x&#x27;,&#x27;y&#x27;];a.concat(b, true); // [&quot;a&quot;, &quot;b&quot;, &quot;x&quot;, &quot;y&quot;, true] array.join(separator) join 方法把 array 中的每个元素构造成一个字符串，接着用一个 separator 分隔符把它们连接在一起。默认的separator 是逗号,。想要无间隔的连接，可以使用空字符串。 123var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];a.join(); // &#x27;a,b,c&#x27;a.join(&#x27;&#x27;); // &#x27;abc&#x27; 如果想把大量的字符串片段组装成一个字符串，用 `+` 元素运算符连接这些片段会比把这些片段放到一个数组中并且用 `join` 连接起来更快。 array.pop() pop 方法移除数组中的最后一个元素并返回该元素。如果 array 是空值，则会返回 undefined 123456var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];a.pop(); // &#x27;c&#x27;// pop可以这样实现：Array.method(&#x27;pop&#x27;, function() &#123; return this.splice( this.length - 1, 1 )[0];&#125;); array.push(item1[, item2, ...]) push 方法把一个或多个参数附加到一个数组的尾部。参数可以是任何类型的值，也可以是数组。如果是数组，它会把参数数组作为这个元素添加到数组中。返回修改后的数组长度。 12345678910111213var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var b = [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;];var c = a.push(b, true);// a: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;], true]// c: 5// push可以这样实现：Array.method(&#x27;push&#x27;, function() &#123; this.splice.apply( this, [this.length, 0]. concat(Array.prototype.slice.apply(arguments))); return this.length;&#125;); array.reverse() reverse 方法反转 array 里的元素的顺序，并返回 array 本身。 12var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var b = a.reverse(); // a和b都是[&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;] array.shift() shift 方法移除数组中的第一个元素，并且返回这个元素。如果数组为空，则返回 undefined。 shift 通常比 pop 慢得多。 123456var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var b = a.shift(); // a: [&#x27;b&#x27;, &#x27;c&#x27;], b: &#x27;a&#x27;// shift实现Array.method(&#x27;shift&#x27;, function() &#123; return this.splice(0, 1)[0];&#125;); array.slice(start, end) slice 方法对数组进行一段浅复制。复制从下标 start 到 end 结束。end 下标默认是 array.length 。如果两个参数任意一个是负数，那么 end 数值会是和 array.length 相加之后的值。如果 start 大于array.length，则返回一个空数组。 1234var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var b = a.slice(0, 1); // [&#x27;a&#x27;]var c = a.slice(1); // [&#x27;b&#x27;, &#x27;c&#x27;]var d = a.slice(-1); // [&#x27;c&#x27;] array.sort(comparefn) sort 方法对 array 里的所有元素进行排序，默认的比较函数是把被排序的元素都视为字符串。所以它不能正确地给一组数字进行排序： 12var n = [4, 8, 15, 16, 23, 42];n.sort(); // [15, 16, 23, 4, 42, 8] 幸运的是你可以使用自定义的比较函数来使得一组数字能正常排序，比较函数接受两个参数，如果他们相等，则返回0，如果第一个参数应该排序在前面，则返回负数，如果第二个参数应该排在前面，则返回一个正数。 123n.sort(function(a, b) &#123; return a - b;&#125;); // [4, 8, 15, 16, 23, 42] 如果想给包含任何简单值的数组进行排序，可以这样： 12345678910var m = [&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;a&#x27;, 5, 3, 10];m.sort(function(a, b) &#123; if (a === b) &#123; return 0; &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1;&#125;); // [3, 5, 10, &#x27;a&#x27;, &#x27;aa&#x27;, &#x27;bb&#x27;] array.splice(start, deleteCount, item...) splice 方法从 array 中移除一个或多个元素，并用新的 item 替换它们。start 是移除元素的起始位置，deleteCount 是移除个数。如果有额外的参数，则 item 会插入到被移除的元素的位置上。返回一个包含被移除元素的数组。 12var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var r = a.splice(1, 1, &#x27;ache&#x27;, &#x27;bug&#x27;); // a: [&#x27;a&#x27;, &#x27;ache&#x27;, &#x27;bug&#x27;, &#x27;c&#x27;], r: [&#x27;b&#x27;] array.unshift(item...) unshift 方法是把 item 插入到数组的开始部分。返回新数组的 length。 12var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];var r = a.unshift(&#x27;#&#x27;, &#x27;$&#x27;); // a: [&#x27;#&#x27;, &#x27;$&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], r: 5","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"}]},{"title":"正则表达式理论篇","slug":"regexp-concept","date":"2016-11-04T02:09:04.000Z","updated":"2021-09-06T09:57:50.217Z","comments":true,"path":"2016/11/04/regexp-concept/","link":"","permalink":"https://bubuzou.com/2016/11/04/regexp-concept/","excerpt":"先来看一个例子这里有一个例子，用来匹配 URL 的正则表达式。 12345678var url = &#x27;http://bubuzou.com:80/goodparts?q#fragment&#x27;var parse_url = /^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Z-a-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/console.log(parse_url.exec(url))/*上面这段代码产生的结果如下：[&quot;http://bubuzou.com:80/goodparts?q#fragment&quot;, &quot;http&quot;, &quot;//&quot;, &quot;bubuzou.com&quot;, &quot;80&quot;, &quot;goodparts&quot;, &quot;q&quot;, &quot;fragment&quot;]*/","text":"先来看一个例子这里有一个例子，用来匹配 URL 的正则表达式。 12345678var url = &#x27;http://bubuzou.com:80/goodparts?q#fragment&#x27;var parse_url = /^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Z-a-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/console.log(parse_url.exec(url))/*上面这段代码产生的结果如下：[&quot;http://bubuzou.com:80/goodparts?q#fragment&quot;, &quot;http&quot;, &quot;//&quot;, &quot;bubuzou.com&quot;, &quot;80&quot;, &quot;goodparts&quot;, &quot;q&quot;, &quot;fragment&quot;]*/ 现在让我们来分解 parse_url 的各个部分，看看它是如何工作的： ^ 字符表示字符串的开始 (?:([A-Za-z]+):)?这个因子匹配一个协议名，但是只有当它后面跟随:的时候才匹配。(?:...) 表示一个非捕获型的分组。后缀 ? 表示这个分组是可选的，表示匹配 0 次或者 1 次。(...) 表示一个捕获型分组。一个捕获型分组会复制它所匹配的文本，并且将其放到 result 数组里。每个捕获型分组会被指定一个编号。第一个捕获型分组的编号是 1，所以该分组所匹配的结果会出现在 result[1] 中。[...] 表示一个字符类。A-Za-z 这个字符类包含 26 个大写字母和 26 个小写字母。+ 表示这个字符类会被匹配 1 次或多次。: 会按照字面进行匹配。 (\\/&#123;0,3&#125;) 这个因子是捕获分组 2 。\\/ 表示匹配 / （斜杠），它用 \\ 来进行转义。&#123;0,3&#125; 表示会被匹配0-3 次 ([0-9.\\-A-Z-a-z]+) 这个因子是捕获分组 3 。它会匹配一个主机名，由一个或多个数字、字母，以及 . 或-组成。 (?::(\\d+))? 这个因子匹配的是端口号。(\\d+) 是捕获分组 4，表示匹配一个或多个数字。 (?:\\/([^?#]*))? 是一个可选的分组，以一个 / 开始。[^?#] 是捕获分组 5 ，以一个 ^ 开始表示这个类包含除 ? 和 # 之外的所有字符。 * 表示匹配 0 次或多次。 (?:\\?([^#]*))? 是一个以 ? 开始的分组。包含捕获分组 6，这个分组包含 0 个或多个非 # 的字符 (?:#(.*))? 这个可选分组是以 # 开始的，. 会匹配除了行结束符以外的所有字符。 $ 表示字符串的结束 所谓正则表达式，就是一种描述字符串结构模式的形式化表达方法。 这是《精通正则表达式》对它的定义。正则表达式又叫做规则表达式(Regular Expression，简写 regexp).正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式能干嘛 测试字符串是否满足某种模式。比如字符串内是否出现电话号码模式，又称为数据验证。 替换文本。可以用正则表达式来识别字符串中的特定文本，完全删除或者用其他文本替换它。 提取字符串。基本匹配模式从字符串中提取需要的子字符串。 正则表达式已经在很多软件中得到广泛的应用，包括 `*nix(Linux, Unix等)`，`HP` 等操作系统，`PHP`、`C#`、`Java`等开发环境，以及很多的应用软件中，都可以看到正则表达式的影子。 正则表达式结构优先考虑的方法是使用正则表达式字面量： 1var patt = /pattern/modifiers; 另一种方法是使用 RegExp 构造器： 1var patt = new RegExp(pattern, modifiers) pattern（模式） 描述了表达式的模式 modifiers（修饰符） 用于指定全局匹配、区分大小写的匹配和多行匹配 修饰符 modifiers： 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配 m 执行多行匹配 123var patt = /hello/givar str = &#x27;Hello world!&#x27;patt.exec(str) // 将会匹配&#x27;Hello&#x27; 正则表达因子一个正则表达式因子可以是一个字符、一个圆括号包围的组、一个字符类或者是一个转义序列。下面这些字符都会按照字面进行处理\\ / [ ] ( ) &#123; &#125; ? + * | . ^ $如果你希望这些字符按照字面意思去匹配，那需要在其前面加上\\进行转义。 123var patt = /\\.\\d+/var str = &#x27;-12.568&#x27;patt.exec(str) // 匹配&#x27;.568&#x27; 正则表达式特殊字符: 特殊字符 描述 ^ 匹配输入字符串开始处的位置；但在中括号表达式中是表示对字符集求反。若要匹配 ^ 字符本身，请使用 \\^。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，那么 $ 还匹配 \\n 或 \\r 前面的位置。若要匹配 $ 字符本身，请使用 \\$。 () 标记子表达式的开始和结束。可以捕获子表达式以供以后使用。若要匹配这两个字符，请使用 \\( 和 \\)。 * 零次或多次匹配前面的字符或子表达式。若要匹配 * 字符，请使用 \\*。 + 一次或多次匹配前面的字符或子表达式。若要匹配 + 字符，请使用 \\+。 ? 零次或一次匹配前面的字符或子表达式，或指示“非贪心”限定符。若要匹配 ? 字符，请使用\\?。 . 匹配除换行符 \\n 之外的任何单个字符。若要匹配 . 请使用 \\。 [] 标记中括号表达式的开始。若要匹配这些字符，请使用 \\[ 和\\]。 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，字符 n 匹配字符 n。\\n 匹配换行符。序列 \\\\ 匹配 \\，序列 \\( 匹配 (。 / 表示文本正则表达式的开始或结束。若要匹配 / 字符，请使用 \\/。 &#123;&#125; 标记限定符表达式的开始。若要匹配这些字符，请使用 \\&#123; 和 \\&#125;。 竖线 指出在两个项之间进行选择。要匹配竖线，请使用 \\ 竖线。 正则表达式序列一个正则表达式序列包含一个或多个正则表达式因子。每个因子能选择是否跟随一个量词，这个量词决定了这个因子被允许出现的次数。如果没有量词，则只匹配一次。 123var patt = /\\d&#123;3&#125;\\.\\d/var str = &#x27;abc1893.65d&#x27;patt.exec(str) // 匹配&#x27;893.6&#x27; 正则表达式分支一个正则表达式分支包含一个或多个正则表达式序列。这些序列被|字符分隔。如果这些序列中的任何一项符合匹配条件，那么这个选择就被匹配。它会按照书写顺序从左到右依次匹配这些序列。 123var str = &#x27;information&#x27;str.match(/or|for/) // 匹配&#x27;for&#x27;str.match(/or|orm/) // 匹配&#x27;or&#x27; 正则表达式分组正则表达式的分组共有 6 种。 (...)捕获型，捕获型分组是一个被包围在圆括号中的正则表达式分支。任何匹配这个分组的字符都会被捕获。每个捕获分组都将有一个编号。第一个捕获分组的编号是 1，以此类推。 12;/(:\\d+)/.exec(&#x27;bubuzou.com:80/&#x27;)// 结果是[&#x27;:80&#x27;, &#x27;:80&#x27;]，第一个&#x27;:80&#x27;表示整个正则的匹配，第二个&#x27;:80&#x27;表示捕获分组1的匹配 (?:...) 非捕获型，仅做简单的匹配，并不会捕获所匹配的文本。也不会进行编号。 1/(?::\\d+)/.exec( &#x27;bubuzou.com:80/&#x27; ); 结果是[&#x27;:80&#x27;]，不包含分组捕获。 (?=pattern) 正向肯定预查。匹配其跟随了 pattern 的字符串。这不是一个好的特性。 1;/window(?=95|98|2000)/.exec(&#x27;window98&#x27;) // 匹配&#x27;window&#x27; (?!pattern) 正向否定预查。匹配其没有跟随了 pattern 的字符串。这不是一个好的特性。 1;/window(?!95|98|2000)/.exec(&#x27;windowNT&#x27;) // 匹配&#x27;window&#x27; (?&lt;=pattern) 反向肯定预查。匹配前面带 pattern 的字符串。这不是一个好的特性。 1;/(?&lt;=95|98|2000)windows/.exec(&#x27;95windows&#x27;) // 匹配&#x27;windows&#x27; (?&lt;!pattern) 反向否定预查。匹配前面没有带 pattern 的字符串。这不是一个好的特性。 RegExp 对象方法 方法 描述 regexp.exec(string) 检索字符串中指定的值。如果匹配成功，则返回一个数组。数组中下标为 0 的值表示匹配的子字符串，下标为 1 的值是分组 1 捕获的文本。如果匹配失败，则会返回 null. regexp.test(string) 检索字符串中指定的值。返回 true 或 false。 test 方法中不需要对 regexp 进行全局匹配的配置，因为结果都一样。 string.match(regexp) 获取匹配结果。如果没有 g 标识，则结果和 regexp.exec(string) 一样。如果有 g 标识，则返回包含所有匹配结果（除了分组捕获之外）的数组。 string.replace(searchValue, replaceValue) replace 方法对字符串执行查找和替换工作，并返回一个新的字符串。参数 searchValue 可以是一个字符串或者正则表达式。如果是字符串，则在字符串中第一次出现的地方被替换。如果是正则表达式且带有 g，则会替换所有匹配，如果没有 g 则只会替换第一个匹配。replaceValue 可以是一个字符串或者一个函数。如果是一个函数则有特别含义。如果是一个函数，则每遇到一个匹配函数就会被调用一次，而函数返回的字符串将作为替换的文本。 string.search(regexp) 和 indexOf 方法类似，只是它接受的参数是一个正则表达式而非字符串。如果找到匹配，则返回第一个匹配的首字符的位置，没找到就返回 -1 string.split(separator, limit) 把 string 分割成片段来创建一个字符串数组。limit 可以限制分割的数量。separator可以是字符串或正则表达式。 regexp.exec(string)： 123456789// RegExpObject.exec(string);var str = &#x27;user1abcuser2abc&#x27;, patt = /user\\d/g, resultwhile ((result = patt.exec(str))) &#123; console.log(result)&#125;// 第一次：[&quot;user1&quot;, index: 0, input: &quot;user1abcuser2abc&quot;]// 第二次：[&quot;user2&quot;, index: 8, input: &quot;user1abcuser2abc&quot;] 如果regexp带有g标识，那么查找不是从这个字符串的起始位置开始，而是从regexp.lastIndex位置开始。如果匹配成功，那么regexp.lastIndex将被设置为该匹配后第一个字符的位置。不成功的匹配会将regexp重新设置为0。 regexp.test(string)： 1;/Hello/i.test(&#x27;hello world&#x27;) // true string.match(regexp)： 12&#x27;user1abcuser2abc&#x27;.match(/user\\d/g) // [&#x27;user1&#x27;, &#x27;user2&#x27;]&#x27;user1abcuser2abc&#x27;.match(/user\\d/) // [&#x27;user1&#x27;] string.replace(searchValue, replaceValue)： 123var patt = /\\((\\d&#123;3&#125;)\\)/g, str = &#x27;(555)666-1212&#x27;.replace(patt, &#x27;$1-&#x27;)console.log(str) // 结果：&#x27;555-666-1212&#x27; 美元符号序列 替换对象 $$ $ $&amp; 整个匹配的文本 $number 分组匹配的文本 $ 匹配之前的文本 $ 匹配之后的文本 string.search(regexp)： 1&#x27;hello world&#x27;.search(/world/) // 6 string.split(separator, limit)： 12&#x27;123456&#x27;.split(&#x27;&#x27;, 3) // [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]&#x27;last, first, middle&#x27;.split(/\\s*,\\s*/) // [&#x27;last&#x27;, &#x27;first&#x27;, &#x27;middle&#x27;] 正则表达式字符表 量词 描述 * 零次或多次匹配前面的字符或子表达式。例如，zo 匹配 z 和 zoo。 等效于 &#123;0,&#125;。 + 一次或多次匹配前面的字符或子表达式。例如，zo+ 匹配 zo 和 zoo，但不匹配 z。+ 等效于 &#123;1,&#125;。 ? 零次或一次匹配前面的字符或子表达式。例如，do(es)? 匹配 do 或 does 中的 do。? 等效于 &#123;0,1&#125;。 &#123;n&#125; n 是非负整数。正好匹配 n 次。例如，o&#123;2&#125; 不匹配 Bob 中的 o，但匹配 food 中的两个 o。 &#123;n,&#125; n 是非负整数。至少匹配 n 次。例如，o&#123;2,&#125; 不匹配 Bob 中的 o，而匹配 foooood 中的所有 o。o&#123;1,&#125; 等效于 o+。o&#123;0,&#125; 等效于 o*。 &#123;n,m&#125; m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，o&#123;1,3&#125; 匹配 fooooood 中的头三个 o。o&#123;0,1&#125; 等效于 o?。注意：您不能将空格插入逗号和数字之间。 方括号：方括号用于查找某个范围内的字符 表达式 描述 [abc] 查找方括号之间的任何字符 [^abc] 查找任何不在方括号之间的字符 [0-9] 查找任何从 0 至 9 的数字 [a-z] 查找任何从小写 a 至小写 a 的字符 () 匹配一个子表达式的开始和结束位置 元字符：拥有特殊含义的字符 元字符 描述 . 查找单个字符，除了换行和行结束符 \\w 查找单词字符 \\W 查找非单次字符 \\b 匹配一个字的边界，即字与空格间的位置 \\B 非字符边界匹配 \\d 查找数字 \\D 查找非数字字符 \\s 查找空白字符 \\S 查找非空白字符","categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://bubuzou.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]}],"categories":[{"name":"web综合","slug":"web综合","permalink":"https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"},{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://bubuzou.com/categories/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/categories/JavaScript/"},{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/categories/vue/"},{"name":"css","slug":"css","permalink":"https://bubuzou.com/categories/css/"},{"name":"http","slug":"http","permalink":"https://bubuzou.com/categories/http/"},{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"git","slug":"git","permalink":"https://bubuzou.com/categories/git/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://bubuzou.com/tags/mac/"},{"name":"shell","slug":"shell","permalink":"https://bubuzou.com/tags/shell/"},{"name":"小程序","slug":"小程序","permalink":"https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"反编译","slug":"反编译","permalink":"https://bubuzou.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"name":"命令","slug":"命令","permalink":"https://bubuzou.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://bubuzou.com/tags/TypeScript/"},{"name":"微前端","slug":"微前端","permalink":"https://bubuzou.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"git","slug":"git","permalink":"https://bubuzou.com/tags/git/"},{"name":"eslint","slug":"eslint","permalink":"https://bubuzou.com/tags/eslint/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://bubuzou.com/tags/JavaScript/"},{"name":"css","slug":"css","permalink":"https://bubuzou.com/tags/css/"},{"name":"图像","slug":"图像","permalink":"https://bubuzou.com/tags/%E5%9B%BE%E5%83%8F/"},{"name":"性能优化","slug":"性能优化","permalink":"https://bubuzou.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"http","slug":"http","permalink":"https://bubuzou.com/tags/http/"},{"name":"浏览器","slug":"浏览器","permalink":"https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"安全","slug":"安全","permalink":"https://bubuzou.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"vue","slug":"vue","permalink":"https://bubuzou.com/tags/vue/"},{"name":"wepy","slug":"wepy","permalink":"https://bubuzou.com/tags/wepy/"},{"name":"node","slug":"node","permalink":"https://bubuzou.com/tags/node/"},{"name":"jest","slug":"jest","permalink":"https://bubuzou.com/tags/jest/"},{"name":"单元测试","slug":"单元测试","permalink":"https://bubuzou.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"upload","slug":"upload","permalink":"https://bubuzou.com/tags/upload/"},{"name":"element","slug":"element","permalink":"https://bubuzou.com/tags/element/"},{"name":"svg","slug":"svg","permalink":"https://bubuzou.com/tags/svg/"},{"name":"chrome","slug":"chrome","permalink":"https://bubuzou.com/tags/chrome/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://bubuzou.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]}