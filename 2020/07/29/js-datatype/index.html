<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> JavaScript中的数据类型 · 步步走</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="JavaScript中的数据类型、类型转换、类型校验、null、undefined、boolean、string、number、内存管理"><meta name="keywords" content="js数据类型、类型转换、类型校验、变量存储、IEEE 754、内存管理、Symbol"><meta name="author" content="typeR"><link rel="short icon" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/favicon.ico"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://bubuzou.com/atom.xml" title="步步走"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="步步走" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/logo.svg"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/read/" target="_self" data-hover="读书" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">JavaScript中的数据类型</h1><div class="post-info">2020-07-29<p class="visit"><i data-identity="2020/07/29/js-datatype/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h2 id="JavaScript-中有哪些数据类型？"><a href="#JavaScript-中有哪些数据类型？" class="headerlink" title="JavaScript 中有哪些数据类型？"></a>JavaScript 中有哪些数据类型？</h2><p>计算机世界中定义的数据类型其实就是为了描述现实世界中存在的事实而定义的。比如我们用人来举例：</p>
<ol>
<li><p>有没有人在房间里？这里的有和没有就是是或者非的概念，在 <code>JS</code> 中对应 <code>Boolean</code> 类型，<code>true</code> 表示是，<code>false</code> 表示非；</p>
</li>
<li><p>有几个人在房间里？这里的几个表示的是一个量级概念，在 <code>JS</code> 中对应 <code>Number</code> 类型，包含整数和浮点数，还有一些特殊的值，比如：<code>-Infinity</code> 表示负无穷大、<code>+Infinity</code> 表示正无穷大、<code>NaN</code> 表示不是一个数字；</p>
</li>
<li><p>房间里的这些人都是我的朋友。这是一句陈述语句，这种文本类的信息将会以字符串形式进行存储，在 <code>JS</code> 中对应 <code>String</code> 类型；</p>
</li>
<li><p>房间里没有人。这里的没有代表无和空的概念，在 <code>JS</code> 中 <code>null</code> 和 <code>undefined</code> 都可以表示这个意思；</p>
</li>
<li><p>现实世界中所有人都是独一无二的，这在 <code>JS</code> 中对应 <code>Symbol</code> 类型，表示唯一且不可改变；</p>
</li>
<li><p><code>Number</code> 所表示的整数是有范围的，超出范围的数据就没法用 <code>Number</code> 表示了，于是 <code>ES10</code> 中提出了一种新的数据类型 <code>BigInt</code>，能表示任何位数的整数；</p>
</li>
<li><p>以上提到的 <code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>null</code>、<code>undefined</code>、<code>Symbol</code> 和 <code>BigInt</code> 等 7 种类型都是 <code>JavaScript</code> 中的原始类型，还有一种是非原始类型叫做对象类型；比如：一个人是对象，这个人有名字、性别、年龄等；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">  sex: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  age: <span class="number">26</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<a id="more"></a>

<h2 id="为什么要区分原始类型和对象类型？他们之间有什么区别？"><a href="#为什么要区分原始类型和对象类型？他们之间有什么区别？" class="headerlink" title="为什么要区分原始类型和对象类型？他们之间有什么区别？"></a>为什么要区分原始类型和对象类型？他们之间有什么区别？</h2><h3 id="原始类型的不可变性"><a href="#原始类型的不可变性" class="headerlink" title="原始类型的不可变性"></a>原始类型的不可变性</h3><p>在回答这个问题之前，我们先看一下变量在内存中是如何存储的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="keyword">let</span> name2 = name1.concat(<span class="string">&#x27;.com&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(name1) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure>

<p>执行完上面这段代码，我们发现变量 <code>name1</code> 的值还是不变，依然是 <code>bubuzou</code>。这就说明了字符串的不可变性。但是你看了下面的这段代码，你就会产生疑问了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">name1 += <span class="string">&#x27;.com&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(name1) <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure>

<p>你说字符串是不可变的，那现在不是变了嘛？<br>其实这只是变量的值变了，但是存在内存中的字符串依然不变。这就涉及到变量在内存中的存储了。<br>在 <code>JavaScript</code> 中，变量在内存中有 2 种存储方式：存在栈中和存在堆中。那么栈内存和堆内存有啥区别呢？</p>
<p>栈内存：</p>
<ul>
<li>顺序存储结构，特点是先进后出。就像一个兵乒球盒子一样，兵乒球从外面一个个的放入盒子里，最先取出来的一定是最后放入盒子的那个。</li>
<li>存储空间固定</li>
<li>可以直接操作其保存的值，执行效率高</li>
</ul>
<p>堆内存：</p>
<ul>
<li>无序的存储结构</li>
<li>存储空间可以动态变化</li>
<li>无法直接操作其内部的存储，需要通过引用地址操作</li>
</ul>
<p>了解完变量在内存中的存储方式有 2 种，那我们继续以上面那串代码为例，画出变量的存储结构图：<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype01.png" alt="js_datatype_01-w548"><br>然后我们可以描述下当计算机执行这段代码时候的发生了什么？首先定义了一个变量 <code>name1</code> 并且给其赋值 <code>bubuzou</code> 这个时候就会在内存中开辟一块空间用来存储字符串 <code>bubuzou</code>，然后变量指向了这个内存空间。然后再执行第二行代码 <code>let name2 = name1.concat(&#39;.com&#39;)</code> 这里的拼接操作其实是产生了一个新字符串 <code>bubuzou.com</code>，所以又会为这个新字符串创建一块新内存，并且把定义的变量 <code>name2</code> 指向这个内存地址。 所以我们看到其实整个操作 <code>bubuzou</code> 这个字符串所在的内存其实是没有变化的，即使在第二段代码中执行了 <code>name1 += &#39;.com&#39;</code> 操作，其实也只是变量 <code>name1</code> 指向了新的字符串 <code>bubuzou.com</code> 而已，旧的字符串 <code>bubuzou</code> 依然存在内存中，不过一段时间后由于该字符串没有被变量所引用，所以会被当成垃圾进行回收，从而释放掉该块内存空间。</p>
<p>从而我们得出结论：原始类型的值都是固定的，而对象类型则是由原始类型的键值对组合成一个复杂的对象；他们在内存中的存储方式是不一样的，原始类型的值直接存在栈内存中，而对象类型的实际值是存在堆内存中的，在栈内存中保存了一份引用地址，这个地址指向堆内存中的实际值，所以对象类型又习惯被叫做引用类型。</p>
<blockquote>
<p>想一个问题为什么引用类型的值要存储到堆内存中？能不能存到栈内存中呢？答案一：因为引用类型大小不固定，而栈的大小是固定的，堆空间的大小是可以动态变化的，所以引用类型的值适合存在堆中；答案二：在代码执行过程中需要频繁的切换执行上下文的时候，如果把引用类型的值存到栈中，将会造成非常大的内存开销。</p>
</blockquote>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>当我们对两个变量进行比较的时候，不同类型的变量是有不同表现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1 === str2) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person1 === person2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们定义了 2 个字符串变量和 2 个对象变量，他们都长一模一样，但是字符串变量会相等，对象变量却不相等。这是因为在 <code>JavaScript</code> 中，原型类型进行比较的时候比较的是存在栈中的值是否相等；而引用类型进行比较的时候，是比较栈内存中的引用地址是否相等。<br>如上几个变量在内存中的存储模型如图所示：<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype02.png" alt="js_datatype_02"></p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>变量进行复制的时候，原始类型和引用类型变量也是有区别的，来看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = str1</span><br><span class="line">str2 = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1) <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype03.png" alt="js_datatype_02"></p>
<ol>
<li><code>let str1 = &#39;hello&#39;</code>: 复制前，定义了一个变量 <code>str1</code>，并且给其赋值 <code>hello</code>，这个时候 <code>hello</code> 这个字符串就会在栈内存中被分配一块空间进行存储，然后变量 <code>str1</code> 会指向这个内存地址；</li>
<li><code>let str2 = str1</code>：复制后，把 <code>str1</code> 的值赋值给 <code>str2</code>，这个时候会在栈中新开辟一块空间用来存储 <code>str2</code> 的值；</li>
<li><code>str2 = &#39;world&#39;</code>：给 <code>str2</code> 赋值了一个新的字符串 <code>world</code>，那么将新建一块内存用来存储 <code>world</code>，同时 <code>str2</code> 原来的值 <code>hello</code> 的内存空间因为没有变量所引用，所以一段时间后建被当成垃圾回收；</li>
<li><code>console.log( str1 )</code>：因为 <code>str1</code> 和 <code>str2</code> 的栈内存地址是不一样的，所以即使 <code>str2</code> 的值被改变，也不会影响到 <code>str1</code>。</li>
</ol>
<p>然后我们继续往下，看下引用类型的复制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let person1 &#x3D; &#123;</span><br><span class="line">    name: &#39;bubuzou&#39;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line">let person2 &#x3D; person1</span><br><span class="line">person2.name &#x3D; &#39;bubuzou.com&#39;</span><br><span class="line">console.log( person1.name)  &#x2F;&#x2F; &#39;bubuzou.com&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype04.png" alt="js_datatype_02"><br>原始类型进行复制的时候是变量的值进行重新赋值，而如上图所示：引用类型进行复制的时候是把变量所指向的引用地址进行赋值给新的变量，所以复制后 <code>person1</code> 和 <code>person2</code> 都指向堆内存中的同一个值，所以当改变 <code>person2.name</code> 的时候， <code>person1.name</code> 也会被改变就是这个原因。</p>
<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>先说一下结论，在 <code>JavaScript</code> 中，所有函数的参数传递都是按值进行传递的。看如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">changeName(name)</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure>

<p>定义了一个变量 <code>name</code>，并赋值为 <code>bubuzou</code>，函数调用的时候传入 <code>name</code>，这个时候会在函数内部创建一个局部变量 <code>name</code> 并且把全局变量的值 <code>bubuzou</code> 传递给他，这个操作其实是在内存里新建了一块空间用来存放局部变量的值，然后又把局部变量的值改成了 <code>bubuzou.com</code>，这个时候其实内存中会有 3 块地址空间分别用来存放全局变量的值 <code>bubuzou</code>、局部变量原来的值 <code>bubuzou</code>、和局部变量新的值 <code>bubuzou.com</code>；一旦函数调用结束，局部变量将被销毁，一段时间后由于局部变量新旧值没有变量引用，那这两块空间将被回收释放；所以这个时候全局 <code>name</code> 的值依然是 <code>bubuzou</code>。</p>
<p>再来看看引用类型的传参，会不会有所不同呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changePerosn</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  person.name = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">changePerosn(person)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure>

<p>引用类型进行函数传参的时候，会把引用地址复制给局部变量，所以全局的 <code>person</code> 和函数内部的局部变量 <code>person</code> 是指向同一个堆地址的，所以一旦一方改变，另一方也将被改变，所以至此我们是不是可以下结论说：当函数进行传参的时候如果参数是引用类型那么就是引用传递嘛？</p>
<p>将上面的例子改造下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changePerosn</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  person.name = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">  person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;hello world&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">changePerosn(person)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>person</code> 是引用传递的话，那就会自动指向值被改为 <code>hello world</code> 的新对象；事实上全局变量 <code>person</code> 的引用地址自始至终都没有改变，倒是局部变量 <code>person</code> 的引用地址发生了改变。</p>
<h2 id="null-和-undefined-傻傻分不清？"><a href="#null-和-undefined-傻傻分不清？" class="headerlink" title="null 和 undefined 傻傻分不清？"></a>null 和 undefined 傻傻分不清？</h2><p><code>null</code> 在 <code>JavaScript</code> 中自成一种原始类型，只有一个值 <code>null</code>，表示无、空、值未知等特殊值。可以直接给一个变量赋值为 <code>null</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p><code>undefined</code> 和 <code>null</code> 一样也是自成一种原始类型，表示定义了一个变量，但是没有赋值，则这个变量的值就是 <code>undefined</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s</span><br><span class="line"><span class="built_in">console</span>.log(s) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>虽然可以给变量直接赋值为 <code>undefined</code> 也不会报错，但是原则上如果一个变量值未定，或者表示空，则直接赋值为 <code>null</code> 比较合适，不建议给变量赋值 <code>undefined</code>。<br><code>null</code> 和 <code>undefined</code> 在进行逻辑判断的时候都是会返回 <code>false</code> 的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>,</span><br><span class="line">  b</span><br><span class="line"><span class="built_in">console</span>.log(a ? <span class="string">&#x27;a&#x27;</span> : b ? <span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;c&#x27;</span>) <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>null</code> 在转成数字类型的时候会变成 <code>0</code>，而 <code>undefined</code> 会变成 <code>NaN</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>,</span><br><span class="line">  b</span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(+b) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="认识新的原始类型-Symbol"><a href="#认识新的原始类型-Symbol" class="headerlink" title="认识新的原始类型 Symbol"></a>认识新的原始类型 Symbol</h2><p><code>Symbol</code> 值表示唯一标识符，是 <code>ES6</code> 中新引进的一种原始类型。可以通过 <code>Symbol()</code> 来创建一个重要的值，也可以传入描述值；其唯一性体现在即使是传入一样的描述，他们两者之间也是不会相等的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="全局的-Symbol"><a href="#全局的-Symbol" class="headerlink" title="全局的 Symbol"></a>全局的 Symbol</h3><p>那还是不是任意 2 个描述一样的 <code>Symbol</code> 都是不相等的呢？答案是否定的。可以通过 <code>Symbol.for()</code> 来查找或新建一个 <code>Symbol</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>Symbol.for()</code> 可以在根据传入的描述在全局范围内进行查找，如果没找到则新建一个 <code>Symbol</code>，并且返回；所以当执行第二行代码 <code>Symbol.for(&#39;bubuzou&#39;)</code> 的时候，就会找到全局的那个描述为 <code>bubuzou</code> 的 <code>Symbol</code>，所以这里 <code>a</code> 和 <code>b</code> 是会绝对相等的。</p>
<p>居然可以通过描述找到 <code>Symbol</code>， 那是否可以通过 <code>Symbol</code> 来找到描述呢？答案是肯定的，但是必须是全局的 <code>Symbol</code>，如果没找到则会返回 <code>undefined</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> desc = <span class="built_in">Symbol</span>.keyFor(a)</span><br><span class="line"><span class="built_in">console</span>.log(desc) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是对于任何一个 <code>Symbol</code> 都有一个属性 <code>description</code>，表示这个 <code>Symbol</code> 的描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.description) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-作为对象属性"><a href="#Symbol-作为对象属性" class="headerlink" title="Symbol 作为对象属性"></a>Symbol 作为对象属性</h3><p>我们知道对象的属性键可以是字符串，但是不能是 <code>Number</code> 或者 <code>Boolean</code>；<code>Symbol</code> 被设计出来其实最大的初衷就是用于对象的属性键：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="built_in">Symbol</span>(<span class="string">&#x27;20&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">  [age]: <span class="string">&#x27;20&#x27;</span>, <span class="comment">// 在对象字面量中使用 `Symbol` 的时候需要使用中括号包起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里给 <code>person</code> 定义了一个 <code>Symbol</code> 作为属性键的属性，这个相比于用字符串作为属性键有啥好处呢？最明显的好处就是如果这个 <code>person</code> 对象是多个开发者进行开发维护，那么很容易再给 <code>person</code> 添加属性的时候出现同名的，如果是用字符串作为属性键那肯定是冲突了，但是如果用 <code>Symbol</code> 作为属性键，就不会存在这个问题了，因为它是唯一标识符，所以可以使对象的属性受到保护，不会被意外的访问或者重写。</p>
<p>注意一点，如果用 <code>Symbol</code> 作为对象的属性键的时候，<code>for in</code> 、<code>Object.getOwnPropertyNames</code>、或 <code>Object.keys()</code> 这里循环是无法获取 <code>Symbol</code> 属性键的，但是可以通过 <code>Object.getOwnPropertySymbols()</code> 来获取；在上面的代码基础上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o) <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(person)) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(person)) <span class="comment">// [Symbol(20)]</span></span><br></pre></td></tr></table></figure>

<h2 id="你可能不知道的-Number-类型"><a href="#你可能不知道的-Number-类型" class="headerlink" title="你可能不知道的 Number 类型"></a>你可能不知道的 Number 类型</h2><p><code>JavaScript</code> 中的数字涉及到了两种类型：一种是 <code>Number</code> 类型，以 <code>64</code> 位的格式 <code>IEEE-754</code> 存储，也被称为双精度浮点数，就是我们平常使用的数字，其范围是 $2^{52}$ 到 -$2^{52}$；第二种类型是 <code>BigInt</code>，能够表示任意长度的整数，包括超出 $2^{52}$ 到 -$2^{52}$ 这个范围外的数。这里我们只介绍 <code>Number</code> 数字。</p>
<h3 id="常规数字和特殊数字"><a href="#常规数字和特殊数字" class="headerlink" title="常规数字和特殊数字"></a>常规数字和特殊数字</h3><p>对于一个常规的数字，我们直接写即可，比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>但是还有一种位数特别多的数字我们习惯用科学计数法的表示方法来写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> billion = <span class="number">1000000000</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1e9</span></span><br></pre></td></tr></table></figure>

<p>以上两种写法是一个意思， <code>1e9</code> 表示 1 x $10^9$；如果是 <code>1e-3</code> 表示 1 / $10^3$ = 0.001。<br>在 <code>JavaScript</code> 中也可以用数字表示不同的进制，比如：十进制中的 <code>10</code> 在 二、八和十六进制中可以分别表示成 <code>0b1010</code>、<code>0o12</code> 和 <code>0xa</code>；其中的 <code>0b</code> 是二进制前缀，<code>0o</code> 是八进制前缀，而 <code>ox</code> 是十六进制的前缀。</p>
<p>我们也可以通过 <code>toString(base)</code> 方法来进行进制之间的转换， <code>base</code> 是进制的基数，表示几进制，默认是 <code>10</code> 进制的，会返回一个转换数值的字符串表示。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)) <span class="comment">// &#x27;1010&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>)) <span class="comment">// &#x27;12&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>)) <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>数字也可以直接调用方法，<code>10..toString( 2 )</code> 这里的 2 个 <code>.</code> 号不是写错了，而是必须是 2 个，否则会报 <code>SyntaxError</code> 错误。第一个点表示小数点，第二个才是调用方法。点符号首先会被认为是数字常量的一部分，其次再被认为是属性访问符，如果只写一个点的话，计算机无法知道这个是表示一个小数呢还是去调用函数。数字直接调用函数还可以有以下几种写法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="number">10</span>).toString(<span class="number">2</span>) <span class="comment">// 将10用括号包起来</span></span><br><span class="line">;(<span class="number">10.0</span>).toString(<span class="number">2</span>) <span class="comment">// 将10写成10.0的形式</span></span><br><span class="line">;(<span class="number">10</span>).toString(<span class="number">2</span>) <span class="comment">// 空格加上点符号调用</span></span><br></pre></td></tr></table></figure>

<p><code>Number</code> 类型除了常规数字之外，还包含了一些特殊的数字：</p>
<ul>
<li><p><code>NaN</code>：表示不是一个数字，通常是由不合理的计算导致的结果，比如数字除以字符串 <code>1 / &#39;a&#39;</code>;<br><code>NaN</code> 和任何数进行比较都是返回 <code>false</code>，包括他自己： <code>NaN == NaN</code> 会返回 <code>false</code>;<br>如何判断一个数是不是 <code>NaN</code> 呢？有四种方法：</p>
<pre><code>方法一：通过 `isNaN()` 函数，这个方法会对传入的字符串也返回 `true`，所以判断不准确，不推荐使用：
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;isNaN&lt;/span&gt;( &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;isNaN&lt;/span&gt;( &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt; )  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
方法二：通过 `Number.isNaN()`，推荐使用：
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.isNaN( &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.isNaN( &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt; )  &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
方法三：通过 `Object.is(a, isNaN)`:
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.is( &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;/&lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NaN&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.is( &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NaN&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
方法四：通过判断 `n !== n`，返回 `true`， 则 `n` 是 `NaN` :
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; s = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( s !== s )  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre>
</li>
<li><p><code>+Infinity</code>：表示正无穷大，比如 <code>1/0</code> 计算的结果, <code>-Infinity</code> 表示负无穷大，比如 <code>-1/0</code> 的结果。</p>
</li>
<li><p><code>+0</code> 和 <code>-0</code>，<code>JavaScript</code> 中的数字都有正负之分，包括零也是这样，他们会绝对相等：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="为什么-0-1-0-2-不等于-0-3"><a href="#为什么-0-1-0-2-不等于-0-3" class="headerlink" title="为什么 0.1 + 0.2 不等于 0.3"></a>为什么 0.1 + 0.2 不等于 0.3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>有没有想过为什么上面的会不相等？因为数字在 <code>JavaScript</code> 内部是用二进制进行存储的，其遵循 <code>IEEE 754</code> 标准的，用 <code>64</code> 位来存储一个数字，<code>64</code> 位又被分隔成 <code>1</code>、<code>11</code> 和 <code>52</code> 位来分别表示符号位、指数位和尾数位。<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype05.png" alt="js_datatype_05"><br>比如十进制的 <code>0.1</code> 转成二进制后是多少？我们手动计算一下，十进制小数转二进制小数的规则是“乘 2 取整，顺序排列”，具体做法是：用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 * 2 &#x3D; 0.2  &#x2F;&#x2F; 第1步：整数为0，小数0.2</span><br><span class="line">0.2 * 2 &#x3D; 0.4  &#x2F;&#x2F; 第2步：整数为0，小数0.4</span><br><span class="line">0.4 * 2 &#x3D; 0.8  &#x2F;&#x2F; 第3步：整数为0，小数0.8</span><br><span class="line">0.8 * 2 &#x3D; 1.6  &#x2F;&#x2F; 第4步：整数为1，小数0.6</span><br><span class="line">0.6 * 2 &#x3D; 1.2  &#x2F;&#x2F; 第5步：整数为1，小数0.2</span><br><span class="line">0.2 * 2 &#x3D; 0.4  &#x2F;&#x2F; 第6步：整数为0，小数0.4</span><br><span class="line">0.4 * 2 &#x3D; 0.8  &#x2F;&#x2F; 第7步：整数为0，小数0.8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们这样依次计算下去之后发现得到整数的顺序排列是 <code>0001100110011001100....</code> 无限循环，所以理论上十进制的 <code>0.1</code> 转成二进制后会是一个无限小数 <code>0.0001100110011001100...</code>，用科学计数法表示后将是 <code>1.100110011001100...</code> x $2^{-4}$ ，但是由于 <code>IEEE 754</code> 标准规定了一个数字的存储位数只能是 <code>64</code> 位，有效位数是 <code>52</code> 位，所以将会对 <code>1100110011001100....</code> 这个无限数字进行舍入总共 <code>52</code> 位作为有效位，然后二进制的末尾取舍规则是看后一位数如果是 <code>1</code> 则进位，如果是 <code>0</code> 则直接舍去。那么由于 <code>1100110011001100....</code> 这串数字的第 <code>53</code> 位刚好是 <code>1</code> ，所以最终的会得到的数字是 <code>1100110011001100110011001100110011001100110011001101</code>，即<br><code>1.100110011001100110011001100110011001100110011001101</code> x $2^{-4}$。<br>十进制转二进制也可以用 <code>toString</code> 来进行转化:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">0.1</span>).toString(<span class="number">2</span>)) <span class="comment">// &#x27;0.0001100110011001100110011001100110011001100110011001101&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们发现十进制的 <code>0.1</code> 在转化成二进制小数的时候发生了精度的丢失，由于进位，它比真实的值更大了。而 <code>0.2</code> 其实也有这样的问题，也会发生精度的丢失，所以实际上 <code>0.1 + 0.2</code> 不会等于 <code>0.3</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>) <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure>

<p>那是不是没办法判断两个小数是否相等了呢？答案肯定是否定的，想要判断 2 个小数 <code>n1</code> 和 <code>n2</code> 是否相等可以如下操作：</p>
<ul>
<li><p>方法一：两小数之差的绝对值如果比 <code>Number.EPSILON</code> 还小，那么说明两数是相等的。</p>
<p><code>Number.EPSILON</code> 是 <code>ES6</code> 中的误差精度，实际值可以认为等于 $2^{-52}$。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.abs(n1 - n2) &lt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;n1 和 n2 相等&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：通过 <code>toFixed(n)</code> 对结果进行舍入，<code>toFixed()</code> 将会返回字符串，我们可以用 一元加 <code>+</code> 将其转成数字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="built_in">console</span>.log(+sum.toFixed(<span class="number">2</span>) === <span class="number">0.3</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数值的转化"><a href="#数值的转化" class="headerlink" title="数值的转化"></a>数值的转化</h3><p>对数字进行操作的时候将常常遇到数值的舍入和字符串转数字的问题，这里我们巩固下基础。先来看舍入的：</p>
<ul>
<li><p><code>Math.floor()</code>，向下舍入，得到一个整数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">2.2</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">2.8</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.ceil()</code>，向上舍入，得到一个整数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">2.2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">2.8</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.round()</code>，对第一位小数进行四舍五入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(<span class="number">2.26</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">2.46</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">2.5</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Number.prototype.toFixed(n)</code>，和 <code>Math.round()</code> 一样会进行四舍五入，将数字舍入到小数点后 <code>n</code> 位，并且以字符串的形式返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="number">12</span>).toFixed(<span class="number">2</span>) <span class="comment">// &#x27;12.00&#x27;</span></span><br><span class="line">;(<span class="number">12.14</span>).toFixed(<span class="number">1</span>) <span class="comment">// &#x27;12.1&#x27;</span></span><br><span class="line">;(<span class="number">12.15</span>).toFixed(<span class="number">1</span>) <span class="comment">// &#x27;12.2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为什么 <code>6.35.toFixed(1)</code> 会等于 <code>6.3</code> ？因为 <code>6.35</code> 其实是一个无限小数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="number">6.35</span>).toFixed(<span class="number">20</span>) <span class="comment">// &quot;6.34999999999999964473&quot;</span></span><br></pre></td></tr></table></figure>

<p>所以在 <code>6.35.toFixed(1)</code> 求值的时候会得到 <code>6.3</code>。</p>
</li>
</ul>
<p>再来看看字符串转数字的情况：</p>
<ul>
<li><p><code>Number(n)</code> 或 <code>+n</code>，直接将 <code>n</code> 进行严格转化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27; &#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;010&#x27;</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;010&#x27;</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;12a&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;12a&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parseInt()</code>，非严格转化，从左到右解析字符串，遇到非数字就停止解析，并且把解析的数字返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12a&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;a12&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xA&#x27;</span>) <span class="comment">// 10，0x开头的将会被当成十六进制数</span></span><br></pre></td></tr></table></figure>

<p><code>parseInt()</code> 默认是用十进制去解析字符串的，其实他是支持传入第二个参数的，表示要以多少进制的 基数去解析第一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1010&#x27;</span>, <span class="number">2</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>) <span class="comment">// 255</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如何判断一个数是不是整数？介绍两种方法：</p>
<ul>
<li><p>方法一：通过 <code>Number.isInteger()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">12.0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">12.2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：<code>typeof num == &#39;number&#39; &amp;&amp; num % 1 == 0</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInteger</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> num == <span class="string">&#x27;number&#x27;</span> &amp;&amp; num % <span class="number">1</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>除了原始类型外，还有一个特别重要的类型：引用类型。高程里这样描述他：引用类型是一种数据结构， 用于将数据和功能组织在一起。到目前为止，我们看到最多的引用类型就是 <code>Object</code>，创建一个 <code>Object</code> 有两种方式：</p>
<ul>
<li><p>方式一：通过 <code>new</code> 操作符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">person.age = <span class="number">20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：通过对象字面量，这是我们最喜欢用的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="内置的引用类型"><a href="#内置的引用类型" class="headerlink" title="内置的引用类型"></a>内置的引用类型</h3><p>除了 <code>Object</code> 外，在 <code>JavaScript</code> 中还有别的内置的引用类型，比如：</p>
<ul>
<li><code>Array</code> 数组</li>
<li><code>Date</code> 日期</li>
<li><code>RegExp</code> 正则表达式</li>
<li><code>Function</code> 函数</li>
</ul>
<p>他们的原型链的顶端都会指向 <code>Object</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">console</span>.log(d.__proto__.__proto__.constructor) <span class="comment">// ƒ Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>先来看一个问题，为什么原始类型的变量没有属性和方法，但是却能够调用方法呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">str.substring(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// &#x27;bub&#x27;</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>JavaScript</code> 为了更好地操作原始类型，设计出了几个对应的包装类型，他们分别是：</p>
<ul>
<li><code>Boolean</code></li>
<li><code>Number</code></li>
<li><code>String</code></li>
</ul>
<p>上面那串代码的执行过程其实是这样的：</p>
<ol>
<li>创建 String 类型的一个实例;</li>
<li>在实例上调用指定的方法;</li>
<li>销毁这个实例</li>
</ol>
<p>用代码体现一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line">str.substring(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">str = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>原始类型调用函数其实就是自动进行了装箱操作，将原始类型转成了包装类型，然后其实原始类型和包装类型是有本质区别的，原始类型是原始值，而包装类型是对象实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str1 === str2) <span class="comment">// fasle</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str1) <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str2) <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>

<p>居然有装箱操作，那肯定也有拆箱操作，所谓的拆箱就是包装类型转成原始类型的过程，又叫 <code>ToPromitive</code>，来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  toString: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(+obj) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj&#125;</span>`</span>) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在拆箱操作的时候，默认会尝试调用包装类型的 <code>toString()</code> 和 <code>valueOf()</code> 方法，对于不同的 <code>hint</code> 调用顺序会有所区别，如果 <code>hint</code> 是 <code>string</code> 则优先调用 <code>toString()</code>，否则的话，则优先调用 <code>valueOf()</code>。<br>默认情况下，一个 <code>Object</code> 对象具有 <code>toString()</code> 和 <code>valueOf()</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.valueOf()) <span class="comment">// &#123;&#125;，valueOf会返回对象本身</span></span><br></pre></td></tr></table></figure>

<h2 id="类型装换"><a href="#类型装换" class="headerlink" title="类型装换"></a>类型装换</h2><p><code>Javascript</code> 是弱类型的语音，所以对变量进行操作的时候经常会发生类型的转换，尤其是隐式类型转换，可能会让代码执行结果出乎意料之外，比如如下的代码你能理解其执行结果嘛？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;[] + &#123;&#125; <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">;+[] <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h3><p>所以我们需要知道类型转换的规则，以下整理出一个表格，列出了常见值和类型以及转换之后的结果，仅供参考。</p>
<table>
<thead>
<tr>
<th align="center">转换前的值</th>
<th align="center">转换前类型</th>
<th align="center">toBoolean</th>
<th align="center">toNumber</th>
<th align="center">toString</th>
</tr>
</thead>
<tbody><tr>
<td align="center">true</td>
<td align="center">Boolean</td>
<td align="center">-</td>
<td align="center">1</td>
<td align="center">“true”</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">Boolean</td>
<td align="center">-</td>
<td align="center">0</td>
<td align="center">“false”</td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">Null</td>
<td align="center">false</td>
<td align="center">0</td>
<td align="center">“null”</td>
</tr>
<tr>
<td align="center">undefined</td>
<td align="center">Undefined</td>
<td align="center">false</td>
<td align="center">NaN</td>
<td align="center">“undefined”</td>
</tr>
<tr>
<td align="center">123</td>
<td align="center">Number</td>
<td align="center">true</td>
<td align="center">-</td>
<td align="center">“123”</td>
</tr>
<tr>
<td align="center">Infinity</td>
<td align="center">Number</td>
<td align="center">true</td>
<td align="center">-</td>
<td align="center">“Infinity”</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">Number</td>
<td align="center">false</td>
<td align="center">-</td>
<td align="center">“0”</td>
</tr>
<tr>
<td align="center">NaN</td>
<td align="center">Number</td>
<td align="center">false</td>
<td align="center">-</td>
<td align="center">“NaN”</td>
</tr>
<tr>
<td align="center">“”</td>
<td align="center">String</td>
<td align="center">false</td>
<td align="center">0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">“ “</td>
<td align="center">String</td>
<td align="center">true</td>
<td align="center">0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">“0”</td>
<td align="center">String</td>
<td align="center">true</td>
<td align="center">0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">“123”</td>
<td align="center">String</td>
<td align="center">true</td>
<td align="center">123</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">“123abc”</td>
<td align="center">String</td>
<td align="center">true</td>
<td align="center">NaN</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">Symbol()</td>
<td align="center">Symbol</td>
<td align="center">true</td>
<td align="center">TypeError</td>
<td align="center">TypeError</td>
</tr>
<tr>
<td align="center">{}</td>
<td align="center">Object</td>
<td align="center">true</td>
<td align="center">NaN</td>
<td align="center">“[object Object]”</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">Object</td>
<td align="center">true</td>
<td align="center">0</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">[“0”]</td>
<td align="center">Object</td>
<td align="center">true</td>
<td align="center">0</td>
<td align="center">“0”</td>
</tr>
<tr>
<td align="center">[“0”, “a”]</td>
<td align="center">Object</td>
<td align="center">true</td>
<td align="center">NaN</td>
<td align="center">“0,a”</td>
</tr>
<tr>
<td align="center">[“0”, undefined, “a”]</td>
<td align="center">Object</td>
<td align="center">true</td>
<td align="center">Nan</td>
<td align="center">“0,,a”</td>
</tr>
</tbody></table>
<h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><p>我们平时写代码的时候应该尽量让写出来的代码通俗易懂，让别人能阅读后知道你是要做什么，所以在对类型进行判断的时候应该尽量显示的处理。<br>比如将字符串转成数字，可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;21&#x27;</span>) <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;21.8&#x27;</span>) + <span class="comment">// 21.8</span></span><br><span class="line">  <span class="string">&#x27;21&#x27;</span> <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<p>将数字显示转成字符串可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">21</span>) <span class="comment">// &#x27;21&#x27;</span></span><br><span class="line">;(<span class="number">21</span>).toString() <span class="comment">// &#x27;21&#x27;</span></span><br></pre></td></tr></table></figure>

<p>显示转成布尔类型可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;21&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&#x27;21&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>除了以上之外，还有一些关于类型转换的冷门操作，有时候也挺管用的：<br>直接用一元加操作符获取当前时间的毫秒数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;+<span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// 1595517982686</span></span><br></pre></td></tr></table></figure>

<p>用 <code>~</code> 配合 <code>indexOf()</code> 将操作结果直接转成布尔类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (~str.indexOf(<span class="string">&#x27;.com&#x27;</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;str如果包含了.com字符串，则会打印这句话&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>~~</code> 对字符或数字截取整数，和 <code>Math.floor()</code> 有稍许不同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="number">21.1</span> <span class="comment">// 21</span></span><br><span class="line">~~<span class="number">-21.9</span> <span class="comment">// -21</span></span><br><span class="line">~~<span class="string">&#x27;1.2a&#x27;</span> <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">21.1</span>) <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">-21.9</span>) <span class="comment">// -22</span></span><br></pre></td></tr></table></figure>

<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换发生在 <code>JavaScript</code> 的运行时，通常是由某些操作符或语句引起的，有下面这几种情况：</p>
<ul>
<li><p>隐式转成布尔类型：</p>
<ol>
<li><code>if (..)</code>语句中的条件判断表达式。</li>
<li><code>for ( .. ; .. ; .. )</code>语句中的条件判断表达式(第二个)。</li>
<li><code>while (..)</code> 和 <code>do..while(..)</code> 循环中的条件判断表达式。</li>
<li><code>? :</code>中的条件判断表达式。</li>
<li>逻辑运算符 <code>||</code> (逻辑或)和 <code>&amp;&amp;</code> (逻辑与)左边的操作数(作为条件判断表达式)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">42</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="string">&#x27;bubuzou&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">null</span> ? <span class="string">&#x27;存在&#x27;</span> : <span class="string">&#x27;不存在&#x27;</span> <span class="comment">// &#x27;不存在&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上例中的非布尔值会被隐式强制类型转换为布尔值以便执行条件判断。<br>需要特别注意的是 <code>||</code> 和 <code>&amp;&amp;</code> 操作符。<code>||</code> 的操作过程是只有当左边的值返回 <code>false</code> 的时候才会对右边进行求值且将它作为最后结果返回，类似 <code>a ? a : b</code> 这种效果:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;a&#x27;</span> || <span class="string">&#x27;b&#x27;</span> <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;c&#x27;</span> <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>而 <code>&amp;&amp;</code> 的操作过程是只有当左边的值返回 <code>true</code> 的时候才对右边进行求值且将右边的值作为结果返回，类似 <code>a ? b : a</code> 这种效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;a&#x27;</span> &amp;&amp; <span class="string">&#x27;b&#x27;</span> <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">&#x27;c&#x27;</span> <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数学操作符 <code>- * /</code> 会对非数字类型的会优先转成数字类型，但是对 <code>+</code> 操作符会比较特殊：</p>
<ol>
<li>当一侧为 <code>String</code> 类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li>
<li>当一侧为 <code>Number</code> 类型，另一侧为原始类型，则将原始类型转换为 <code>Number</code> 类型。</li>
<li>当一侧为 <code>Number</code> 类型，另一侧为引用类型，将引用类型和 <code>Number</code> 类型转换成字符串后拼接。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span> + <span class="string">&#x27;bubuzou&#x27;</span> <span class="comment">// &#x27;42bubuzou&#x27;</span></span><br><span class="line"><span class="number">42</span> + <span class="literal">null</span> <span class="comment">// 42</span></span><br><span class="line"><span class="number">42</span> + <span class="literal">true</span> <span class="comment">// 43</span></span><br><span class="line"><span class="number">42</span> + [] <span class="comment">// &#x27;42&#x27;</span></span><br><span class="line"><span class="number">42</span> + &#123;&#125; <span class="comment">// &#x27;42[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>宽松相等和严格相等<br>宽松相等（<code>==</code>）和严格相等（<code>===</code>）在面试的时候经常会被问到，而回答一般是 <code>==</code> 是判断值是否相等，而 <code>===</code> 除了判断值会不会相等之外还会判断类型是否相等，这个答案不完全正确，更好的回答是：<code>==</code> 在比较过程中允许发生隐式类型转换，而 <code>===</code> 不会。 那 <code>==</code> 是怎么进行类型转换的呢？</p>
<ol>
<li><p>数字和字符串比，字符串将转成数字进行比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> == <span class="string">&#x27;20&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">20</span> === <span class="string">&#x27;20&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>别的类型和布尔类型比较，布尔类型将首先转成数字进行比较，<code>true</code> 转成数字 <code>1</code>, <code>false</code> 转成数字 <code>0</code>，注意这个是非常容易出错的一个点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;bubuzou&#x27;</span> == <span class="literal">true</span>  <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>  <span class="comment">// false,</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>  <span class="comment">// false</span></span><br><span class="line">[] == <span class="literal">true</span>  <span class="comment">// false</span></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>]  == <span class="literal">true</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以写代码进行判断的时候一定不要写成 <code>x == true</code> 或 <code>x == false</code> 这种，而应该直接 <code>if (x)</code> 判断。</p>
</li>
<li><p><code>null</code> 和 <code>undefined</code>: <code>null == undefined</code> 比较结果是 <code>true</code>，除此之外，<code>null</code>、<code>undefined</code> 和其他任何结果的比较值都为 <code>false</code>。可以认为在 <code>==</code> 的情况下，<code>null</code> 和 <code>undefined</code> 可以相互的进行隐式类型转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原始类型和引用类型比较，引用类型会首先进行 <code>ToPromitive</code> 转成原始类型然后进行比较，规则参考上面介绍的拆箱操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;42&#x27;</span> == [<span class="number">42</span>] <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;1,2,3&#x27;</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;[object Object]&#x27;</span> == &#123;&#125; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == [<span class="literal">undefined</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>  <span class="comment">// false</span></span><br><span class="line">+<span class="number">0</span> == <span class="number">-0</span>  <span class="comment">// true</span></span><br><span class="line">[] == ![]  <span class="comment">// true，![]的优先级比==高，所以![]先转成布尔值变成false；即变成[] == false，false再转成数字0，[]转成数字0，所以[] == ![]</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;\n&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><h3 id="用-typeof-检测原始类型"><a href="#用-typeof-检测原始类型" class="headerlink" title="用 typeof 检测原始类型"></a>用 typeof 检测原始类型</h3><p><code>JavaScript</code> 中有 <code>null</code>、<code>undefined</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>Symbol</code> 等六种原始类型，我们可以用 <code>typeof</code> 来判断值是什么原始类型的，会返回类型的字符串表示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;42&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是原始类型中有一个例外，<code>typeof null</code> 会得到 ‘object’，所以我们用 <code>typeof</code> 对原始值进行类型判断的时候不能得到一个准确的答案，那如何判断一个值是不是 <code>null</code> 类型的呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="literal">null</span></span><br><span class="line">!o &amp;&amp; <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> <span class="comment">// 用于判断 o 是否是 null 类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>undefined</code> 和 <code>undeclared</code> 有什么区别？前者是表示在作用域中定义了但是没有赋值的变量，而后者是表示在作用域中没有定义的变量；分别表示 <code>undefined</code> 未定义、<code>undeclared</code> 未声明。</p>
</blockquote>
<p><code>typeof</code> 能够对原始类型进行判断，那是否也能判断引用类型呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>() <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>() <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从上面的结果我们可以得到这样一个结论： <code>typeof</code> 对引用类型判断的时候只有 <code>function</code> 类型可以正确判断，其他都无法正确判断具体是什么引用类型。</p>
<h3 id="用-instanceof-检测引用类型"><a href="#用-instanceof-检测引用类型" class="headerlink" title="用 instanceof 检测引用类型"></a>用 instanceof 检测引用类型</h3><p>我们知道 <code>typeof</code> 只能对部分原始类型进行检测，对引用类型毫无办法。<code>JavaScript</code> 提供了一个操作符 <code>instanceof</code>，我们来看下他是否能检测引用类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>  <span class="comment">// true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们发现数组即是 <code>Array</code> 的实例，也是 <code>Object</code> 的实例，因为所以引用类型原型链的终点都是 <code>Object</code>，所以 <code>Array</code> 自然是 <code>Object</code> 的实例。那么我们得出结论：<code>instanceof</code> 用于检测引用类型好像也不是很靠谱的选择。</p>
<h3 id="用-toString-进行类型检测"><a href="#用-toString-进行类型检测" class="headerlink" title="用 toString 进行类型检测"></a>用 toString 进行类型检测</h3><p>我们可以使用 <code>Object.prototype.toString.call()</code> 来检测任何变量值的类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) <span class="comment">// &#x27;[object Boolean]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// &#x27;[object Undefined]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// &#x27;[object Null]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">20</span>) <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;bubuzou&#x27;</span>) <span class="comment">// &#x27;[object String]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()) <span class="comment">// &#x27;[object Symbol]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) <span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// &#x27;[object Function]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// &#x27;[object Date]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) <span class="comment">// &#x27;[object RegExp]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>) <span class="comment">// &#x27;[object JSON]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(MATH) <span class="comment">// &#x27;[object MATH]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>)(</span><br><span class="line">  <span class="comment">// &#x27;[object Window]&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>) <span class="comment">// &#x27;[object Arguments]&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">)()</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cec1bcff265da1b8f1aa08f">【JS 进阶】你真的掌握变量和类型了吗</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26854244/">你不知道的 JS 中卷-第四章</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5d116a9df265da1bb47d717b">JS 中的栈内存堆内存</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li>
</ul>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2020/08/06/wepy2/" title="小程序升级WePY2踩坑记" class="prev">PREV</a><a href="/2020/03/26/nvm/" title="使用nvm来管理Node版本" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2024 <a href="https://weibo.com/316000381" target="_blank">typeR</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>