<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> 详细设计一个文章页目录插件 · 步步走</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="详细设计一个文章页目录插件"><meta name="keywords" content="详细设计一个文章页目录插件"><meta name="author" content="typeR"><link rel="short icon" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/favicon.ico"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://bubuzou.com/atom.xml" title="步步走"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="步步走" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/read/" target="_self" data-hover="读书" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">详细设计一个文章页目录插件</h1><div class="post-info">2020-10-14<p class="visit"><i data-identity="2020/10/14/article-catalog/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><p>在说这个插件之前，可以先去 <a href="https://bubuzou.com/2020/09/21/vue-operate/">https://bubuzou.com/</a> 这个网站体验下这个插件的效果，好有个大概的印象。</p>
<p>通过阅读这篇文章，你可以收获什么？</p>
<ol>
<li>用 <code>JS</code> 直接操作 <code>DOM</code></li>
<li>浏览器 <code>BOM</code> 相关知识</li>
<li>性能优化思考</li>
<li>插件设计思考</li>
</ol>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>平时我们在用 <code>Markdown</code> 写的文章，如果放到自己的博客或者投稿到掘金等平台，其内容会被浏览器解析成 <code>HTML</code>。而 <code>Markdown</code> 里面的一级（#）、二级（##）、三级标题（###）分别对应于页面的文章标题、一级目录、二级目录。基于此，就可以很好的利用该生成的页面实现一个目录，便于更直观方便的的浏览文章内容，而这就是最初我想为博客里的文章页实现一个目录功能的理由。</p>
<blockquote>
<p>这个插件是基于 <code>Hexo</code> 生成的网页来实现的，且目前只支持一级和二级目录，因为作为一篇文章来说有两个层级已经可以很好的将一块内容划分细说得很清楚了。</p>
</blockquote>
<a id="more"></a>

<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/catalog.png"></p>
<p>首先我打算将文章的目录放置在文章内容的右侧，且是悬浮固定在那里不随浏览器的滚动而滚动。因为我们都习惯从上到下从左到右的去浏览文章，所以我希望首先映入眼帘的是文章内容而不是文章目录；另外因为我的博客的首页和文章列表页都是左侧是浏览区域而右侧是操作区域，所以把目录放到右侧能保持整站的布局统一以及操作的便利性。</p>
<h3 id="需要做什么"><a href="#需要做什么" class="headerlink" title="需要做什么"></a>需要做什么</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/highlight.png"></p>
<ol>
<li>首先需要根据文章内容的二级和三级标题生成目录；</li>
<li>然后，页面从上到下滚动过程中，需要在右侧目录里高亮当前的标题，而高亮的原则是当前标题所在的位置到浏览器可视区域顶部的距离需要小于或等于一个固定值，如上图所示；</li>
<li>在合适的时候滚动目录列表，使得当前高亮的子目录会出现在滚动区域内部，且尽量处于滚动区域的中间区域；</li>
<li>当点击某个子目录的时候需要高亮当前点击的目录，且文章内容滚动到对应目录的位置，使得点击目录对应的文章标题所在的位置距离可视区域顶部的距离刚好等于一个固定值。</li>
</ol>
<h3 id="滚动目录的机制是怎样的"><a href="#滚动目录的机制是怎样的" class="headerlink" title="滚动目录的机制是怎样的"></a>滚动目录的机制是怎样的</h3><p>对于的第三点提到在合适的时候滚动目录，那什么时候才算合适呢？目录能不能滚动，以及怎么滚动总共分为以下 5 种情况：</p>
<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_top.png"></p>
<ol>
<li>当目录能在滚动区域完全显示的时候，即滚动区域高度大于所有目录子项高度总和的时候，不进行目录滚动，如上面的图 ① ；</li>
<li>当目录不能在滚动区域完全显示的时候，目录需要滚动。所以需要做的就是在一个划定的区域内滚动目录，超出该区域的目录子项将会自动隐藏。通过滚动目录，我们可以实现目录列表的头尾两个目录子项都能很好的在划定区域里显示出来。随着页面的滚动，目录将从头滚到尾，那么滚动的范围是从第一个子目录贴着滚动区域的顶部到最后一个子目录贴着滚动区域的底部为止；</li>
<li>当页面在最顶部的时候，当前高亮的子目录肯定是第一个，随着页面的向下滚动，高亮的位置也在不断下移，当高亮位置移动到在目录滚动区域的上半部分之前，这段不进行目录滚动，如上面的图 ② 到 图 ③ 的变化过程；</li>
<li>当第一个子目录贴着滚动区域的顶部，且高亮位置在中位往下继续滚动的时候，需要进行目录滚动，滚动的距离是当前高亮目录所在位置距离滚动区域中间位置的高度差，如上面的图 ③ 到图 ④ 的变化过程；</li>
<li>如果这个高度差过于大，使得滚动后最后一个子元素不能贴着滚动区域底部的时候，则不按照这个高度差进行滚动，而真实需要滚动的距离是最后一个子目录到滚动区域底部的距离，如上面的图 ④ 到图 ⑤ 的变化过程。</li>
</ol>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>由于文章页是由 <code>Hexo</code> 基于 <code>Markdown</code> 生成而来的，所以它有自己特定的 <code>HTML</code> 格式，它的格式大概是如下这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;7种组件通信方式随你选&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;headerlink&quot;</span> <span class="attr">title</span>=<span class="string">&quot;7种组件通信方式随你选&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    7种组件通信方式随你选</span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是部分文章内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;props-on-emit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;headerlink&quot;</span> <span class="attr">title</span>=<span class="string">&quot;props/@on+$emit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    props/@on+$emit</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是部分文章内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;$attrs和$listeners&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;headerlink&quot;</span> <span class="attr">title</span>=<span class="string">&quot;$attrs和$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    $attrs和$listeners</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是部分文章内容 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到所有的二级标题（H2）和三级标题（H3）都是在同一个父元素下面，且每个标题下面都包含了一个带有 <code>headerlink</code> 类名的链接，另外还有标题属性。</p>
<p>这个时候我们就能很容易的获取到所有的标题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arContentAnchor = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.headerlink&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这串代码的结果会返回一个 <code>NodeList</code>，有了它我们就可以去生成目录了。</p>
<h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/catalog_show.png"></p>
<p>生成目录无非就是产生一串 <code>HTML</code>，除此之外还有哪些要做的呢？<br>首先要确定下，目录都包含了哪些部分，如上图所示这里大概是包含了 3 部分：目录条、序号和标题。那么就可以先确定好 <code>HTML</code> 结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-body&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-tack1 on&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-index&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>7种组件通信方式随你选<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-dot&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>arCatalog-line</code> 表示目录条，<code>arCatalog-body</code> 是滚动区域，<code>dl</code> 是滚动列表，<code>dd</code> 是目录子项，<code>arCatalog-index</code> 是目录序号，链接里放的是子目录标题。有了 <code>HTML</code> ，接下来要做的就是把目录的样式写好，写完后样式比较多，所以就不在这里贴出来了。</p>
<p>生成目录到这里就完事了吗？并没有，由于浏览器可视区域是不固定的，所以我们需要计算出目录所在滚动区域的高度。</p>
<p>滚动高度 = n个目录子项 * 子项的实际高度</p>
<p>先说子项的实际高度，对于目录子项的样式上，我这里没有用内间距和外边距，而是通过 <code>line-height</code> 来控制他们之间的间隙，那么：</p>
<p>子项的实际高度 = 子项的行高</p>
<p>再说 <code>n</code> 个目录子项，那到底 <code>n</code> 是多少呢？在目录的 <code>Y</code> 轴方向上，除了有目录，还有顶部的菜单，以及为了美观还需要适当的留白，所以：</p>
<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_height.png"></p>
<p>n = (视口高度 - （顶部菜单高度 + 留白高度））/ 子项行高</p>
<p>所以，最终我们可以计算出滚动高度：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> DEFAULT = &#123;</span><br><span class="line">    lineHeight: <span class="number">28</span>,           <span class="comment">// 每个菜单的行高是 28</span></span><br><span class="line">    moreHeight: <span class="number">10</span>,           <span class="comment">// 菜单左侧的线比菜单多出的高度</span></span><br><span class="line">    surplusHeight: <span class="number">180</span>,       <span class="comment">// 除了菜单高度+留白高度</span></span><br><span class="line">    delay: <span class="number">200</span>,               <span class="comment">// 防抖的延迟时间</span></span><br><span class="line">    duration: <span class="number">200</span>,            <span class="comment">// 滚动的动画持续时间</span></span><br><span class="line">    toTopDistance: <span class="number">80</span>,        <span class="comment">// 距离视口顶部多少高度之内时候触发高亮</span></span><br><span class="line">    selector: <span class="string">&#x27;.headerlink&#x27;</span>,  <span class="comment">// 文章内容中标题标签的 selector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxCatalogCount 就是上面提到的 n 个目录子项中的 n</span></span><br><span class="line"><span class="keyword">let</span> maxCatalogCount = <span class="built_in">Math</span>.floor((<span class="built_in">window</span>.innerHeight - DEFAULT.surplusHeight) / DEFAULT.lineHeight)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动区域高度</span></span><br><span class="line"><span class="keyword">let</span> catalogHeight = arContentAnchor.length &gt; maxCatalogCount ? maxCatalogCount * DEFAULT.lineHeight : arContentAnchor.length * DEFAULT.lineHeight;</span><br></pre></td></tr></table></figure>

<p>完整的生成目录的函数代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成目录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateCatalog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> catalogHeight = arContentAnchor.length &gt; maxCatalogCount ? maxCatalogCount * DEFAULT.lineHeight : arContentAnchor.length * DEFAULT.lineHeight;</span><br><span class="line">    <span class="keyword">let</span> retStr = <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;arCatalog&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;arCatalog-line&quot; </span></span><br><span class="line"><span class="string">        style=&quot;height: <span class="subst">$&#123;catalogHeight + DEFAULT.moreHeight&#125;</span>px&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;arCatalog-body&quot; </span></span><br><span class="line"><span class="string">        style=&quot;max-height: <span class="subst">$&#123;catalogHeight&#125;</span>px; height: <span class="subst">$&#123;catalogHeight&#125;</span>px&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;dl style=&quot;margin-top: <span class="subst">$&#123;marginTop&#125;</span>px&quot;&gt;`</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> h2Index = <span class="number">0</span>,</span><br><span class="line">        h3Index = <span class="number">1</span>,</span><br><span class="line">        acIndex = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        tagName = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> currNode <span class="keyword">of</span> arContentAnchor) &#123;</span><br><span class="line">        tagName = currNode.parentElement.tagName</span><br><span class="line">        <span class="keyword">if</span> ( tagName === <span class="string">&#x27;H3&#x27;</span> ) &#123;</span><br><span class="line">            acIndex = <span class="string">`<span class="subst">$&#123;h2Index&#125;</span>.<span class="subst">$&#123;h3Index++&#125;</span>`</span></span><br><span class="line">            className = <span class="string">&#x27;arCatalog-tack2&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            acIndex = ++h2Index</span><br><span class="line">            h3Index = <span class="number">1</span></span><br><span class="line">            className = <span class="string">&#x27;arCatalog-tack1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        retStr += <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;dd class=&quot;<span class="subst">$&#123;className&#125;</span> <span class="subst">$&#123;index++ === lastOnIndex ? <span class="string">&#x27;on&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;span class=&quot;arCatalog-index&quot;&gt;<span class="subst">$&#123;acIndex&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">            &lt;a href=&quot;#&quot;&gt;<span class="subst">$&#123;currNode.title&#125;</span>&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;span class=&quot;arCatalog-dot&quot;&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">            &lt;/dd&gt;`</span></span><br><span class="line">    &#125;;</span><br><span class="line">    retStr += <span class="string">`&lt;/dl&gt;&lt;/div&gt;&lt;/div&gt;`</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;arAnchorBar&#x27;</span>).innerHTML = retStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置滚动监听事件"><a href="#设置滚动监听事件" class="headerlink" title="设置滚动监听事件"></a>设置滚动监听事件</h3><p>给 <code>window</code> 加上滚动事件，用于监听当滚动的时候去做一些操作，这里的操作就是设置高亮和滚动目录。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setHighlight()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有目录总数超过滚动区域可容纳最大目录数的时候，目录才需要滚动</span></span><br><span class="line"><span class="keyword">if</span> (catalogLength &gt; maxCatalogCount) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        scrollCatalog()</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上这样就能监听浏览器滚动事件，从而做一些事情啦。但是这样会导致函数被频繁调用，从而存在性能问题，其实我们更希望当滚动开始到滚动结束的时候，只执行一次函数即可，那这个直接上防抖即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖：触发高频事件 n 秒后只会执行一次，如果 n 秒内事件再次触发，则会重新计时。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(fn.id)</span><br><span class="line">        fn.id = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply(_this, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们只需要把 <code>scroll</code> 监听回调里的函数对应换成如下的即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    debounce(setHighlight, DEFAULT.delay)()</span><br><span class="line">    debounce(resetStatus, DEFAULT.delay)()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (catalogLength &gt; maxCatalogCount) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        debounce(scrollCatalog, DEFAULT.delay)()</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高亮当前目录"><a href="#高亮当前目录" class="headerlink" title="高亮当前目录"></a>高亮当前目录</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bcr.png"></p>
<p>这部分内容开始前，我们先来复习一个 <code>API</code>，该方法会返回元素的大小及其相对于视口的位置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getBoundingClientRect()</span><br></pre></td></tr></table></figure>

<p>需求分析的时候有提到，高亮的原则是当前标题所在的位置到浏览器可视区域顶部的距离需要小于或等于一个固定值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arContentAnchor[index].getBoundingClientRect().top &lt;= DEFAULT.toTopDistance</span><br></pre></td></tr></table></figure>

<p>所以当遍历 <code>arContentAnchor</code> 这个列表，某项的位置小于固定值，且差值最小的时候，该项对应的目录就应该被设置为高亮：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curr = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>)</span><br><span class="line">curr.classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextOnIndex = <span class="number">0</span>,</span><br><span class="line">    currNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nextOnIndex &lt; arContentAnchor.length) &#123;</span><br><span class="line">    currNode = arContentAnchor[nextOnIndex]</span><br><span class="line">    <span class="keyword">if</span> (currNode.getBoundingClientRect().top &lt;= DEFAULT.toTopDistance) &#123;</span><br><span class="line">        nextOnIndex++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">nextOnIndex = nextOnIndex === arContentAnchor.length ? nextOnIndex - <span class="number">1</span> : nextOnIndex;</span><br><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>)</span><br><span class="line">catalogDd[nextOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>到此一切都看起来很美好，但是上面这段代码存在性能问题，只要页面一滚动就会从第一个目录到最后一个目录之间进行查找，知道找到那个符合要求的为止，这样的话遍历次数太多了。</p>
<p>我们知道页面滚动无非就是在当前这个位置的前提下，往上滚动或者向下滚动，如果我们把 <code>nextOnIndex</code> 记为滚动前的索引，在根据滚动方向进行加加减减不就可以很好的减少遍历次数嘛？想法貌似不错，来试一下。</p>
<p>首先我们要判断当前滚动是向上还是向下滚动，可以根据两次滚动前后的偏移量来判断：</p>
<p>向上滚动 = 滚动后偏移量 &lt; 滚动前偏移量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastSH = <span class="built_in">window</span>.pageYOffset</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最近一次页面的滚动方向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollDirection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sh = <span class="built_in">window</span>.pageYOffset, ret = <span class="string">&#x27;bottom&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (sh &lt; lastSH) &#123;</span><br><span class="line">        ret = <span class="string">&#x27;top&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    lastSH = sh</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道了滚动方向，我们就可以很好的写出设置高亮的优化代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curr = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> nextOnIndex = onIndex;</span><br><span class="line"><span class="keyword">if</span> (defaultDirec === <span class="string">&#x27;bottom&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextOnIndex &lt; catalogLength) &#123;</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">        <span class="keyword">if</span> ( currTop &gt; DEFAULT.toTopDistance &amp;&amp; nextOnIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nextOnIndex--</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        nextOnIndex++</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextOnIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">        <span class="keyword">if</span> ( currTop &lt;= DEFAULT.toTopDistance)&#123;</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        nextOnIndex--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">nextOnIndex = nextOnIndex === arContentAnchor.length ? nextOnIndex - <span class="number">1</span> : nextOnIndex &lt; <span class="number">0</span> ? <span class="number">0</span> : nextOnIndex </span><br><span class="line">catalogDd[nextOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>优化后的遍历次数明显减少，而且遍历次数基本上是小于或等于滚动前后目录索引的差值。<br>虽然经过优化后，已经明显的减少了遍历次数，但是我还想再优化一下。纳尼？</p>
<p>很多文章页很长，所以有回到顶部这种功能，试想一下，如果当前页面已经滚动到最底部，这个时候来一下回到顶部，那刚刚写的优化代码会遍历几次？答案是：遍历次数将会是目录子项的总数。文章最开始提到的那个体验地址的那篇文章 <a href="https://bubuzou.com/2020/09/21/vue-operate/">34条我能告诉你的Vue之实操篇</a> 有 43 个子目录，所以需要遍历 43 次，真的不能接受结果，所以再来优化一次。</p>
<p>二次优化主要是处理边际问题，即滚动到头尾部的时候加上判断，最终二次优化后的高亮当前目录函数如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高亮当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHighlight</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    defaultDirec = getScrollDirection()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hasStopSetHighlight) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">        scrollTop,</span><br><span class="line">    &#125; = <span class="built_in">document</span>.scrollingElement;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> curr = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> onIndex = [].indexOf.call(catalogDd, curr),  <span class="comment">// 当前高亮索引</span></span><br><span class="line">        nextOnIndex = onIndex;  <span class="comment">// 滚动后高亮索引</span></span><br><span class="line">        </span><br><span class="line">    curr.classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> scrollHeight = <span class="built_in">document</span>.documentElement.scrollHeight || <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">    <span class="keyword">if</span> (arContentAnchor[catalogLength - <span class="number">1</span>].getBoundingClientRect().top &lt;= DEFAULT.toTopDistance || </span><br><span class="line">        <span class="built_in">window</span>.innerHeight + <span class="built_in">window</span>.pageYOffset === scrollHeight) &#123;  <span class="comment">// 尾部</span></span><br><span class="line">        lastOnIndex = catalogLength - <span class="number">1</span></span><br><span class="line">        catalogDd[lastOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scrollTop &lt;= firstDdTop) &#123;  <span class="comment">// 顶部</span></span><br><span class="line">        catalogDd[<span class="number">0</span>].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">        lastOnIndex = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 中间：使用缓存，直接从上一次索引（onIndex）位置开始查找</span></span><br><span class="line">        <span class="keyword">if</span> (defaultDirec === <span class="string">&#x27;bottom&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nextOnIndex &lt; catalogLength) &#123;</span><br><span class="line">                <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">                <span class="keyword">if</span> ( currTop &gt; DEFAULT.toTopDistance &amp;&amp; nextOnIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    nextOnIndex--</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                nextOnIndex++</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (nextOnIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">                <span class="keyword">if</span> ( currTop &lt;= DEFAULT.toTopDistance)&#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                nextOnIndex--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nextOnIndex = nextOnIndex === catalogLength ? nextOnIndex - <span class="number">1</span> : nextOnIndex &lt; <span class="number">0</span> ? <span class="number">0</span> : nextOnIndex </span><br><span class="line">        lastOnIndex = nextOnIndex</span><br><span class="line">        catalogDd[nextOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滚动目录"><a href="#滚动目录" class="headerlink" title="滚动目录"></a>滚动目录</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_to_bottom.png"></p>
<p>根据之前需求分析里的说明，我们可以知道当浏览器向下滚动的时候，会分成 3 种情况：</p>
<ol>
<li>滚动后的高亮子目录处于于滚动区域上半部分，即中位线以上，此时目录不进行滚动，如上图 ①；</li>
<li>滚动后的高亮子目录处于滚动区域的下半部分，即中位线以下，此时目录的滚动距离将是滚动后高亮子目录的底部位置到中位线的高度差，如上图 ②；</li>
<li>滚动后的高亮目录处于中位线以下且最后一个子目录需要贴着滚动区域底部，此时目录的滚动距离将是滚动列表底部到滚动区域底部的高度差，如上图 ③。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catalogBody = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog-body&#x27;</span>),</span><br><span class="line">    initBodyTop = catalogBody..getBoundingClientRect().top,</span><br><span class="line">    bodyMidBottom = initBodyTop + <span class="built_in">Math</span>.ceil((maxCatalogCount / <span class="number">2</span> )) * DEFAULT.lineHeight;  <span class="comment">// 中位线位置</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (curr.bottom + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= bodyBCR.bottom) &#123;  <span class="comment">// 上半部分</span></span><br><span class="line">    <span class="comment">// 不滚动</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.bottom - bodyMidBottom &lt; list.bottom - bodyBCR.bottom) &#123;  <span class="comment">// 中位以下</span></span><br><span class="line">    marginTop += -<span class="built_in">Math</span>.floor((curr.bottom - bodyMidBottom ) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyBCR.bottom &lt;= list.bottom) &#123;  <span class="comment">// 当剩余滚动距离</span></span><br><span class="line">    marginTop = bodyBCR.bottom - initDlBottom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，当浏览器向上滚动的时候，也能很好的得出其滚动逻辑：</p>
<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_to_top.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bodyBCR.top + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= curr.top) &#123;</span><br><span class="line">    <span class="comment">// 不滚动</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyMidBottom - curr.top &lt; bodyBCR.top - list.top) &#123;</span><br><span class="line">    marginTop += <span class="built_in">Math</span>.floor((bodyMidBottom - curr.top) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.top &lt;= bodyBCR.top) &#123;</span><br><span class="line">    marginTop = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的滚动目录函数完整代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动滚动目录树，使得当前高亮目录在可视范围内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollCatalog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentCatalog = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> curr = currentCatalog.getBoundingClientRect(),</span><br><span class="line">        list = catalogDl.getBoundingClientRect();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (defaultDirec === <span class="string">&#x27;bottom&#x27;</span>) &#123;  <span class="comment">// 向下滚动</span></span><br><span class="line">        <span class="keyword">if</span> (curr.bottom + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= bodyBCR.bottom) &#123;  <span class="comment">// 上半部分</span></span><br><span class="line">            <span class="comment">// 不滚动</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.bottom - bodyMidBottom &lt; list.bottom - bodyBCR.bottom)&#123;  <span class="comment">// 中位以下</span></span><br><span class="line">            marginTop += -<span class="built_in">Math</span>.floor((curr.bottom - bodyMidBottom ) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyBCR.bottom &lt;= list.bottom) &#123;  <span class="comment">// 当剩余滚动距离</span></span><br><span class="line">            marginTop = bodyBCR.bottom - initDlBottom</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 向上滚动</span></span><br><span class="line">        <span class="keyword">if</span> (bodyBCR.top + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= curr.top) &#123;</span><br><span class="line">            <span class="comment">// 不滚动</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyMidBottom - curr.top &lt; bodyBCR.top - list.top) &#123;</span><br><span class="line">            marginTop += <span class="built_in">Math</span>.floor((bodyMidBottom - curr.top) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.top &lt;= bodyBCR.top) &#123;</span><br><span class="line">            marginTop = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catalogDl.style.marginTop = marginTop + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子目录点击事件"><a href="#子目录点击事件" class="headerlink" title="子目录点击事件"></a>子目录点击事件</h3><p>当点击子目录的时候需要做 2 件事情，第一是滚动页面到对应的目录位置，然后是高亮当前点击的目录；</p>
<p>滚动页面到对应的目录位置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给目录子项绑定事件</span></span><br><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">    curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollTop = <span class="built_in">document</span>.body.scrollTop = currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样实现页面的滚动是没什么问题，就是体验不太好，突然从一个位置滚动到另外一个位置，显得突兀，能不能来点动画效果？类似 <code>jQuery</code> 的 <code>animate()</code> ？没问题，我们来尝试着实现一下。</p>
<p>用 <code>JS</code> 实现动画效果，一定离不开定时器，诸如 <code>setTimeout</code>、<code>setInterval</code> 之类，但是这次我不打算用他们，而是用 <code>HTML5</code> 中增加的 <code>requestAnimationFrame</code>，这是一个专门为浏览器实现动画而提供的 <code>API</code>。它虽然也是个定时器，但是相比于另外两个，他不需要传递时间，因为传递的回调函数里自带了参数 <code>DOMHighResTimeStamp</code>，这个参数表示回调函数被触发的时间。</p>
<p>除此之外，<code>requestAnimationFrame</code> 中的回调函数执行次数通常是每秒60次，即大概每 16.6 毫秒执行一次回调函数，但在大多数遵循 <code>W3C</code> 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。好了，对于 <code>requestAnimationFrame</code> 的介绍就到这里，下面我们直接来说下动画实现滚动的核心原理：</p>
<p>每次滚动距离 = ( 滚动距离 / 动画持续时间 ) * 每次动画执行时间距离第一次执行时间的差值 + 当前滚动距离</p>
<p>直接来看完整的动画实现滚动的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动到目标位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollToDest</span>(<span class="params">destScrollTop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> startTime;   </span><br><span class="line">    <span class="keyword">let</span> currScrollTop = <span class="built_in">window</span>.pageYOffset;</span><br><span class="line">    <span class="keyword">let</span> duration = <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!startTime) &#123;</span><br><span class="line">            startTime = timestamp</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> elapsed = <span class="built_in">Math</span>.round(timestamp - startTime)</span><br><span class="line">        <span class="keyword">const</span> distance = elapsed * ((<span class="built_in">Math</span>.floor(destScrollTop) - currScrollTop) / duration) + currScrollTop</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollTop = <span class="built_in">document</span>.body.scrollTop = distance</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (elapsed &lt; duration) &#123;</span><br><span class="line">            <span class="built_in">window</span>.requestAnimationFrame(step)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在有了动画函数，我们需要改写下子目录的点击事件，给滚动加上过渡效果，让人体验起来更加舒服：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>);</span><br><span class="line"></span><br><span class="line">catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">    curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">        scrollToDest(currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第一件事已经做好，接下来做第二件事，高亮当前点击某个子目录：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给目录子项绑定事件</span></span><br><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>);</span><br><span class="line"></span><br><span class="line">catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">    curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        hasStopSetHighlight = <span class="literal">true</span></span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>).classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">        catalogDd[index].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">        lastOnIndex = index</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">        scrollToDest(currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如上即可，但是由于点击了某个子目录，页面会进行滚动，而页面滚动又会触发 <code>setHighlight</code> 函数对目录进行高亮，所以我这里的做法是用了一个全局变量 <code>hasStopSetHighlight</code> 用来控制当点击子目录的时候，不进行 <code>setHighlight</code> 设置高亮操作。</p>
<h3 id="浏览器视口高度变了怎么办"><a href="#浏览器视口高度变了怎么办" class="headerlink" title="浏览器视口高度变了怎么办"></a>浏览器视口高度变了怎么办</h3><p>因为我们的滚动高度是根据浏览器视口高度计算出来的，如果浏览器视口高度变化了，那这个时候再去滚动页面，那肯定会出问题的。所以需要做的就是把和视口高度有关的逻辑抽离出来，统一放到一个函数里，当监听到视口高度变化的时候，再去执行这个函数。</p>
<p>先来写监听函数，同样用上了防抖函数处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    debounce(initCatalog, DEFAULT.delay)()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>然后去把相关逻辑抽离出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCatalog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tempHeight = <span class="built_in">window</span>.innerHeight</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (viewPortHeight !== tempHeight) &#123;</span><br><span class="line">        viewPortHeight = tempHeight</span><br><span class="line">        maxCatalogCount = <span class="built_in">Math</span>.floor((viewPortHeight - DEFAULT.surplusHeight) / DEFAULT.lineHeight)</span><br><span class="line">        </span><br><span class="line">        generateCatalog()</span><br><span class="line">        </span><br><span class="line">        catalogLength = arContentAnchor.length</span><br><span class="line">        lastSH = <span class="built_in">window</span>.pageYOffset</span><br><span class="line">        catalogBody = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog-body&#x27;</span>)</span><br><span class="line">        catalogDl = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog dl&#x27;</span>)</span><br><span class="line">        catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>)</span><br><span class="line">        bodyBCR = catalogBody.getBoundingClientRect()</span><br><span class="line">        initBodyTop = bodyBCR.top</span><br><span class="line">        initDlBottom = initDlBottom || catalogDl.getBoundingClientRect().bottom</span><br><span class="line">        firstDdTop = firstDdTop || catalogDd[<span class="number">0</span>].getBoundingClientRect().top,</span><br><span class="line">        bodyMidBottom = initBodyTop + <span class="built_in">Math</span>.ceil((maxCatalogCount / <span class="number">2</span> )) * DEFAULT.lineHeight;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给目录子项绑定事件</span></span><br><span class="line">        catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">            curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                e.preventDefault()</span><br><span class="line">                hasStopSetHighlight = <span class="literal">true</span></span><br><span class="line">                <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>).classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">                catalogDd[index].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">                lastOnIndex = index</span><br><span class="line">                <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">                scrollToDest(currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance)</span><br><span class="line">            &#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器视口高度变化后，这里有个细节需要提一下，那就是滚动目录的 <code>margin-top</code> 以及高亮位置是希望变化的，所以我们需要使用全局变量进行提前保存起来，分别用到的全局变量是 <code>marginTop</code> 和 <code>lastOnIndex</code>。</p>
<h3 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h3><p>上面的代码都是把不同的功能点提取到函数里进行操作，看起来比较散乱，所以我们需要看看一个完整的目录插件应该是什么样子？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * articleCatalog v2.0</span></span><br><span class="line"><span class="comment"> * Copyright(c) 2016 by bulandent</span></span><br><span class="line"><span class="comment"> * Date: 2017-5-27 16:10:41</span></span><br><span class="line"><span class="comment"> * Updated: 2020-10-10 17:40:04</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> articleCatalog = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.headerlink&#x27;</span>).length === <span class="number">0</span> || <span class="built_in">window</span>.innerWidth &lt; <span class="number">900</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> DEFAULT = &#123;</span><br><span class="line">        lineHeight: <span class="number">28</span>,           <span class="comment">// 每个菜单的行高是 28</span></span><br><span class="line">        moreHeight: <span class="number">10</span>,           <span class="comment">// 菜单左侧的线比菜单多出的高度</span></span><br><span class="line">        surplusHeight: <span class="number">180</span>,       <span class="comment">// 除了菜单高度+留白高度</span></span><br><span class="line">        delay: <span class="number">200</span>,               <span class="comment">// 防抖的延迟时间</span></span><br><span class="line">        duration: <span class="number">200</span>,            <span class="comment">// 滚动的动画持续时间</span></span><br><span class="line">        toTopDistance: <span class="number">80</span>,        <span class="comment">// 距离视口顶部多少高度之内时候触发高亮</span></span><br><span class="line">        selector: <span class="string">&#x27;.headerlink&#x27;</span>,  <span class="comment">// 文章内容中标题标签的 selector</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        DEFAULT = <span class="built_in">Object</span>.assign(DEFAULT, args)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> arContentAnchor = <span class="built_in">document</span>.querySelectorAll(DEFAULT.selector),</span><br><span class="line">            catalogLength = arContentAnchor.length,</span><br><span class="line">            maxCatalogCount = <span class="number">0</span>,          <span class="comment">// 视口内能容纳的最大目录个数</span></span><br><span class="line">            viewPortHeight = <span class="number">0</span>,           <span class="comment">// 当前视口的高度</span></span><br><span class="line">            marginTop = <span class="number">0</span>,                <span class="comment">// 菜单的初始滚动距离</span></span><br><span class="line">            defaultDirec = <span class="string">&#x27;bottom&#x27;</span>,      <span class="comment">// 默认滚动方向</span></span><br><span class="line">            lastSH = <span class="number">0</span>,                   <span class="comment">// 获取页面初始滚动距离</span></span><br><span class="line">            lastOnIndex = <span class="number">0</span>,              <span class="comment">// 上次高亮的目录索引</span></span><br><span class="line">            catalogBody = [],             <span class="comment">// .arCatalog-body</span></span><br><span class="line">            catalogDl = <span class="literal">null</span>,             <span class="comment">// .arCatalog-body dl</span></span><br><span class="line">            catalogDd = [],                 <span class="comment">// .arCatalog-body dd</span></span><br><span class="line">            initBodyTop = <span class="number">0</span>,              <span class="comment">// 目录可视区域的 top</span></span><br><span class="line">            initDlBottom = <span class="number">0</span>,             <span class="comment">// 目录 dl 的 bottom</span></span><br><span class="line">            firstDdTop = <span class="number">0</span>,               <span class="comment">// 第一个 dd 的 top</span></span><br><span class="line">            bodyMidBottom = <span class="number">0</span>,            <span class="comment">// 目录可视区域的中间位置的 dd 的 bottom</span></span><br><span class="line">            bodyBCR = <span class="literal">null</span>,                  <span class="comment">// 目录可视区域的边界值</span></span><br><span class="line">            hasStopSetHighlight = <span class="literal">false</span>;  <span class="comment">// 在点击目录子项的时候直接高亮当前目录，而不通过 scroll 事件触发 setHighlight 函数</span></span><br><span class="line">            </span><br><span class="line">        initCatalog()</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            debounce(setHighlight, DEFAULT.delay)()</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (catalogLength &gt; maxCatalogCount) &#123;</span><br><span class="line">            <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                debounce(scrollCatalog, DEFAULT.delay)()</span><br><span class="line">            &#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            debounce(initCatalog, DEFAULT.delay)()</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 此处声明初始化函数 initCatalog</span></span><br><span class="line">        <span class="comment">// 此处声明生成目录函数 generateCatalog</span></span><br><span class="line">        <span class="comment">// 此处声明设置高亮函数 setHighlight</span></span><br><span class="line">        <span class="comment">// 此处声明滚动目录函数 scrollCatalog</span></span><br><span class="line">        <span class="comment">// 此处声明动画实现滚动函数 scrollToDest</span></span><br><span class="line">        <span class="comment">// 此处声明防抖函数 debounce</span></span><br><span class="line">        <span class="comment">// 此处声明获取滚动方向函数 getScrollDirection</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resetStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (hasStopSetHighlight) &#123;</span><br><span class="line">                hasStopSetHighlight = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>然后在实际页面里使用的时候，只需要引入 <code>articleCatalog.js</code>，然后直接用调用函数即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">articleCatalog()</span><br></pre></td></tr></table></figure>

<p>当然调用的时候也支持传入一些参数，参数说明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">articleCatalog(&#123;</span><br><span class="line">    lineHeight: 28,           &#x2F;&#x2F; 每个菜单的行高是 28</span><br><span class="line">    moreHeight: 10,           &#x2F;&#x2F; 菜单左侧的线比菜单多出的高度</span><br><span class="line">    surplusHeight: 180,       &#x2F;&#x2F; 除了菜单高度+留白高度</span><br><span class="line">    delay: 200,               &#x2F;&#x2F; 防抖的延迟时间</span><br><span class="line">    duration: 200,            &#x2F;&#x2F; 滚动的动画持续时间</span><br><span class="line">    toTopDistance: 80,        &#x2F;&#x2F; 距离视口顶部多少高度之内时候触发高亮</span><br><span class="line">    selector: &#39;.headerlink&#39;,  &#x2F;&#x2F; 文章内容中标题标签的 selector</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意传入参数也是瞎传的，需要配合该插件的样式，否则容易程问题。比如明明页面中子目录的真实行高是 <code>28px</code>，你却传入 <code>lineHeight: 24</code>，那肯定是不行的。</p>
<blockquote>
<p>使用这个插件是有前提的，那就是其文章页的 HTML 结构必须满足上面提到的那种结构才行，且只支持两级子目录。</p>
</blockquote>
<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202009/gzh.png"></p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2020/10/22/promise/" title="深入理解Promise" class="prev">上一篇</a><a href="/2020/09/21/vue-operate/" title="34条我能告诉你的Vue之实操篇" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2020 <a href="https://weibo.com/316000381" target="_blank">typeR</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>