<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> CSS特性检测@supports与Modernizr · 步步走</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="介绍了几种不同的方式来检测某个CSS属性是否被浏览器所兼容：@supports、Modernizr以及js实现的方法cssTest"><meta name="keywords" content="css特性检测、css @supports、modernizr"><meta name="author" content="typeR"><link rel="short icon" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/favicon.ico"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://bubuzou.com/atom.xml" title="步步走"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="步步走" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/read/" target="_self" data-hover="读书" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">CSS特性检测@supports与Modernizr</h1><div class="post-info">2017-03-13<p class="visit"><i data-identity="2017/03/13/detect-css-property/" class="article-timer"></i><span>次访问</span></p><a href="http://www.cnblogs.com/coco1s/p/6478389.html" target="_blank" title="http://www.cnblogs.com/coco1s/p/6478389.html" class="post-from">原文地址</a></div><div class="post-content"><p>什么是 <code>CSS</code> 特性检测？我们知道，前端技术日新月异的今天，各种新技术新属性层出不穷。在 <code>CSS</code> 层面亦不例外。</p>
<p>一些新属性能极大提升用户体验以及减少工程师的工作量，并且在当下的前端氛围下：</p>
<ul>
<li>很多实验性功能未成为标准却被大量使用；</li>
<li>需要兼容多终端，多浏览器，而各浏览器对某一新功能的实现表现的天差地别；</li>
</ul>
<p>所以有了优雅降级和渐进增强的说法，在这种背景下，又想使用新的技术给用户提供更好的体验，又想做好回退机制保证低版本终端用户的基本体验，<code>CSS</code> 特性检测就应运而生了。</p>
<p><code>CSS</code> 特性检测就是针对不同浏览器终端，判断当前浏览器对某个特性是否支持。运用 <code>CSS</code> 特性检测，我们可以在支持当前特性的浏览器环境下使用新的技术，而不支持的则做出某些回退机制。</p>
<p>本文将主要介绍两种 <code>CSS</code> 特性检测的方式：</p>
<ul>
<li><code>@supports</code></li>
<li><code>modernizr</code></li>
<li>用 <code>javascript</code> 进行特性检测</li>
</ul>
<a id="more"></a>

<h2 id="CSS-supports"><a href="#CSS-supports" class="headerlink" title="CSS @supports"></a>CSS @supports</h2><p>传统的 <code>CSS</code> 特性检测都是通过 <code>javascript</code> 实现的，但是未来，原生 <code>CSS</code> 即可实现。<br><code>CSS @supports</code> 通过 <code>CSS</code> 语法来实现特性检测，并在内部 <code>CSS</code> 区块中写入如果特性检测通过希望实现的 <code>CSS</code> 语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@supports &lt;supports_condition&gt; &#123;</span><br><span class="line">    <span class="comment">/* specific rules */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">&#125;</span><br><span class="line">@supports (position:sticky) &#123;</span><br><span class="line">    div &#123;</span><br><span class="line">        position:sticky;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的写法，首先定义了 <code>div</code> 的 <code>position: fixed</code> ，紧接着下面一句 <code>@supports (position:sticky)</code> 则是特性检测括号内的内容，如果当前浏览器支持 <code>@supports</code> 语法，并且支持 <code>position:sticky</code> 语法，那么 <code>div</code> 的 则会被设置为 <code>position:sticky</code> 。</p>
<p>我们可以看到，<code>@supports</code> 语法的核心就在于这一句：<code>@supports (...) &#123; &#125;</code> ，括号内是一个 <code>CSS</code> 表达式，如果浏览器判断括号内的表达式合法，那么接下来就会去渲染括号内的 <code>CSS</code> 表达式。除了这种最常规的用法，还可以配合其他几个关键字：</p>
<h2 id="supports-not"><a href="#supports-not" class="headerlink" title="@supports not"></a>@supports not</h2><p><code>not</code> 操作符可以放在任何表达式的前面来产生一个新的表达式，新的表达式为原表达式的值的否定。看个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@supports not (background: linear-gradient(<span class="number">90</span>deg, red, yellow)) &#123;</span><br><span class="line">    div &#123;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为添加了 <code>not</code> 关键字，所以与上面第一个例子相反，这里如果检测到浏览器不支持线性渐变 <code>background: linear-gradient(90deg, red, yellow)</code> 的语法，则将 <code>div</code> 的颜色设置为红色 <code>background: red</code> 。</p>
<h2 id="supports-and"><a href="#supports-and" class="headerlink" title="@supports and"></a>@supports and</h2><p>用 <code>and</code> 操作符连接两个原始的表达式。只有两个原始表达式的值都为真，生成的表达式才为真，反之为假。来看个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br><span class="line">@supports (display:-webkit-box) and (-webkit-line-clamp:<span class="number">2</span>) and (-webkit-box-orient:vertical) &#123;</span><br><span class="line">    p &#123;</span><br><span class="line">        display: -webkit-box;</span><br><span class="line">        -webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">        -webkit-box-orient: vertical;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面同时，检测 <code>@supports (display:-webkit-box) and (-webkit-line-clamp:2) and (-webkit-box-orient:vertical)</code> 了三个语法，如果同时支持，则设定三个 <code>CSS</code> 规则。这三个语法必须同时得到浏览器的支持，如果表达式为真。</p>
<h2 id="supports-or"><a href="#supports-or" class="headerlink" title="@supports or"></a>@supports or</h2><p><code>@supports or</code> 表示只要表达式里存在一个是真的，那么这个表达式就是返回真。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@supports (background:-webkit-linear-gradient(<span class="number">0</span>deg, yellow, red)) or (background:linear-gradient(<span class="number">90</span>deg, yellow, red))&#123;</span><br><span class="line">    div &#123;</span><br><span class="line">        background:-webkit-linear-gradient(<span class="number">0</span>deg, yellow, red);</span><br><span class="line">        background:linear-gradient(<span class="number">90</span>deg, yellow, red)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="supports的兼容性"><a href="#supports的兼容性" class="headerlink" title="@supports的兼容性"></a>@supports的兼容性</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/supports_01.png" alt="younghz的Markdown库"></p>
<p>这仍是一个实验中的功能，虽然大部分浏览器都已经支持了，但是目前看来，即是在移动端想要全部兼容仍需要等待一段时间。但是我们已经可以开始使用起来了，使用 <code>@supports</code> 实现渐进增强的效果。</p>
<div class="tip">
渐进增强（`progressive enhancement`）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验：
</div>

<h2 id="CSS-supports-1"><a href="#CSS-supports-1" class="headerlink" title="CSS.supports()"></a>CSS.supports()</h2><p>谈到了 <code>@supports</code>，就有必要再说说 <code>CSS.supports()</code> 。<br>它是作为 <code>@supports</code> 的另一种形式出现的，我们可以使用 <code>javascript</code> 的方式来获得 <code>CSS</code> 属性的支持情况。<br>可以打开控制台，输入 <code>CSS.supports</code> 试试：</p>
<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/supports_02.png" alt="function@supports"></p>
<p>如果没有自己实现 <code>CSS.supports</code> 这个方法，输出上述信息，表示浏览器是支持 <code>@supports</code> 语法的，使用如下：</p>
<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/supports_03.png" alt="supports@demos"></p>
<p>那它有什么用呢？如果你的页面需要动态添加一些你不确定哪些浏览器支持的新的属性，那它也许会派上用场。以及，它可以配合我们下文即将要讲的 <code>modernizr</code> 。</p>
<h2 id="modernizr"><a href="#modernizr" class="headerlink" title="modernizr"></a>modernizr</h2><p>上面介绍了 <code>CSS</code> 方式的特性检测，在以前，通常是使用 <code>javascript</code> 来进行特性检测的，其中 <code>modernizr</code> 就是其中最为出色的佼佼者。<br><code>modernizr</code>（戳我查看 <code>Github</code> ）是一个开源的 <code>javascript</code> 库。有着将近 <code>2W</code> 的 <code>star</code> ，其优秀程度可见一斑。<br>简单看看使用方法，假设页面已经引用了 <code>modernizr</code> ，语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listen to a test, give it a callback</span></span><br><span class="line">Modernizr.on(<span class="string">&#x27;testname&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> result </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;The test passed!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;The test failed!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 或者是类似 CSS.supports()</span></span><br><span class="line">Modernizr.testAllProps(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;linear-gradient(90deg, #888, #ccc)&#x27;</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="特性检测原理"><a href="#特性检测原理" class="headerlink" title="特性检测原理"></a>特性检测原理</h2><p>如果嫌引入整一个 <code>Modernizr</code> 库太大，页面又不支持 <code>@supports</code> ，其实我们自己用简单的 <code>javascript</code> 实现也非常方便简单。<br>想要知道浏览器支持多少 <code>CSS</code> 属性，可以在调试窗口试试：</p>
<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/supports_04.png" alt="html.style"></p>
<p>上面图片截取的只是打印出来的一小部分。如果我们要检测某个属性样式是否被支持，在任意的 <code>element.style</code> 检测它是否存在即可。<br>当然，元素可能有 <code>background</code> 属性，但是不支持具体的 <code>linear-gradinet()</code> 属性值。这个时候该如何检测呢？只需要将具体的值赋值给某一元素，再查询这个属性值能否被读取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = <span class="built_in">document</span>.documentElement;</span><br><span class="line">root.style.backgroundImage = <span class="string">&#x27;linear-gradient(90deg, #888, #ccc)&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(root.style.backgroundImage) &#123;</span><br><span class="line">    <span class="comment">// 支持</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不支持</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="各种方式间的优劣"><a href="#各种方式间的优劣" class="headerlink" title="各种方式间的优劣"></a>各种方式间的优劣</h2><ul>
<li><p>原生的 <code>@supports</code> 的性能肯定是最好的，而且无需引入外部 <code>javascript</code> ，首推这个，但是无奈兼容问题，目前来看不是最好的选择。</p>
</li>
<li><p><code>Modernizr</code> 功能强大，兼容性好，但是需要引入外部 <code>javascript</code>，多一个 <code>http</code> 请求，如果只是进行几个特性检测，有点杀鸡用牛刀的感觉。</p>
</li>
<li><p>针对需要的特性检测，使用 <code>javascript</code> 实现一个简单的函数，再把上面用到的方法封装一下：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于简单的 CSS 特性检测</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>[String] property 需要检测的 CSS 属性名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>[String] value 样式的具体属性值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return </span>[Boolean] 是否通过检查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cssTest</span>(<span class="params">property, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用于测试的元素，隐藏在页面上</span></span><br><span class="line">    <span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-display-none&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 只有一个参数的情况</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(property <span class="keyword">in</span> ele.style) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 两个参数的情况</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">2</span>)&#123;</span><br><span class="line">        ele.style[property] = value;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(ele.style[property]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/201703/supports_05.png" alt="supports@demos"></p>
</li>
</ul>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2017/03/30/chrome-devtools/" title="chrome开发者工具实用小技巧" class="prev">上一篇</a><a href="/2017/03/10/background-property/" title="background属性" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2020 <a href="https://weibo.com/316000381" target="_blank">typeR</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>