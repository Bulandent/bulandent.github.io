<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>步步走</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bubuzou.com/"/>
  <updated>2024-06-12T09:38:59.255Z</updated>
  <id>https://bubuzou.com/</id>
  
  <author>
    <name>typeR</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何反编译微信小程序</title>
    <link href="https://bubuzou.com/2024/06/12/decompile-applet/"/>
    <id>https://bubuzou.com/2024/06/12/decompile-applet/</id>
    <published>2024-06-12T09:37:58.000Z</published>
    <updated>2024-06-12T09:38:59.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是反编译"><a href="#什么是反编译" class="headerlink" title="什么是反编译"></a>什么是反编译</h2><p>微信小程序可以运行在手机微信或者 pc 版微信环境下，它是以一个应用包的形式存在的，这个应用包的后缀通常是 .wxapkg。如果想知道某个微信小程序的功能模块是如何实现的，就需要把这个包给解开，这个过程就叫反编译。</p><h2 id="获取小程序包"><a href="#获取小程序包" class="headerlink" title="获取小程序包"></a>获取小程序包</h2><p>要反编译微信小程序，那首先就需要获取微信小程序的应用包。</p><p>可以在 pc 版本微信上获取包，那么就需要在 pc 版微信上先运行某个小程序；运行完成后，就会在电脑某个目录下生成这个小程序的包，我们需要找到这个目录，那么就找到了这个包了。</p><p>windows 和 mac 环境不同，包的位置也会不一样。</p><p><em>windows 系统</em></p><p>打开微信设置-文件管理-就能看到微信的目录了，继续往下找到 /applet 这个目录，就能看到小程序的包了。示例：D:\软件\WeChat Files\WeChat Files\Applet\小程序 AppID__APP__.wxapkg</p><p><em>mac 系统</em></p><p>包通常是被放在：/System/Volumes/Data/Users/你的用户名/Library/Containers/com.tencent.xinWeChat/Data/.wxapplet/packages/小程序 AppID/随机数/<strong>APP</strong>.wxapkg</p><a id="more"></a><p>知道了目录后，就可以拿到包了。在 mac 下进入某个目录可以这样做：访达-前往-前往文件夹-然后把目录路径贴到输入框，选择某个路径就可以进去了。</p><blockquote><p>如果 mac 系统的包不在刚刚说的目录下，还有一种方式可以找到。那就是通过微信小程序 AppID 来搜索目录。那就需要先知道某个微信小程序的 AppID 是什么。</p></blockquote><p>可以通过如下这张图的操作路径来获取 AppID：</p><p><img src="http://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202406/002.png" alt="获取AppID"></p><p>拿到了 AppID 后，就可以通过终端里输入命令来进行搜索了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name 某个AppID</span><br></pre></td></tr></table></figure><p><img src="http://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202406/001.png"></p><p>当搜索到这种路径的时候就说明找到了，就可以停止搜索了。</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>拿到了小程序应用包，接下来就需要通过代码把这个包给解开，然后还原成可以跑在微信开发者工具上的微信小程序项目代码了。</p><p>反编译使用的是 github 上的开源项目：<a href="https://github.com/threecha/wxappUnpacker">wxappUnpacker</a></p><p>把这个项目 clone 到本地后，安装好依赖，就可以使用如下命令进行反编译了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node wuWxapkg.js /System/Volumes/Data/Users/你的用户名/Library/Containers/com.tencent.xinWeChat/Data/.wxapplet/packages/小程序AppID/随机数/__APP__.wxapkg</span><br></pre></td></tr></table></figure><p>由于这个库的程序比较旧了，而小程序的项目结构或者语法再时时更新，所以在解包的时候有可能会报错，这个不用管。</p><p>解包完成后，会在 <strong>APP</strong>.wxapkg 的同级目录生成一个 <strong>APP</strong> 的文件夹，这个文件夹就是微信开发者工具的可识别的项目目录。把它复制到外面，好让微信开发者工具方便导入，导入项目过程中的 AppID 使用测试号即可。</p><p>在微信开发者加载代码的过程中，正常不会很顺利，我自己反编译了几个小程序也都会有问题。比如如下图：</p><p><img src="http://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202406/003.png" alt="报错"></p><p><em>问题一：require(…)() is not a function</em></p><p>比如如下文件 miniprogram_npm/@vant/weapp/wxs/utils.wxs 中的 require(…)() 改成 require(…) 即可。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-  var bem = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/bem.wxs&#x27;)();</span></span><br><span class="line"><span class="addition">+  var bem = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/bem.wxs&#x27;);</span></span><br><span class="line"><span class="deletion">-  var memoize = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/memoize.wxs&#x27;)();</span></span><br><span class="line"><span class="addition">+  var memoize = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/memoize.wxs&#x27;);</span></span><br><span class="line"><span class="deletion">-  var addUnit = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/add-unit.wxs&#x27;)();</span></span><br><span class="line"><span class="addition">+  var addUnit = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/add-unit.wxs&#x27;);</span></span><br><span class="line">module.exports = (&#123;</span><br><span class="line">    bem: memoize(bem),</span><br><span class="line">    memoize: memoize,</span><br><span class="line">    addUnit: addUnit,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><em>问题二：_typeof2 is not a function</em></p><p>这个错误文件是 @babel/runtime/helpers/typeof.js，把如下代码替换掉原文件代码即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_typeof2</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="string">&quot;@babel/helpers - typeof&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> (_typeof2 =</span><br><span class="line">    <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="string">&quot;symbol&quot;</span> == <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator</span><br><span class="line">      ? <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">typeof</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> o &amp;&amp;</span><br><span class="line">            <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp;</span><br><span class="line">            o.constructor === <span class="built_in">Symbol</span> &amp;&amp;</span><br><span class="line">            o !== <span class="built_in">Symbol</span>.prototype</span><br><span class="line">            ? <span class="string">&quot;symbol&quot;</span></span><br><span class="line">            : <span class="keyword">typeof</span> o;</span><br><span class="line">        &#125;)(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="string">&quot;symbol&quot;</span> === _typeof2(<span class="built_in">Symbol</span>.iterator)</span><br><span class="line">      ? (<span class="built_in">module</span>.exports = _typeof =</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _typeof2(o);</span><br><span class="line">          &#125;)</span><br><span class="line">      : (<span class="built_in">module</span>.exports = _typeof =</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o &amp;&amp;</span><br><span class="line">              <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp;</span><br><span class="line">              o.constructor === <span class="built_in">Symbol</span> &amp;&amp;</span><br><span class="line">              o !== <span class="built_in">Symbol</span>.prototype</span><br><span class="line">              ? <span class="string">&quot;symbol&quot;</span></span><br><span class="line">              : _typeof2(o);</span><br><span class="line">          &#125;),</span><br><span class="line">    _typeof(o)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = _typeof;</span><br></pre></td></tr></table></figure><p>其他一些别的错误，需要看报错信息对应改一下，这里就不再多介绍了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是反编译&quot;&gt;&lt;a href=&quot;#什么是反编译&quot; class=&quot;headerlink&quot; title=&quot;什么是反编译&quot;&gt;&lt;/a&gt;什么是反编译&lt;/h2&gt;&lt;p&gt;微信小程序可以运行在手机微信或者 pc 版微信环境下，它是以一个应用包的形式存在的，这个应用包的后缀通常是 .wxapkg。如果想知道某个微信小程序的功能模块是如何实现的，就需要把这个包给解开，这个过程就叫反编译。&lt;/p&gt;
&lt;h2 id=&quot;获取小程序包&quot;&gt;&lt;a href=&quot;#获取小程序包&quot; class=&quot;headerlink&quot; title=&quot;获取小程序包&quot;&gt;&lt;/a&gt;获取小程序包&lt;/h2&gt;&lt;p&gt;要反编译微信小程序，那首先就需要获取微信小程序的应用包。&lt;/p&gt;
&lt;p&gt;可以在 pc 版本微信上获取包，那么就需要在 pc 版微信上先运行某个小程序；运行完成后，就会在电脑某个目录下生成这个小程序的包，我们需要找到这个目录，那么就找到了这个包了。&lt;/p&gt;
&lt;p&gt;windows 和 mac 环境不同，包的位置也会不一样。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;windows 系统&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;打开微信设置-文件管理-就能看到微信的目录了，继续往下找到 /applet 这个目录，就能看到小程序的包了。示例：D:\软件\WeChat Files\WeChat Files\Applet\小程序 AppID__APP__.wxapkg&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mac 系统&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;包通常是被放在：/System/Volumes/Data/Users/你的用户名/Library/Containers/com.tencent.xinWeChat/Data/.wxapplet/packages/小程序 AppID/随机数/&lt;strong&gt;APP&lt;/strong&gt;.wxapkg&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="https://bubuzou.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="反编译" scheme="https://bubuzou.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>从 ESLint 开始，说透我如何在团队项目中基于 Vue 做代码校验</title>
    <link href="https://bubuzou.com/2021/06/16/eslint/"/>
    <id>https://bubuzou.com/2021/06/16/eslint/</id>
    <published>2021-06-16T02:23:14.000Z</published>
    <updated>2024-06-12T09:26:57.287Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202106/eslint.png"></p><p>最近遇到了一个老项目，比较有意思的是这个项目集前后端的代码于一起，而后端也会去修改前端代码，所以就出现了后端用 IntelliJ IDEA 来开发前端项目，而前端用 VSCode 来开发前端项目的情况。<br>于是乎，出现了代码规范的问题，所以就有了这篇文章，整理了一下前端代码校验以及在 Vue 项目中的实践。</p><p>阅读完这篇文章，你可以收获：</p><ul><li>能够自己亲手写出一套 ESLint 配置；</li><li>会知道业界都有哪些著名的 JS 代码规范，熟读它们可以让你写出更规范的代码；</li><li>vue-cli 在初始化一个包含代码校验的项目时都做了什么；</li><li>Prettier 是什么？为什么要使用它？如何与 ESLint 配合使用？</li><li>EditorConfig 又是什么？如何使用？</li><li>如何在 VSCode 中通过插件来协助代码校验工作；</li><li>如何保证 push 到远程仓库的代码是符合规范的；</li></ul><a id="more"></a><p>下面开始阅读吧，如果你对 ESLint 比较熟悉，可以直接跳过这个部分。</p><h2 id="ESLint-是什么"><a href="#ESLint-是什么" class="headerlink" title="ESLint 是什么"></a>ESLint 是什么</h2><p>ESLint 是一个集代码审查和修复的工具，它的核心功能是通过配置一个个规则来限制代码的合法性和风格。</p><h3 id="配置解析器和解析参数"><a href="#配置解析器和解析参数" class="headerlink" title="配置解析器和解析参数"></a>配置解析器和解析参数</h3><p>ESLint 的解析器，早期的时候用的是 <a href="http://esprima.org/" title="Esprima">Esprima</a>，后面基于 Esprima v1.2.2 版本开发了一个新的解析器 <a href="https://github.com/eslint/espree" title="Espree">Espree</a>，并且把它当做默认解析器。</p><p>除了使用 ESLint 自带的解析器外，还可以指定其他解析器：</p><ul><li><a href="https://github.com/babel/babel/tree/main/eslint/babel-eslint-parser" title="@babel/eslint-parser">@babel/eslint-parser</a>：使 Babel 和 ESLint 兼容，对一些 Babel 语法提供支持；</li><li><a href="https://github.com/typescript-eslint/typescript-eslint" title="@typescript-eslint/parser">@typescript-eslint/parser</a>：TSLint 被弃用后，TypeScript 提供了此解析器用于将其与 ESTree 兼容，使 ESLint 对 TypeScript 进行支持；</li></ul><p>为项目指定某个选择器的原则是什么？</p><ul><li>如果你的项目用到了比较新的 ES 语法，比如 ES2021 的 Promise.any()，那就可以指定 @babel/eslint-parser 为解析器；</li><li>如果项目是基于 TS 开发的，那就使用 @typescript-eslint/parser；</li></ul><blockquote><p>如果你对 ES 最新标准还不熟悉，可以看看这篇文章：<a href="https://juejin.cn/post/6896986598999588872">送你一份精心总结的 3 万字 ES6 实用指南（下）</a></p></blockquote><p>除了指定解析器 parser 外，还可以额外配置解析器参数 parserOption：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ESLint 默认解析器，也可以指定成别的</span></span><br><span class="line">    parser: <span class="string">&quot;espree&quot;</span>,</span><br><span class="line">    parserOption: &#123;</span><br><span class="line">        <span class="comment">// 指定要使用的 ECMAScript 版本，默认值 5</span></span><br><span class="line">        ecmaVersion: <span class="number">5</span>,</span><br><span class="line">        <span class="comment">// 设置为 script (默认) 或 module（如果你的代码是 ECMAScript 模块)</span></span><br><span class="line">        sourceType: <span class="string">&quot;script&quot;</span>,</span><br><span class="line">        <span class="comment">// 这是个对象，表示你想使用的额外的语言特性,所有选项默认都是 false</span></span><br><span class="line">        ecmafeatures: &#123;</span><br><span class="line">            <span class="comment">// 是否允许在全局作用域下使用 return 语句</span></span><br><span class="line">            globalReturn: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// 是否启用全局 strict 模式（严格模式）</span></span><br><span class="line">            impliedStrict: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// 是否启用JSX</span></span><br><span class="line">            jsx: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// 是否启用对实验性的objectRest/spreadProperties的支持</span></span><br><span class="line">            experimentalObjectRestSpread: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定环境-env"><a href="#指定环境-env" class="headerlink" title="指定环境 env"></a>指定环境 env</h3><p>指定不同的环境可以给对应环境下提供预设的全局变量。比如说在 browser 环境下，可以使用 window 全局变量；在 node 环境下，可以使用 process 全局变量等；</p><p>ESLint 中可配置的环境比较多，<a href="https://eslint.org/docs/user-guide/configuring/language-options#specifying-environments" title="Specifying Environments">这里有份完整的环境列表</a>，下面列出几个比较常见的：</p><ul><li>browser：浏览器全局变量；</li><li>node：Node.js 全局变量和作用域；</li><li>es6：es6 中除了模块之外的其他特性，同时将自动设置 parserOptions.ecmaVersion 参数为 6；以此类推 ES2017 是 7，而 ES2021 是 12；</li><li>es2017：parserOptions.ecmaVersion 为 8；</li><li>es2020：parserOptions.ecmaVersion 为 11；</li><li>es2021：parserOptions.ecmaVersion 为 12；</li></ul><p>配置方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    env: &#123;</span><br><span class="line">        browser: <span class="literal">true</span>,</span><br><span class="line">        node: <span class="literal">true</span>,</span><br><span class="line">        es6: <span class="literal">true</span>,</span><br><span class="line">        commonjs: <span class="literal">true</span>,</span><br><span class="line">        mocha: <span class="literal">true</span>,</span><br><span class="line">        jquery: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以指定多个环境并不意味着配置的环境越多越好，实际配置的时候还是得依据当前项目的环境来选择。</p><h3 id="配置全局变量-globals"><a href="#配置全局变量-globals" class="headerlink" title="配置全局变量 globals"></a>配置全局变量 globals</h3><p>ESLint 的一些核心规则依赖于对代码在运行时可用的全局变量的了解。 由于这些在不同环境之间可能会有很大差异，并且在运行时会进行修改，因此 ESLint 不会假设你的执行环境中存在哪些全局变量。</p><p>如果你想使用这些全局变量，那就可以通过 globals 来指定。比如在 <a href="https://github.com/facebook/react/blob/master/.eslintrc.js" title="react .eslintrc.js">react .eslintrc.js</a> 里就把 spyOnDev、 spyOnProd 等变量挂在了 global 下作为全局变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    globals: &#123;</span><br><span class="line">        spyOnDev: <span class="literal">true</span>,</span><br><span class="line">        spyOnProd: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于它的值需要特别说明下：</p><ul><li>false、readable、readonly 这 3 个是等价的，表示变量只可读不可写；</li><li>true、writeable、writable 这 3 个是等价的，表示变量可读可写；</li></ul><h3 id="配置扩展-extends"><a href="#配置扩展-extends" class="headerlink" title="配置扩展 extends"></a>配置扩展 extends</h3><p>实际项目中配置规则的时候，不可能团队一条一条的去商议配置，太费精力了。通常的做法是使用业内大家普通使用的、遵循的编码规范；然后通过 extends 去引入这些规范。extends 配置的时候接受字符串或者数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;plugin:vue/essential&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;eslint-config-standard&#x27;</span>, <span class="comment">// 可以缩写成 &#x27;standard&#x27;</span></span><br><span class="line">        <span class="string">&#x27;@vue/prettier&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;./node_modules/coding-standard/.eslintrc-es6&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从上面的配置，可以知道 extends 支持的配置类型可以是以下几种</strong></p><ul><li>eslint 开头的：是 ESLint 官方的扩展；</li><li>plugin 开头的：是插件类型扩展，比如 plugin:vue/essential；</li><li>eslint-config 开头的：来自 npm 包，使用时可以省略前缀 eslint-config-，比如上面的可以直接写成 standard；</li><li>@开头的：扩展和 eslint-config 一样，只是在 npm 包上面加了一层作用域 scope；</li><li>一个执行配置文件的相对路径或绝对路径；</li></ul><p><strong>那有哪些常用的、比较著名扩展可以被 extends 引入呢</strong></p><ul><li><a href="https://eslint.org/docs/rules/">eslint:recommended</a>：ESLint 内置的推荐规则，即 ESLint Rules 列表中打了钩的那些规则；</li><li><a href="https://eslint.org/docs/rules/">eslint:all</a>：ESLint 内置的所有规则；</li><li><a href="https://github.com/standard/eslint-config-standard" title="eslint-config-standard">eslint-config-standard</a>：standard 的 JS 规范；</li><li><a href="https://github.com/prettier/eslint-config-prettier" title="eslint-config-prettier">eslint-config-prettier</a>：关闭和 ESLint 中以及其他扩展中有冲突的规则；</li><li><a href="https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb-base">eslint-config-airbnb-base</a>：airbab 的 JS 规范；</li><li><a href="https://github.com/AlloyTeam/eslint-config-alloy" title="eslint-config-alloy">eslint-config-alloy</a>：腾讯 AlloyTeam 前端团队出品，可以很好的针对你项目的技术栈进行配置选择，比如可以选 React、Vue（现已支持 Vue 3.0）、TypeScript 等；</li></ul><h3 id="使用插件-plugins"><a href="#使用插件-plugins" class="headerlink" title="使用插件 plugins"></a>使用插件 plugins</h3><p><strong>ESLint 提供插件是干嘛用的</strong></p><p>ESLint 虽然可以定义很多的 rules，以及通过 extends 来引入更多的规则，但是说到底只是检查 JS 语法。如果需要检查 Vue 中的 template 或者 React 中的 jsx，就束手无策了。<br>所以引入插件的目的就是为了增强 ESLint 的检查能力和范围。</p><p><strong>如何配置插件</strong></p><p>ESLint 相关的插件的命名形式有 2 种：不带命名空间的和带命名空间的，比如：</p><ul><li>eslint-plugin- 开头的可以省略这部分前缀；</li><li>@<scope>/ 开头的；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">&#x27;jquery&#x27;</span>, <span class="comment">// 是指 eslint-plugin-jquery</span></span><br><span class="line">    <span class="string">&#x27;@jquery/jquery&#x27;</span>, <span class="comment">// 是指 @jquery/eslint-plugin-jquery</span></span><br><span class="line">    <span class="string">&#x27;@foobar&#x27;</span>, <span class="comment">// 是指 @foobar/eslint-plugin</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要基于插件进行 extends 和 rules 的配置的时候，需要加上插件的引用，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="string">&#x27;jquery&#x27;</span>,   <span class="comment">// eslint-plugin-jquery</span></span><br><span class="line">        <span class="string">&#x27;@foo/foo&#x27;</span>, <span class="comment">// @foo/eslint-plugin-foo</span></span><br><span class="line">        <span class="string">&#x27;@bar,      // @bar/eslint-plugin</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    extends: [</span></span><br><span class="line"><span class="string">        &#x27;</span>plugin:jquery/recommended<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;</span>plugin:@foo/foo/recommended<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;</span>plugin:@bar/recommended<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    rules: &#123;</span></span><br><span class="line"><span class="string">        &#x27;</span>jquery/a-rule<span class="string">&#x27;: &#x27;</span>error<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;</span>@foo/foo/some-rule<span class="string">&#x27;: &#x27;</span>error<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;</span>@bar/another-rule<span class="string">&#x27;: &#x27;</span>error<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>以上配置来自 <a href="https://eslint.org/docs/user-guide/configuring/plugins#configuring-plugins" title="ESLint plugins">ESLint plugins</a></p><h3 id="配置规则-rules"><a href="#配置规则-rules" class="headerlink" title="配置规则 rules"></a>配置规则 rules</h3><p>ESLint 提供了大量内置的规则，这里是它的规则列表 <a href="https://eslint.org/docs/rules/">ESLint Rules</a>，除此之外你还可以通过插件来添加更多的规则。</p><p><strong>规则的校验说明，有 3 个报错等级</strong></p><ul><li>off 或 0：关闭对该规则的校验；</li><li>warn 或 1：启用规则，不满足时抛出警告，且不会退出编译进程；</li><li>error 或 2：启用规则，不满足时抛出错误，且会退出编译进程；</li></ul><p>通常规则只需要配置开启还是关闭即可；但是也有些规则可以传入属性，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">&#x27;quotes&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;single&#x27;</span>],  <span class="comment">// 如果不是单引号，则报错</span></span><br><span class="line">        <span class="string">&#x27;one-var&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;var&#x27;</span>: <span class="string">&#x27;always&#x27;</span>,  <span class="comment">// 每个函数作用域中，只允许 1 个 var 声明</span></span><br><span class="line">            <span class="string">&#x27;let&#x27;</span>: <span class="string">&#x27;never&#x27;</span>,   <span class="comment">// 每个块作用域中，允许多个 let 声明</span></span><br><span class="line">            <span class="string">&#x27;const&#x27;</span>: <span class="string">&#x27;never&#x27;</span>, <span class="comment">// 每个块作用域中，允许多个 const 声明</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何知道某个扩展有哪些规则可以配置，以及每个规则具体限制？<br>这里直接给出业内著名且使用比较多的规则列表的快速链接：</p><ul><li><a href="https://eslint.org/docs/rules/">ESLint rules</a>，这整个列表对应 eslint:all，而打钩 ✔️ 的是 eslint:recommenmed；</li><li><a href="https://github.com/prettier/eslint-config-prettier/blob/main/index.js">Prettier rules</a></li><li><a href="https://github.com/standard/standard/blob/master/RULES.md">standard rules</a></li><li><a href="https://github.com/airbnb/javascript">airbnb rules</a></li><li><a href="https://github.com/AlloyTeam/eslint-config-alloy/blob/master/config/rules/vue.json">AlloyTeam vue rules</a></li></ul><p><strong>规则的优先级</strong></p><ul><li>如果 extends 配置的是一个数组，那么最终会将所有规则项进行合并，出现冲突的时候，后面的会覆盖前面的；</li><li>通过 rules 单独配置的规则优先级比 extends 高；</li></ul><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p><strong>配置当前目录为 root</strong></p><p>ESLint 检测配置文件步骤：</p><ul><li><ol><li>在要检测的文件同一目录里寻找 .eslintrc.* 和 package.json；</li></ol></li><li><ol start="2"><li>紧接着在父级目录里寻找，一直到文件系统的根目录；</li></ol></li><li><ol start="3"><li>如果在前两步发现有 root：true 的配置，停止在父级目录中寻找 .eslintrc；</li></ol></li><li><ol start="4"><li>如果以上步骤都没有找到，则回退到用户主目录 ~/.eslintrc 中自定义的默认配置；</li></ol></li></ul><p>通常我们都习惯把 ESLint 配置文件放到项目根目录，因此可以为了避免 ESLint 校验的时候往父级目录查找配置文件，所以需要在配置文件中加上 root: true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加共享数据</strong></p><p>ESLint 支持在配置文件添加共享设置，你可以添加 settings 对象到配置文件，它将提供给每一个将被执行的规则。如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    settings: &#123;</span><br><span class="line">        sharedData: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://gist.github.com/rswanderer/29dc65efc421b3b5b0442f1bd3dcd046" title="ESLint配置文件.eslintrc参数说明">ESLint 配置文件.eslintrc 参数说明</a></p><p><strong>针对个别文件设置新的检查规则</strong></p><p>比如 webpack 的中包含了某些运行时的 JS 文件，而这些文件是只跑在浏览器端的，所以需要针对这部分文件进行差异化配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">overrides: [</span><br><span class="line">  &#123;</span><br><span class="line">    files: [<span class="string">&#x27;lib/**/*.runtime.js&#x27;</span>, <span class="string">&#x27;hot/*.js&#x27;</span>],</span><br><span class="line">    env: &#123;</span><br><span class="line">      es6: <span class="literal">false</span>,</span><br><span class="line">      browser: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    globals: &#123;</span><br><span class="line">      <span class="built_in">Promise</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">      ecmaVersion: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>以上配置来自 <a href="https://github.com/webpack/webpack/blob/master/.eslintrc.js" title="webpack .eslintrc.js">webpack .eslintrc.js</a></p><h2 id="如何校验"><a href="#如何校验" class="headerlink" title="如何校验"></a>如何校验</h2><p>上面细说了 ESLint 的各种配置项，以及针对 Vue 项目如何进行差异配置的说明。</p><p>现在我们知道了如何配置，但是你知道这些配置都是配置到哪里的吗？</p><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>ESLint 支持 3 种配置方式：</p><ul><li>命令行：不推荐，不做介绍；</li><li>单文件内注释：不推荐，不做介绍；</li><li>配置文件：配置文件的类型可以是好几种，比如：.js、.yml、json 等。推荐使用 .eslintrc.js；</li></ul><p>下面通过命令来生成一个配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 eslint</span></span><br><span class="line">npm i eslint -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个配置文件</span></span><br><span class="line">npx eslint --init</span><br></pre></td></tr></table></figure><p>最后会在当前目录生成一个 .eslintrc.js 文件。这里就不把代码贴出来了，没参考意义。</p><p>上面我们知道了可以将配置统一写到一个配置文件里，但是你知道该如何去触发这个配置文件的校验规则嘛？</p><h3 id="校验单个文件"><a href="#校验单个文件" class="headerlink" title="校验单个文件"></a>校验单个文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验 a.js 和 b.js</span></span><br><span class="line">npx eslint a.js b.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验 src 和 scripts 目录</span></span><br><span class="line">npx eslint src scripts</span><br></pre></td></tr></table></figure><h3 id="校验别的类型的文件"><a href="#校验别的类型的文件" class="headerlink" title="校验别的类型的文件"></a>校验别的类型的文件</h3><p>通常 ESLint 只能校验 JS 文件。比如需要校验 .vue 文件，光配置 vue 插件和 vue-eslint-parser 解析器是不够的，还需要让 ESLint 在查找文件的时候找到 .vue 文件。</p><p>可以通过 –ext 来指定具体需要校验的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx eslint --ext .js,.jsx,.vue src</span><br></pre></td></tr></table></figure><h3 id="自动修复部分校验错误的代码"><a href="#自动修复部分校验错误的代码" class="headerlink" title="自动修复部分校验错误的代码"></a>自动修复部分校验错误的代码</h3><p>rules 列表项中标识了一个扳手 🔧 图案的规则就标识该规则是可以通过 ESLint 工具自动修复代码的。<br>如何自动修复呢？通过 –fix 即可。比如对于 ESLint Rules 里的这个 <a href="https://eslint.org/docs/rules/semi">semi</a> 规则，它就是带扳手图案的。</p><p>对于如下的 a.js 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">12</span></span><br></pre></td></tr></table></figure><p>当在配置文件配置了 ‘semi’: [2, ‘always’] 后，运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx eslint --fix a.js</span><br></pre></td></tr></table></figure><p>校验直接就通过了，且会自动修复代码，在代码末尾自动加上分号。</p><h3 id="把校验命令加到-package-json"><a href="#把校验命令加到-package-json" class="headerlink" title="把校验命令加到 package.json"></a>把校验命令加到 package.json</h3><p>检验命令比较长，也难记，习惯上会把这些命名直接写到 package.json 里：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;npx eslint --ext .js,.jsx,.vue src&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint:fix&quot;</span>: <span class="string">&quot;npx eslint --fix --ext .js,.jsx,.vue src&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤一些不需要校验的文件"><a href="#过滤一些不需要校验的文件" class="headerlink" title="过滤一些不需要校验的文件"></a>过滤一些不需要校验的文件</h3><p>对于一些公共的 JS、测试脚本或者是特定目录下的文件习惯上是不需要校验的，因此可以在项目根目录通过创建一个 .eslintignore 文件来配置，告诉 ESLint 校验的时候忽略它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public&#x2F;</span><br><span class="line">src&#x2F;main.js</span><br></pre></td></tr></table></figure><p>除了 .eslintignore 中指定的文件或目录，ESLint 总是忽略 /node_modules/ 和 /bower_components/ 中的文件；因此对于一些目前解决不了的规则报错，但是如果又急于打包上线，在不影响运行的情况下，我们就可以利用 .eslintignore 文件将其暂时忽略。</p><h2 id="在-Vue-项目中的实践"><a href="#在-Vue-项目中的实践" class="headerlink" title="在 Vue 项目中的实践"></a>在 Vue 项目中的实践</h2><p>上面把 ESLint 的几乎所有的配置参数和校验方式都详细的介绍了一遍，但是如果想在项目中落地，仅仅靠上面的知识还是不够的。下面将细说如何在 Vue 中落地代码校验。</p><p>关于如何在 Vue 中落地代码校验，一般是有 2 种情况：</p><ul><li>通过 vue-cli 初始化项目的时候已经选择了对应的校验配置</li><li>对于一个空的 Vue 项目，想接入代码校验</li></ul><p>其实这 2 种情况最终的校验的核心配置都是一样的，只是刚开始的时候安装的包有所区别。下面通过分析 vue-cli 配置的代码校验，来看看它到底做了哪些事情，通过它安装的包以及包的作用，我们就会知道如何在空项目中配置代码校验了。</p><h3 id="通过-vue-cli-初始化的项目"><a href="#通过-vue-cli-初始化的项目" class="headerlink" title="通过 vue-cli 初始化的项目"></a>通过 vue-cli 初始化的项目</h3><p>如果你的项目最初是通过 vue-cli 新建的，那么在新建的时候会让你选</p><ul><li>是否支持 eslint；</li><li>是否开启保存校验；</li><li>是否开启提交前校验；</li></ul><p>如果都开启了话，会安装如下几个包：</p><ul><li>eslint：前面 2 大章节介绍的就是这玩意，ESLint 出品，是代码校验的基础包，且提供了很多内置的 Rules，比如 eslint:recommended 经常被作为项目的 JS 检查规范被引入；</li><li>babel-eslint：一个对 Babel 解析器的包装，使其能够与 ESLint 兼容；</li><li>lint-staged：请看后面 pre-commit 部分；</li><li>@vue/cli-plugin-eslint</li><li>eslint-plugin-vue</li></ul><p>下面重点介绍 @vue/cli-plugin-eslint 和 eslint-plugin-vue，说下这 2 个包是干嘛的。</p><h4 id="vue-cli-plugin-eslint"><a href="#vue-cli-plugin-eslint" class="headerlink" title="@vue/cli-plugin-eslint"></a>@vue/cli-plugin-eslint</h4><p>这个包它主要干了 2 件事情：</p><p><strong>第一件事</strong></p><p>往 package.json 里注册了一个命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;vue-cli-service lint&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这个命令之后，它会去检查和修复部分可以修复的问题。默认查找的文件是 src 和 tests 目录下所有的 .js,.jsx,.vue 文件，以及项目根目录下所有的 js 文件（比如，也会检查 .eslintrc.js）。</p><p>当然你也可以自定义的传入参数和校验文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue-cli-service lint [options] [...files]</span><br></pre></td></tr></table></figure><p>支持的参数如下：</p><ul><li>–no-fix: 不会修复 errors 和 warnings；</li><li>–max-errors [limit]：指定导致出现 npm ERR 错误的最大 errors 数量；</li></ul><p><strong>第二件事</strong></p><p>增加了代码保存触发校验的功能 lintOnSave，这个功能默认是开启的。如果想要关闭这个功能，可以在 vue.config.js 里配置，习惯上只开启 development 环境下的代码保存校验功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lintOnSave 参数说明：</p><ul><li>true 或者 warning：开启保存校验，会将 errors 级别的错误在终端中以 WARNING 的形式显示。默认的，WARNING 将不会导致编译失败；</li><li>false：不开启保存校验；</li><li>error：开启保存校验，会将 errors 级别的错误在终端中以 ERROR 的形式出现，会导致编译失败，同时浏览器页面变黑，显示 Failed to compile。</li></ul><h4 id="eslint-plugin-vue"><a href="#eslint-plugin-vue" class="headerlink" title="eslint-plugin-vue"></a>eslint-plugin-vue</h4><p>eslint-plugin-vue 是对 .vue 文件进行代码校验的插件。</p><p><strong>针对这个插件，它提供了这几个扩展</strong></p><ul><li>plugin:vue/base：基础</li><li>plugin:vue/essential：预防错误的（用于 Vue 2.x）</li><li>plugin:vue/recommended：推荐的，最小化任意选择和认知开销（用于 Vue 2.x）；</li><li>plugin:vue/strongly-recommended：强烈推荐，提高可读性（用于 Vue 2.x）；</li><li>plugin:vue/vue3-essential：（用于 Vue 3.x）</li><li>plugin:vue/vue3-strongly-recommended：（用于 Vue 3.x）</li><li>plugin:vue/vue3-recommended：（用于 Vue 3.x）</li></ul><p>各扩展规则列表：<a href="https://eslint.vuejs.org/rules/">vue rules</a></p><p><strong>看到这么一堆的扩展，是不是都不知道选哪个了</strong></p><p>代码规范的东西，原则还是得由各自的团队去磨合商议出一套适合大家的规则。不过，如果你用的是 Vue2，我这里可以推荐 2 套 extends 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Vue 官方示例上的配置</span></span><br><span class="line">   <span class="keyword">extends</span>: [<span class="string">&#x27;eslint:recommended&#x27;</span>, <span class="string">&#x27;plugin:vue/recommended&#x27;</span>],</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 或者使用 AlloyTeam 团队那套</span></span><br><span class="line">   <span class="keyword">extends</span>: [<span class="string">&#x27;alloy&#x27;</span>, <span class="string">&#x27;alloy/vue&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置和插件对应的解析器</strong></p><p>如果是 Vue 2.x 项目，配置了 eslint-plugin-vue 插件和 extends 后，template 校验还是会失效，因为不管是 ESLint 默认的解析器 Espree 还是 babel-eslint 都只能解析 JS，无法解析 template 的内容。</p><p>而 vue-eslint-parser 只能解析 template 的内容，但是不会解析 JS，因此还需要对解析器做如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    parser: <span class="string">&#x27;vue-eslint-parser&#x27;</span>,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        parser: <span class="string">&#x27;babel-eslint&#x27;</span>,</span><br><span class="line">        ecmaVersion: <span class="number">12</span>,</span><br><span class="line">        sourceType: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;plugin:vue/recommended&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    plugins: [<span class="string">&#x27;vue&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://eslint.vuejs.org/user-guide/#faq" title="eslint-plugin-vue">eslint-plugin-vue faq</a></p><h3 id="让-Prettier-管控代码风格"><a href="#让-Prettier-管控代码风格" class="headerlink" title="让 Prettier 管控代码风格"></a>让 Prettier 管控代码风格</h3><p>针对 Prettier 不得不提出以下疑问？</p><ul><li>Prettier 是什么？</li><li>为什么有了 ESLint，还需要引入 Prettier 呢？它两之间有什么区别？</li><li>如何配置 Prettier？</li><li>Prettier 如何和 ESLint 结合使用？</li></ul><h4 id="Prettier-是什么"><a href="#Prettier-是什么" class="headerlink" title="Prettier 是什么"></a>Prettier 是什么</h4><p>用它自己的话来说：我是一个自以为是的<strong>代码格式化</strong>工具，而且我支持的文件类型很多，比如：</p><ul><li>JavaScript（包括实验中的特性）</li><li>JSX</li><li>Vue</li><li>TypeScript</li><li>CSS、Less、SCSS</li><li>HTML</li><li>JSON</li><li>Markdown</li></ul><p>以及还有一些其他类型的文件。</p><h4 id="Prettier-对比-ESLint"><a href="#Prettier-对比-ESLint" class="headerlink" title="Prettier 对比 ESLint"></a>Prettier 对比 ESLint</h4><p>我们知道 ESLint 负责了对代码的校验功能，并且主要提供了 2 类规则：</p><ul><li>检查格式化的规则</li><li>检查代码质量的规则</li></ul><p>说到底 ESLint 就是通过一条条的规则去限制代码的规范，但是这些规则毕竟是有限的，而且更重要的是这些规则的重点并不在代码风格上，所以单凭 ESLint 并不能完全的统一代码风格。</p><p>这个时候就需要引入 Prettier 了，因为它干的事就是只管代码格式化，不管代码质量。</p><blockquote><p>Prettier：在代码风格这一块，我一直拿捏的死死的。</p></blockquote><h4 id="如何配置-Prettier"><a href="#如何配置-Prettier" class="headerlink" title="如何配置 Prettier"></a>如何配置 Prettier</h4><p>初始化操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">npm i prettier -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建 .prettierrc.js</span></span><br><span class="line"><span class="built_in">echo</span> module.exports = &#123;&#125; &gt; .prettierrc.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建 .prettierignore</span></span><br><span class="line"><span class="built_in">echo</span> &gt; .prettierignore</span><br></pre></td></tr></table></figure><p>Prettier 支持可以配置参数不多，总共才 21 个，这里是所有参数的说明 <a href="https://prettier.io/docs/en/options.html#print-width" title="prettier options">prettier options</a></p><p>所有参数都有默认值，也就是说即使你没有配置 .prettierrc.js，当你用 Prettier 去格式化代码的时候全部都会走默认配置。针对个别参数，你不想用默认设置的话，就可以在 .prettierrc.js 配置具体想要的值。</p><p>如下，把项目中会用到的参数进行一个说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  printWidth: <span class="number">80</span>, <span class="comment">//（默认值）单行代码超出 80 个字符自动换行</span></span><br><span class="line">  tabWidth: <span class="number">2</span>, <span class="comment">//（默认值）一个 tab 键缩进相当于 2 个空格</span></span><br><span class="line">  useTabs: <span class="literal">true</span>, <span class="comment">// 行缩进使用 tab 键代替空格</span></span><br><span class="line">  semi: <span class="literal">false</span>, <span class="comment">//（默认值）语句的末尾加上分号</span></span><br><span class="line">  singleQuote: <span class="literal">true</span>, <span class="comment">// 使用单引号</span></span><br><span class="line">  quoteProps: <span class="string">&#x27;as-needed&#x27;</span>, <span class="comment">//（默认值）仅仅当必须的时候才会加上双引号</span></span><br><span class="line">  jsxSingleQuote: <span class="literal">true</span>, <span class="comment">// 在 JSX 中使用单引号</span></span><br><span class="line">  trailingComma: <span class="string">&#x27;all&#x27;</span>, <span class="comment">// 不用在多行的逗号分隔的句法结构的最后一行的末尾加上逗号</span></span><br><span class="line">  bracketSpacing: <span class="literal">true</span>, <span class="comment">//（默认值）在括号和对象的文字之间加上一个空格</span></span><br><span class="line">  jsxBracketSameLine: <span class="literal">true</span>, <span class="comment">// 把 &gt; 符号放在多行的 JSX 元素的最后一行</span></span><br><span class="line">  arrowParens: <span class="string">&#x27;avoid&#x27;</span>, <span class="comment">// 当箭头函数中只有一个参数的时候可以忽略括弧</span></span><br><span class="line">  htmlWhitespaceSensitivity: <span class="string">&#x27;ignore&#x27;</span>, <span class="comment">// vue template 中的结束标签结尾尖括号掉到了下一行</span></span><br><span class="line">  vueIndentScriptAndStyle: <span class="literal">false</span>, <span class="comment">//（默认值）对于 .vue 文件，不缩进 &lt;script&gt; 和 &lt;style&gt; 里的内容</span></span><br><span class="line">  embeddedLanguageFormatting: <span class="string">&#x27;auto&#x27;</span>, <span class="comment">//（默认值）允许自动格式化内嵌的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩展阅读：关于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas#trailing_commas_in_functions" title="Trailing commas">Trailing commas</a> 你或许想了解更多。</p></blockquote><p>然后可以通过命令来格式化代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将格式化当前目录及子目录下所有文件</span></span><br><span class="line">npx prettier --write .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查某个文件是否已经格式化</span></span><br><span class="line">npx prettier --check src/main.js</span><br></pre></td></tr></table></figure><p>如果有些文件不想被 Prettier 格式化，可以将其写入到 .prettierignore 里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;</span><br><span class="line">package.json</span><br><span class="line">public&#x2F;</span><br><span class="line">test&#x2F;*.*</span><br></pre></td></tr></table></figure><h4 id="Prettier-和-ESLint-一起干活更配哦"><a href="#Prettier-和-ESLint-一起干活更配哦" class="headerlink" title="Prettier 和 ESLint 一起干活更配哦"></a>Prettier 和 ESLint 一起干活更配哦</h4><p>上面介绍了 Prettier 的具体配置，这里主要介绍和 ESLint 结合使用的配置和注意事项。</p><p>和 ESLint 配合使用需要用到 eslint-plugin-prettier 这个插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint-plugin-prettier -D</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    plugins: [<span class="string">&#x27;prettier&#x27;</span>],</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个插件的工作原理是先调用 Prettier 对你的代码进行格式化，然后会把格式化前后不一致的地方进行标记，通过配置 ‘prettier/prettier’: ‘error’ 此条规则会将标记地方进行 error 级别的报错提示，然后可以通过 ESLint 的 –fix 自动修复功能将其修复。</p><p><strong>冲突了怎么办</strong></p><p>通过前面的介绍，我们知道 ESLint 也是会对代码风格做一些限制的，而 Prettier 主要就是规范代码风格，所以在把它们结合一起使用的时候是存会在一些问题的。对于个别规则，会使得双方在校验后出现代码格式不一致的问题。</p><p>那么当 Prettier 和 ESLint 出现冲突之后，该怎么办呢？</p><p>用 Prettier 的话来说很简单，只要使用 eslint-config-prettier 就可以了。解决冲突的思路就是通过将这个包提供的扩展放到 extends 最后面引入，依据 rules 生效的优先级，所以它会覆盖前面起冲突的规则，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;prettier&#x27;</span>,  <span class="comment">// 必须放最后</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了能覆盖和 ESLint 中起冲突的规则之外，eslint-config-prettier 还能覆盖来自以下插件的规则（只列了部分）：</p><ul><li>eslint-plugin-standard</li><li>eslint-plugin-vue</li></ul><p>那 eslint-config-prettier 到底提供了哪些覆盖规则呢？直接看这个列表：<a href="https://github.com/prettier/eslint-config-prettier/blob/main/index.js">eslint-config-prettier rules</a></p><p>如果想覆盖某些插件的规则，需要引入对应插件的扩展，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;plugin:vue/recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;prettier/standard&#x27;</span>,      <span class="comment">// 覆盖 eslint-config-stanard</span></span><br><span class="line">        <span class="string">&#x27;prettier/vue&#x27;</span>,           <span class="comment">// 覆盖 eslint-plugin-vue</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示：在 eslint-config-prettier 8.0.0 版本后，extends 不再需要为单独的插件引入对应扩展来覆盖冲突了，统一引入 ‘prettier’ 即可。</p></blockquote><p>如果同时使用了 eslint-plugin-prettier 和 eslint-config-prettier 可以这么配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [<span class="string">&#x27;plugin:prettier/recommended&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实和下面这些配置是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [<span class="string">&#x27;prettier&#x27;</span>],  <span class="comment">// eslint-config-prettier 提供的，用于覆盖起冲突的规则</span></span><br><span class="line">    plugins: [<span class="string">&#x27;prettier&#x27;</span>],  <span class="comment">// 注册 eslint-plugin-prettier 插件</span></span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;arrow-body-style&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;prefer-arrow-callback&#x27;</span>: <span class="string">&#x27;off&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果是在 Vue 2 项目中配置 ESLint 和 Prettier 会这么配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    parser: <span class="string">&#x27;vue-eslint-parser&#x27;</span>,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        parser: <span class="string">&#x27;babel-eslint&#x27;</span>,</span><br><span class="line">        ecmaVersion: <span class="number">12</span>,</span><br><span class="line">        sourceType: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;plugin:vue/recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>,  <span class="comment">// 在前面 Vue 配置的基础上加上这行</span></span><br><span class="line">    ],</span><br><span class="line">    plugins: [<span class="string">&#x27;vue&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果你的项目是用 vue-cli 初始化的，且选择了 eslint + prettier 方案的话，生成的项目中，.eslintrc.js 配置文件中 extends 的配置是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;plugin:vue/essential&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;@vue/prettier&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的最后一项扩展是 @vue/prettier，这个对应的是 @vue/eslint-config-prettier 这个包，让我们看看这个包下面的 index.js 内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    plugins: [<span class="string">&#x27;prettier&#x27;</span>],</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="built_in">require</span>.resolve(<span class="string">&#x27;eslint-config-prettier&#x27;</span>),</span><br><span class="line">        <span class="built_in">require</span>.resolve(<span class="string">&#x27;eslint-config-prettier/vue&#x27;</span>)</span><br><span class="line">    ],</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和我们上面配置的内容是相差无几的，而引入 eslint-config-prettier/vue 是因为这个 @vue/eslint-config-prettier 包依赖的 eslint-config-prettier 版本是 ^6.0.0 版本的，所以在处理冲突的时候需要特别指定和对应类型插件匹配的扩展。</p><h3 id="让-EditorConfig-助力多编辑器开发吧"><a href="#让-EditorConfig-助力多编辑器开发吧" class="headerlink" title="让 EditorConfig 助力多编辑器开发吧"></a>让 EditorConfig 助力多编辑器开发吧</h3><p><a href="https://editorconfig.org/" title="EditorConfig">EditorConfig</a> 是个啥玩意？<br>它可以对多种类型的单文件进行简单的格式化，它提供的配置参数很少：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告诉 EditorConfig 插件，这是根文件，不用继续往上查找</span></span><br><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配全部文件</span></span><br><span class="line">[*]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置字符集</span></span><br><span class="line">charset = utf-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进风格，可选 space、tab</span></span><br><span class="line">indent_style = tab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进的空格数，当 indent_style = tab 将使用 tab_width</span></span><br><span class="line"><span class="comment"># 否则使用 indent_size</span></span><br><span class="line">indent_size = 2</span><br><span class="line">tab_width = 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结尾换行符，可选 lf、cr、crlf</span></span><br><span class="line">end_of_line = lf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件结尾插入新行</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一行中的前后空格</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配md结尾的文件</span></span><br><span class="line">[*.md]</span><br><span class="line">insert_final_newline = <span class="literal">false</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>虽然它提供的格式化的配置参数很少，就 3 个，缩进风格、是否在文件末尾插入新行和是否删除一行中前后空格。但是它还是非常有必要存在的，理由有 3 个：</p><ul><li>能够在不同的编辑器和 IDE 中保持一致的代码风格；</li><li>配合插件打开文件即自动格式化，非常方便</li><li>支持格式化的文件类型很多；</li></ul><p>如果需要让以上的配置生效，还得在 VSCode 里安装 EditorConfig for VS Code 这个插件配合使用。</p><p><strong>重点来了</strong></p><p>可以看到 EditorConfig 和 Prettier 会存在一些重复的配置，比如都提供了对缩进的配置参数，所以在实际使用的时候需要避免它们，或者把他们的参数设置为一致。</p><h3 id="在-VSCode-中支持-ESLint"><a href="#在-VSCode-中支持-ESLint" class="headerlink" title="在 VSCode 中支持 ESLint"></a>在 VSCode 中支持 ESLint</h3><p>前面做的配置，都需要执行命令才能进行检查和修复代码，还是挺不方便的，如果我希望编辑完或者保存的时候去检查代码该如何做呢？可以直接在 IDE 里安装 ESLint 插件，因为我使用的是 VSCode，所以这里只介绍在 VSCode 中的配置。</p><p>在使用前，需要把 ESLint 扩展安装到 VSCode 里，这里我就不细说安装步骤了。<br>安装完成后，需要在设置里写入配置：</p><ul><li>在 VSCode 左下角找到一个齿轮 ⚙ 图标，点击后选择设置选项，这个时候打开了设置面板；</li><li>然后在 VSCode 右上角找到打开设置（json）的图标，点击后，会打开 settings.json 文件；</li><li>然后把以下配置贴进去即可；</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;eslint.alwaysShowStatus&quot;</span>: <span class="literal">true</span>, <span class="comment">// 总是在 VSCode 显示 ESLint 的状态</span></span><br><span class="line">  <span class="attr">&quot;eslint.quiet&quot;</span>: <span class="literal">true</span>, <span class="comment">// 忽略 warning 的错误</span></span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 保存时使用 ESLint 修复可修复错误</span></span><br><span class="line">    <span class="attr">&quot;source.fixAll&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置说明，在 ESLint 2.0.4 版本开始：</p><ul><li>不需要通过 eslint.validate 来指定校验的文件类型了，已经自动支持了 .vue 文件；</li><li>editor.codeActionsOnSave 开启保存自动修复功能；</li></ul><p>当这样配置之后呢，每次编辑代码 ESLint 都会实时校验代码，且当保存的时候会自动 fix，是不是很方便呢。不过对于有些无法自动 fix 的代码就需要你手动去修改了，如果不想修改的话就可以配置 rules 把该条规则给关闭掉。</p><p>其实在团队开发的时候，最好把针对 VSCode 的配置，写一个文件跟随着项目，一起提交到远程仓库，这样的话就保证了项目成员都是用的这套配置。比如可以在项目根目录新建 .vscode/settings.json，然后写入上面的那串配置内容。</p><h3 id="在提交前做校验-pre-commit"><a href="#在提交前做校验-pre-commit" class="headerlink" title="在提交前做校验 pre-commit"></a>在提交前做校验 pre-commit</h3><p>以上只是通过 ESLint 自动修复能够修复的错误以及通过 Prettier 进行代码的格式化，但是在实际开发的时候难免会遇到无法 fix 的错误，可能开发人员也忘记修改，如果这个时候把代码提交到远程仓库，那就把糟糕的代码给提交上去了。</p><p>那么如何杜绝把糟糕的代码提交上去呢？可以通过配置 git hooks 的 pre-commit 钩子来实现这个目的。主要是利用了 <a href="https://typicode.github.io/husky/#/?id=install" title="husky">husky</a> 和 <a href="https://github.com/okonet/lint-staged" title="lint-staged">lint-staged</a> 这 2 个包。husky 就是用来配置 git hooks 的，而 lint-staged 则是对拿到的 staged 文件进行处理，比如执行 npx eslint –fix 进行代码校验。</p><p>具体操作步骤如下：</p><p>1、执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx mrm lint-staged</span><br></pre></td></tr></table></figure><p>会自动安装 lint-staged 和 husky 并且在 package.json 里写入 lint-staged。</p><blockquote><p>注意：mrm 是一个自动化工具，它将根据 package.json 依赖项中的代码质量工具来安装和配置 husky 和 lint-staged，因此请确保在此之前安装并配置所有代码质量工具，如 Prettier 和 ESlint。</p></blockquote><p>如果上面顺利会在 package.json 里写入 lint-staged，可以自行修改让它支持 .vue 文件的校验：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;*.&#123;js,vue&#125;&quot;</span>: <span class="string">&quot;eslint --cache --fix&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、启动 git hooks</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky install</span><br></pre></td></tr></table></figure><p>经过上面的命令后，v6 版本的 husky 会在项目根目录新建一个 .husky 目录。如果是 v4 版本的则会写入到 package.json 里。</p><p>3、创建 pre-commit 钩子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit <span class="string">&quot;npx lint-staged&quot;</span></span><br></pre></td></tr></table></figure><p>到这里后，git commit 前自动执行代码校验和修复的功能就算完成了。然后你可以试试修改文件，然后提交试试。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202106/16231352077403.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章比较长，前前后后讲了很多代码校验的东西，现在我们来梳理下。</p><p>首先用 ESLint 来做代码校验，它自带的 ruels 能提供 2 种类型的校验，分别是代码错误校验和代码格式校验，而 ESLint 本身的核心工作其实就是校验和修复错误的代码，而对格式化的规则提供的不多。</p><p>所以如果想要对代码格式化进行一个更加精细的配置则需要借助 Prettier，因为它是只负责风格的管控，所以用它再适合不过了。但是如果把 ESLint 和 Prettier 结合起来一起使用的话，就可能会出现规则的冲突了，毕竟它们两者都会对风格进行处理，所以这个时候就可以通过 eslint-config-prettier 这个扩展来把冲突的规则进行关闭，这个扩展不仅可以关闭和 ESLint 内置规则的冲突，还可以关闭实际项目中引用到的扩展规则的冲突，比如和 Vue、React、TypeScript、Flow 的冲突。</p><p>在把 ESLint 和 Prettier 结合的时候，我们希望让 ESLint 来检查代码错误，而 Prettier 校验代码风格，那么这个时候其实是有 2 个任务的，需要用 2 条命令来处理的。但是有了 eslint-plugin-prettier 这个插件后就可以很方便的把它们结合起来，当需要校验代码错误的时候 ESLint 自动会给你校验，当然前提是 VSCode 里必须按照 ESLint 插件，而当需要校验代码风格的时候 ESLint 就会调用 Prettier 的能力进行代码风格的检查。</p><p>文章的后面分别又细说了 EditorConfig 和提交代码前校验的处理，这里就不多讲了。</p><p>看到这里希望你对代码校验和规范有一个新的认识，不过我最希望的是你能够自己动手为你的项目配置一套校验规则，如果不能成功，一定是我的文章写的有问题，欢迎评论区留言指出不足之处，我是大海我来了，下篇文章见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202106/eslint.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近遇到了一个老项目，比较有意思的是这个项目集前后端的代码于一起，而后端也会去修改前端代码，所以就出现了后端用 IntelliJ IDEA 来开发前端项目，而前端用 VSCode 来开发前端项目的情况。&lt;br&gt;于是乎，出现了代码规范的问题，所以就有了这篇文章，整理了一下前端代码校验以及在 Vue 项目中的实践。&lt;/p&gt;
&lt;p&gt;阅读完这篇文章，你可以收获：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够自己亲手写出一套 ESLint 配置；&lt;/li&gt;
&lt;li&gt;会知道业界都有哪些著名的 JS 代码规范，熟读它们可以让你写出更规范的代码；&lt;/li&gt;
&lt;li&gt;vue-cli 在初始化一个包含代码校验的项目时都做了什么；&lt;/li&gt;
&lt;li&gt;Prettier 是什么？为什么要使用它？如何与 ESLint 配合使用？&lt;/li&gt;
&lt;li&gt;EditorConfig 又是什么？如何使用？&lt;/li&gt;
&lt;li&gt;如何在 VSCode 中通过插件来协助代码校验工作；&lt;/li&gt;
&lt;li&gt;如何保证 push 到远程仓库的代码是符合规范的；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://bubuzou.com/categories/vue/"/>
    
    
      <category term="eslint" scheme="https://bubuzou.com/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>死磕 36 个 JS 手写题（搞懂后，提升真的大）</title>
    <link href="https://bubuzou.com/2021/04/02/write-js-hand-by-hand/"/>
    <id>https://bubuzou.com/2021/04/02/write-js-hand-by-hand/</id>
    <published>2021-04-02T09:30:05.000Z</published>
    <updated>2021-04-30T01:47:48.107Z</updated>
    
    <content type="html"><![CDATA[<p><strong>为什么要写这类文章</strong></p><p>作为一个程序员，代码能力毋庸置疑是非常非常重要的，就像现在为什么大厂面试基本都问什么 API 怎么实现可见其重要性。我想说的是居然手写这么重要，那我们就必须掌握它，所以文章标题用了死磕，一点也不过分，也希望不被认为是标题党。</p><p>作为一个普通前端，我是真的写不出 Promise A+ 规范，但是没关系，我们可以站在巨人的肩膀上，要相信我们现在要走的路，前人都走过，所以可以找找现在社区已经存在的那些优秀的文章，比如工业聚大佬写的 <a href="https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g">100 行代码实现 Promises/A+ 规范</a>，找到这些文章后不是收藏夹吃灰，得找个时间踏踏实实的学，一行一行的磨，直到搞懂为止。我现在就是这么干的。</p><p><strong>能收获什么</strong></p><p>这篇文章总体上分为 2 类手写题，前半部分可以归纳为是常见需求，后半部分则是对现有技术的实现；</p><ul><li>对常用的需求进行手写实现，比如数据类型判断函数、深拷贝等可以直接用于往后的项目中，提高了项目开发效率；</li><li>对现有关键字和 API 的实现，可能需要用到别的知识或 API，比如在写 forEach 的时候用到了无符号位右移的操作，平时都不怎么能够接触到这玩意，现在遇到了就可以顺手把它掌握了。所以手写这些实现能够潜移默化的扩展并巩固自己的 JS 基础；</li><li>通过写各种测试用例，你会知道各种 API 的边界情况，比如 Promise.all， 你得考虑到传入参数的各种情况，从而加深了对它们的理解及使用；</li></ul><p><strong>阅读的时候需要做什么</strong></p><p>阅读的时候，你需要把每行代码都看懂，知道它在干什么，为什么要这么写，能写得更好嘛？比如在写图片懒加载的时候，一般我们都是根据当前元素的位置和视口进行判断是否要加载这张图片，普通程序员写到这就差不多完成了。而大佬程序员则是会多考虑一些细节的东西，比如性能如何更优？代码如何更精简？比如 yeyan1996 写的图片懒加载就多考虑了 2 点：比如图片全部加载完成的时候得把事件监听给移除；比如加载完一张图片的时候，得把当前 img 从 imgList 里移除，起到优化内存的作用。</p><p>除了读通代码之外，还可以打开 Chrome 的 Script snippet 去写测试用例跑跑代码，做到更好的理解以及使用。</p><p>在看了几篇以及写了很多测试用例的前提下，尝试自己手写实现，看看自己到底掌握了多少。条条大路通罗马，你还能有别的方式实现嘛？或者你能写得比别人更好嘛？</p><p>好了，还楞着干啥，开始干活。</p><a id="more"></a><h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><p>typeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeOf</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line">typeOf([])        <span class="comment">// &#x27;array&#x27;</span></span><br><span class="line">typeOf(&#123;&#125;)        <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line">typeOf(<span class="keyword">new</span> <span class="built_in">Date</span>)  <span class="comment">// &#x27;date&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.colors</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Dog.prototype =  <span class="keyword">new</span> Animal()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog1 = <span class="keyword">new</span> Dog()</span><br><span class="line">dog1.colors.push(<span class="string">&#x27;brown&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> dog2 = <span class="keyword">new</span> Dog()</span><br><span class="line"><span class="built_in">console</span>.log(dog2.colors)  <span class="comment">// [&#x27;black&#x27;, &#x27;white&#x27;, &#x27;brown&#x27;]</span></span><br></pre></td></tr></table></figure><p>原型链继承存在的问题：</p><ul><li>问题1：原型中包含的引用类型属性将被所有实例共享；</li><li>问题2：子类在实例化的时候不能给父类构造函数传参；</li></ul><h3 id="借用构造函数实现继承"><a href="#借用构造函数实现继承" class="headerlink" title="借用构造函数实现继承"></a>借用构造函数实现继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="built_in">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype =  <span class="keyword">new</span> Animal()</span><br></pre></td></tr></table></figure><p>借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="built_in">this</span>, name)</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype =  <span class="keyword">new</span> Animal()</span><br><span class="line">Dog.prototype.constructor = Dog</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">&#x27;奶昔&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">dog1.colors.push(<span class="string">&#x27;brown&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">&#x27;哈赤&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(dog2) </span><br><span class="line"><span class="comment">// &#123; name: &quot;哈赤&quot;, colors: [&quot;black&quot;, &quot;white&quot;], age: 1 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承已经相对完善了，但还是存在问题，它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。</p><p>所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。</p><p>寄生式组合继承写法上和组合继承基本类似，区别是如下这里：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Dog.prototype =  new Animal()</span></span><br><span class="line"><span class="deletion">- Dog.prototype.constructor = Dog</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ function F() &#123;&#125;</span></span><br><span class="line"><span class="addition">+ F.prototype = Animal.prototype</span></span><br><span class="line"><span class="addition">+ let f = new F()</span></span><br><span class="line"><span class="addition">+ f.constructor = Dog</span></span><br><span class="line"><span class="addition">+ Dog.prototype = f</span></span><br></pre></td></tr></table></figure><p>稍微封装下上面添加的代码后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = object(parent.prototype)</span><br><span class="line">    prototype.constructor = child</span><br><span class="line">    child.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Dog, Animal)</span><br></pre></td></tr></table></figure><p>如果你嫌弃上面的代码太多了，还可以基于组合继承的代码改成最简单的寄生式组合继承：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Dog.prototype =  new Animal()</span></span><br><span class="line"><span class="deletion">- Dog.prototype.constructor = Dog</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ Dog.prototype =  Object.create(Animal.prototype)</span></span><br><span class="line"><span class="addition">+ Dog.prototype.constructor = Dog</span></span><br></pre></td></tr></table></figure><h3 id="class-实现继承"><a href="#class-实现继承" class="headerlink" title="class 实现继承"></a>class 实现继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125; </span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>ES5 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.indexOf(item) === index</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span> [...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="number">2</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>现在就是要实现 flat 这种效果。</p><p>ES5 实现：递归。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>浅拷贝：只考虑对象类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单版深拷贝：只考虑普通对象属性，不考虑内置对象和函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? deepClone(obj[key]) : obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂版深克隆：基于简单版的基础上，还考虑了内置对象比如 Date、RegExp 等对象和函数以及解决了循环引用的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> target === <span class="string">&quot;function&quot;</span>) &amp;&amp; target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target, map = new WeakMap()</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前值的构造函数：获取它的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">constructor</span> = target.<span class="keyword">constructor</span>;</span><br><span class="line">    // 检测当前对象target是否与正则、日期格式对象匹配</span><br><span class="line">    if (/^(RegExp|Date)$/i.test(<span class="keyword">constructor</span>.name)) &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的特殊对象(正则类/日期类)的实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">constructor</span>(target);  </span><br><span class="line">    &#125;</span><br><span class="line">    if (isObject(target)) &#123;</span><br><span class="line">        map.set(target, <span class="literal">true</span>);  <span class="comment">// 为循环引用的对象做标记</span></span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">                cloneTarget[prop] = deepClone(target[prop], map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件总线（发布订阅模式）"><a href="#事件总线（发布订阅模式）" class="headerlink" title="事件总线（发布订阅模式）"></a>事件总线（发布订阅模式）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.cache = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    on(name, fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cache[name]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.cache[name].push(fn)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cache[name] = [fn]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    off(name, fn) &#123;</span><br><span class="line">        <span class="keyword">let</span> tasks = <span class="built_in">this</span>.cache[name]</span><br><span class="line">        <span class="keyword">if</span> (tasks) &#123;</span><br><span class="line">            <span class="keyword">const</span> index = tasks.findIndex(<span class="function"><span class="params">f</span> =&gt;</span> f === fn || f.callback === fn)</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                tasks.splice(index, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    emit(name, once = <span class="literal">false</span>, ...args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cache[name]) &#123;</span><br><span class="line">            <span class="comment">// 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span></span><br><span class="line">            <span class="keyword">let</span> tasks = <span class="built_in">this</span>.cache[name].slice()</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> tasks) &#123;</span><br><span class="line">                fn(...args)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (once) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="built_in">this</span>.cache[name]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> eventBus = <span class="keyword">new</span> EventEmitter()</span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello, <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">eventBus.on(<span class="string">&#x27;aaa&#x27;</span>, fn1)</span><br><span class="line">eventBus.on(<span class="string">&#x27;aaa&#x27;</span>, fn2)</span><br><span class="line">eventBus.emit(<span class="string">&#x27;aaa&#x27;</span>, <span class="literal">false</span>, <span class="string">&#x27;布兰&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="comment">// &#x27;布兰 12&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;hello, 布兰 12&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="解析-URL-参数为对象"><a href="#解析-URL-参数为对象" class="headerlink" title="解析 URL 参数为对象"></a>解析 URL 参数为对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.exec(url)[<span class="number">1</span>]; <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">    <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">    <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">    paramsArr.forEach(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/=/</span>.test(param)) &#123; <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">            <span class="keyword">let</span> [key, val] = param.split(<span class="string">&#x27;=&#x27;</span>); <span class="comment">// 分割 key 和 value</span></span><br><span class="line">            val = <span class="built_in">decodeURIComponent</span>(val); <span class="comment">// 解码</span></span><br><span class="line">            val = <span class="regexp">/^\d+$/</span>.test(val) ? <span class="built_in">parseFloat</span>(val) : val; <span class="comment">// 判断是否转为数字</span></span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123; <span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">                paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">                paramsObj[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">            paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>; <span class="comment">// 模板字符串正则</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(template)) &#123; <span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">        <span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>]; <span class="comment">// 查找当前模板里第一个模板字符串的字段</span></span><br><span class="line">        template = template.replace(reg, data[name]); <span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">        <span class="keyword">return</span> render(template, data); <span class="comment">// 递归的渲染并返回渲染后的结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> template; <span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">&#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">render(template, person); <span class="comment">// 我是布兰，年龄12，性别undefined</span></span><br></pre></td></tr></table></figure><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>与普通的图片懒加载不同，如下这个多做了 2 个精心处理：</p><ul><li>图片全部加载完成后移除事件监听；</li><li>加载完的图片，从 imgList 移除；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imgList = [...document.querySelectorAll(<span class="string">&#x27;img&#x27;</span>)]</span><br><span class="line"><span class="keyword">let</span> length = imgList.length</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> imgLazyLoad = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> deleteIndexList = []</span><br><span class="line">        imgList.forEach(<span class="function">(<span class="params">img, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> rect = img.getBoundingClientRect()</span><br><span class="line">            <span class="keyword">if</span> (rect.top &lt; <span class="built_in">window</span>.innerHeight) &#123;</span><br><span class="line">                img.src = img.dataset.src</span><br><span class="line">                deleteIndexList.push(index)</span><br><span class="line">                count++</span><br><span class="line">                <span class="keyword">if</span> (count === length) &#123;</span><br><span class="line">                    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;scroll&#x27;</span>, imgLazyLoad)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        imgList = imgList.filter(<span class="function">(<span class="params">img, index</span>) =&gt;</span> !deleteIndexList.includes(index))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里最好加上防抖处理</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, imgLazyLoad)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.cn/post/6844903856489365518#heading-19" title="图片懒加载">图片懒加载</a></p><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。</p><p>简单版：函数内部支持使用 this 和 event 对象；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;layout&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, e)  <span class="comment">// 分别打印：node 这个节点 和 MouseEvent</span></span><br><span class="line">    node.innerHTML = count++;</span><br><span class="line">&#125;;</span><br><span class="line">node.onmousemove = debounce(getUserAction, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>最终版：除了支持 this 和 event 外，还支持以下功能：</p><ul><li>支持立即执行；</li><li>函数可能有返回值；</li><li>支持取消功能；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setUseAction = debounce(getUserAction, <span class="number">10000</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 使用防抖</span></span><br><span class="line">node.onmousemove = setUseAction</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消防抖</span></span><br><span class="line">setUseAction.cancel()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/22">JavaScript专题之跟着underscore学防抖</a></p><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>触发高频事件，且 N 秒内只执行一次。</p><p>简单版：使用时间戳来实现，立即执行一次，然后每 N 秒执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        context = <span class="built_in">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终版：支持取消节流；另外通过传入第三个参数，options.leading 来表示是否可以立即执行一次，opitons.trailing 表示结束调用的时候是否还要执行一次，默认都是 true。<br>注意设置的时候不能同时将 leading 或 trailing 设置为 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="built_in">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        previous = <span class="number">0</span>;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节流的使用就不拿代码举例了，参考防抖的写就行。</p><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/26">JavaScript专题之跟着 underscore 学节流</a></p><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。还不懂？来举个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> addCurry = curry(add)</span><br><span class="line">addCurry(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>现在就是要实现 curry 这个函数，使函数从一次调用传入多个参数变成多次调用每次传一个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> judge = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == fn.length) <span class="keyword">return</span> fn(...args)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> judge(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> partialAdd = partial(add, <span class="number">1</span>)</span><br><span class="line">partialAdd(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>发现没有，其实偏函数和函数柯里化有点像，所以根据函数柯里化的实现，能够能很快写出偏函数的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上这个功能比较简单，现在我们希望偏函数能和柯里化一样能实现占位功能，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clg</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> partialClg = partial(clg, <span class="string">&#x27;_&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">partialClg(<span class="number">1</span>, <span class="number">3</span>)  <span class="comment">// 依次打印：1, 2, 3</span></span><br></pre></td></tr></table></figure><p><code>_</code> 占的位其实就是 1 的位置。相当于：partial(clg, 1, 2)，然后 partialClg(3)。明白了原理，我们就来写实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        args[index] = </span><br><span class="line">        <span class="keyword">return</span> fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 核心原理：script 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> generateUrl = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dataSrc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params.hasOwnProperty(key)) &#123;</span><br><span class="line">                dataSrc += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dataSrc += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataSrc&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">        scriptEle.src = generateUrl()</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(scriptEle)</span><br><span class="line">        <span class="built_in">window</span>[callbackName] = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            <span class="built_in">document</span>.removeChild(scriptEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Mscrosoft.XMLHttp&#x27;</span>);</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">false</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                resolve(xhr.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.responseText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现数组原型方法"><a href="#实现数组原型方法" class="headerlink" title="实现数组原型方法"></a>实现数组原型方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach2 = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)  <span class="comment">// this 就是当前的数组</span></span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">// 后面有解释</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            callback.call(thisArg, O[k], k, O);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#polyfill" title="forEach#polyfill">forEach#polyfill</a></p><p>O.length &gt;&gt;&gt; 0 是什么操作？就是无符号右移 0 位，那有什么意义嘛？就是为了保证转换后的值为正整数。其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。感兴趣可以阅读 <a href="https://zhuanlan.zhihu.com/p/100790268" title="something &gt;&gt;&gt; 0是什么意思">something &gt;&gt;&gt; 0是什么意思?</a>。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>基于 forEach 的实现能够很容易写出 map 的实现：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span></span><br><span class="line"><span class="addition">+ Array.prototype.map2 = function(callback, thisArg) &#123;</span></span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&#x27;this is null or not defined&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &#x27; is not a function&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line"><span class="deletion">-   let k = 0</span></span><br><span class="line"><span class="addition">+   let k = 0, res = []</span></span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line"><span class="deletion">-           callback.call(thisArg, O[k], k, O);</span></span><br><span class="line"><span class="addition">+           res[k] = callback.call(thisArg, O[k], k, O);</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+   return res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>同样，基于 forEach 的实现能够很容易写出 filter 的实现：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span></span><br><span class="line"><span class="addition">+ Array.prototype.filter2 = function(callback, thisArg) &#123;</span></span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&#x27;this is null or not defined&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &#x27; is not a function&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line"><span class="deletion">-   let k = 0</span></span><br><span class="line"><span class="addition">+   let k = 0, res = []</span></span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line"><span class="deletion">-           callback.call(thisArg, O[k], k, O);</span></span><br><span class="line"><span class="addition">+           if (callback.call(thisArg, O[k], k, O)) &#123;</span></span><br><span class="line"><span class="addition">+               res.push(O[k])                </span></span><br><span class="line"><span class="addition">+           &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+   return res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>同样，基于 forEach 的实现能够很容易写出 some 的实现：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span></span><br><span class="line"><span class="addition">+ Array.prototype.some2 = function(callback, thisArg) &#123;</span></span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&#x27;this is null or not defined&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &#x27; is not a function&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">    let k = 0</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line"><span class="deletion">-           callback.call(thisArg, O[k], k, O);</span></span><br><span class="line"><span class="addition">+           if (callback.call(thisArg, O[k], k, O)) &#123;</span></span><br><span class="line"><span class="addition">+               return true</span></span><br><span class="line"><span class="addition">+           &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+   return false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce2 = <span class="function"><span class="keyword">function</span>(<span class="params">callback, initialValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>, acc</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        acc = initialValue</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没传入初始值的时候，取数组中第一个非 empty 的值为初始值</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; len &amp;&amp; !(k <span class="keyword">in</span> O)) &#123;</span><br><span class="line">            k++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; len) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>( <span class="string">&#x27;Reduce of empty array with no initial value&#x27;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        acc = O[k++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            acc = callback(acc, O[k], k, O)</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现函数原型方法"><a href="#实现函数原型方法" class="headerlink" title="实现函数原型方法"></a>实现函数原型方法</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>使用一个指定的 this 值和一个或多个参数来调用一个函数。</p><p>实现要点：</p><ul><li>this 可能传入 null；</li><li>传入不固定个数的参数；</li><li>函数可能有返回值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply 和 call 一样，唯一的区别就是 call 是传入不固定个数的参数，而 apply 是传入一个数组。</p><p>实现要点：</p><ul><li>this 可能传入 null；</li><li>传入一个数组；</li><li>函数可能有返回值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="string">&#x27;arr[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind 方法会创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><p>实现要点：</p><ul><li>bind() 除了 this 外，还可传入多个参数；</li><li>bing 创建的新函数可能传入多个参数；</li><li>新函数可能被当做构造函数调用；</li><li>函数可能有返回值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-new-关键字"><a href="#实现-new-关键字" class="headerlink" title="实现 new 关键字"></a>实现 new 关键字</h2><p>new 运算符用来创建用户自定义的对象类型的实例或者具有构造函数的内置对象的实例。</p><p>实现要点：</p><ul><li>new 会产生一个新对象；</li><li>新对象需要能够访问到构造函数的属性，所以需要重新指定它的原型；</li><li>构造函数可能会显示返回；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ret || obj 这里这么写考虑了构造函数显示返回 null 的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> ? ret || obj : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = objectFactory(person, <span class="string">&#x27;布兰&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="实现-instanceof-关键字"><a href="#实现-instanceof-关键字" class="headerlink" title="实现 instanceof 关键字"></a>实现 instanceof 关键字</h2><p>instanceof 就是判断构造函数的 prototype 属性是否出现在实例的原型链上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = left.__proto__</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (proto === right.prototype) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        proto = proto.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 left.<strong>proto</strong> 这种写法可以换成 Object.getPrototypeOf(left)。</p><h2 id="实现-Object-create"><a href="#实现-Object-create" class="headerlink" title="实现 Object.create"></a>实现 Object.create</h2><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create2 = <span class="function"><span class="keyword">function</span>(<span class="params">proto, propertyObject = undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Object prototype may only be an Object or null.&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (propertyObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = proto</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="keyword">new</span> F()</span><br><span class="line">    <span class="keyword">if</span> (propertyObject != <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(obj, propertyObject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个没有原型对象的对象，Object.create(null)</span></span><br><span class="line">        obj.__proto__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-Object-assign"><a href="#实现-Object-assign" class="headerlink" title="实现 Object.assign"></a>实现 Object.assign</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign2 = <span class="function"><span class="keyword">function</span>(<span class="params">target, ...source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="built_in">Object</span>(target) </span><br><span class="line">    source.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                    ret[key] = obj[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-JSON-stringify"><a href="#实现-JSON-stringify" class="headerlink" title="实现 JSON.stringify"></a>实现 JSON.stringify</h2><p>JSON.stringify([, replacer [, space]) 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 replacer 和第三个参数 space，如果对这两个参数的作用还不了解，建议阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" title="stringify">MDN</a> 文档。</p><ol><li>基本数据类型：<ul><li>undefined 转换之后仍是 undefined(类型也是 undefined)</li><li>boolean 值转换之后是字符串 “false”/“true”</li><li>number 类型(除了 NaN 和 Infinity)转换之后是字符串类型的数值</li><li>symbol 转换之后是 undefined</li><li>null 转换之后是字符串 “null”</li><li>string 转换之后仍是string</li><li>NaN 和 Infinity 转换之后是字符串 “null”</li></ul></li><li>函数类型：转换之后是 undefined</li><li>如果是对象类型(非函数)<ul><li>如果是一个数组：如果属性值中出现了 undefined、任意的函数以及 symbol，转换成字符串 “null” ；</li><li>如果是 RegExp 对象：返回 {} (类型是 string)；</li><li>如果是 Date 对象，返回 Date 的 toJSON 字符串值；</li><li>如果是普通对象；<ul><li>如果有 toJSON() 方法，那么序列化 toJSON() 的返回值。</li><li>如果属性值中出现了 undefined、任意的函数以及 symbol 值，忽略。</li><li>所有以 symbol 为属性键的属性都会被完全忽略掉。</li></ul></li></ul></li><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataType = <span class="keyword">typeof</span> data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dataType !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = data;</span><br><span class="line">        <span class="comment">//data 可能是 string/number/null/undefined/boolean</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(data) || data === <span class="literal">Infinity</span>) &#123;</span><br><span class="line">            <span class="comment">//NaN 和 Infinity 序列化返回 &quot;null&quot;</span></span><br><span class="line">            result = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&#x27;function&#x27;</span> || dataType === <span class="string">&#x27;undefined&#x27;</span> || dataType === <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//function 、undefined 、symbol 序列化返回 undefined</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            result = <span class="string">&#x27;&quot;&#x27;</span> + data + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//boolean 返回 String()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.toJSON &amp;&amp; <span class="keyword">typeof</span> data.toJSON === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> jsonStringify(data.toJSON());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> result = [];</span><br><span class="line">            <span class="comment">//如果是数组</span></span><br><span class="line">            <span class="comment">//toJSON 方法可以存在于原型链中</span></span><br><span class="line">            data.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&#x27;undefined&#x27;</span> || <span class="keyword">typeof</span> item === <span class="string">&#x27;function&#x27;</span> || <span class="keyword">typeof</span> item === <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">                    result[index] = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result[index] = jsonStringify(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            result = <span class="string">&quot;[&quot;</span> + result + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> result.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//普通对象</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 循环引用抛错(暂未检测，循环引用时，堆栈溢出)</span></span><br><span class="line"><span class="comment">             * symbol key 忽略</span></span><br><span class="line"><span class="comment">             * undefined、函数、symbol 为属性值，被忽略</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">let</span> result = [];</span><br><span class="line">            <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">//key 如果是symbol对象，忽略</span></span><br><span class="line">                    <span class="keyword">if</span> (data[item] !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> data[item] !== <span class="string">&#x27;function&#x27;</span></span><br><span class="line">                        &amp;&amp; <span class="keyword">typeof</span> data[item] !== <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">//键值如果是 undefined、函数、symbol 为属性值，忽略</span></span><br><span class="line">                        result.push(<span class="string">&#x27;&quot;&#x27;</span> + item + <span class="string">&#x27;&quot;&#x27;</span> + <span class="string">&quot;:&quot;</span> + jsonStringify(data[item]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;&#123;&quot;</span> + result + <span class="string">&quot;&#125;&quot;</span>).replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/YvetteLau/Step-By-Step/issues/39#issuecomment-508327280" title="实现 JSON.stringify">实现 JSON.stringify</a></p><h2 id="实现-JSON-parse"><a href="#实现-JSON-parse" class="headerlink" title="实现 JSON.parse"></a>实现 JSON.parse</h2><p>介绍 2 种方法实现：</p><ul><li>eval 实现；</li><li>new Function 实现；</li></ul><h3 id="eval-实现"><a href="#eval-实现" class="headerlink" title="eval 实现"></a>eval 实现</h3><p>第一种方式最简单，也最直观，就是直接调用 eval，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + json + <span class="string">&quot;)&quot;</span>);  <span class="comment">// obj 就是 json 反序列化之后得到的对象</span></span><br></pre></td></tr></table></figure><p>但是直接调用 eval 会存在安全问题，如果数据中可能不是 json 数据，而是可执行的 JavaScript 代码，那很可能会造成 XSS 攻击。因此，在调用 eval 之前，需要对数据进行校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    rx_one.test(</span><br><span class="line">        json.replace(rx_two, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            .replace(rx_three, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">            .replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> +json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/youngwind/blog/issues/115#issue-300869613" title="JSON.parse 三种实现方式">JSON.parse 三种实现方式</a></p><h3 id="new-Function-实现"><a href="#new-Function-实现" class="headerlink" title="new Function 实现"></a>new Function 实现</h3><p>Function 与 eval 有相同的字符串参数特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = (<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + json))();</span><br></pre></td></tr></table></figure><h2 id="实现-Promise"><a href="#实现-Promise" class="headerlink" title="实现 Promise"></a>实现 Promise</h2><p>实现 Promise 需要完全读懂 <a href="https://promisesaplus.com/" title="Promise A+ 规范">Promise A+ 规范</a>，不过从总体的实现上看，有如下几个点需要考虑到：</p><ul><li>then 需要支持链式调用，所以得返回一个新的 Promise；</li><li>处理异步问题，所以得先用 onResolvedCallbacks 和 onRejectedCallbacks 分别把成功和失败的回调存起来；</li><li>为了让链式调用正常进行下去，需要判断 onFulfilled 和 onRejected 的类型；</li><li>onFulfilled 和 onRejected 需要被异步调用，这里用 setTimeout 模拟异步；</li><li>处理 Promise 的 resolve；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> resolve = (value) = &gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.value = value;</span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.forEach((fn) = &gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> reject = (reason) = &gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.reason = reason;</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach((fn) = &gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 解决 onFufilled，onRejected 没有传值的问题</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : (v) = &gt; v;</span><br><span class="line">        <span class="comment">// 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获</span></span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span> ? onRejected : (err) = &gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 每次调用 then 都返回一个新的 promise</span></span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) = &gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">                <span class="comment">//Promise/A+ 2.2.4 --- setTimeout</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        <span class="comment">// x可能是一个proimise</span></span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">                <span class="comment">//Promise/A+ 2.2.3</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.push(() = &gt; &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            </span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(() = &gt; &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> resolvePromise = (promise2, x, resolve, reject) = &gt; &#123;</span><br><span class="line">    <span class="comment">// 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Promise/A+ 2.3.3.3.3 只能调用一次</span></span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line">    <span class="comment">// 后续的条件要严格判断 保证代码能和别的库一起使用</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> &amp;&amp; x != <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3</span></span><br><span class="line">                then.call(</span><br><span class="line">                    x, (y) = &gt; &#123;</span><br><span class="line">                        <span class="comment">// 根据 promise 的状态决定是成功还是失败</span></span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1</span></span><br><span class="line">                        resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                    &#125;, (r) = &gt; &#123;</span><br><span class="line">                        <span class="comment">// 只要失败就失败 Promise/A+ 2.3.3.3.2</span></span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        reject(r);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4</span></span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// Promise/A+ 2.3.3.2</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4</span></span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Promise 写完之后可以通过 promises-aplus-tests 这个包对我们写的代码进行测试，看是否符合 A+ 规范。不过测试前还得加一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="comment">// 这里是上面写的 Promise 全部代码</span></span><br><span class="line"><span class="built_in">Promise</span>.defer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全局安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i promises-aplus-tests -g</span><br></pre></td></tr></table></figure><p>终端下执行验证命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests promise.js</span><br></pre></td></tr></table></figure><p>上面写的代码可以顺利通过全部 872 个测试用例。</p><p>参考：</p><ul><li><a href="https://juejin.cn/post/6844903625769091079" title="BAT前端经典面试问题：史上最最最详细的手写Promise教程">BAT前端经典面试问题：史上最最最详细的手写Promise教程</a></li><li><a href="https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g" title="100 行代码实现 Promises/A+ 规范">100 行代码实现 Promises/A+ 规范</a></li></ul><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是 Promsie，则直接输出它</span></span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://bubuzou.com/2020/10/22/promise/" title="深入理解 Promise">深入理解 Promise</a></p><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 的规则是这样的：</p><ul><li>传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；</li><li>只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；</li><li>只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>, result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                index++</span><br><span class="line">                result[i] = val</span><br><span class="line">                <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                rejecte(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>Promise.allSettled 的规则是这样：</p><ul><li>所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise，且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象；</li><li>如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    status: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                    value: val</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">if</span> (result.length === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    status: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                    reason: err</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">if</span> (result.length === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>Promise.any 的规则是这样：</p><ul><li>空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；</li><li>只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；</li><li>其他情况都会返回一个 pending 的新实例；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (promiseArr.length === <span class="number">0</span>) <span class="keyword">return</span> </span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">                </span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                index++</span><br><span class="line">                <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                  reject(<span class="keyword">new</span> AggregateError(<span class="string">&#x27;All promises were rejected&#x27;</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>能看到这里的对代码都是真爱了，毕竟代码这玩意看起来是真的很枯燥，但是如果看懂了后，就会像打游戏赢了一样开心，而且这玩意会上瘾，当你通关了越多的关卡后，你的能力就会拔高一个层次。用标题的话来说就是：搞懂后，提升真的大。加油吧💪，干饭人</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202104/16172447086022.jpg" alt="-w117"></p><p>噢不，代码人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;为什么要写这类文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个程序员，代码能力毋庸置疑是非常非常重要的，就像现在为什么大厂面试基本都问什么 API 怎么实现可见其重要性。我想说的是居然手写这么重要，那我们就必须掌握它，所以文章标题用了死磕，一点也不过分，也希望不被认为是标题党。&lt;/p&gt;
&lt;p&gt;作为一个普通前端，我是真的写不出 Promise A+ 规范，但是没关系，我们可以站在巨人的肩膀上，要相信我们现在要走的路，前人都走过，所以可以找找现在社区已经存在的那些优秀的文章，比如工业聚大佬写的 &lt;a href=&quot;https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g&quot;&gt;100 行代码实现 Promises/A+ 规范&lt;/a&gt;，找到这些文章后不是收藏夹吃灰，得找个时间踏踏实实的学，一行一行的磨，直到搞懂为止。我现在就是这么干的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;能收获什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇文章总体上分为 2 类手写题，前半部分可以归纳为是常见需求，后半部分则是对现有技术的实现；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对常用的需求进行手写实现，比如数据类型判断函数、深拷贝等可以直接用于往后的项目中，提高了项目开发效率；&lt;/li&gt;
&lt;li&gt;对现有关键字和 API 的实现，可能需要用到别的知识或 API，比如在写 forEach 的时候用到了无符号位右移的操作，平时都不怎么能够接触到这玩意，现在遇到了就可以顺手把它掌握了。所以手写这些实现能够潜移默化的扩展并巩固自己的 JS 基础；&lt;/li&gt;
&lt;li&gt;通过写各种测试用例，你会知道各种 API 的边界情况，比如 Promise.all， 你得考虑到传入参数的各种情况，从而加深了对它们的理解及使用；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;阅读的时候需要做什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;阅读的时候，你需要把每行代码都看懂，知道它在干什么，为什么要这么写，能写得更好嘛？比如在写图片懒加载的时候，一般我们都是根据当前元素的位置和视口进行判断是否要加载这张图片，普通程序员写到这就差不多完成了。而大佬程序员则是会多考虑一些细节的东西，比如性能如何更优？代码如何更精简？比如 yeyan1996 写的图片懒加载就多考虑了 2 点：比如图片全部加载完成的时候得把事件监听给移除；比如加载完一张图片的时候，得把当前 img 从 imgList 里移除，起到优化内存的作用。&lt;/p&gt;
&lt;p&gt;除了读通代码之外，还可以打开 Chrome 的 Script snippet 去写测试用例跑跑代码，做到更好的理解以及使用。&lt;/p&gt;
&lt;p&gt;在看了几篇以及写了很多测试用例的前提下，尝试自己手写实现，看看自己到底掌握了多少。条条大路通罗马，你还能有别的方式实现嘛？或者你能写得比别人更好嘛？&lt;/p&gt;
&lt;p&gt;好了，还楞着干啥，开始干活。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>1.5 万字 CSS 基础拾遗（核心知识、常用需求）</title>
    <link href="https://bubuzou.com/2021/03/22/css_base/"/>
    <id>https://bubuzou.com/2021/03/22/css_base/</id>
    <published>2021-03-22T01:20:26.000Z</published>
    <updated>2021-09-06T09:56:22.607Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章围绕了 CSS 的核心知识点和项目中常见的需求来展开。虽然行文偏长，但偏基础，适合初级中级前端阅读，阅读的时候请适当跳过已经掌握的部分。</p><p>这篇文章断断续续写了比较久，也参考了许多优秀的文章，但或许文章里还是存在不好或不对的地方，请多多指教，可以评论里直接提出来哈。</p><p>小 tip：后续内容更精彩哦。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/cssxm.png"></p><a id="more"></a><h2 id="核心概念和知识点"><a href="#核心概念和知识点" class="headerlink" title="核心概念和知识点"></a>核心概念和知识点</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>CSS 的核心功能是将 CSS 属性设定为特定的值。一个属性与值的键值对被称为<strong>声明</strong>（declaration）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br></pre></td></tr></table></figure><p>而如果将一个或者多个声明用 <code>&#123;&#125;</code> 包裹起来后，那就组成了一个<strong>声明块</strong>（declaration block）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明块如果需要作用到对应的 HTML 元素，那还需要加上<strong>选择器</strong>。选择器和声明块组成了<strong>CSS 规则集</strong>（CSS ruleset），常简称为 CSS 规则。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css001.png"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>规则集中最后一条声明可以省略分号，但是并不建议这么做，因为容易出错。</p></blockquote><p>CSS 中的<strong>注释</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 单行注释 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多行</span></span><br><span class="line"><span class="comment">    注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 CSS 文件中，除了注释、CSS 规则集以及 @规则 外，定义的一些别的东西都将被浏览器忽略。</p><h3 id="规则"><a href="#规则" class="headerlink" title="@规则"></a>@规则</h3><p>CSS 规则是样式表的主体，通常样式表会包括大量的规则列表。但有时候也需要在样式表中包括其他的一些信息，比如字符集，导入其它的外部样式表，字体等，这些需要专门的语句表示。</p><p>而 @规则 就是这样的语句。CSS 里包含了以下 @规则：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@namespace">@namespace</a> 告诉 CSS 引擎必须考虑 XML 命名空间。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">@media</a>, 如果满足媒体查询的条件则条件规则组里的规则生效。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@page">@page</a>, 描述打印文档时布局的变化.</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">@font-face</a>, 描述将下载的外部的字体。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes">@keyframes</a>, 描述 CSS 动画的关键帧。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@document">@document</a>, 如果文档样式表满足给定条件则条件规则组里的规则生效。 (推延至 CSS Level 4 规范)</li></ul><p>除了以上这几个之外，下面还将对几个比较生涩的 @规则 进行介绍。</p><h4 id="charset"><a href="#charset" class="headerlink" title="@charset"></a>@charset</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset" title="@charset">@charset</a> 用于定义样式表使用的字符集。它必须是样式表中的第一个元素。如果有多个 <code>@charset</code> 被声明，只有第一个会被使用，而且不能在 HTML 元素或 HTML 页面的 <code>&lt;style&gt;</code> 元素内使用。</p><p>注意：值必须是双引号包裹，且和</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br></pre></td></tr></table></figure><p>平时写样式文件都没写 @charset 规则，那这个 CSS 文件到底是用的什么字符编码的呢？</p><p>某个样式表文件到底用的是什么字符编码，浏览器有一套识别顺序（优先级由高到低）：</p><ul><li><p>文件开头的 <a href="https://en.wikipedia.org/wiki/Byte_order_mark" title="Byte order mark">Byte order mark</a> 字符值，不过一般编辑器并不能看到文件头里的 BOM 值；</p></li><li><p>HTTP 响应头里的 <code>content-type</code> 字段包含的 <code>charset</code> 所指定的值，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text&#x2F;css; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure></li><li><p>CSS 文件头里定义的 @charset 规则里指定的字符编码；</p></li><li><p><code>&lt;link&gt;</code> 标签里的 charset 属性，该条已在 HTML5 中废除；</p></li><li><p>默认是 <code>UTF-8</code>。</p></li></ul><h4 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import" title="@import">@import</a> 用于告诉 CSS 引擎引入一个外部样式表。</p><p>link 和 @import 都能导入一个样式文件，它们有什么区别嘛？</p><ul><li>link 是 HTML 标签，除了能导入 CSS 外，还能导入别的资源，比如图片、脚本和字体等；而 @import 是 CSS 的语法，只能用来导入 CSS；</li><li>link 导入的样式会在页面加载时同时加载，@import 导入的样式需等页面加载完成后再加载；</li><li>link 没有兼容性问题，@import 不兼容 ie5 以下；</li><li>link 可以通过 JS 操作 DOM 动态引入样式表改变样式，而@import 不可以。</li></ul><h4 id="supports"><a href="#supports" class="headerlink" title="@supports"></a>@supports</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports" title="@supports">@supports</a> 用于查询特定的 CSS 是否生效，可以结合 not、and 和 or 操作符进行后续的操作。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果支持自定义属性，则把 body 颜色设置为变量 varName 指定的颜色 */</span></span><br><span class="line"><span class="keyword">@supports</span> (<span class="attribute">--foo:</span> green) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--varName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>层叠样式表，这里的层叠怎么理解呢？其实它是 CSS 中的核心特性之一，用于合并来自多个源的属性值的算法。比如说针对某个 HTML 标签，有许多的 CSS 声明都能作用到的时候，那最后谁应该起作用呢？层叠性说的大概就是这个。</p><p>针对不同源的样式，将按照如下的顺序进行层叠，越往下优先级越高：</p><ul><li>用户代理样式表中的声明(例如，浏览器的默认样式，在没有设置其他样式时使用)。</li><li><del>用户样式表中的常规声明(由用户设置的自定义样式。由于 Chrome 在很早的时候就放弃了用户样式表的功能，所以这里将不再考虑它的排序。)</del>。</li><li>作者样式表中的常规声明(这些是我们 Web 开发人员设置的样式)。</li><li>作者样式表中的 !important 声明。</li><li><del>用户样式表中的 !important 声明 S</del>。</li></ul><p>理解层叠性的时候需要结合 CSS 选择器的优先级以及继承性来理解。比如针对同一个选择器，定义在后面的声明会覆盖前面的；作者定义的样式会比默认继承的样式优先级更高。</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>CSS 选择器无疑是其核心之一，对于基础选择器以及一些常用伪类必须掌握。下面列出了常用的选择器。<br>想要获取更多选择器的用法可以看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors" title="MDN CSS Selectors">MDN CSS Selectors</a>。</p><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><ul><li>标签选择器：<code>h1</code></li><li>类选择器：<code>.checked</code></li><li>ID 选择器：<code>#picker</code></li><li>通配选择器：<code>*</code></li></ul><p><strong>属性选择器</strong></p><ul><li><code>[attr]</code>：指定属性的元素；</li><li><code>[attr=val]</code>：属性等于指定值的元素；</li><li><code>[attr*=val]</code>：属性包含指定值的元素；</li><li><code>[attr^=val]</code> ：属性以指定值开头的元素；</li><li><code>[attr$=val]</code>：属性以指定值结尾的元素；</li><li><code>[attr~=val]</code>：属性包含指定值(完整单词)的元素(不推荐使用)；</li><li><code>[attr|=val]</code>：属性以指定值(完整单词)开头的元素(不推荐使用)；</li></ul><h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4><ul><li>相邻兄弟选择器：<code>A + B</code></li><li>普通兄弟选择器：<code>A ~ B</code></li><li>子选择器：<code>A &gt; B</code></li><li>后代选择器：<code>A B</code></li></ul><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><p><strong>条件伪类</strong></p><ul><li><code>:lang()</code>：基于元素语言来匹配页面元素；</li><li><code>:dir()</code>：匹配特定文字书写方向的元素；</li><li><code>:has()</code>：匹配包含指定元素的元素；</li><li><code>:is()</code>：匹配指定选择器列表里的元素；</li><li><code>:not()</code>：用来匹配不符合一组选择器的元素；</li></ul><p><strong>行为伪类</strong></p><ul><li><code>:active</code>：鼠标激活的元素；</li><li><code>:hover</code>： 鼠标悬浮的元素；</li><li><code>::selection</code>：鼠标选中的元素；</li></ul><p><strong>状态伪类</strong></p><ul><li><code>:target</code>：当前锚点的元素；</li><li><code>:link</code>：未访问的链接元素；</li><li><code>:visited</code>：已访问的链接元素；</li><li><code>:focus</code>：输入聚焦的表单元素；</li><li><code>:required</code>：输入必填的表单元素；</li><li><code>:valid</code>：输入合法的表单元素；</li><li><code>:invalid</code>：输入非法的表单元素；</li><li><code>:in-range</code>：输入范围以内的表单元素；</li><li><code>:out-of-range</code>：输入范围以外的表单元素；</li><li><code>:checked</code>：选项选中的表单元素；</li><li><code>:optional</code>：选项可选的表单元素；</li><li><code>:enabled</code>：事件启用的表单元素；</li><li><code>:disabled</code>：事件禁用的表单元素；</li><li><code>:read-only</code>：只读的表单元素；</li><li><code>:read-write</code>：可读可写的表单元素；</li><li><code>:blank</code>：输入为空的表单元素；</li><li><code>:current()</code>：浏览中的元素；</li><li><code>:past()</code>：已浏览的元素；</li><li><code>:future()</code>：未浏览的元素；</li></ul><p><strong>结构伪类</strong></p><ul><li><code>:root</code>：文档的根元素；</li><li><code>:empty</code>：无子元素的元素；</li><li><code>:first-letter</code>：元素的首字母；</li><li><code>:first-line</code>：元素的首行；</li><li><code>:nth-child(n)</code>：元素中指定顺序索引的元素；</li><li><code>:nth-last-child(n)</code>：元素中指定逆序索引的元素；；</li><li><code>:first-child </code>：元素中为首的元素；</li><li><code>:last-child</code> ：元素中为尾的元素；</li><li><code>:only-child</code>：父元素仅有该元素的元素；</li><li><code>:nth-of-type(n) </code>：标签中指定顺序索引的标签；</li><li><code>:nth-last-of-type(n)</code>：标签中指定逆序索引的标签；</li><li><code>:first-of-type</code> ：标签中为首的标签；</li><li><code>:last-of-type</code>：标签中为尾标签；</li><li><code>:only-of-type</code>：父元素仅有该标签的标签；</li></ul><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><ul><li><code>::before</code>：在元素前插入内容；</li><li><code>::after</code>：在元素后插入内容；</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css022.png"></p><p>优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。为了记忆，可以把权重分成如下几个等级，数值越大的权重越高：</p><ul><li>10000：!important；</li><li>01000：内联样式；</li><li>00100：ID 选择器；</li><li>00010：类选择器、伪类选择器、属性选择器；</li><li>00001：元素选择器、伪元素选择器；</li><li>00000：通配选择器、后代选择器、兄弟选择器；</li></ul><p>可以看到内联样式（通过元素中 style 属性定义的样式）的优先级大于任何选择器；而给属性值加上 <code>!important</code> 又可以把优先级提至最高，就是因为它的优先级最高，所以需要谨慎使用它，以下有些使用注意事项：</p><ul><li>一定要优先考虑使用样式规则的优先级来解决问题而不是 !important；</li><li>只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important；</li><li>永远不要在你的插件中使用 !important；</li><li>永远不要在全站范围的 CSS 代码中使用 !important；</li></ul><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css023.jpg"></p><p>在 CSS 中有一个很重要的特性就是子元素会继承父元素对应属性计算后的值。比如页面根元素 html 的文本颜色默认是黑色的，页面中的所有其他元素都将继承这个颜色，当申明了如下样式后，H1 文本将变成橙色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设想一下，如果 CSS 中不存在继承性，那么我们就需要为不同文本的标签都设置一下 color，这样一来的后果就是 CSS 的文件大小就会无限增大。</p><p>CSS 属性很多，但并不是所有的属性默认都是能继承父元素对应属性的，那哪些属性存在默认继承的行为呢？一定是那些不会影响到页面布局的属性，可以分为如下几类：</p><ul><li>字体相关：<code>font-family</code>、<code>font-style</code>、<code>font-size</code>、<code>font-weight</code> 等；</li><li>文本相关：<code>text-align</code>、<code>text-indent</code>、<code>text-decoration</code>、<code>text-shadow</code>、<code>letter-spacing</code>、<code>word-spacing</code>、<code>white-space</code>、<code>line-height</code>、<code>color</code> 等；</li><li>列表相关：<code>list-style</code>、<code>list-style-image</code>、<code>list-style-type</code>、<code>list-style-position</code> 等；</li><li>其他属性：<code>visibility</code>、<code>cursor</code> 等；</li></ul><p>对于其他默认不继承的属性也可以通过以下几个属性值来控制继承行为：</p><ul><li><code>inherit</code>：继承父元素对应属性的计算值；</li><li><code>initial</code>：应用该属性的默认值，比如 color 的默认值是 <code>#000</code>；</li><li><code>unset</code>：如果属性是默认可以继承的，则取 <code>inherit</code> 的效果，否则同 <code>initial</code>；</li><li><code>revert</code>：效果等同于 <code>unset</code>，兼容性差。</li></ul><h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p>在 CSS 的世界中，会把内容按照从左到右、从上到下的顺序进行排列显示。正常情况下会把页面分割成一行一行的显示，而每行又可能由多列组成，所以从视觉上看起来就是从上到下从左到右，而这就是 CSS 中的流式布局，又叫文档流。文档流就像水一样，能够自适应所在的容器，一般它有如下几个特性：</p><ul><li>块级元素默认会占满整行，所以多个块级盒子之间是从上到下排列的；</li><li>内联元素默认会在一行里一列一列的排布，当一行放不下的时候，会自动切换到下一行继续按照列排布；</li></ul><p><strong>如何脱离文档流呢？</strong></p><p>脱流文档流指节点脱流正常文档流后，在正常文档流中的其他节点将忽略该节点并填补其原先空间。文档一旦脱流，计算其父节点高度时不会将其高度纳入，脱流节点不占据空间。有两种方式可以让元素脱离文档流：浮动和定位。</p><ul><li>使用浮动（float）会将元素脱离文档流，移动到容器左/右侧边界或者是另一个浮动元素旁边，该浮动元素之前占用的空间将被别的元素填补，另外浮动之后所占用的区域不会和别的元素之间发生重叠；</li><li>使用绝对定位（<code>position: absolute;</code>）或者固定定位（<code>position: fixed;</code>）也会使得元素脱离文档流，且空出来的位置将自动被后续节点填补。</li></ul><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>在 CSS 中任何元素都可以看成是一个盒子，而一个盒子是由 4 部分组成的：内容（content）、内边距（padding）、边框（border）和外边距（margin）。</p><p>盒模型有 2 种：标准盒模型和 IE 盒模型，分别是由 W3C 和 IExplore 制定的标准。</p><p>如果给某个元素设置如下样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准盒模型认为：盒子的实际尺寸 = 内容（设置的宽/高） + 内边距 + 边框</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/contentbox.png"></p><p>所以 <code>.box</code> 元素内容的宽度就为 <code>200px</code>，而实际的宽度则是 <code>width</code> + <code>padding-left</code> + <code>padding-right</code> + <code>border-left-width</code> + <code>border-right-width</code> = 200 + 10 + 10 + 1 + 1 = 222。</p><p>IE 盒模型认为：盒子的实际尺寸 = 设置的宽/高 = 内容 + 内边距 + 边框</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/borderbox.png"></p><p><code>.box</code> 元素所占用的实际宽度为 <code>200px</code>，而内容的真实宽度则是 <code>width</code> - <code>padding-left</code> - <code>padding-right</code> - <code>border-left-width</code> - <code>border-right-width</code> = 200 - 10 - 10 - 1 - 1 = 178。</p><p>现在高版本的浏览器基本上默认都是使用标准盒模型，而像 IE6 这种老古董才是默认使用 IE 盒模型的。</p><p>在 CSS3 中新增了一个属性 <code>box-sizing</code>，允许开发者来指定盒子使用什么标准，它有 2 个值：</p><ul><li><code>content-box</code>：标准盒模型；</li><li><code>border-box</code>：IE 盒模型；</li></ul><h3 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h3><p>视觉格式化模型（Visual formatting model）是用来处理和在视觉媒体上显示文档时使用的计算规则。CSS 中一切皆盒子，而视觉格式化模型简单来理解就是规定这些盒子应该怎么样放置到页面中去，这个模型在计算的时候会依赖到很多的因素，比如：盒子尺寸、盒子类型、定位方案（是浮动还是定位）、兄弟元素或者子元素以及一些别的因素。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css016.jpg" alt="Visual formatting model"></p><p>从上图中可以看到视觉格式化模型涉及到的内容很多，有兴趣深入研究的可以结合上图看这个 W3C 的文档 <a href="https://www.w3.org/TR/CSS2/visuren.html" title="Visual formatting model">Visual formatting model</a>。所以这里就简单介绍下盒子类型。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css018.png"></p><p>盒子类型由 display 决定，同时给一个元素设置 display 后，将会决定这个盒子的 2 个显示类型（display type）：</p><ul><li>outer display type（对外显示）：决定了该元素本身是如何布局的，即参与何种格式化上下文；</li><li>inner display type（对内显示）：其实就相当于把该元素当成了容器，规定了其内部子元素是如何布局的，参与何种格式化上下文；</li></ul><h4 id="outer-display-type"><a href="#outer-display-type" class="headerlink" title="outer display type"></a>outer display type</h4><p>对外显示方面，盒子类型可以分成 2 类：block-level box（块级盒子） 和 inline-level box（行内级盒子）。</p><p>依据上图可以列出都有哪些块级和行内级盒子：</p><ul><li>块级盒子：display 为 block、list-item、table、flex、grid、flow-root 等；</li><li>行内级盒子：display 为 inline、inline-block、inline-table 等；</li></ul><p>所有块级盒子都会参与 BFC，呈现垂直排列；而所有行内级盒子都参会 IFC，呈现水平排列。</p><p>除此之外，block、inline 和 inline-block 还有什么更具体的区别嘛？</p><p><strong>block</strong></p><ul><li>占满一行，默认继承父元素的宽度；多个块元素将从上到下进行排列；</li><li>设置 width/height 将会生效；</li><li>设置 padding 和 margin 将会生效；</li></ul><p><strong>inline</strong></p><ul><li>不会占满一行，宽度随着内容而变化；多个 inline 元素将按照从左到右的顺序在一行里排列显示，如果一行显示不下，则自动换行；</li><li>设置 width/height 将不会生效；</li><li>设置竖直方向上的 padding 和 margin 将不会生效；</li></ul><p><strong>inline-block</strong></p><ul><li>是行内块元素，不单独占满一行，可以看成是能够在一行里进行左右排列的块元素；</li><li>设置 width/height 将会生效；</li><li>设置 padding 和 margin 将会生效；</li></ul><h4 id="inner-display-type"><a href="#inner-display-type" class="headerlink" title="inner display type"></a>inner display type</h4><p>对内方面，其实就是把元素当成了容器，里面包裹着文本或者其他子元素。container box 的类型依据 display 的值不同，分为 4 种：</p><ul><li>block container：建立 BFC 或者 IFC；</li><li>flex container：建立 FFC；</li><li>grid container：建立 GFC;</li><li>ruby container：接触不多，不做介绍。</li></ul><p>值得一提的是如果把 img 这种替换元素（replaced element）申明为 block 是不会产生 container box 的，因为替换元素比如 img 设计的初衷就仅仅是通过 src 把内容替换成图片，完全没考虑过会把它当成容器。</p><p>参考：</p><ul><li><a href="https://yachen168.github.io/article/display.html" title="CSS 原理 - 你所不知道的 display">CSS 原理 - 你所不知道的 display</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10223896?sc=pt" title="格式化上下文">格式化上下文</a></li></ul><h3 id="格式化上下文"><a href="#格式化上下文" class="headerlink" title="格式化上下文"></a>格式化上下文</h3><p>格式化上下文（Formatting Context）是 CSS2.1 规范中的一个概念，大概说的是页面中的一块渲染区域，规定了渲染区域内部的子元素是如何排版以及相互作用的。</p><p>不同类型的盒子有不同格式化上下文，大概有这 4 类：</p><ul><li>BFC (Block Formatting Context) 块级格式化上下文；</li><li>IFC (Inline Formatting Context) 行内格式化上下文；</li><li>FFC (Flex Formatting Context) 弹性格式化上下文；</li><li>GFC (Grid Formatting Context) 格栅格式化上下文；</li></ul><p>其中 BFC 和 IFC 在 CSS 中扮演着非常重要的角色，因为它们直接影响了网页布局，所以需要深入理解其原理。</p><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><p>块格式化上下文，它是一个独立的渲染区域，只有块级盒子参与，它规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css019.png" alt="图来源于 yachen168"></p><p><strong>BFC 渲染规则</strong></p><ul><li>内部的盒子会在垂直方向，一个接一个地放置；</li><li>盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；</li><li>每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；</li><li>BFC 的区域不会与 float 盒子重叠；</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算 BFC 的高度时，浮动元素也参与计算。</li></ul><p><strong>如何创建 BFC？</strong></p><ul><li>根元素：html</li><li>非溢出的可见元素：overflow 不为 visible</li><li>设置浮动：float 属性不为 none</li><li>设置定位：position 为 absolute 或 fixed</li><li>定义成块级的非块级元素：display: inline-block/table-cell/table-caption/flex/inline-flex/grid/inline-grid</li></ul><p><strong>BFC 应用场景</strong></p><p>1、 自适应两栏布局</p><p>应用原理：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css013.gif"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span>aside<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    &lt;!-- 触发 BFC --&gt;</span><br><span class="line">    <span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>;<span class="selector-tag">BFCoverflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、清除内部浮动</p><p>浮动造成的问题就是父元素高度坍塌，所以清除浮动需要解决的问题就是让父元素的高度恢复正常。而用 BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css014.png"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、 防止垂直 margin 合并</p><p>BFC 渲染原理之一：同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个 BFC 中即可阻止垂直 margin 合并。那如何让 2 个相邻的兄弟元素不在同一个 BFC 中呢？可以给其中一个元素外面包裹一层，然后触发其包裹层的 BFC，这样一来 2 个元素就不会在同一个 BFC 中了。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css015.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;contain-b&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo3</span> <span class="selector-class">.a</span>,</span><br><span class="line"><span class="selector-class">.demo3</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.contain-b</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上 3 个 示例 ，可以结合这个 <a href="https://codepen.io/bulandent/pen/eYBVpEm">BFC 应用示例</a> 配合观看更佳。</p><p>参考：<a href="https://yachen168.github.io/article/Formatting-context.html" title="CSS 原理 - Formatting Context">CSS 原理 - Formatting Context</a></p><h4 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h4><p>IFC 的形成条件非常简单，块级元素中仅包含内联级别元素，需要注意的是当 IFC 中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css020.png"></p><p><strong>IFC 渲染规则</strong></p><ul><li>子元素在水平方向上一个接一个排列，在垂直方向上将以容器顶部开始向下排列；</li><li>节点无法声明宽高，其中 margin 和 padding 在水平方向有效在垂直方向无效；</li><li>节点在垂直方向上以不同形式对齐；</li><li>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的线盒（line box）。线盒的宽度是由包含块（containing box）和与其中的浮动来决定；</li><li>IFC 中的 line box 一般左右边贴紧其包含块，但 float 元素会优先排列。</li><li>IFC 中的 line box 高度由 line-height 计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同；</li><li>当内联级盒子的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性值来决定；</li><li>当一个内联盒子超过父元素的宽度时，它会被分割成多盒子，这些盒子分布在多个 line box 中。如果子元素未设置强制换行的情况下，inline box 将不可被分割，将会溢出父元素。</li></ul><p>针对如上的 IFC 渲染规则，你是不是可以分析下下面这段代码的 IFC 环境是怎么样的呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>It can get <span class="tag">&lt;<span class="name">strong</span>&gt;</span>very complicated<span class="tag">&lt;/<span class="name">storng</span>&gt;</span> once you start looking into it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css017.gif"></p><p>对应上面这样一串 HTML 分析如下：</p><ul><li>p 标签是一个 block container，对内将产生一个 IFC；</li><li>由于一行没办法显示完全，所以产生了 2 个线盒（line box）；线盒的宽度就继承了 p 的宽度；高度是由里面的内联盒子的 line-height 决定；</li><li>It can get：匿名的内联盒子；</li><li>very complicated：strong 标签产生的内联盒子；</li><li>once you start：匿名的内联盒子；</li><li>looking into it.：匿名的内联盒子。</li></ul><p>参考：<a href="https://www.w3.org/TR/CSS2/visuren.html#inline-formatting" title="Inline formatting contexts">Inline formatting contexts</a></p><p><strong>IFC 应用场景</strong></p><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。</li><li>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中。</li></ul><p>偷个懒，demo 和图我就不做了。</p><h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p>在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴。众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开，而这其实就是层叠上下文所要描述的东西。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csszindex.png" alt="-w566"></p><p>我们对层叠上下文的第一印象可能要来源于 z-index，认为它的值越大，距离屏幕观察者就越近，那么层叠等级就越高，事实确实是这样的，但层叠上下文的内容远非仅仅如此：</p><ul><li>z-index 能够在层叠上下文中对元素的堆叠顺序其作用是必须配合定位才可以；</li><li>除了 z-index 之外，一个元素在 Z 轴上的显示顺序还受层叠等级和层叠顺序影响；</li></ul><p>在看层叠等级和层叠顺序之前，我们先来看下如何产生一个层叠上下文，特定的 HTML 元素或者 CSS 属性产生层叠上下文，MDN 中给出了这么一个列表，符合以下任一条件的元素都会产生层叠上下文：</p><ul><li>html 文档根元素</li><li>声明 position: absolute/relative 且 z-index 值不为 auto 的元素；</li><li>声明 position: fixed/sticky 的元素；</li><li>flex 容器的子元素，且 z-index 值不为 auto；</li><li>grid 容器的子元素，且 z-index 值不为 auto；</li><li>opacity 属性值小于 1 的元素；</li><li>mix-blend-mode 属性值不为 normal 的元素；</li><li>以下任意属性值不为 none 的元素：<ul><li>transform</li><li>filter</li><li>perspective</li><li>clip-path</li><li>mask / mask-image / mask-border</li></ul></li><li>isolation 属性值为 isolate 的元素；</li><li>-webkit-overflow-scrolling 属性值为 touch 的元素；</li><li>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；</li><li>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</li></ul><p><strong>层叠等级</strong></p><p>层叠等级指节点在三维空间 Z 轴上的上下顺序。它分两种情况：</p><ul><li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在 Z 轴上的上下顺序；</li><li>在其他普通元素中，它描述定义的是这些普通元素在 Z 轴上的上下顺序；</li></ul><p>普通节点的层叠等级优先由其所在的层叠上下文决定，层叠等级的比较只有在当前层叠上下文中才有意义，脱离当前层叠上下文的比较就变得无意义了。</p><p><strong>层叠顺序</strong></p><p>在同一个层叠上下文中如果有多个元素，那么他们之间的层叠顺序是怎么样的呢？</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css002.png"></p><p>以下这个列表越往下层叠优先级越高，视觉上的效果就是越容易被用户看到（不会被其他元素覆盖）：</p><ul><li>层叠上下文的 border 和 background</li><li>z-index &lt; 0 的子节点</li><li>标准流内块级非定位的子节点</li><li>浮动非定位的子节点</li><li>标准流内行内非定位的子节点</li><li>z-index: auto/0 的子节点</li><li>z-index &gt; 0 的子节点</li></ul><p><strong>如何比较两个元素的层叠等级？</strong></p><ul><li>在同一个层叠上下文中，比较两个元素就是按照上图的介绍的层叠顺序进行比较。</li><li>如果不在同一个层叠上下文中的时候，那就需要比较两个元素分别所处的层叠上下文的等级。</li><li>如果两个元素都在同一个层叠上下文，且层叠顺序相同，则在 HTML 中定义越后面的层叠等级越高。</li></ul><p>参考：<a href="https://juejin.cn/post/6844903667175260174" title="彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index">彻底搞懂 CSS 层叠上下文、层叠等级、层叠顺序、z-index</a></p><h3 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h3><p>CSS 的声明是由属性和值组成的，而值的类型有许多种：</p><ul><li>数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值；</li><li>百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的 font-size；</li><li>颜色：用于指定 background-color、color 等；</li><li>坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性；</li><li>函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等；</li></ul><p>而还有些值是需要带单位的，比如 width: 100px，这里的 px 就是表示长度的单位，长度单位除了 px 外，比较常用的还有 em、rem、vw/vh 等。那他们有什么区别呢？又应该在什么时候使用它们呢？</p><h4 id="px"><a href="#px" class="headerlink" title="px"></a>px</h4><p>屏幕分辨率是指在屏幕的横纵方向上的像素点数量，比如分辨率 1920×1080 意味着水平方向含有 1920 个像素数，垂直方向含有 1080 个像素数。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css004.png"></p><p>而 px 表示的是 CSS 中的像素，在 CSS 中它是绝对的长度单位，也是最基础的单位，其他长度单位会自动被浏览器换算成 px。但是对于设备而言，它其实又是相对的长度单位，比如宽高都为 2px，在正常的屏幕下，其实就是 4 个像素点，而在设备像素比(devicePixelRatio) 为 2 的 Retina 屏幕下，它就有 16 个像素点。所以屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。</p><p>讲到这里，还有一些相关的概念需要理清下：</p><p><strong>设备像素（Device pixels）</strong></p><p>设备屏幕的物理像素，表示的是屏幕的横纵有多少像素点；和屏幕分辨率是差不多的意思。</p><p><strong>设备像素比（DPR）</strong></p><p>设备像素比表示 1 个 CSS 像素等于几个物理像素。</p><p>计算公式：DPR = 物理像素数 / 逻辑像素数；</p><p>在浏览器中可以通过 window.devicePixelRatio 来获取当前屏幕的 DPR。</p><p><strong>像素密度（DPI/PPI）</strong></p><p>像素密度也叫显示密度或者屏幕密度，缩写为 DPI(Dots Per Inch) 或者 PPI(Pixel Per Inch)。从技术角度说，PPI 只存在于计算机显示领域，而 DPI 只出现于打印或印刷领域。</p><p>计算公式：像素密度 = 屏幕对角线的像素尺寸 / 物理尺寸</p><p>比如，对于分辨率为 750 * 1334 的 iPhone 6 来说，它的像素密度为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">750</span> * <span class="number">750</span> + <span class="number">1334</span> * <span class="number">1334</span>) / <span class="number">4.7</span> = <span class="number">326</span>ppi</span><br></pre></td></tr></table></figure><p><strong>设备独立像素（DIP）</strong></p><p>DIP 是特别针对 Android 设备而衍生出来的，原因是安卓屏幕的尺寸繁多，因此为了显示能尽量和设备无关，而提出的这个概念。它是基于屏幕密度而计算的，认为当屏幕密度是 160 的时候，px = DIP。</p><p>计算公式：dip = px * 160 / dpi</p><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>em 是 CSS 中的相对长度单位中的一个。居然是相对的，那它到底是相对的谁呢？它有 2 层意思：</p><ul><li>在 font-size 中使用是相对于<strong>父元素</strong>的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；</li><li>在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；</li></ul><p>我们都知道每个浏览器都会给 HTML 根元素 html 设置一个默认的 font-size，而这个值通常是 16px。这也就是为什么 1em = 16px 的原因所在了。</p><p>em 在计算的时候是会层层计算的，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于如上一个结构的 HTML，由于根元素 html 的字体大小是 16px，所以 p 标签最终计算出来后的字体大小会是 16 _ 2 _ 2 = 64px</p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem(root em) 和 em 一样，也是一个相对长度单位，不过 rem 相对的是 HTML 的根元素 html。</p><p>rem 由于是基于 html 的 font-size 来计算，所以通常用于自适应网站或者 H5 中。</p><p>比如在做 H5 的时候，前端通常会让 UI 给 750px 宽的设计图，而在开发的时候可以基于 iPhone X 的尺寸 375px * 812px 来写页面，这样一来的话，就可以用下面的 JS 依据当前页面的视口宽度自动计算出根元素 html 的基准 font-size 是多少。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> docEl = doc.documentElement,</span><br><span class="line">    resizeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>,</span><br><span class="line">    psdWidth = <span class="number">750</span>, <span class="comment">// 设计图宽度</span></span><br><span class="line">    recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> clientWidth = docEl.clientWidth</span><br><span class="line">      <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (clientWidth &gt;= <span class="number">640</span>) &#123;</span><br><span class="line">        docEl.style.fontSize = <span class="number">200</span> * (<span class="number">640</span> / psdWidth) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        docEl.style.fontSize = <span class="number">200</span> * (clientWidth / psdWidth) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 绑定事件的时候最好配合防抖函数</span></span><br><span class="line">  win.addEventListener(resizeEvt, debounce(recalc, <span class="number">1000</span>), <span class="literal">false</span>)</span><br><span class="line">  doc.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, recalc, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> context = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p>比如当视口是 375px 的时候，经过计算 html 的 font-size 会是 100px，这样有什么好处呢？好处就是方便写样式，比如从设计图量出来的 header 高度是 50px 的，那我们写样式的时候就可以直接写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css005.png"></p><p>每个从设计图量出来的尺寸只要除于 100 即可得到当前元素的 rem 值，都不用经过计算，非常方便。偷偷告诉你，如果你把上面那串计算 html 标签 font-size 的 JS 代码中的 200 替换成 2，那在计算 rem 的时候就不需要除于 100 了，从设计图量出多大 px，就直接写多少个 rem。</p><h4 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw/vh"></a>vw/vh</h4><p>vw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位：</p><ul><li>1vw = 视口宽度均分成 100 份中 1 份的长度；</li><li>1vh = 视口高度均分成 100 份中 1 份的长度；</li></ul><p>在 JS 中 100vw = window.innerWidth，100vh = window.innerHeight。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css006.jpg"></p><p>vw/vh 的出现使得多了一种写自适应布局的方案，开发者不再局限于 rem 了。</p><p>相对视口的单位，除了 vw/vh 外，还有 vmin 和 vmax：</p><ul><li>vmin：取 vw 和 vh 中值较小的；</li><li>vmax：取 vw 和 vh 中值较大的；</li></ul><h3 id="颜色体系"><a href="#颜色体系" class="headerlink" title="颜色体系"></a>颜色体系</h3><p>CSS 中用于表示颜色的值种类繁多，足够构成一个体系，所以这里就专门拿出一个小节来讲解它。</p><p>根据 <a href="https://drafts.csswg.org/css-color-3/" title="CSS 颜色草案">CSS 颜色草案</a> 中提到的颜色值类型，大概可以把它们分为这几类：</p><ul><li>颜色关键字</li><li>transparent 关键字</li><li>currentColor 关键字</li><li>RGB 颜色</li><li>HSL 颜色</li></ul><h4 id="颜色关键字"><a href="#颜色关键字" class="headerlink" title="颜色关键字"></a>颜色关键字</h4><p>颜色关键字（color keywords）是不区分大小写的标识符，它表示一个具体的颜色，比如 white（白），黑（black）等；</p><p>可接受的关键字列表在 CSS 的演变过程中发生了改变：</p><ul><li>CSS 标准 1 只接受 16 个基本颜色，称为 VGA 颜色，因为它们来源于 VGA 显卡所显示的颜色集合而被称为 VGA colors （视频图形阵列色彩）。</li><li>CSS 标准 2 增加了 orange 关键字。</li><li>从一开始，浏览器接受其它的颜色，由于一些早期浏览器是 X11 应用程序，这些颜色大多数是 X11 命名的颜色列表，虽然有一点不同。SVG 1.0 是首个正式定义这些关键字的标准；CSS 色彩标准 3 也正式定义了这些关键字。它们经常被称作扩展的颜色关键字， X11 颜色或 SVG 颜色 。</li><li>CSS 颜色标准 4 添加可 rebeccapurple 关键字来纪念 web 先锋 Eric Meyer。</li></ul><p>如下这张图是 16 个基础色，又叫 VGA 颜色。截止到目前为止 CSS 颜色关键字总共有 146 个，这里可以查看 <a href="https://codepen.io/bulandent/pen/gOLovwL" title="完整的色彩关键字列表">完整的色彩关键字列表</a>。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css007.png" alt="VGA 颜色"></p><p>需要注意的是如果声明的时候的颜色关键字是错误的，浏览器会忽略它。</p><h4 id="transparent-关键字"><a href="#transparent-关键字" class="headerlink" title="transparent 关键字"></a>transparent 关键字</h4><p>transparent 关键字表示一个完全透明的颜色，即该颜色看上去将是背景色。从技术上说，它是带有 alpha 通道为最小值的黑色，是 rgba(0,0,0,0) 的简写。</p><p>透明关键字有什么应用场景呢？</p><p><strong>实现三角形</strong></p><p>下面这个图是用 4 条边框填充的正方形，看懂了它你大概就知道该如何用 CSS 写三角形了。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css008.png"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border-top-color</span>: <span class="number">#ffc107</span>;</span><br><span class="line">  <span class="attribute">border-right-color</span>: <span class="number">#00bcd4</span>;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>: <span class="number">#e26b6b</span>;</span><br><span class="line">  <span class="attribute">border-left-color</span>: <span class="number">#cc7cda</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 transparent 实现三角形的原理：</p><ul><li>首先宽高必须是 0px，通过边框的粗细来填充内容；</li><li>那条边需要就要加上颜色，而不需要的边则用 transparent；</li><li>想要什么样姿势的三角形，完全由上下左右 4 条边的中有颜色的边和透明的边的位置决定；</li><li>等腰三角形：设置一条边有颜色，然后紧挨着的 2 边是透明，且宽度是有颜色边的一半；直角三角形：设置一条边有颜色，然后紧挨着的任何一边透明即可。</li></ul><p>看下示例：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css009.png"></p><p><strong>增大点击区域</strong></p><p>常常在移动端的时候点击的按钮的区域特别小，但是由于现实效果又不太好把它做大，所以常用的一个手段就是通过透明的边框来增大按钮的点击区域：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="currentColor-关键字"><a href="#currentColor-关键字" class="headerlink" title="currentColor 关键字"></a>currentColor 关键字</h4><p>currentColor 会取当前元素继承父级元素的文本颜色值或声明的文本颜色值，即 computed 后的 color 值。</p><p>比如，对于如下 CSS，该元素的边框颜色会是 red：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid currentColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RGB-A-颜色"><a href="#RGB-A-颜色" class="headerlink" title="RGB[A] 颜色"></a>RGB[A] 颜色</h4><p>RGB[A] 颜色是由 R(red)-G(green)-B(blue)-A(alpha) 组成的色彩空间。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css010.png"></p><p>在 CSS 中，它有两种表示形式：</p><ul><li>十六进制符号；</li><li>函数符；</li></ul><p><strong>十六进制符号</strong></p><p>RGB 中的每种颜色的值范围是 00~ff，值越大表示颜色越深。所以一个颜色正常是 6 个十六进制字符加上 # 组成，比如红色就是 #ff0000。</p><p>如果 RGB 颜色需要加上不透明度，那就需要加上 alpha 通道的值，它的范围也是 00~ff，比如一个带不透明度为 67% 的红色可以这样写 #ff0000aa。</p><p>使用十六进制符号表示颜色的时候，都是用 2 个十六进制表示一个颜色，如果这 2 个字符相同，还可以缩减成只写 1 个，比如，红色 #f00；带 67% 不透明度的红色 #f00a。</p><p><strong>函数符</strong></p><p>当 RGB 用函数表示的时候，每个值的范围是 0<del>255 或者 0%</del>100%，所以红色是 rgb(255, 0, 0)， 或者 rgb(100%, 0, 0)。</p><p>如果需要使用函数来表示带不透明度的颜色值，值的范围是 0<del>1 及其之间的小数或者 0%</del>100%，比如带 67% 不透明度的红色是 rgba(255, 0, 0, 0.67) 或者 rgba(100%, 0%, 0%, 67%)</p><blockquote><p>需要注意的是 RGB 这 3 个颜色值需要保持一致的写法，要嘛用数字要嘛用百分比，而不透明度的值的可以不用和 RGB 保持一致写法。比如 rgb(100%, 0, 0) 这个写法是无效的；而 rgb(100%, 0%, 0%, 0.67) 是有效的。</p></blockquote><p>在第 4 代 CSS 颜色标准中，新增了一种新的函数写法，即可以把 RGB 中值的分隔逗号改成空格，而把 RGB 和 alpha 中的逗号改成 /，比如带 67% 不透明度的红色可以这样写 rgba(255 0 0 / 0.67)。另外还把 rgba 的写法合并到 rgb 函数中了，即 rgb 可以直接写带不透明度的颜色。</p><h4 id="HSL-A-颜色"><a href="#HSL-A-颜色" class="headerlink" title="HSL[A] 颜色"></a>HSL[A] 颜色</h4><p>HSL[A] 颜色是由色相(hue)-饱和度(saturation)-亮度(lightness)-不透明度组成的颜色体系。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css011.png"></p><ul><li>色相（H）是色彩的基本属性，值范围是 0<del>360 或者 0deg</del>360deg， 0 (或 360) 为红色, 120 为绿色, 240 为蓝色；</li><li>饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0~100% 的数值；0% 为灰色， 100% 全色；</li><li>亮度（L），取 0~100%，0% 为暗，100% 为白；</li><li>不透明度（A），取 0<del>100%，或者 0</del>1 及之间的小数；</li></ul><p>写法上可以参考 RGB 的写法，只是参数的值不一样。</p><p>给一个按钮设置不透明度为 67% 的红色的 color 的写法，以下全部写法效果一致：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000aa</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f00a</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.67</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">100%</span> <span class="number">0%</span> <span class="number">0%</span> / <span class="number">67%</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">100%</span>, <span class="number">50%</span>, <span class="number">67%</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">hsl</span>(<span class="number">0deg</span> <span class="number">100%</span> <span class="number">50%</span> / <span class="number">67%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小提示：在 Chrome DevTools 中可以按住 shift + 鼠标左键可以切换颜色的表示方式。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css012.gif"></p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询是指针对不同的设备、特定的设备特征或者参数进行定制化的修改网站的样式。</p><p>你可以通过给 <code>&lt;link&gt;</code> 加上 media 属性来指定该样式文件只能对什么设备生效，不指定的话默认是 all，即对所有设备都生效：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>都支持哪些设备类型？</p><ul><li>all：适用于所有设备；</li><li>print：适用于在打印预览模式下在屏幕上查看的分页材料和文档；</li><li>screen：主要用于屏幕；</li><li>speech：主要用于语音合成器。</li></ul><blockquote><p>需要注意的是：通过 media 指定的 <link> 资源尽管不匹配它的设备类型，但是浏览器依然会加载它。</p></blockquote><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css021.png"></p><p>除了通过 <code>&lt;link&gt;</code> 让指定设备生效外，还可以通过 <code>@media</code> 让 CSS 规则在特定的条件下才能生效。响应式页面就是使用了 @media 才让一个页面能够同时适配 PC、Pad 和手机端。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">1000px</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>媒体查询支持逻辑操作符：</p><ul><li>and：查询条件都满足的时候才生效；</li><li>not：查询条件取反；</li><li>only：整个查询匹配的时候才生效，常用语兼容旧浏览器，使用时候必须指定媒体类型；</li><li>逗号或者 or：查询条件满足一项即可匹配；</li></ul><p>媒体查询还支持<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#%E5%AA%92%E4%BD%93%E7%89%B9%E6%80%A7" title="众多的媒体特性">众多的媒体特性</a>，使得它可以写出很复杂的查询条件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用户设备的最小高度为680px或为纵向模式的屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-height:</span> <span class="number">680px</span>), screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> portrait) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见需求"><a href="#常见需求" class="headerlink" title="常见需求"></a>常见需求</h2><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>之前我们通常是在预处理器里才可以使用变量，而现在 CSS 里也支持了变量的用法。通过自定义属性就可以在想要使用的地方引用它。</p><p>自定义属性也和普通属性一样具有级联性，申明在 :root 下的时候，在全文档范围内可用，而如果是在某个元素下申明自定义属性，则只能在它及它的子元素下才可以使用。</p><p>自定义属性必须通过 <code>--x</code> 的格式申明，比如：–theme-color: red; 使用自定义属性的时候，需要用 var 函数。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span> 定义自定义属性 <span class="selector-tag">--</span> &gt; <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--theme-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!<span class="selector-tag">--</span> 使用变量 <span class="selector-tag">--</span> &gt; <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--theme-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css024.png"></p><p>上图这个是使用 CSS 自定义属性配合 JS 实现的动态调整元素的 box-shadow，具体可以看这个 <a href="https://codepen.io/bulandent/pen/GVjxLJ">codepen demo</a>。</p><h3 id="1px-边框解决方案"><a href="#1px-边框解决方案" class="headerlink" title="1px 边框解决方案"></a>1px 边框解决方案</h3><p>Retina 显示屏比普通的屏幕有着更高的分辨率，所以在移动端的 1px 边框就会看起来比较粗，为了美观通常需要把这个线条细化处理。这里有篇文章列举了 7 种方案可以参考一下：<a href="https://www.jianshu.com/p/7e63f5a32636" title="7种方法解决移动端Retina屏幕1px边框问题">7 种方法解决移动端 Retina 屏幕 1px 边框问题</a></p><p>而这里附上最后一种通过伪类和 transform 实现的相对完美的解决方案：</p><p>只设置单条底部边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale-1px-bottom</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale-1px-bottom</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时设置 4 条边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale-1px</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: left top;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>什么是浮动：浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。</p><p>为什么要清楚浮动，它造成了什么问题？</p><p>因为浮动元素会脱离正常的文档流，并不会占据文档流的位置，所以如果一个父元素下面都是浮动元素，那么这个父元素就无法被浮动元素所撑开，这样一来父元素就丢失了高度，这就是所谓的浮动造成的父元素高度坍塌问题。</p><p>父元素高度一旦坍塌将对后面的元素布局造成影响，为了解决这个问题，所以需要清除浮动，让父元素恢复高度，那该如何做呢？</p><p>这里介绍两种方法：通过 BFC 来清除、通过 clear 来清除。</p><h4 id="BFC-清除浮动"><a href="#BFC-清除浮动" class="headerlink" title="BFC 清除浮动"></a>BFC 清除浮动</h4><p>前面介绍 BFC 的时候提到过，计算 BFC 高度的时候浮动子元素的高度也将计算在内，利用这条规则就可以清楚浮动。</p><p>假设一个父元素 parent 内部只有 2 个子元素 child，且它们都是左浮动的，这个时候 parent 如果没有设置高度的话，因为浮动造成了高度坍塌，所以 parent 的高度会是 0，此时只要给 parent 创造一个 BFC，那它的高度就能恢复了。</p><p>而产生 BFC 的方式很多，我们可以给父元素设置 overflow: auto 来简单的实现 BFC 清除浮动，但是为了兼容 IE 最好用 overflow: hidden。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 overflow: hidden 来清除浮动并不完美，当元素有阴影或存在下拉菜单的时候会被截断，所以该方法使用比较局限。</p><h4 id="通过-clear-清除浮动"><a href="#通过-clear-清除浮动" class="headerlink" title="通过 clear 清除浮动"></a>通过 clear 清除浮动</h4><p>我先把结论贴出来：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的核心原理就是通过 ::after 伪元素为在父元素的最后一个子元素后面生成一个内容为空的块级元素，然后通过 clear 将这个伪元素移动到所有它之前的浮动元素的后面，画个图来理解一下。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css003.png"></p><p>可以结合这个 <a href="https://codepen.io/bulandent/pen/LYbOvOa">codepen demo</a> 一起理解上图的 clear 清楚浮动原理。</p><p>上面这个 demo 或者图里为了展示需要所以给伪元素的内容设置为了 ::after，实际使用的时候需要设置为空字符串，让它的高度为 0，从而父元素的高度都是由实际的子元素撑开。</p><p>该方式基本上是现在人人都在用的清除浮动的方案，非常通用。</p><p>参考：<a href="https://www.jianshu.com/p/09bd5873bed4" title="CSS中的浮动和清除浮动，梳理一下">CSS 中的浮动和清除浮动，梳理一下</a></p><h3 id="消除浏览器默认样式"><a href="#消除浏览器默认样式" class="headerlink" title="消除浏览器默认样式"></a>消除浏览器默认样式</h3><p>针对同一个类型的 HTML 标签，不同的浏览器往往有不同的表现，所以在网站制作的时候，开发者通常都是需要将这些浏览器的默认样式清除，让网页在不同的浏览器上能够保持一致。</p><p>针对清除浏览器默认样式这件事，在很早之前 CSS 大师 Eric A. Meyer 就干过。它就是写一堆通用的样式用来重置浏览器默认样式，这些样式通常会放到一个命名为 reset.css 文件中。比如大师的 <a href="https://meyerweb.com/eric/tools/css/reset/" title="reset.css">reset.css</a> 是这么写的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-tag">span</span>,</span><br><span class="line"><span class="selector-tag">applet</span>,</span><br><span class="line"><span class="selector-tag">object</span>,</span><br><span class="line"><span class="selector-tag">iframe</span>,</span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span>,</span><br><span class="line"><span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-tag">blockquote</span>,</span><br><span class="line"><span class="selector-tag">pre</span>,</span><br><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">abbr</span>,</span><br><span class="line"><span class="selector-tag">acronym</span>,</span><br><span class="line"><span class="selector-tag">address</span>,</span><br><span class="line"><span class="selector-tag">big</span>,</span><br><span class="line"><span class="selector-tag">cite</span>,</span><br><span class="line"><span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">del</span>,</span><br><span class="line"><span class="selector-tag">dfn</span>,</span><br><span class="line"><span class="selector-tag">em</span>,</span><br><span class="line"><span class="selector-tag">img</span>,</span><br><span class="line"><span class="selector-tag">ins</span>,</span><br><span class="line"><span class="selector-tag">kbd</span>,</span><br><span class="line"><span class="selector-tag">q</span>,</span><br><span class="line"><span class="selector-tag">s</span>,</span><br><span class="line"><span class="selector-tag">samp</span>,</span><br><span class="line"><span class="selector-tag">small</span>,</span><br><span class="line"><span class="selector-tag">strike</span>,</span><br><span class="line"><span class="selector-tag">strong</span>,</span><br><span class="line"><span class="selector-tag">sub</span>,</span><br><span class="line"><span class="selector-tag">sup</span>,</span><br><span class="line"><span class="selector-tag">tt</span>,</span><br><span class="line"><span class="selector-tag">var</span>,</span><br><span class="line"><span class="selector-tag">b</span>,</span><br><span class="line"><span class="selector-tag">u</span>,</span><br><span class="line"><span class="selector-tag">i</span>,</span><br><span class="line"><span class="selector-tag">center</span>,</span><br><span class="line"><span class="selector-tag">dl</span>,</span><br><span class="line"><span class="selector-tag">dt</span>,</span><br><span class="line"><span class="selector-tag">dd</span>,</span><br><span class="line"><span class="selector-tag">ol</span>,</span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">li</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span>,</span><br><span class="line"><span class="selector-tag">form</span>,</span><br><span class="line"><span class="selector-tag">label</span>,</span><br><span class="line"><span class="selector-tag">legend</span>,</span><br><span class="line"><span class="selector-tag">table</span>,</span><br><span class="line"><span class="selector-tag">caption</span>,</span><br><span class="line"><span class="selector-tag">tbody</span>,</span><br><span class="line"><span class="selector-tag">tfoot</span>,</span><br><span class="line"><span class="selector-tag">thead</span>,</span><br><span class="line"><span class="selector-tag">tr</span>,</span><br><span class="line"><span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-tag">td</span>,</span><br><span class="line"><span class="selector-tag">article</span>,</span><br><span class="line"><span class="selector-tag">aside</span>,</span><br><span class="line"><span class="selector-tag">canvas</span>,</span><br><span class="line"><span class="selector-tag">details</span>,</span><br><span class="line"><span class="selector-tag">embed</span>,</span><br><span class="line"><span class="selector-tag">figure</span>,</span><br><span class="line"><span class="selector-tag">figcaption</span>,</span><br><span class="line"><span class="selector-tag">footer</span>,</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">hgroup</span>,</span><br><span class="line"><span class="selector-tag">menu</span>,</span><br><span class="line"><span class="selector-tag">nav</span>,</span><br><span class="line"><span class="selector-tag">output</span>,</span><br><span class="line"><span class="selector-tag">ruby</span>,</span><br><span class="line"><span class="selector-tag">section</span>,</span><br><span class="line"><span class="selector-tag">summary</span>,</span><br><span class="line"><span class="selector-tag">time</span>,</span><br><span class="line"><span class="selector-tag">mark</span>,</span><br><span class="line"><span class="selector-tag">audio</span>,</span><br><span class="line"><span class="selector-tag">video</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font</span>: inherit;</span><br><span class="line">  <span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* HTML5 display-role reset for older browsers */</span></span><br><span class="line"><span class="selector-tag">article</span>,</span><br><span class="line"><span class="selector-tag">aside</span>,</span><br><span class="line"><span class="selector-tag">details</span>,</span><br><span class="line"><span class="selector-tag">figcaption</span>,</span><br><span class="line"><span class="selector-tag">figure</span>,</span><br><span class="line"><span class="selector-tag">footer</span>,</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">hgroup</span>,</span><br><span class="line"><span class="selector-tag">menu</span>,</span><br><span class="line"><span class="selector-tag">nav</span>,</span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ol</span>,</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span>,</span><br><span class="line"><span class="selector-tag">q</span> &#123;</span><br><span class="line">  <span class="attribute">quotes</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-pseudo">:after</span>,</span><br><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">content</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">  <span class="attribute">border-spacing</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他的这份 reset.css 据说是被使用最广泛的重设样式的方案了。</p><p>除了 reset.css 外，后来又出现了 <a href="https://github.com/necolas/normalize.css" title="Normalize.css">Normalize.css</a> 。关于 Normalize.css, 其作者 necolas 专门写了一篇文章介绍了它，并谈到了它和 reset.css 的区别。这个是他写那篇文章的翻译版：<a href="https://jerryzou.com/posts/aboutNormalizeCss/" title="让我们谈一谈 Normalize.css">让我们谈一谈 Normalize.css</a>。</p><p>文章介绍到：Normalize.css 只是一个很小的 CSS 文件，但它在默认的 HTML 元素样式上提供了跨浏览器的高度一致性。相比于传统的 CSS reset，Normalize.css 是一种现代的、为 HTML5 准备的优质替代方案，现在已经有很多知名的框架和网站在使用它了。</p><p>Normalize.css 的具体样式可以看这里 <a href="https://necolas.github.io/normalize.css/latest/normalize.css">Normalize.css</a></p><p>区别于 reset.css，Normalize.css 有如下特点：</p><ul><li>reset.css 几乎为所有标签都设置了默认样式，而 Normalize.css 则是有选择性的保护了部分有价值的默认值；</li><li>修复了很多浏览器的 bug，而这是 reset.css 没做到的；</li><li>不会让你的调试工具变的杂乱，相反 reset.css 由于设置了很多默认值，所以在浏览器调试工具中往往会看到一大堆的继承样式，显得很杂乱；</li><li>Normalize.css 是模块化的，所以可以选择性的去掉永远不会用到的部分，比如表单的一般化；</li><li>Normalize.css 有详细的说明文档；</li></ul><h3 id="长文本处理"><a href="#长文本处理" class="headerlink" title="长文本处理"></a>长文本处理</h3><p><strong>默认：字符太长溢出了容器</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext01.png"></p><p><strong>字符超出部分换行</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext02.png"></p><p><strong>字符超出位置使用连字符</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext03.png"></p><p><strong>单行文本超出省略</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext04.png"></p><p><strong>多行文本超出省略</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext05.png"></p><p>查看以上这些方案的示例： <a href="https://codepen.io/bulandent/pen/abBrNby">codepen demo</a></p><p>有意思的是刚好前两天看到 chokcoco 针对文本溢出也写了一篇文章，主要突出的是对整块的文本溢出处理。啥叫整块文本？比如，下面这种技术标签就是属于整块文本：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext06.png"></p><p>另外他还对 iOS/Safari 做了兼容处理，感兴趣的可以去阅读下：<a href="https://juejin.cn/post/6938583040469762055" title="CSS 整块文本溢出省略特性探究">CSS 整块文本溢出省略特性探究</a>。</p><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>让元素在父元素中呈现出水平垂直居中的形态，无非就 3 种情况：</p><ul><li>单行的文本、inline 或者 inline-block 元素；</li><li>固定宽高的块级盒子；</li><li>不固定宽高的块级盒子；</li></ul><p>以下列到的所有水平垂直居中方案这里写了个 <a href="https://codepen.io/bulandent/pen/ymaKoM">codepen demo</a>，配合示例阅读效果更佳。</p><h4 id="单行的文本、inline-或-inline-block-元素"><a href="#单行的文本、inline-或-inline-block-元素" class="headerlink" title="单行的文本、inline 或 inline-block 元素"></a>单行的文本、inline 或 inline-block 元素</h4><p><strong>水平居中</strong></p><p>此类元素需要水平居中，则父级元素必须是块级元素(<code>block level</code>)，且父级元素上需要这样设置样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>垂直居中</strong></p><p>方法一：通过设置上下内间距一致达到垂直居中的效果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.single-line</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：通过设置 <code>height</code> 和 <code>line-height</code> 一致达到垂直居中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.single-line</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="固定宽高的块级盒子"><a href="#固定宽高的块级盒子" class="headerlink" title="固定宽高的块级盒子"></a>固定宽高的块级盒子</h4><p><strong>方法一：absolute + 负 margin</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter01.png"></p><p><strong>方法二：absolute + margin auto</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter02.png"></p><p><strong>方法三：absolute + calc</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter03.png"></p><h4 id="不固定宽高的块级盒子"><a href="#不固定宽高的块级盒子" class="headerlink" title="不固定宽高的块级盒子"></a>不固定宽高的块级盒子</h4><p>这里列了 6 种方法，参考了<a href="https://segmentfault.com/a/1190000016389031">颜海镜</a> 写的文章 ，其中的两种 line-height 和 writing-mode 方案看后让我惊呼：还有这种操作？学到了学到了。</p><p><strong>方法一：absolute + transform</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter04.png"></p><p><strong>方法二：line-height + vertical-align</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter05.png"></p><p><strong>方法三：writing-mode</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter06.png"></p><p><strong>方法四：table-cell</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter07.png"></p><p><strong>方法五：flex</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter08.png"></p><p><strong>方法六：grid</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter09.png"></p><h3 id="常用布局"><a href="#常用布局" class="headerlink" title="常用布局"></a>常用布局</h3><h4 id="两栏布局（边栏定宽主栏自适应）"><a href="#两栏布局（边栏定宽主栏自适应）" class="headerlink" title="两栏布局（边栏定宽主栏自适应）"></a>两栏布局（边栏定宽主栏自适应）</h4><p>针对以下这些方案写了几个示例： <a href="https://codepen.io/bulandent/pen/JjbqxbM">codepen demo</a></p><p><strong>方法一：float + overflow（BFC 原理）</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css2layout01.png"></p><p><strong>方法二：float + margin</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css2layout02.png"></p><p><strong>方法三：flex</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css2layout03.png"></p><p><strong>方法四：grid</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css2layout04.png"></p><h4 id="三栏布局（两侧栏定宽主栏自适应）"><a href="#三栏布局（两侧栏定宽主栏自适应）" class="headerlink" title="三栏布局（两侧栏定宽主栏自适应）"></a>三栏布局（两侧栏定宽主栏自适应）</h4><p>针对以下这些方案写了几个示例： <a href="https://codepen.io/bulandent/pen/abBrXrj">codepen demo</a></p><p><strong>方法一：圣杯布局</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3layout01.png"></p><p><strong>方法二：双飞翼布局</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3layout02.png"></p><p><strong>方法三：float + overflow（BFC 原理）</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3layout03.png"></p><p><strong>方法四：flex</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3layout04.png"></p><p><strong>方法五：grid</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3layout05.png"></p><h4 id="多列等高布局"><a href="#多列等高布局" class="headerlink" title="多列等高布局"></a>多列等高布局</h4><p>结合示例阅读更佳：<a href="https://codepen.io/bulandent/pen/jOVogdj">codepen demo</a></p><p><strong>方法一：padding + 负 margin</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csssameheight01.png"></p><p><strong>方法二：设置父级背景图片</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csssameheight02.png"></p><h4 id="三行布局（头尾定高主栏自适应）"><a href="#三行布局（头尾定高主栏自适应）" class="headerlink" title="三行布局（头尾定高主栏自适应）"></a>三行布局（头尾定高主栏自适应）</h4><p>列了 4 种方法，都是基于如下的 HTML 和 CSS 的，结合示例阅读效果更佳：<a href="https://codepen.io/bulandent/pen/yLVdpvr">codepen demo</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-class">.layout</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法一：calc</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3row01.png"></p><p><strong>方法二：absolute</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3row02.png"></p><p><strong>方法三：flex</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3row03.png"></p><p><strong>方法四：grid</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3row04.png"></p><h2 id="结了个尾"><a href="#结了个尾" class="headerlink" title="结了个尾"></a>结了个尾</h2><p>这是我断断续续写了 2 周完成的文章，算是自己对 CSS 的一个总结，虽然写得很长，但不足以覆盖所有 CSS 的知识，比如动画和一些 CSS3 的新特性就完全没涉及，因为这要写下来估计得有大几万字（其实就是懒 😝 ）。</p><p>码字作图不易，如果喜欢或者对你有丝毫帮助的话，帮忙点个 👍 哈，点赞就是我的动力。同时也希望自己能坚持认真的写下去，因为在总结提升自己的同时如果也能帮助更多的前端 er，那将会让我感觉很开心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章围绕了 CSS 的核心知识点和项目中常见的需求来展开。虽然行文偏长，但偏基础，适合初级中级前端阅读，阅读的时候请适当跳过已经掌握的部分。&lt;/p&gt;
&lt;p&gt;这篇文章断断续续写了比较久，也参考了许多优秀的文章，但或许文章里还是存在不好或不对的地方，请多多指教，可以评论里直接提出来哈。&lt;/p&gt;
&lt;p&gt;小 tip：后续内容更精彩哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/cssxm.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://bubuzou.com/categories/css/"/>
    
    
      <category term="css" scheme="https://bubuzou.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>为你的网站加上 WebP 格式的图片吧</title>
    <link href="https://bubuzou.com/2021/01/23/webp/"/>
    <id>https://bubuzou.com/2021/01/23/webp/</id>
    <published>2021-01-23T01:49:25.000Z</published>
    <updated>2021-09-06T09:58:29.176Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一篇文章：<a href="https://github.com/Bulandent/blog/issues/17">jpg、gif、png 和 svg 用于 web 上，我们该如何选择最合适的图像格式</a>，介绍了这几种图片格式的特点，以及如何为网站选择合适的图片，然后评论区有位大佬让我补充下 WebP 格式，于是乎它来了。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp006.png"></p><h2 id="什么是-WebP-格式"><a href="#什么是-WebP-格式" class="headerlink" title="什么是 WebP 格式"></a>什么是 WebP 格式</h2><p>WebP 是一种现代图像格式，可为 Web 上的图像提供出色的无损和有损压缩。 使用 WebP，网站管理员和 Web 开发人员可以创建更小，更丰富的图像，从而使 Web 更快。</p><p>与 PNG 相比，WebP 无损图像的尺寸要小 26％。 在同等的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。</p><p>无损 WebP 支持透明性（也称为 Alpha 通道），而仅增加了 22％ 的字节数。 对于可以接受有损 RGB 压缩的情况，有损 WebP 还支持透明性，与 PNG 相比，文件大小通常小 3 倍。</p><blockquote><p>上面这 3 段话来源于 <a href="https://developers.google.com/speed/webp">https://developers.google.com/speed/webp</a></p></blockquote><a id="more"></a><h2 id="为什么你需要这个格式"><a href="#为什么你需要这个格式" class="headerlink" title="为什么你需要这个格式"></a>为什么你需要这个格式</h2><p>因为 WebP 图像比 JPEG 和 PNG 图像小-通常文件大小减少 25-35％。这样可以减小页面大小并提高性能。举 2 个例子：</p><ul><li>YouTube 发现，切换到 WebP 缩略图可将页面加载速度提高 10％。</li><li>当他们切换到使用 WebP 时，Facebook 节省了 25-35％ 的 JPEG 文件大小，节省了 80％ 的 PNG 文件大小。</li></ul><p>WebP 是 JPEG，PNG 和 GIF 图像的理想替代品。 另外，WebP 提供无损压缩和有损压缩。 在无损压缩中，不会丢失任何数据。 有损压缩会减小文件大小，但会以降低图像质量为代价。</p><h2 id="如何将图片转成-WebP-格式"><a href="#如何将图片转成-WebP-格式" class="headerlink" title="如何将图片转成 WebP 格式"></a>如何将图片转成 WebP 格式</h2><p>通常，开发者会用如下两种方式来将图片转成 WebP 格式：</p><ul><li><a href="https://developers.google.com/speed/webp/docs/using">cwebp</a> 命令行工具</li><li><a href="https://github.com/imagemin/imagemin-webp">Imagemin WebP</a> 插件（npm 包）</li></ul><p>如果你的项目比较简单或者你仅需要将图片转化一次，那么 <code>cwebp</code> 命令行工具是一个很好的选择；而如果你使用构建工具比如 <code>Webpack</code> 或 <code>Gulp</code> 等去构建你的项目的时候，那么将图片转 <code>WebP</code> 使用 <code>Imagemin WebP</code> 插件就是你最好的选择了。</p><p>当你需要把图片转成 <code>WebP</code> 格式的时候，你可以设置很多的参数，但是你最需要关心的就仅仅只是压缩质量，你可以指定一个压缩的质量等级，它的范围是从 0 ~ 100，0 表示质量最差，100 是最好。那么该把它设置成多少才最合适呢？这就需要你好好的花费一翻功夫去实践到底哪个质量等级是既兼顾了呈现质量又不会使得文件太大呢？</p><h3 id="使用-cwebp-转换图片"><a href="#使用-cwebp-转换图片" class="headerlink" title="使用 cwebp 转换图片"></a>使用 cwebp 转换图片</h3><p>使用这个命令前需要先安装它的工具包 webp，按照如下几个步骤操作即可：</p><ul><li><p>可以<a href="https://storage.googleapis.com/downloads.webmproject.org/releases/webp/index.html">去这下载 webp 工具包</a> ，这个网站提供了很多版本的包，选择一个和电脑匹配的包，比如我是 Mac 系统，我下载的是 <code>libwebp-1.1.0-rc2-mac-10.15</code> 版本的包，下载完成后解压，然后把解压后的文件夹放到你想要存放的目录，我是把他放到了 <code>/Applications/Utilities/</code> 下；</p></li><li><p>设置环境变量，使得命令可以在终端下使用。而我是直接修改当前用户下的 <code>.bash_profile</code> 文件，该文件目录：<code>/Users/ccp/.bash_profile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;$PATH:&#x2F;Applications&#x2F;Utilities&#x2F;libwebp-1.1.0-rc2-mac-10.15&#x2F;bin</span><br></pre></td></tr></table></figure><p>修改完成后，需要让命令立即生效的话，需要在终端下运行：<code>source .bash_profile</code></p></li><li><p>然后就可以在终端下输入 <code>cwebp</code>，如果它能提示你如何使用该命令，说明这个包安装好了，可以正常使用 cwebp 命令了。</p></li><li><p>阅读 libwebp 包的下的 READMD，可以发现，该包除了有 cwebp 命令外，还提供了很多额外的命令，具体用法可以自行查阅相关文档。</p></li></ul><p>除了以上这种操作稍微麻烦的安装方式外，还可以使用 OS X 的包管理工具进行安装（你怎么不早说 😭）：</p><ul><li><a href="https://formulae.brew.sh/formula/webp">Homebrew WebP package</a></li><li><a href="https://www.macports.org/ports.php?by=library&substr=webp">Macports WebP package</a></li></ul><p>安装成功后，就可以愉快的使用 cwebp 命令了。来看看以下操作：</p><p>使用 cwebp 的默认压缩设置转换单张图片（默认是有损压缩，且默认的压缩的质量参数是 75）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cwebp images&#x2F;flower.jpg -o images&#x2F;flower.webp</span><br></pre></td></tr></table></figure><p>使用 50 质量等级去转换单张图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cwebp -q 50 images&#x2F;flower.jpg -o images&#x2F;flower.webp</span><br></pre></td></tr></table></figure><p>转换指定目录下的所有文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for file in images&#x2F;*; do cwebp &quot;$file&quot; -o &quot;$&#123;file%.*&#125;.webp&quot;; done</span><br></pre></td></tr></table></figure><h3 id="使用-Imagemin-转换图片"><a href="#使用-Imagemin-转换图片" class="headerlink" title="使用 Imagemin 转换图片"></a>使用 Imagemin 转换图片</h3><p>Imagemin Webp 插件可以在 Node 环境中独立使用，也可以结合 Webpack 等构建工具使用。通常只需要 10 行左右代码即可配置完成。</p><p>Node 环境下配置，以下代码会把 images 目录下的图片转成 WebP 图片后存到 compressed_images 目录下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imagemin = <span class="built_in">require</span>(<span class="string">&#x27;imagemin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> imageminWebp = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-webp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">imagemin([<span class="string">&#x27;images/*&#x27;</span>], &#123;</span><br><span class="line">  destination: <span class="string">&#x27;compressed_images&#x27;</span>,</span><br><span class="line">  plugins: [imageminWebp(&#123; <span class="attr">quality</span>: <span class="number">50</span> &#125;)],</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Done!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在构建工具 Webpack 下使用，这里还配合了 <code>copy-webpack-plugin</code> 插件实现图片的复制。以下代码来源于 <a href="https://glitch.com/edit/#!/webp-webpack">webp-webpack</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2018 Google LLC.</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ImageminWebP = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-webp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ImageminPlugin = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-webpack-plugin&#x27;</span>).default</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">from</span>: <span class="string">&#x27;./images/**/**&#x27;</span>,</span><br><span class="line">        to: <span class="string">&#x27;./images/[name].webp&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]),</span><br><span class="line">    <span class="keyword">new</span> ImageminPlugin(&#123;</span><br><span class="line">      <span class="comment">// imagemin-webp docs: https://github.com/imagemin/imagemin-webp</span></span><br><span class="line">      plugins: [ImageminWebP(&#123; <span class="attr">quality</span>: <span class="number">50</span> &#125;)],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以尝试使用 <a href="https://www.npmjs.com/package/imagemin-webp-webpack-plugin">imagemin-webp-webpack-plugin</a> 这个插件，因为我看它最近 4 个月内有过更新，下载量也快 10K 了，应该可以满足需求。</p><h2 id="对比-WebP-和-其他图片格式"><a href="#对比-WebP-和-其他图片格式" class="headerlink" title="对比 WebP 和 其他图片格式"></a>对比 WebP 和 其他图片格式</h2><p>下面我用 PS 做了一张图片：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp001.png"></p><p>然后用它导出了 4 张图片，它们的信息如下：</p><ul><li><code>jpg_60.jpg</code>：质量为 60 的 JPG 格式图片，48KB；</li><li><code>jpg_100.jpg</code>：质量为 100 的 JPG 格式图片，142KB；</li><li><code>png_8.png</code>：8 位的 PNG 格式图片，60KB；</li><li><code>png_24.png</code>：24 位的 PNG 格式图片，200KB；</li></ul><p>然后我用如下命令，批量将他们转成了 WebP 格式的图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for file in Downloads&#x2F;img&#x2F;*; do cwebp &quot;$file&quot; -o &quot;$&#123;file%.*&#125;.webp&quot;; done</span><br></pre></td></tr></table></figure><p>然后可以看到 <code>Downloads/img/</code> 文件夹下所有文件的信息如下：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp002.png"></p><p>发现这 4 张图片被转成 WebP 格式的图片后文件大小居然都差不多大，大概都是 22KB，比原来真的小了太多了，尤其是 PNG 24 和 JPG 质量 100 的图片体积缩减更加明显。<strong>而最差的 JPG 质量 60 的图片再被转成 WebP 格式后，体积竟然还缩减了 54% 左右</strong>。</p><p>接下来我们再把这 4 张图片通过在线工具 <a href="https://tinypng.com/">TinyPNG</a> 压缩一下，以下是文件压缩后的信息（左右两列绿色数字分别表示：文件压缩前大小和压缩后大小）：</p><p><img src="../webp_003.png"></p><p>发现 TinyPNG 对 PNG 24 和 JPG 质量 100 的图片压缩效果比较明显。**另外将这压缩过的 4 张图片和 WebP 格式的图片（22KB）相比，发现 WebP 图片的文件大小还是明显小很多，小了超过 50%**，所以这就是为什么建议在 Web 应用上使用 WebP 图片的原因，真的优化太大了。</p><h2 id="让-WebP-图片在-Mac-下正常预览"><a href="#让-WebP-图片在-Mac-下正常预览" class="headerlink" title="让 WebP 图片在 Mac 下正常预览"></a>让 WebP 图片在 Mac 下正常预览</h2><p>从这往上翻的第二张图，可以发现 WebP 格式的图片在 Mac 下是无法正常预览的，所以需要给 Mac 加上这种能力。另外需要说一句 WebP 图片在 Chrome 下可以很好的支持了，直接将图片拖到浏览器中即可显示。</p><p>说到预览，看一下 WebP 在各浏览器下的兼容程度：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp005.png"></p><p>由上图可以看出，基本上现代浏览器已经能很好的支持 WebP 图片了，所以在生产环境上使用它是一点问题都没有。</p><p>Mac 需要正常预览 WebP 图片，可以在这里 <a href="https://github.com/Nyx0uf/qlImageSize">qlImageSize</a> 下载了 2 个插件来支持它：</p><ul><li><code>qlImageSize</code>：<code>QuickLook</code> 插件，用来预览 WebP 图片，且能在标题栏里显示尺寸、文件大小等信息，另外还可以让 WebP 图片在访达中以缩略图的形式显示出来。</li><li><code>mdImageSize</code>：<code>Spotlight</code> 插件，用来在显示简介的时候能够支持 WebP 图片的信息；</li></ul><p>下载完这 2 个插件包后，解压，然后把插件复制到对应的目录下保存：</p><ul><li><code>qlImageSize</code> 复制到 <code>/Library/QuickLook</code> 目录下；</li><li><code>mdImageSize</code> 复制到 <code>/Library/Spotlight</code> 目录下；</li></ul><p>这个时候 WebP 图片应该就能快速预览了，还不行的话就重启下访达进程（按住 option，同时鼠标右键点击访达，选择重新开启）。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp004.png"></p><h2 id="兼容不同浏览器"><a href="#兼容不同浏览器" class="headerlink" title="兼容不同浏览器"></a>兼容不同浏览器</h2><p>如果你的网站对于不兼容 WebP 格式的图片的浏览器（比如 IE11）也有需求的话，那这里有一套方案可以让图片不会因为浏览器兼容性而显示出错：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;flower.webp&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/jpeg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;flower.jpg&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;flower.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于上面这段代码，浏览器会首先检测是否支持 <code>&lt;source&gt;</code> 标签列表里的资源，如果兼容的话，默认会加载 <code>flower.webp</code> 图片，如果都不支持 <code>&lt;source&gt;</code> 列表里的资源的话，则会去加载 <code>&lt;img&gt;</code> 里指定的图片。</p><h2 id="接下来该干什么"><a href="#接下来该干什么" class="headerlink" title="接下来该干什么"></a>接下来该干什么</h2><p>之前我做的项目里的图片基本都是 JPG\PNG 格式的，我找了一张我们网站首页的 Banner 图，就是那种 1920px 宽度的图片，它在被压缩工具压缩后文件大小还有 275 KB ，而当我用 cwebp 工具用 -q 75 的质量参数去转换成 WebP 图片后，你们知道它的文件大小变成多少了吗？它变成 50KB 😱</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp007.png"></p><p>真的的不试不知道，一试吓一跳，原来 WebP 格式的图片能够带来这么大的优化效果，最关键的是 2 张图片用肉眼看起来显示效果差不多。</p><p>真的很棒 👍，WebP 凭借一己之力将网站的性能优化提高了一个档次。所以接下来 KPI 就有了：可以很愉快的把项目里所有的图片都转成 WebP 图片了。这么干完之后，你就可以和领导提涨薪了，领导领导我把我们网站优化了一下，性能提升了 10% ~ 20% 左右。不过接下来发生什么，可不要来找我哈。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://web.dev/serve-images-webp/">https://web.dev/serve-images-webp/</a></li><li><a href="https://developers.google.com/speed/webp">https://developers.google.com/speed/webp</a></li><li><a href="https://github.com/Nyx0uf/qlImageSize">https://github.com/Nyx0uf/qlImageSize</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了一篇文章：&lt;a href=&quot;https://github.com/Bulandent/blog/issues/17&quot;&gt;jpg、gif、png 和 svg 用于 web 上，我们该如何选择最合适的图像格式&lt;/a&gt;，介绍了这几种图片格式的特点，以及如何为网站选择合适的图片，然后评论区有位大佬让我补充下 WebP 格式，于是乎它来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp006.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-WebP-格式&quot;&gt;&lt;a href=&quot;#什么是-WebP-格式&quot; class=&quot;headerlink&quot; title=&quot;什么是 WebP 格式&quot;&gt;&lt;/a&gt;什么是 WebP 格式&lt;/h2&gt;&lt;p&gt;WebP 是一种现代图像格式，可为 Web 上的图像提供出色的无损和有损压缩。 使用 WebP，网站管理员和 Web 开发人员可以创建更小，更丰富的图像，从而使 Web 更快。&lt;/p&gt;
&lt;p&gt;与 PNG 相比，WebP 无损图像的尺寸要小 26％。 在同等的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。&lt;/p&gt;
&lt;p&gt;无损 WebP 支持透明性（也称为 Alpha 通道），而仅增加了 22％ 的字节数。 对于可以接受有损 RGB 压缩的情况，有损 WebP 还支持透明性，与 PNG 相比，文件大小通常小 3 倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面这 3 段话来源于 &lt;a href=&quot;https://developers.google.com/speed/webp&quot;&gt;https://developers.google.com/speed/webp&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web综合" scheme="https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="图像" scheme="https://bubuzou.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
      <category term="性能优化" scheme="https://bubuzou.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>让人爱不释手的 JS 扩展操作符 13 用</title>
    <link href="https://bubuzou.com/2021/01/13/spread-operator/"/>
    <id>https://bubuzou.com/2021/01/13/spread-operator/</id>
    <published>2021-01-13T01:49:25.000Z</published>
    <updated>2021-01-26T00:43:28.808Z</updated>
    
    <content type="html"><![CDATA[<p>我相信你一定或多或少的接触或使用过 <code>JS</code> 中的扩展操作符（Spread Operator），在基本形式中，扩展操作符看起来像三个点，比如如下这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...arr]</span><br></pre></td></tr></table></figure><p>而实际上，它也就是这么用的，但是如果事情有这么简单，就不用我在这里写了。扩展操作符给我最大的印象就是，这玩意还挺方便的，然而最近写代码的时候经常性的遇到需要使用扩展操作符的场景，所以我干脆在网上找了些资料，把平时常见的应用场景给罗列了下，发现这个操作符是真的强大，有多强大？来看看下面这些用法吧。</p><h2 id="1-字符串转数组"><a href="#1-字符串转数组" class="headerlink" title="1. 字符串转数组"></a>1. 字符串转数组</h2><p>字符串转数组最普遍的做法是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure><p>而使用了扩展操作符后可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> arr = [...str]</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-将类数组转换为数组"><a href="#2-将类数组转换为数组" class="headerlink" title="2. 将类数组转换为数组"></a>2. 将类数组转换为数组</h2><p>在 <code>JS</code> 中有一种数据结构叫做 <code>NodeList</code>，它和数组很相似，也被叫做“类数组”，类数组是什么？在 MDN 中是这么定义它的：</p><blockquote><p>类数组：拥有一个 length 属性和若干索引属性的任意对象。</p></blockquote><p>类数组有哪些呢？以下这些可以看成是类数组：</p><ul><li><code>NodeList</code>：<code>document.querySelectorAll()</code> 返回的对象；</li><li><code>HTMLCollection</code>：<code>document.getElementsByTagName()</code> 返回的对象；</li><li><code>Arguments</code>：函数里的参数对象；</li></ul><p>类数组没有数组的一些方法比如 <code>push</code>、<code>map</code> 等，所以经常需要将它们转成数组，而通常我们是这么转化的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(nodeList <span class="keyword">instanceof</span> NodeList)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, nodeList)</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [].slice.call(nodeList)</span><br><span class="line"><span class="built_in">console</span>.log(arr2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 又或者</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="built_in">Array</span>.from(nodeList)</span><br><span class="line"><span class="built_in">console</span>.log(arr3 <span class="keyword">instanceof</span> <span class="built_in">Array</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>而有了扩展操作符可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> arr = [...nodeList]</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="3-向数组中添加项"><a href="#3-向数组中添加项" class="headerlink" title="3. 向数组中添加项"></a>3. 向数组中添加项</h2><p>往数组中添加几项通常这样操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头部添加</span></span><br><span class="line">arr.unshift(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1, 2, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从尾部添加</span></span><br><span class="line">arr.push(<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1，2, 5, 6, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从任意位置添加</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1，2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><p>使用扩展操作符后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, ...arr, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="4-拷贝数组和对象"><a href="#4-拷贝数组和对象" class="headerlink" title="4. 拷贝数组和对象"></a>4. 拷贝数组和对象</h2><p>通常拷贝一个数组，可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arr.slice()</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)   <span class="comment">// [2, 3, 5, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// [1, 3, 5, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr3)  <span class="comment">// [1, 3, 5, 7]</span></span><br></pre></td></tr></table></figure><p>但是有了扩展操作符，拷贝数组就能写得很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// [1, 3, 5, 7]</span></span><br></pre></td></tr></table></figure><p>同样的，扩展操作符还能拷贝对象。<br>拷贝对象的通常做法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Object</span>.assign(&#123;&#125;, person)</span><br><span class="line">person.age = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 20 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2)      <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>有了扩展操作符，拷贝一个对象就相当方便了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p2 = &#123;...person&#125;</span><br><span class="line">person.age = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 20 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2)      <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至还可以这么写</span></span><br><span class="line"><span class="keyword">let</span> &#123;...p3&#125; = person</span><br></pre></td></tr></table></figure><blockquote><p>注意：扩展操作符只能深拷贝结构为一层的对象，如果对象是两层的结构，那么使用扩展操作符拷贝会是浅拷贝。</p></blockquote><h2 id="5-合并数组或对象"><a href="#5-合并数组或对象" class="headerlink" title="5. 合并数组或对象"></a>5. 合并数组或对象</h2><p>数组合并通常是这么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr3 = arr1.concat( arr2 )</span><br><span class="line"><span class="built_in">console</span>.log(arr3)  <span class="comment">// [1, 3, 5, 2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>使用扩展操作符后，可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr3 = [...arr1, ...arr2]</span><br><span class="line"><span class="built_in">console</span>.log(arr3)  <span class="comment">// [1, 3, 5, 2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>对了，它除了能合并数组外还能合并对象呢。合并对象，通常的做法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p2 = &#123; <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Object</span>.assign(&#123;&#125;, p1, p2)</span><br><span class="line"><span class="built_in">console</span>.log(p3)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12&#125;</span></span><br></pre></td></tr></table></figure><p>用扩展操作符合并对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p2 = &#123; <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p3 = &#123; ...p1, ...p2 &#125;</span><br><span class="line"><span class="built_in">console</span>.log(p3)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12&#125;</span></span><br></pre></td></tr></table></figure><h2 id="6-解构对象"><a href="#6-解构对象" class="headerlink" title="6. 解构对象"></a>6. 解构对象</h2><p>经常我们给对象设置参数的时候会这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">    sex: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name = person.name</span><br><span class="line"><span class="keyword">let</span> age = person.age</span><br><span class="line"><span class="keyword">let</span> sex = person.sex</span><br></pre></td></tr></table></figure><p>而有了扩展操作符，我们就可以这么写，不过其实如下这种写法并不是扩展操作符的写法🤣，而是剩余操作符的写法，虽然写出来后看起来差不多，但就在操作对象这一点上，基本上可以认为它和扩展操作符是相反的操作，扩展操作符是用来展开对象的属性到多个变量上，而剩余操作符是用来把多个参数凝聚到一个变量上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">    sex: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name, ...reset &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(name)   <span class="comment">// &#x27;布兰&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(reset)  <span class="comment">// &#123; age: 12, sex: &#x27;male&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="7-给对象添加属性"><a href="#7-给对象添加属性" class="headerlink" title="7. 给对象添加属性"></a>7. 给对象添加属性</h2><p>给对象加属性通常这样加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line">person.age = <span class="number">12</span></span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>使用扩展操作符给对象添加属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line">person = &#123;...person, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>关于使用扩展操作符给对象添加属性，这里有 2 个小技巧：</p><ul><li><ol><li>给新对象设置默认值：</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认 person 对象的 age 属性值 为 12</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">age</span>: <span class="number">12</span>, ...&#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; age: 12, name: &#x27;布兰&#x27; &#125; </span></span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>重写对象属性</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 对象的 age 属性被重写为 20</span></span><br><span class="line">person = &#123;...person, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 20 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="8-设置对象-Getter"><a href="#8-设置对象-Getter" class="headerlink" title="8. 设置对象 Getter"></a>8. 设置对象 Getter</h2><p>设置对象 <code>Getter</code> 通常做法是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    get() &#123; <span class="keyword">return</span> <span class="number">12</span> &#125;,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.age)  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>而有了扩展操作符后可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line">person = &#123;</span><br><span class="line">    ...person, </span><br><span class="line">    <span class="keyword">get</span> <span class="title">age</span>() &#123; <span class="keyword">return</span> <span class="number">12</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.age)  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h2 id="9-将数组作为函数参数展开"><a href="#9-将数组作为函数参数展开" class="headerlink" title="9. 将数组作为函数参数展开"></a>9. 将数组作为函数参数展开</h2><p>如果我们有一个形参是多个参数的函数，但是当调用的时候发现入参却是一个数组，常规做法是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>) </span>&#123; &#125; </span><br><span class="line">fn.apply(<span class="literal">null</span>, arr)</span><br></pre></td></tr></table></figure><p>使用扩展操作符后，就简单多了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>) </span>&#123; &#125; </span><br><span class="line">fn(...arr)</span><br></pre></td></tr></table></figure><h2 id="10-无限参数的函数"><a href="#10-无限参数的函数" class="headerlink" title="10. 无限参数的函数"></a>10. 无限参数的函数</h2><p>如果有这么一个累加函数，他会把所有传递进来的参数都加起来，普通做法是把参数都整合到数组里，然后这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( doSum([<span class="number">1</span>, <span class="number">3</span>]) )     <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log( doSum([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]) )  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>如果参数不是数组，而是需要一个个传递，相当于函数必须支持无限参数，那可能会这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++)&#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="comment">// let args = [].slice.call(arguments) </span></span><br><span class="line">    <span class="comment">// return args.reduce((acc, cur) =&gt; acc + cur)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>) )        <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>) )     <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) )  <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>而有了扩展操作符，就简单多了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSum</span>(<span class="params">...arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>) )        <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>) )     <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) )  <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><h2 id="11-扩展函数的剩余参数"><a href="#11-扩展函数的剩余参数" class="headerlink" title="11. 扩展函数的剩余参数"></a>11. 扩展函数的剩余参数</h2><p>有的时候一个函数需要传递很多的参数，比如小程序页面（<code>WePY</code>）的 <code>onLoad</code> 生命周期函数里就可能有很多别的页面传递过来的参数，然后还需要在函数里进行一些数据初始化工作，这样一来就会显得很臃肿不美观，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">a, b, x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 进行一系列初始化数据工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用了扩展操作符后，我们就可以按照业务把参数进行解构，把本该在一个函数里进行初始化的工作拆分成多个，可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">other</span>(<span class="params"> x, y </span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">a, b, ...restConfig</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 a 和 b 参数进行操作</span></span><br><span class="line">    <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">    <span class="keyword">return</span> other( ...restConfig )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-结合-Math-函数使用"><a href="#12-结合-Math-函数使用" class="headerlink" title="12. 结合 Math 函数使用"></a>12. 结合 Math 函数使用</h2><p>比如当需要对一个数组求最大值的时候，通常会这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].concat(arr).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max(arr)[<span class="number">0</span>])  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> <span class="built_in">Math</span>.max(acc, cur))  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 又或者</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>但是使用扩展操作符后，能够把给数组求最大值写得更加简洁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...arr)</span><br><span class="line"><span class="built_in">console</span>.log(max)  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h2 id="13-在-new-表达式中使用"><a href="#13-在-new-表达式中使用" class="headerlink" title="13. 在 new 表达式中使用"></a>13. 在 new 表达式中使用</h2><p>假设有一个数组格式的日期，想要通过 Date 构造函数创建一个日期实例的话，可能会这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2021</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>([].toString.call(arr))</span><br><span class="line"><span class="built_in">console</span>.log(date)  <span class="comment">// &#x27;Mon Feb 01 2021 00:00:00 GMT+0800 (中国标准时间)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> (<span class="built_in">Function</span>.prototype.bind.apply(</span><br><span class="line">    <span class="built_in">Date</span>, </span><br><span class="line">    [<span class="literal">null</span>].concat(arr)</span><br><span class="line">))</span><br><span class="line"><span class="built_in">console</span>.log(date2)  <span class="comment">// &#x27;Mon Feb 01 2021 00:00:00 GMT+0800 (中国标准时间)&#x27; </span></span><br></pre></td></tr></table></figure><p>而有了扩展操作符就简单多了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2021</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(...arr)</span><br><span class="line"><span class="built_in">console</span>.log(date)  <span class="comment">// &#x27;Mon Feb 01 2021 00:00:00 GMT+0800 (中国标准时间)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个操作符真可谓使用简单无脑，但是功能效率上不得不说很强大，所以我们要做的就是只要记住在什么时候使用它就好了，于是乎为了让大家能更好的记住这 13 种使用场景，我特意做了一个图，方便大家记忆，是不是很贴？是的话请不要吝啬你的爱心，给个小星星👍吧，感谢感谢。以上这些只列了 13 种写法，我觉得作为一个这么强大的操作符，肯定有更多使用的场景，欢迎把你们知道的写到评论区吧。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/js_spread_operator.png"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/post/6896986598999588872#heading-46">「建议收藏」送你一份精心总结的3万字ES6实用指南（下）</a></li><li><a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md">https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md</a></li><li><a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Rest.md">https://github.com/tc39/proposal-object-rest-spread/blob/master/Rest.md</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我相信你一定或多或少的接触或使用过 &lt;code&gt;JS&lt;/code&gt; 中的扩展操作符（Spread Operator），在基本形式中，扩展操作符看起来像三个点，比如如下这样：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[...arr]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;而实际上，它也就是这么用的，但是如果事情有这么简单，就不用我在这里写了。扩展操作符给我最大的印象就是，这玩意还挺方便的，然而最近写代码的时候经常性的遇到需要使用扩展操作符的场景，所以我干脆在网上找了些资料，把平时常见的应用场景给罗列了下，发现这个操作符是真的强大，有多强大？来看看下面这些用法吧。&lt;/p&gt;
&lt;h2 id=&quot;1-字符串转数组&quot;&gt;&lt;a href=&quot;#1-字符串转数组&quot; class=&quot;headerlink&quot; title=&quot;1. 字符串转数组&quot;&gt;&lt;/a&gt;1. 字符串转数组&lt;/h2&gt;&lt;p&gt;字符串转数组最普遍的做法是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr = str.split(&lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr)  &lt;span class=&quot;comment&quot;&gt;// [&amp;#x27;h&amp;#x27;, &amp;#x27;e&amp;#x27;, &amp;#x27;l&amp;#x27;, &amp;#x27;l&amp;#x27;, &amp;#x27;o&amp;#x27;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;而使用了扩展操作符后可以这样：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr = [...str]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr)  &lt;span class=&quot;comment&quot;&gt;// [&amp;#x27;h&amp;#x27;, &amp;#x27;e&amp;#x27;, &amp;#x27;l&amp;#x27;, &amp;#x27;l&amp;#x27;, &amp;#x27;o&amp;#x27;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>6 分钟了解 HTTP 发展史</title>
    <link href="https://bubuzou.com/2021/01/05/http/"/>
    <id>https://bubuzou.com/2021/01/05/http/</id>
    <published>2021-01-05T01:49:25.000Z</published>
    <updated>2021-09-06T09:57:14.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。</p><h3 id="完整请求流程"><a href="#完整请求流程" class="headerlink" title="完整请求流程"></a>完整请求流程</h3><ul><li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li><li>建立好连接之后，会发送一个 GET 请求行的信息，如 GET /index.html 用来获取 index.html。</li><li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li><li>HTML 文档传输完成后，断开连接。</li></ul><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_031.png" alt="HTTP/0.9 请求过程"></p><a id="more"></a><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li><li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li><li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li></ul><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>HTTP/0.9 存在许多的问题，比如如下的这些：</p><ul><li>只支持 HTML 类型文件，无法传输 JS、CSS、字体、图片和视频等类型的文件；</li><li>文件传输格式局限于 ASCII，无法输出其他类型编码的文件；</li><li>只有请求行，传输给服务器的信息太少；</li><li>只响应请求数据，不能传输额外的数据给浏览器。</li></ul><p>所以它已经不能满足当时的需求了，于是乎 HTTP/1.0 来了，它带来了这些：</p><ul><li><p>新增了请求头和请求体，能传输更多的信息给服务器，比如如下请求头字段：Accept 文件类型，Accept-Encoding 压缩格式，Accept-Charset 字符编码格式，Accept-Language 国际化语音：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Accept: text&#x2F;html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Charset: ISO-8859-1,utf-8</span><br><span class="line">Accept-Language: zh-CN,zh</span><br></pre></td></tr></table></figure></li><li><p>请求头新增 User-Agent 字段，用于服务器统计客户端信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br></pre></td></tr></table></figure></li><li><p>新增了响应头，能够告诉浏览器更多的信息，比如 Content-Encoding 表示服务器返回文件的压缩类型，Content-Type 告诉浏览器服务器返回的是什么类型的文件以及使用了什么编码格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure></li><li><p>新增响应行状态码，用于告知浏览器当前请求的状态，比如 200 表示请求成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure></li><li><p>新增缓存机制，用来缓存已经下载过的资源，减轻了服务端压力。</p></li></ul><p>在构建请求流程上来看，HTTP/1.0 区别于 HTTP/0.9 最大的区别就是在请求和响应的时候新增了不少字段用于在浏览器和服务器之间通信。</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>HTTP/1.0 虽说已经能够传输不同类型的文件了，但是它还是有缺点的，比如每发出一次 HTTP 请求都需要经历如下阶段：</p><ul><li>建立 TCP 连接；</li><li>HTTP 请求；</li><li>HTTP 响应；</li><li>断开 TCP 连接。</li></ul><p>HTTP/1.0 发送多个同域名请求：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_032.png" alt="HTTP/1.0 的短链接"></p><p>可以发现每次请求都需要重新建立 TCP 连接和断开连接的操作，这无疑增加了网络开销，同时也延迟了页面显示。</p><p><strong>HTTP/1.1 在请求头中增加了 Connection 字段</strong>：用于提供 TCP 的持久连接**：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>它默认是开启持久连接的，即对于同一个域名，浏览器默认支持 6 个 TCP 持久连接。<br>当启用持久连接后，多个同域名下的请求发送会是如下情况：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_033.png" alt="HTTP/1.1 的持久连接"></p><p><strong>HTTP/1.1 中新增 Host 字段，用于支持虚拟主机</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: bubuzou.com</span><br></pre></td></tr></table></figure><blockquote><p>虚拟主机：一台物理机器上绑定多个虚拟主机，每个虚拟主机有单独的域名，这些域名都公用一个 IP 地址。</p></blockquote><p><strong>HTTP/1.1 通过引入 Chunk transfer 机制来支持动态内容</strong>：服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。</p><p><strong>HTTP/1.1 还引入了客户端 Cookie 机制和安全机制</strong></p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>我们知道 HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：</p><ul><li>增加了持久连接；</li><li>浏览器为每个域名最多同时维护 6 个 TCP 持久连接；</li><li>使用 CDN 的实现域名分片机制。</li></ul><h3 id="HTTP-1-1-中依然存在的问题"><a href="#HTTP-1-1-中依然存在的问题" class="headerlink" title="HTTP/1.1 中依然存在的问题"></a>HTTP/1.1 中依然存在的问题</h3><p>虽然 HTTP/1.1 采取了很多优化资源加载速度的策略，也取得了一定的效果，但是 HTTP/1.1 对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题。</p><p>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</p><p>之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。</p><p>之所以会出现这个问题，主要是 3 个问题导致的：</p><p><strong>第一个原因，TCP 的慢启动</strong></p><p>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。这个过程可以想象是一辆车的启动过程，开始的时候慢，当速度起来后加速就更快了。</p><p>而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p><p><strong>第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽</strong></p><p>你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。</p><p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p><p><strong>第三个原因，HTTP/1.1 队头阻塞的问题</strong></p><p>我们知道在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p><p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。</p><h3 id="HTTP-2-的多路复用"><a href="#HTTP-2-的多路复用" class="headerlink" title="HTTP/2 的多路复用"></a>HTTP/2 的多路复用</h3><p>为了解决 HTTP/1.1 中存在的问题，在 HTTP/2 中采用最具颠覆性的方案：多路复用机制。<br><img src="https://static001.geekbang.org/resource/image/0a/00/0a990f86ad9c19fd7d7620b2ef7ee900.jpg"></p><p><strong>HTTP/2 多路复用是什么</strong></p><p>HTTP/2 的多路复用机制用简单的话来说就是浏览器针对同一域名的资源，只建立一个 TCP 连接通道，所有的针对这个域名的请求全部都在这个通道中完成；</p><p>除此之外，数据的传输不再使用文本格式，而是会将它们分割为更小的流和帧，并对他们采用二进制格式的编码。在一个 TCP 连接通道中，支持任意数量的双向数据流，这些数据流是并行、乱序的且它们之间互不干扰。而数据流中传输的数据是二进制帧，它是 HTTP/2 中数据传输的最小单位，一个流中的帧是按照顺序传输的，且是并行的，所以无需按顺序等待。</p><p><strong>解决了什么问题</strong></p><p>因为只使用一个 TCP 连接，所以减少了由于 TCP 慢启动而消耗的时间，另外也由于只有单条 TCP 连接，所以不存在不同的 TCP 争夺网络带宽的问题。</p><p>客户端发送的请求经过二进制分帧层后，不再是一个个完整的 HTTP 请求报文，而是一堆乱序的帧（即不同流的帧是乱的，但是同一条流的帧数顺序传输的），所以就不会按顺序传输，也就不存在等待，从而解决了 HTTP 对头阻塞问题。</p><p><strong>是如何实现的</strong></p><ul><li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li><li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。请求头的信息存在 header 帧中，而请求体数据存在 data 帧中。</li><li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li><li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li><li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li><li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。</li></ul><h3 id="HTTP-2-其他特性"><a href="#HTTP-2-其他特性" class="headerlink" title="HTTP/2 其他特性"></a>HTTP/2 其他特性</h3><p><strong>1. 可以设置请求的优先级</strong></p><p>在浏览器中，某些数据是非常重要的，比如关键 CSS 或者 JS，这些重要的数据如果比较晚才推送到浏览器，那么对用户来说肯定是一个不好的体验。</p><p>所以 HTTP/2 中可以支持设置请求的优先级，这样服务器收到高优先级的请求后，会优先处理。</p><p><strong>2. 服务器推送</strong></p><p>在 HTTP/2 中服务器解析到一个 HTML 页面后，服务器知道浏览器需要这个页面上引用到的资源，比如 CSS 和 JS，那么服务器就会主动的把这些资源一并推送给浏览器，减少客户端的等待时间。</p><p><strong>3. 头部压缩</strong></p><p>HTTP/2 使用 HPACK 压缩算法对请求头和响应头进行压缩，虽然单个请求压缩之后效果不是很明显，但是如果一个页面有 100 个请求，那每个请求压缩 20% 之后，那提速效果就很明显了。</p><p>而 HPACK 的压缩原理其实就是 2 点：</p><ul><li>它要求客户端和服务器两者都维护和更新先前看到的报头字段的索引列表（即，建立共享的压缩上下文），然后将该列表用作有效编码先前传输的值的参考。在实际传输的时候用索引代替每一侧的静态或动态表中已经存在的字段，从而减小每个请求的大小。</li><li>它允许通过静态霍夫曼码对发送的标头字段进行编码，从而减小了它们各自的传输大小。</li></ul><h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h2><p>HTTP/2 依然是基于 TCP 的，所以还存在以下一些问题。</p><h3 id="TCP-的队头阻塞"><a href="#TCP-的队头阻塞" class="headerlink" title="TCP 的队头阻塞"></a>TCP 的队头阻塞</h3><p>HTTP/2 中多个请求是跑在一个 TCP 连接中的，如果某个数据流中出现了丢包的情况，就会阻塞该 TCP 连接中的所有请求。这个和 HTTP/1.1 中的不同，在 HTTP/1.1 中，由于浏览器为每个域名建立了 6 个 TCP 连接，如果其中一个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</p><h3 id="TCP-建立连接的延时"><a href="#TCP-建立连接的延时" class="headerlink" title="TCP 建立连接的延时"></a>TCP 建立连接的延时</h3><p>在传输数据之前，需要进行 TCP 的 3 次握手，需要花费 1.5 个 RTT；如果是 HTTPS，那还需要进行 TLS 连接，又需要 1 ~ 2 个 RTT。</p><blockquote><p>网络延迟又叫 RTT(Round Trip Time)，是从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间。</p></blockquote><p>总之，在传输数据之前需要花掉 3 ~ 4 个 RTT。如果客户端和服务器距离近的话，那 1 个 RTT 大概是 10ms，但如果远的话，可能是 100ms，所以传输数据之前需要花掉 300ms 左右，这个时候就能感觉到慢了。</p><h3 id="TCP-协议僵化"><a href="#TCP-协议僵化" class="headerlink" title="TCP 协议僵化"></a>TCP 协议僵化</h3><p>我们知道 TCP 协议存在队头阻塞和建立连接延迟的问题，但是又没办法改进 TCP 协议，理由有如下 2 个：</p><ul><li>中间设备僵化。中间设备比如路由器、交换机、防火墙和 NAT 等，这些设备依赖的软件使用了大量的 TCP 特性，一旦功能被设置后就很少进行更新了。如果在客户端进行升级 TCP 协议，那么当新协议的数据包经过这些设备的时候，可能会不理解包的内容，造成数据丢失。</li><li>操作系统也是导致 TCP 协议僵化的另外一个原因。</li></ul><h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p><img src="https://static001.geekbang.org/resource/image/0b/c6/0bae470bb49747b9a59f9f4bb496a9c6.png"></p><p>HTTP/3 是基于 UDP 实现的，实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。</p><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li><li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li><li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li><li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li></ul><h3 id="HTTP-3-的挑战"><a href="#HTTP-3-的挑战" class="headerlink" title="HTTP/3 的挑战"></a>HTTP/3 的挑战</h3><ul><li>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</li><li>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li><li>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～ 7% 的丢包率。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP-0-9&quot;&gt;&lt;a href=&quot;#HTTP-0-9&quot; class=&quot;headerlink&quot; title=&quot;HTTP/0.9&quot;&gt;&lt;/a&gt;HTTP/0.9&lt;/h2&gt;&lt;p&gt;HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。&lt;/p&gt;
&lt;h3 id=&quot;完整请求流程&quot;&gt;&lt;a href=&quot;#完整请求流程&quot; class=&quot;headerlink&quot; title=&quot;完整请求流程&quot;&gt;&lt;/a&gt;完整请求流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。&lt;/li&gt;
&lt;li&gt;建立好连接之后，会发送一个 GET 请求行的信息，如 GET /index.html 用来获取 index.html。&lt;/li&gt;
&lt;li&gt;服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。&lt;/li&gt;
&lt;li&gt;HTML 文档传输完成后，断开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_031.png&quot; alt=&quot;HTTP/0.9 请求过程&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="http" scheme="https://bubuzou.com/categories/http/"/>
    
    
      <category term="http" scheme="https://bubuzou.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Resourse Hints 知多少</title>
    <link href="https://bubuzou.com/2020/12/28/resource-hints/"/>
    <id>https://bubuzou.com/2020/12/28/resource-hints/</id>
    <published>2020-12-28T01:49:25.000Z</published>
    <updated>2021-01-14T02:21:56.536Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇文章 <a href="https://juejin.cn/post/6914479519394955271">探究网页资源究竟是如何阻塞浏览器加载的</a> 中介绍到 JS 会阻塞 DOM 的加载，样式会阻塞页面的渲染，外链样式里的自定义字体还会对文字造成闪动给用户带来不好的体验，诸如此类问题还有挺多，那到底该如何解决它们呢？</p><p>今天我们就来学习通过在 <code>link</code> 标签里加上特定的属性，比如 <code>preload</code>、<code>prefetch</code> 等来解决此类问题，那么你对这些属性又了解多少呢？把它们用在了你们的项目优化中了嘛？</p><a id="more"></a><h2 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h2><p><code>preload</code> 提升了资源加载的优先级，使得它提前开始加载（预加载），在需要用的时候能够更快的使用上。另外 <code>onload</code> 事件必须等页面所有资源都加载完成才触发，而当给某个资源加上 <code>preload</code> 后，该资源将不会阻塞 <code>onload</code>。</p><h3 id="preload-怎么用"><a href="#preload-怎么用" class="headerlink" title="preload 怎么用"></a>preload 怎么用</h3><p>当某个页面加载了 2 个脚本 <code>jquery.min.js</code> 和 <code>main.js</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时该页面的资源加载 <code>Waterfall</code> 长这样：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_019.png"></p><p>当在 <code>&lt;head&gt;</code> 里通过 <code>&lt;link&gt;</code> 标签给 <code>main.js</code> 配置 <code>preload</code> 预加载后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时的 <code>main.js</code> 加载顺序出现在了 <code>jquery.min.js</code> 的前面，这就是 <code>preload</code> 提升资源加载优先级的效果。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_020.png" alt="preload main.js"></p><blockquote><p>当一直刷新浏览器的时候，偶然出现 Waterfall 并不能准确的显示资源加载的顺序，所以这个时候就需要比较每个资源被加入到下载队列的时间，比如如下的 main.js 由于用了 preload 预加载，所以 queue time 比较早。</p></blockquote><p> <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_021.png" alt="preload main.js"><br> <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_022.png" alt="preload main.js"></p><p>通过 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 只是预加载了资源，但是资源加载完成后并不会执行，所以需要在想要执行的地方通过 <code>&lt;script&gt;</code> 来引入它：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是也有一个例外，因为 <code>CSS</code> 的加载也是通过 <code>&lt;link&gt;</code> 标签引入的，所以我们可以巧妙的利用这点，当 <code>onload</code> 事件触发的时候修改 <code>rel</code> 属性的值，使得它由原来的预加载样式变成引入样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;this.rel=&#x27;stylesheet&#x27;&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果通过 <code>preload</code> 加载了资源，但是又没有使用它，则浏览器会报一个警告：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_023.png" alt="preload main.js"></p><p><code>preload</code> 除了能够预加载脚本之外，还可以通过 <code>as</code> 指定别的资源类型，比如：</p><ul><li><code>style</code> 样式表；</li><li><code>font</code>：字体文件；</li><li><code>image</code>：图片文件；</li><li><code>audio</code>：音频文件；</li><li><code>video</code>：视频文件；</li><li><code>document</code>：文档。</li></ul><h3 id="preload-应用案例"><a href="#preload-应用案例" class="headerlink" title="preload 应用案例"></a>preload 应用案例</h3><p><code>preload</code> 主要用于提升当前页面某些阻塞资源的下载优先级，使得页面能够尽快渲染显示出来。</p><p><strong>案例一：预加载定义在 CSS 中资源的下载，比如自定义字体</strong></p><p>当页面中使用了自定义字体的时候，就必须在 <code>CSS</code> 中引入该字体，而由于字体必须要等到浏览器下载完且解析该 <code>CSS</code> 文件的时候才开始下载，所以对应页面上该字体处可能会出现闪动的现象，为了避免这种现象的出现，就可以使用 <code>preload</code> 来提前加载字体，<code>type</code> 可以用来指定具体的字体类型，<strong>加载字体必须指定 <code>crossorigin</code> 属性，否则会导致字体被加载两次</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">crossorigin</span> <span class="attr">type</span>=<span class="string">&quot;font/woff2&quot;</span> <span class="attr">href</span>=<span class="string">&quot;myfont.woff2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上这种写法和指定 <code>crossorigin=&quot;anonymous&quot;</code> 是等同的效果。</p><p><strong>案例二：预加载 CSS 文件</strong></p><p>在首屏加载优化中一直存在一种技术，叫做抽取关键 <code>CSS</code>，意思就是把页面中在视口中出现的样式抽出一个独立的 <code>CSS</code> 文件出来 <code>critical.css</code>，然后剩余的样式在放到另外一个文件上 <code>non-critical.css</code>：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_030.png"></p><p>由于 <code>CSS</code> 会阻塞页面的渲染，当同时去加载这 2 部分样式的时候，只要 <code>non-critical.css</code> 还没加载完成，那么页面就显示不了，而实际上只需要显示出视口下的界面即可，所以期待的结果是：当加载完成 <code>critical.css</code> 的时候马上显示出视口下的界面，不让 <code>non-critical.css</code> 阻塞渲染，则需要给 <code>non-critical.css</code> 加上预加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://bubuzou.com/non-critical.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://bubuzou.com/critical.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://bubuzou.com/non-critical.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>案例三：创建动态的预加载资源</strong></p><p>当需要预先加载的时候调用 <code>downloadScript</code>，而希望执行的时候则调用 <code>runScript</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">&quot;link&quot;</span>)</span><br><span class="line">    el.as = <span class="string">&quot;script&quot;</span></span><br><span class="line">    el.rel = <span class="string">&quot;preload&quot;</span></span><br><span class="line">    el.href = src</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(el)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>)</span><br><span class="line">    el.src = src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例四：结合媒体查询预加载响应式图片</strong></p><p><code>preload</code> 甚至还可以结合媒体查询加载对应尺寸下的资源，对于以下代码当可视区域尺寸小于 <code>600px</code> 的时候会提前加载这张图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;image&quot;</span> <span class="attr">href</span>=<span class="string">&quot;someimage.jpg&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 600px)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>案例五：结合 <code>Webpack</code> 预加载 <code>JS</code> 模块</strong></p><p><code>Webpack</code> 从 <code>4.6.0</code> 版本开始支持在魔术注释中配置预加载模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(_<span class="comment">/* webpackPreload: true */</span>_ <span class="string">&quot;CriticalChunk&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果是版本比较老的，则可以使用 <code>preload-webpack-plugin</code> 进行处理。</p><h2 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h2><p><code>preload</code> 用于提前加载用于当前页面的资源，而 <code>prefetch</code> 则是用于加载未来（比如下一个页面）会用到的资源，并且告诉浏览器在空闲的时候去下载，它会将下载资源的优先级降到最低。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_018.png"></p><p>比如在首页配置如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们会在页面中看到该脚本的下载优先级已经被降低为 <code>Lowest</code>：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_016.png"></p><p>当资源被下载完成后，会被存到浏览器缓存中，当从首页跳转到页面 A 的时候，假如页面 A 中引入了该脚本，那么浏览器会直接从 <code>prefetch cache</code> 中读取该资源，从而实现资源加载优化。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_017.png"></p><h2 id="preconnect"><a href="#preconnect" class="headerlink" title="preconnect"></a>preconnect</h2><p>当浏览器向服务器请求一个资源的时候，需要建立连接，而建立一个安全的连接需要经历以下 3 个步骤：</p><ul><li>查询域名并将其解析成 IP 地址（DNS Lookup）；</li><li>建立和服务器的连接（Initial connection）；</li><li>加密连接以确保安全（SSL）；</li></ul><p>以上 3 个步骤浏览器都需要和服务器进行通信，而这一来一往的请求和响应势必会耗费不少时间。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_029.png"></p><p>而就基于这点上，可以使用 <code>preconnect</code> 或者 <code>dns-prefetch</code> 进行优化，而它两又是什么呢？怎么使用呢？</p><h3 id="preconnect-是什么，怎么用"><a href="#preconnect-是什么，怎么用" class="headerlink" title="preconnect 是什么，怎么用"></a>preconnect 是什么，怎么用</h3><p>当我们的站点需要对别的域下的资源进行请求的时候，就需要和那个域建立连接，然后才能开始下载资源，如果我都已经知道了是和哪个域进行通信，那不就可以先建立连接，然后等需要进行资源请求的时候就可以直接进行下载了。</p><p>假设当前站点是 <code>https://a.com</code>，这个站点的主页需要请求 <code>https://b.com/b.js</code> 这个资源。对比正常请求和配置了 <code>preconnect</code> 时候的请求，它们在请求时间轴上看到的表现是不一样的：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_024.png"></p><p>通过如下配置可以提前建立和 <code>https://b.com</code> 这个域的连接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://b.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 <code>preconnect</code> 提早建立和第三方源的连接，可以将资源的加载时间缩短 100ms ~ 500ms，这个时间虽然看起来微不足道，但是它是实实在在的优化了页面的性能，提升了用户的体验。</p><blockquote><p>通过 preconnect 和别的域建立连接后，应该尽快的使用它，因为浏览器会关闭所有在 10 秒内未使用的连接。不必要的预连接会延迟其他重要资源，因此要限制 preconnect 连接域的数量。</p></blockquote><h3 id="preconnect-应用场景"><a href="#preconnect-应用场景" class="headerlink" title="preconnect 应用场景"></a>preconnect 应用场景</h3><p><strong>场景一：</strong></p><p>当知道资源是来源于哪个源下，但是对于加载哪个资源不是很明确的时候，比如对于如下这些资源：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_025.png"><br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_026.png"></p><p>它们要嘛是动态的，要嘛是根据不同环境携带不同参数，所以它们很适合用 <code>preconnect</code> 进行加载。</p><p><strong>场景二：</strong></p><p>如果页面上有流媒体，但是没那么快播放，又希望当按下播放按钮的时候可以越快开始越好，此时就可以使用 <code>preconnect</code> 预建立连接，节省一段时间。</p><p>如果用 <code>preconnect</code> 预建立连接的资源是一个字体文件，那么也是需要加上 <code>crossorigin</code> 属性。</p><h2 id="dns-prefetch"><a href="#dns-prefetch" class="headerlink" title="dns-prefetch"></a>dns-prefetch</h2><p>通常我们记住一个网站都是通过它的域名，但是对于服务器来说，它是通过 IP 来记住它们的。浏览器使用 <code>DNS</code> 来将站点转成 IP 地址，这个是建立连接的第一步，而这一步骤通常需要花费的时间大概是 20ms ~ 120ms。因此，可以通过 <code>dns-prefetch</code> 来节省这一步骤的时间。</p><p>居然能通过 <code>preconnect</code> 来减少整个建立连接的时间，那为什么还需要 <code>dns-prefetch</code> 来减少建立连接中第一步 DNS 查找解析的时间呢？</p><p>假如页面引入了许多第三方域下的资源，而如果它们都通过 <code>preconnect</code> 来预建立连接，其实这样的优化效果反而不好，甚至可能变差，所以这个时候就有另外一个方案，那就是对于最关键的连接使用 <code>preconnect</code>，而其他的则可以用 <code>dns-prefetch</code>。</p><p>可以按照如下方式配置 <code>dns-prefetch</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外由于 <code>preconnect</code> 的浏览器兼容稍微比 <code>dns-prefetch</code> 低，看下图：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_027.png" alt="preconnect"><br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_028.png" alt="dns-prefetch"></p><p>因此 <code>dns-prefetch</code> 可以作为不支持预连接的浏览器的后备选择，同时配置它们两即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/fi3ework/blog/issues/16">前端性能优化之关键路径渲染优化</a></li><li><a href="https://web.dev/link-prefetch/">https://web.dev/link-prefetch/</a></li><li><a href="https://www.w3.org/TR/resource-hints/">https://www.w3.org/TR/resource-hints/</a></li><li><a href="https://juejin.cn/post/6844903473163534343">译文Preload，Prefetch 和它们在 Chrome 之中的优先级</a></li><li><a href="https://shubo.io/preload-prefetch-preconnect">preload-prefetch-preconnect</a></li><li><a href="https://web.dev/extract-critical-css/">https://web.dev/extract-critical-css/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上篇文章 &lt;a href=&quot;https://juejin.cn/post/6914479519394955271&quot;&gt;探究网页资源究竟是如何阻塞浏览器加载的&lt;/a&gt; 中介绍到 JS 会阻塞 DOM 的加载，样式会阻塞页面的渲染，外链样式里的自定义字体还会对文字造成闪动给用户带来不好的体验，诸如此类问题还有挺多，那到底该如何解决它们呢？&lt;/p&gt;
&lt;p&gt;今天我们就来学习通过在 &lt;code&gt;link&lt;/code&gt; 标签里加上特定的属性，比如 &lt;code&gt;preload&lt;/code&gt;、&lt;code&gt;prefetch&lt;/code&gt; 等来解决此类问题，那么你对这些属性又了解多少呢？把它们用在了你们的项目优化中了嘛？&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>探究网页资源究竟是如何阻塞浏览器加载的</title>
    <link href="https://bubuzou.com/2020/12/26/browser-block/"/>
    <id>https://bubuzou.com/2020/12/26/browser-block/</id>
    <published>2020-12-26T01:49:25.000Z</published>
    <updated>2021-01-14T02:09:49.712Z</updated>
    
    <content type="html"><![CDATA[<p>一个页面允许加载的外部资源有很多，常见的有脚本、样式、字体、图片和视频等，对于这些外部资源究竟是如何影响整个页面的加载和渲染的呢？今天我们来一探究竟。</p><p>阅读完这篇文章你将解开如下谜团：</p><ul><li>如何用 Chrome 定制网络加载速度？</li><li>图片/视频/字体会阻塞页面加载嘛？</li><li>CSS 是如何阻塞页面加载的？</li><li>JS 又是如何阻塞页面加载的？</li><li>JS 一定会阻塞 DOM 加载嘛？</li><li>defer 和 async 是什么？又有何特点？</li><li>动态脚本会造成阻塞嘛？</li><li>阻塞是怎么和 DOMContentLoaded 与 onload 扯上关系的？</li></ul><a id="more"></a><h2 id="测试前环境准备"><a href="#测试前环境准备" class="headerlink" title="测试前环境准备"></a>测试前环境准备</h2><p>测试之前我们需要对浏览器下载资源的速度进行控制，将它重新设置为 50kb/s，操作方式：</p><ol><li>打开 <code>Chrome</code> 开发者工具；</li><li>在 <code>Network</code> 面板下找到 <code>Disable cache</code> 右侧的下拉列表，然后选择 Add 添加自定义节流配置；</li><li>添加一个下载速度为 50kb/s 的配置；</li><li>最后在第二步骤中的下拉列表选择刚刚配置的选项即可；</li><li>注意：如果当前选择的自定义选项被修改了，则需要切换到别的选项再切回来才可生效。</li></ol><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_005.png"></p><p>为什么是这个速度？因为如下的一些资源，比如图片、样式或者脚本体积都是 50kb 的好几倍，方便测试。</p><h2 id="图片会造成阻塞嘛"><a href="#图片会造成阻塞嘛" class="headerlink" title="图片会造成阻塞嘛"></a>图片会造成阻塞嘛</h2><p>直接写个示例来看下结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;DOMContentLoaded&#x27;</span>)</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;onload&#x27;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://xxx.oss-cn-shenzhen.aliyuncs.com/images/flow.png&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是 h2 标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这张图片的大小大概是 200kb，当把网络下载速度限制成 50kb/s，打开该页面，可以看到如下结果：当 <code>h1</code> 和 <code>h2</code> 标签渲染出来且打印了 <code>DOMContentLoaded</code> 的时候，此时图片还在加载中，这就说明了图片并不会阻塞 <code>DOM</code> 的加载，更加不会阻塞页面渲染；当图片加载完成的时候，会打印 <code>onload</code>，说明图片延迟了 <code>onload</code> 事件的触发。</p><p>视频、字体和图片其实是一样的，也不会阻塞 <code>DOM</code> 的加载和渲染。</p><h2 id="CSS-加载阻塞"><a href="#CSS-加载阻塞" class="headerlink" title="CSS 加载阻塞"></a>CSS 加载阻塞</h2><p>同样的，我们还是直接用代码来测试 <code>CSS</code> 加载对页面阻塞的情况，因为下面代码加载的 <code>bootstrap.css</code> 是 192kb 的，所以理论上下载它应该需要花费 3 到 4 秒左右。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试过程如下：</p><ol><li>在 <code>Elements</code> 面板下，选中 <code>h1</code> 这个标签，然后按 <code>delete</code> 键将它从 <code>DOM</code> 中删掉，从而模拟首次加载；</li><li>刷新浏览器，马上 <code>Elements</code> 面板下就加载出 <code>h1</code> 标签，继续加载 3 到 4 秒后（此时正在加载 <code>bootstrap.css</code>），页面出现 <code>我是 h1 标签</code> 字样，此时页面已经渲染完成。</li></ol><p>从而得出结论：</p><ul><li><code>bootstrap.css</code> 还没加载完成，而 <code>DOM</code> 中就已经出现 <code>h1</code> 标签，<strong>说明 <code>CSS</code> 不会阻塞 <code>DOM</code> 的解析</strong>；</li><li>页面直到 <code>bootstrap.css</code> 加载完成才出现 <code>h1</code> 里的文案，<strong>说明 <code>CSS</code> 会阻塞 <code>DOM</code> 的渲染</strong>。</li></ul><p>为什么是这个结论呢？试想一下页面渲染的流程就知道了。浏览器首先解析 <code>HTML</code> 生成 <code>DOM</code> 树，解析 <code>CSS</code> 生成 <code>CSSOM</code> 树，然后 <code>DOM</code> 树和 <code>CSSOM</code> 树进行合成生成渲染树，通过渲染树进行布局并且计算每个节点信息，绘制页面。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_006.png"></p><p>可以说解析 <code>DOM</code> 和 解析 <code>CSS</code> 其实是并列进行的，既然是并列进行的，那 <code>CSS</code> 和 <code>DOM</code> 就不会互相影响了，这和结论一相符；另外渲染页面一定是在得到 <code>CSSOM</code> 树之后进行的，这和结论二相符。</p><p><code>CSS</code> 一定会阻塞 <code>DOM</code> 的渲染嘛？答案是否定的，当把外链样式放到 <code>&lt;body&gt;</code> 最尾部去加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时刷新浏览器，页面上会马上显示出 <code>我是 h1 标签</code> 字样，当 3 到 4 秒过后样式加载完成的时会造成二次渲染，页面重新渲染出该字样，这就**说明 <code>CSS</code> 阻塞 <code>DOM</code> 的渲染只阻塞定义在 <code>CSS</code> 后面的 <code>DOM</code>**。二次渲染会对用户造成不好的体验且加重了浏览器的负担，所以这也就是为什么需要把外链样式提前到 <code>&lt;head&gt;</code> 里加载的原因。</p><h2 id="CSS-会阻塞后面-JS-的执行嘛"><a href="#CSS-会阻塞后面-JS-的执行嘛" class="headerlink" title="CSS 会阻塞后面 JS 的执行嘛"></a>CSS 会阻塞后面 JS 的执行嘛</h2><p><code>CSS</code> 阻塞了后面 <code>DOM</code> 的渲染，那它会阻塞 <code>JS</code> 的执行嘛？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;888&#x27;</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>刷新浏览器的时候可以看到，浏览器 <code>Console</code> 面板下没有打印内容，而当样式加载完成的时候打印了 888，这就<strong>说明 <code>CSS</code> 会阻塞定义在其之后 <code>JS</code> 的执行</strong>。</p><p>为什么会这样呢？试想一下，如果 <code>JS</code> 里执行的操作需要获取当前 <code>h1</code> 标签的样式，而由于样式没加载完成，所以就无法得到想要的结果，从而证明了 <code>CSS</code> 需要阻塞定义在其之后 <code>JS</code> 的执行。</p><h2 id="JS-加载阻塞"><a href="#JS-加载阻塞" class="headerlink" title="JS 加载阻塞"></a>JS 加载阻塞</h2><p><code>CSS</code> 会阻塞 <code>DOM</code> 的渲染和阻塞定义在其之后的 <code>JS</code> 的执行，那 <code>JS</code> 加载会对渲染过程造成什么影响呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先删除页面中已经存在的 <code>h1</code> 标签（如果存在的话），仔细观察 <code>Elements</code> 面板，当刷新浏览器的时候，一直未加载出 <code>h1</code> 标签（期间页面一直白屏），直到 <code>JS</code> 加载完成后，<code>DOM</code> 中才出现，这足以<strong>说明了 <code>JS</code> 会阻塞定义在其之后的 <code>DOM</code> 的加载</strong>，所以应该将外部 <code>JS</code> 放到 <code>&lt;body&gt;</code> 的最尾部去加载，减少页面加载白屏时间。</p><h2 id="defer-和-async"><a href="#defer-和-async" class="headerlink" title="defer 和 async"></a>defer 和 async</h2><p><code>JS</code> 一定会阻塞定义在其之后的 <code>DOM</code> 的加载嘛？来测试一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段代码的测试结果是当页面中显示出 h1 标签的时候，脚本还没有加载完成，这就说明了 <code>async</code> 脚本不会阻塞 <code>DOM</code> 的加载；同理我们可以用同样的方式测试 <code>defer</code>，也会得到这个结论。</p><p>现在我们知道了通过 <code>defer</code> 或者 <code>async</code> 方式加载 <code>JS</code> 的时候，它是不会阻塞 <code>DOM</code> 加载的。那么你知道 <code>defer</code> 和 <code>async</code> 是什么嘛？它们两者有什么区别呢？</p><p>回答这些疑问之前，我们先来看下当浏览器解析 <code>HTML</code> 遇到 <code>script</code> 标签的时候会发生什么？</p><ul><li>暂停解析 <code>DOM</code>；</li><li>执行 <code>script</code> 里的脚本，如果该 <code>script</code> 是外链，则会先下载它，下载完成后立刻执行；</li><li>执行完成后继续解析剩余 <code>DOM</code>。</li></ul><p>上面这是解析时遇到一个正常的外链的情况，正常外链的下载和执行都会阻塞页面解析；而如果外链是通过 <code>defer</code> 或者 <code>async</code> 加载的时候又会是如何呢？</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_009.png"></p><p><strong><code>defer</code> 特点</strong></p><ul><li>对于 <code>defer</code> 的 <code>script</code>，浏览器会继续解析 <code>html</code>，且同时并行下载脚本，等 <code>DOM</code> 构建完成后，才会开始执行脚本，所以它不会造成阻塞；</li><li><code>defer</code> 脚本下载完成后，执行时间一定是 <code>DOMContentLoaded</code> 事件触发之前执行；</li><li>多个 <code>defer</code> 的脚本执行顺序严格按照定义顺序进行，而不是先下载好的先执行；</li></ul><p><strong><code>async</code> 特点</strong></p><ul><li>对于 <code>async</code> 的 <code>script</code>，浏览器会继续解析 <code>html</code>，且同时并行下载脚本，一旦脚本下载完成会立刻执行；和 <code>defer</code> 一样，它在下载的时候也不会造成阻塞，但是如果它下载完成后 <code>DOM</code> 还没解析完成，则执行脚本的时候是会阻塞解析的；</li><li><code>async</code> 脚本的执行 和 <code>DOMContentLoaded</code> 的触发顺序无法明确谁先谁后，因为脚本可能在 <code>DOM</code> 构建完成时还没下载完，也可能早就下载好了；</li><li>多个 <code>async</code>，按照谁先下载完成谁先执行的原则进行，所以当它们之间有顺序依赖的时候特别容易出错。</li></ul><blockquote><p>defer 和 async 都只能用于外部脚本，如果 script 没有 src 属性，则会忽略它们。</p></blockquote><h2 id="动态脚本会造成阻塞嘛"><a href="#动态脚本会造成阻塞嘛" class="headerlink" title="动态脚本会造成阻塞嘛"></a>动态脚本会造成阻塞嘛</h2><p>对于如下这段代码，当刷新浏览器的时候会发现页面上马上显示出 <code>我是 h1 标签</code>，而过几秒后才加载完动态插入的脚本，所以可以得出结论：<strong>动态插入的脚本不会阻塞页面解析</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略了部分内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span></span><br><span class="line">        script.src = src</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.append(script)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    loadScript(<span class="string">&#x27;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>动态插入的脚本在加载完成后会立即执行，这和 <code>async</code> 一致，所以如果需要保证多个插入的动态脚本的执行顺序，则可以设置 <code>script.async = false</code>，此时动态脚本的执行顺序将按照插入顺序执行和 <code>defer</code> 一样。</p><h2 id="DOMContentLoaded-和-onload"><a href="#DOMContentLoaded-和-onload" class="headerlink" title="DOMContentLoaded 和 onload"></a>DOMContentLoaded 和 onload</h2><p>在浏览器中加载资源涉及到 2 个事件，分别是 <code>DOMContentLoaded</code> 和 <code>onload</code>，那么它们之间有什么区别呢？</p><ul><li><code>onload</code>：当页面所有资源（包括 <code>CSS</code>、<code>JS</code>、图片、字体、视频等）都加载完成才触发，而且它是绑定到 <code>window</code> 对象上；</li><li><code>DOMContentLoaded</code>：当 HTML 已经完成解析，并且构建出了 <code>DOM</code>，但此时外部资源比如样式和脚本可能还没加载完成，并且该事件需要绑定到 <code>document</code> 对象上；</li></ul><p>细心的你一定看到了上面的可能二字，为什么当 <code>DOMContentLoaded</code> 触发的时候样式和脚本是可能还没加载完成呢？</p><h3 id="DOMContentLoaded-遇到脚本"><a href="#DOMContentLoaded-遇到脚本" class="headerlink" title="DOMContentLoaded 遇到脚本"></a>DOMContentLoaded 遇到脚本</h3><p>当浏览器处理一个 <code>HTML</code> 文档，并在文档中遇到 <code>&lt;script&gt;</code> 标签时，就会在继续构建 <code>DOM</code> 之前运行它。这是一种防范措施，因为脚本可能想要修改 <code>DOM</code>，甚至对其执行 <code>document.write</code> 操作，所以 <strong><code>DOMContentLoaded</code> 必须等待脚本执行结束后才触发</strong>。以下这段代码验证了这个结论：当脚本加载完成的时候，<code>Console</code> 面板下才会打印出 <code>DOMContentLoaded</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;DOMContentLoaded&#x27;</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么一定是脚本执行完成后才会触发 <code>DOMContentLoaded</code> 嘛？答案也是否定的，有两个例外，对于 <code>async</code> 脚本和动态脚本是不会阻塞 <code>DOMContentLoaded</code> 触发的。</p><h3 id="DOMContentLoaded-遇到样式"><a href="#DOMContentLoaded-遇到样式" class="headerlink" title="DOMContentLoaded 遇到样式"></a>DOMContentLoaded 遇到样式</h3><p>前面我们已经介绍到 <code>CSS</code> 是不会阻塞 <code>DOM</code> 的解析的，所以理论上 <code>DOMContentLoaded</code> 应该不会等到外部样式的加载完成后才触发，这么分析是对的，让我们用下面代码进行测试一翻就知道了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;DOMContentLoaded&#x27;</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果：当样式还没加载完成的时候，就已经打印出 <code>DOMContentLoaded</code>，这和我们分析的结果是一致的。但是一定是这样嘛？显然不一定，这里有个小坑，（基于上面代码）在样式后面再加上 <code>&lt;script&gt;</code> 标签的时候，会发现只有等样式加载完成了才会打印出 <code>DOMContentLoaded</code>，为什么会这样呢？正是因为 <code>&lt;script&gt;</code> 会阻塞 <code>DOMContentLoaded</code> 的触发，所以<strong>当外部样式后面有脚本（<code>async</code> 脚本和动态脚本除外）的时候，外部样式就会阻塞 <code>DOMContentLoaded</code> 的触发</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只显示了部分内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://zh.javascript.info/onload-ondomcontentloaded">DOMContentLoaded</a></li><li><a href="https://html.spec.whatwg.org/multipage/scripting.html">https://html.spec.whatwg.org/multipage/scripting.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个页面允许加载的外部资源有很多，常见的有脚本、样式、字体、图片和视频等，对于这些外部资源究竟是如何影响整个页面的加载和渲染的呢？今天我们来一探究竟。&lt;/p&gt;
&lt;p&gt;阅读完这篇文章你将解开如下谜团：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何用 Chrome 定制网络加载速度？&lt;/li&gt;
&lt;li&gt;图片/视频/字体会阻塞页面加载嘛？&lt;/li&gt;
&lt;li&gt;CSS 是如何阻塞页面加载的？&lt;/li&gt;
&lt;li&gt;JS 又是如何阻塞页面加载的？&lt;/li&gt;
&lt;li&gt;JS 一定会阻塞 DOM 加载嘛？&lt;/li&gt;
&lt;li&gt;defer 和 async 是什么？又有何特点？&lt;/li&gt;
&lt;li&gt;动态脚本会造成阻塞嘛？&lt;/li&gt;
&lt;li&gt;阻塞是怎么和 DOMContentLoaded 与 onload 扯上关系的？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>很多人知道 Web Storage，但是你清楚 Cookie 嘛</title>
    <link href="https://bubuzou.com/2020/12/24/browser-store/"/>
    <id>https://bubuzou.com/2020/12/24/browser-store/</id>
    <published>2020-12-24T01:49:25.000Z</published>
    <updated>2021-07-07T07:26:28.837Z</updated>
    
    <content type="html"><![CDATA[<p>可以在浏览器的 <code>Application</code> 面板下看到浏览器的本地存储包含了：<code>Cookie</code>、<code>sessionStorage</code>、<code>localStorage</code> 和 <code>IndexedDB</code>。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_008.png"></p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie-是什么"><a href="#Cookie-是什么" class="headerlink" title="Cookie 是什么"></a>Cookie 是什么</h3><p><code>Cookie</code> 又叫 <code>HTTP Cookie</code> 或者叫浏览器 <code>Cookie</code>。<code>Cookie</code> 的作用是维护服务端和客户端的会话状态，简而言之就是告诉服务器当前客户端用户的一些信息，比如是否登录啥的。</p><a id="more"></a><h3 id="Cookie-是如何工作的"><a href="#Cookie-是如何工作的" class="headerlink" title="Cookie 是如何工作的"></a>Cookie 是如何工作的</h3><p><code>Cookie</code> 通常是由服务端生成，然后通过响应头的 <code>Set-Cookie</code> 发送给客户端浏览器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK</span><br><span class="line">Content-type: text&#x2F;html</span><br><span class="line">Set-Cookie: my_cookie&#x3D;bulandent</span><br></pre></td></tr></table></figure><!-- more  --><p>浏览器会将 <code>Cookie</code> 保存在本地，并且会在下次请求头部的 <code>Cookie</code> 中附上这个值：</p><pre><code>GET /home.html HTTP/1.1Host: www.example.orgCookie: my_cookie=bulandent</code></pre><h3 id="Cookie-分类"><a href="#Cookie-分类" class="headerlink" title="Cookie 分类"></a>Cookie 分类</h3><p>按照 <code>Cookie</code> 的生命周期可以将它分为两类：</p><ul><li>会话 <code>Cookie</code>：没有指定过期时间 （<code>Expires</code>）或有效期（<code>Max-Age</code>）的 <code>Cookie</code>，当浏览器关闭后会被自动删除，但是现在很多浏览器都实现了会话恢复功能，即使浏览器关闭，会话 <code>Cookie</code> 也会被保留下来；这种类型的 <code>Cookie</code> 会保存在浏览器的内存中；</li><li>持久性 <code>Cookie</code>：通过指定过期时间 （<code>Expires</code>）或有效期（<code>Max-Age</code>）的一种 <code>Cookie</code>，存储于客户端硬盘中。设定的日期和时间是指和客户端系统时间进行比较的。</li></ul><h3 id="Cookie-限制"><a href="#Cookie-限制" class="headerlink" title="Cookie 限制"></a>Cookie 限制</h3><p><code>Cookie</code> 会绑定特定的域名（<code>Domain</code>），除此之外，它还有如下一些限制：</p><p>通常，只要遵守以下大致的限制，就不会在任何浏览器中碰到问题：</p><ul><li>不超过 300 个 <code>Cookie</code>；</li><li>每个 <code>Cookie</code> 不超过 4KB；</li><li>每个域名下不超过 20 个 <code>Cookie</code>。</li></ul><p>每个域能设置的 <code>Cookie</code> 总数也是受限的，但不同浏览器的限制不同。例如：</p><ul><li>最新版 IE 和 Edge 限制每个域不超过 50 个 <code>Cookie</code>；</li><li>最新版 Firefox 限制每个域不超过 150 个 <code>Cookie</code>；</li><li>最新版 Opera 限制每个域不超过 180 个 <code>Cookie</code>；</li><li>Safari 和 Chrome 对每个域的 <code>Cookie</code> 数没有硬性限制。</li></ul><p>如果 <code>Cookie</code> 总数超过了单域名的上限，浏览器就会删除之前设置的 <code>Cookie</code>，而删除的逻辑不同浏览器也不大相同。</p><h3 id="Cookie-构成"><a href="#Cookie-构成" class="headerlink" title="Cookie 构成"></a>Cookie 构成</h3><p><code>Cookie</code> 构成除了以上提到的 <code>Name</code>、<code>Value</code>、<code>Domain</code>、<code>Expires/Max-Age</code> 外，还有几个比较重要的需要说下：</p><ul><li><p><code>Path</code>：请求 <code>URL</code> 中包含这个路径才会把 <code>Cookie</code> 发送到服务器；</p></li><li><p><code>Secure</code>：只有 <code>HTTPS</code> 请求才会发送标记为 <code>Secure</code> 的 <code>Cookie</code>；</p></li><li><p><code>HttpOnly</code>：将限制在客户端通过 <code>document.cookie</code> 读取设置为 <code>HttpOnly</code> 的 <code>Cookie</code>；</p></li><li><p><code>SameSite</code>：控制 <code>Cookie</code> 在跨站请求的时候是否会被发送，有 3 个值：</p><ul><li><code>None</code> 允许跨站请求发送；</li><li><code>Lax</code>：允许跨站 <code>GET</code> 请求发送；</li><li><code>Strict</code>：不允许跨站请求发送；</li></ul></li></ul><blockquote><p>除了服务器能够设置 Cookie 外，客户端也可以通过 document.cookie 设置。</p></blockquote><h3 id="Cookie-缺陷"><a href="#Cookie-缺陷" class="headerlink" title="Cookie 缺陷"></a>Cookie 缺陷</h3><ul><li><code>Cookie</code> 会被附加在每个 <code>HTTP</code> 请求中，所以无形中增加了流量；</li><li>由于在 <code>HTTP</code> 请求中的 <code>Cookie</code> 是明文传递的，所以安全性成问题，除非用超文本传输安全协定；</li><li><code>Cookie</code> 的大小限制在 <code>4KB</code> 左右，对于复杂的存储需求来说是不够用的。</li></ul><h3 id="Cookie-安全"><a href="#Cookie-安全" class="headerlink" title="Cookie 安全"></a>Cookie 安全</h3><p>黑客常常会利用 <code>Cookie</code> 进行攻击，比如 <code>XSS</code> 和 <code>CSRF</code> 等；所以为了网站安全，通常需要针对 <code>Cookie</code> 做一些安全措施：</p><ul><li>对特殊的 <code>Cookie</code> 设置 <code>HttpOnly</code>，防止被客户端脚本读取，比如维护登录状态的 <code>Cookie</code> 就可以这么做；</li><li>用于敏感信息（例如指示身份验证）的 <code>Cookie</code> 的生存期应较短，并且 <code>SameSite</code> 属性设置为<code>Strict</code> 或 <code>Lax</code>。</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p><code>Web Storage</code> 存在的目的就是为了解决每次向服务器请求的时候都需要携带 <code>Cookie</code> 信息的问题。<code>Web Storage</code> 包含了 2 个对象：<code>sessionStorage</code> 和 <code>localStorage</code>。通过这 2 个对象实现了：</p><ul><li>提供在 <code>Cookie</code> 之外的存储会话数据的途径；</li><li>提供跨会话持久化存储大量数据的机制。</li></ul><h3 id="Web-Storage-的限制"><a href="#Web-Storage-的限制" class="headerlink" title="Web Storage 的限制"></a>Web Storage 的限制</h3><p>和其他客户端数据存储方案一样，<code>Web Storage</code> 也有限制。</p><ul><li>存储大小：不同浏览器给 <code>sessionStorage</code> 和 <code>localStorage</code> 设置了不同的空间限制，但大多数会限制为每个源 5MB；</li><li>存储类型：只能存储字符串，所以如果数据是对象结构的，需要通过 <code>JSON.stringify</code> 先转成字符串；</li><li>存储限制于同一个源（<code>origin</code>），这也是同源策略的限制之一。即 <code>http://a.com</code> 和 <code>https://a.com</code> 存储的 ``Web Storage` 数据是不相同的。</li></ul><p><code>Web Storage</code> 提供了一套详细的 <code>API</code> 使得我们可以很好的进行数据存储：</p><p><strong>属性</strong></p><ul><li><code>Storage.length</code>：返回一个整数，表示存储在 Storage 对象中的数据项数量。</li></ul><p><strong>方法</strong></p><ul><li><code>Storage.key(n)</code>：该方法接受一个数值 n 作为参数，并返回存储中的第 n 个键名；</li><li><code>Storage.getItem()</code>：该方法接受一个键名作为参数，返回键名对应的值；</li><li><code>Storage.setItem()</code>：该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值；</li><li><code>Storage.removeItem()</code>：该方法接受一个键名作为参数，并把该键名从存储中删除；</li><li><code>Storage.clear()</code>：调用该方法会清空存储中的所有键名。</li></ul><p><code>sessionStorage</code> 和 <code>localStorage</code> 都是 <code>Storage</code> 的实例，所以自然而然的它们都拥有上面的属性和方法。</p><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p><code>sessionStorage</code> 对象只会存储会话数据，这意味着当浏览器 tab 页被关闭的时候，对应的 <code>sessionStorage</code> 数据将被清除。除此之外，它还有如下表现：</p><ul><li>不受页面刷新（包括强制刷新）影响，并且可以在浏览器崩溃并重启后恢复；</li><li>在当前页面通过新标签页或窗口打开一个新页面的时候，新页面会复制父级页面的 <code>sessionStorage</code> 数据；</li><li>使用同一个 <code>URL</code> 打开多个标签页，它们各自的 <code>sessionStorage</code> 数据不同；</li></ul><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>区别于 <code>sessionStorage</code>，<code>localStorage</code> 的存储不受会话限制而且能够长期存储于客户端浏览器中，直到手动删除或者清除浏览器缓存。</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>虽然 <code>Web Storage</code> 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心，这个时候就需要用到 <code>IndexedDB</code>，它类似于 <code>MySQL</code>，但是和传统数据库最大的区别在于，它是适用对象存储而不是表格保存数据。<code>IndexedDB</code> 也受到源的限制。</p><h3 id="和-Web-Storage-的区别"><a href="#和-Web-Storage-的区别" class="headerlink" title="和 Web Storage 的区别"></a>和 Web Storage 的区别</h3><ul><li>存储大小：<code>Web Storage</code> 限制每个源大约 5MB。<code>IndexedDB</code> 的存储空间有 2 个限制：全局限制即为浏览器的最大存储空间一般是可用磁盘空间的 50%；组限制为全局限制的 20%，且它至少有 10MB，最大为 2GB 存储空间；</li><li>存储类型：<code>Web Storage</code> 只能存储字符串，<code>IndexedDB</code> 可以存储字符串、<code>Blob</code> 和 <code>ArrayBuffer</code>；</li><li><code>Web Storage</code> 的存储操作是同步进行的；<code>IndexedDB</code> 由于数据量大，所以多数操作都是异步执行的；</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP Cookies</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria">Browser_storage_limits_and_eviction_criteria</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以在浏览器的 &lt;code&gt;Application&lt;/code&gt; 面板下看到浏览器的本地存储包含了：&lt;code&gt;Cookie&lt;/code&gt;、&lt;code&gt;sessionStorage&lt;/code&gt;、&lt;code&gt;localStorage&lt;/code&gt; 和 &lt;code&gt;IndexedDB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_008.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;h3 id=&quot;Cookie-是什么&quot;&gt;&lt;a href=&quot;#Cookie-是什么&quot; class=&quot;headerlink&quot; title=&quot;Cookie 是什么&quot;&gt;&lt;/a&gt;Cookie 是什么&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Cookie&lt;/code&gt; 又叫 &lt;code&gt;HTTP Cookie&lt;/code&gt; 或者叫浏览器 &lt;code&gt;Cookie&lt;/code&gt;。&lt;code&gt;Cookie&lt;/code&gt; 的作用是维护服务端和客户端的会话状态，简而言之就是告诉服务器当前客户端用户的一些信息，比如是否登录啥的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器专题之缓存篇</title>
    <link href="https://bubuzou.com/2020/12/20/browser-cache/"/>
    <id>https://bubuzou.com/2020/12/20/browser-cache/</id>
    <published>2020-12-20T01:49:25.000Z</published>
    <updated>2021-01-14T02:04:36.932Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器缓存一直是个老生常谈的话题，也是面试官常常用来鉴别面试者的利器，作为前端来讲这块知识是属于必须掌握的，再者利用好缓存也是做性能优化的有效方法。本文将从缓存原因、缓存读写顺序，缓存位置以及缓存策略这几个角度介绍浏览器缓存，并且最后给出实践的应用举例。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_015.png"></p><h2 id="为什么要缓存"><a href="#为什么要缓存" class="headerlink" title="为什么要缓存"></a>为什么要缓存</h2><p>很多同学知道缓存的位置和字段，知道怎么用，但是你有没有想过为什么我们的页面需要浏览器缓存呢？</p><ul><li>缓存可以减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定是比从服务器请求更快的；</li><li>减少网络带宽消耗：对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。试想一下如果可以使用缓存，只会产生极小的网络流量，这将有效的降低运营成本。</li><li>降低服务器压力：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。</li></ul><a id="more"></a><h2 id="缓存读写顺序"><a href="#缓存读写顺序" class="headerlink" title="缓存读写顺序"></a>缓存读写顺序</h2><p>当浏览器对一个资源（比如一个外链的 <code>a.js</code>）进行请求的时候会发生什么？请从缓存的角度大概说下：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_012.png"></p><ol><li>调用 <code>Service Worker</code> 的 <code>fetch</code> 事件获取资源；</li><li>查看 <code>memory cache</code>；</li><li>查看 <code>disk cache</code>；这里又细分：<ul><li>如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200；</li><li>如果有强制缓存但已失效，使用协商缓存，比较后确定 304 还是 200；</li></ul></li><li>发送网络请求，等待网络响应；</li><li>把响应内容存入 <code>disk cache</code> (如果请求头信息配置可以存的话)；</li><li>把响应内容的引用存入 <code>memory cache</code> (无视请求头信息的配置，除了 <code>no-store</code> 之外)；</li><li>把响应内容存入 <code>Service Worker</code> 的 <code>Cache Storage</code> (如果 <code>Service Worker</code> 的脚本调用了 <code>cache.put()</code>)；</li></ol><p>上面这一系列过程其实是浏览器查找缓存和把资源存入缓存的执行流程。这其中出现了很多专业词汇，让人看了一脸懵逼，下面将从缓存位置和缓存策略两个角度简要介绍浏览器的缓存。</p><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_013.png"></p><p>从浏览器开发者工具的 <code>Network</code> 面板下某个请求的 <code>Size</code> 中可以看到当前请求资源的大小以及来源，从这些来源我们就知道该资源到底是从 <code>memory cache</code> 中读取的呢，还是从 <code>disk cache</code> 中读取的，亦或者是服务器返回的。而这些就是缓存位置：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_011.png"></p><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p> 是一个注册在指定源和路径下的事件驱动 <code>worker</code>；特点是：</p><ul><li>运行在 <code>worker</code> 上下文，因此它不能访问 <code>DOM</code>；</li><li>独立于主线程之外，不会造成阻塞；</li><li>设计完全异步，所以同步 <code>API</code>（如 <code>XHR</code> 和 <code>localStorage</code> ）不能在 <code>Service Worker</code> 中使用；</li><li>最后处于安全考虑，必须在 <code>HTTPS</code> 环境下才可以使用；</li></ul><p>说了这么多特点，那它和缓存有啥关系？其实它有一个功能就是离线缓存：<code>Service Worker Cache</code>；区别于浏览器内部的 <code>memory cache</code> 和 <code>disk cache</code>，它允许我们自己去操控缓存，具体操作过程可以参看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers">Using_Service_Workers</a>；通过 <code>Service Worker</code> 设置的缓存会出现在浏览器开发者工具 <code>Application</code> 面板下的 <code>Cache Storage</code> 中。</p><h3 id="memory-cache"><a href="#memory-cache" class="headerlink" title="memory cache"></a>memory cache</h3><p>是浏览器内存中的缓存，相比于 <code>disk cache</code> 它的特点是读取速度快，但容量小，且时效性短，一旦浏览器 <code>tab</code> 页关闭，<code>memory cache</code> 就将被清空。<code>memory cache</code> 会自动缓存所有资源嘛？答案肯定是否定的，当 <code>HTTP</code> 头设置了 <code>Cache-Control: no-store</code> 的时候或者浏览器设置了 <code>Disabled cache</code> 就无法把资源存入内存了，其实也无法存入硬盘。当从 <code>memory cache</code> 中查找缓存的时候，不仅仅会去匹配资源的 <code>URL</code>，还会看其 <code>Content-type</code> 是否相同。</p><h3 id="disk-cache"><a href="#disk-cache" class="headerlink" title="disk cache"></a>disk cache</h3><p>也叫 <code>HTTP cache</code> 是存在硬盘中的缓存，根据 <code>HTTP</code> 头部的各类字段进行判定资源的缓存规则，比如是否可以缓存，什么时候过期，过期之后需要重新发起请求吗？相比于 <code>memory cache</code> 的 <code>disk cache</code> 拥有存储空间时间长等优点，网站中的绝大多数资源都是存在 <code>disk cache</code> 中的。</p><blockquote><p>浏览器如何判断一个资源是存入内存还是硬盘呢？关于这个问题，网上说法不一，不过比较靠谱的观点是：对于大文件大概率会存入硬盘中；当前系统内存使用率高的话，文件优先存入硬盘。</p></blockquote><p>缓存按照缓存位置划分，其实还有一个 <code>HTTP/2</code> 的内容 <code>push cache</code>，由于目前国内对 <code>HTTP/2</code> 应用还不广泛，且网上对 <code>push cache</code> 的知识还不齐全，所以本篇不打算介绍这块，感兴趣的可以阅读这篇文章：<a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">HTTP/2 push is tougher than I thought</a></p><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_014.png"></p><p>根据 <code>HTTP header</code> 的字段又可以将缓存分成强缓存和协商缓存。强缓存可以直接从缓存中读取资源返回给浏览器而不需要向服务器发送请求，而协商缓存是当强缓存失效后（过了过期时间），浏览器需要携带缓存标识向服务器发送请求，服务器根据缓存标识决定是否使用缓存的过程。强缓存的字段有：<code>Expires</code> 和 <code>Cache-Control</code>。协商缓存的字段有：<code>Last-Modified</code> 和 <code>ETag</code>。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code> 是 <code>HTTP/1.0</code> 的字段，表示缓存过期时间，它是一个 <code>GMT</code> 格式的时间字符串。<code>Expires</code> 需要在服务端配置（具体配置也根据服务器而定），浏览器会根据该过期日期与客户端时间对比，如果过期时间还没到，则会去缓存中读取该资源，如果已经到期了，则浏览器判断为该资源已经不新鲜要重新从服务端获取。由于 <code>Expires</code> 是一个绝对的时间，所以会局限于客户端时间的准确性，从而可能会出现浏览器判断缓存失效的问题。如下是一个 <code>Expires</code> 示例，是一个日期/时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 21 Oct 2020 07:28:00 GMT</span><br></pre></td></tr></table></figure><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>它是 <code>HTTP/1.1</code> 的字段，其中的包含的值很多：</p><ul><li><code>max-age</code> 最大缓存时间，值的单位是秒，在该时间内，浏览器不需要向浏览器请求。这个设置解决了 <code>Expires</code> 中由于客户端系统时间不准确而导致缓存失效的问题；</li><li><code>must-revalidate</code>：如果超过了 <code>max-age</code> 的时间，浏览器必须向服务器发送请求，验证资源是否还有效；</li><li><code>public</code> 响应可以被任何对象（客户端、代理服务器等）缓存；</li><li><code>private</code> 响应只能被客户端缓存；</li><li><code>no-cache</code> 跳过强缓存，直接进入协商缓存阶段；</li><li><code>no-store</code> 不缓存任何内容，设置了这个后资源也不会被缓存到内存和硬盘；</li></ul><p><code>Cache-Control</code> 的值是可以混合使用的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private, max-age&#x3D;0, no-cache</span><br></pre></td></tr></table></figure><p>当混合使用的时候它们的优先级如下图所示：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_003.png"></p><p><strong>当 <code>Expires</code> 和 <code>Cache-Control</code> 都被设置的时候，浏览器会优先考虑后者</strong>。当强缓存失效的时候，则会进入到协商缓存阶段。具体细节是这样：浏览器从本地查找强缓存，发现失效了，然后会拿着缓存标识请求服务器，服务器拿着这个缓存标识和对应的字段进行校验资源是否被修改，如果没有被修改则此时响应状态会是 304，且不会返回请求资源，而是直接从浏览器缓存中读取。</p><p>而浏览器缓存标识可以是：<code>Last-Modified</code> 和 <code>ETag</code>：</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>资源的最后修改时间；第一次请求的时候，响应头会返回该字段告知浏览器资源的最后一次修改时间；浏览器会将值和资源存在缓存中；再次请求该资源的时候，如果强缓存过期，则浏览器会设置请求头的 <code>If-Modifined-Since</code> 字段值为存储在缓存中的上次响应头 <code>Last-Modified</code> 的值，并且发送请求；服务器拿着 <code>If-Modifined-Since</code> 的值和 <code>Last-Modified</code> 进行对比。如果相等，表示资源未修改，响应 304；如果不相等，表示资源被修改，响应 200，且返回请求资源。如果资源更新的速度是小于 1 秒的，那么该字段将失效，因为 <code>Last-Modified</code> 时间是精确到秒的。所以有了 <code>ETag</code>。</p><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>根据资源内容生成的唯一标识，资源是否被修改的判断过程和上面的一致，只是对应的字段替换了。<code>Last-Modified</code> 替换成 <code>ETag</code>，<code>If-Modifined-Since</code> 替换成 <code>If-None-Match</code>。</p><p>当 <code>Last-Modified</code> 和 <code>ETag</code> 都被设置的时候，浏览器会优先考虑后者。</p><h2 id="浏览器的行为"><a href="#浏览器的行为" class="headerlink" title="浏览器的行为"></a>浏览器的行为</h2><ul><li>浏览器地址栏输入 <code>URL</code> 后回车： 查找 <code>disk cache</code> 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (⌘ + R)：因为 <code>TAB</code> 页并没有关闭，因此 <code>memory cache</code> 是可用的，会被优先使用(如果匹配的话)，其次才是 <code>disk cache</code>。</li><li>强制刷新 (⇧ + ⌘ + R)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了 <code>Pragma: no-cache</code>)。服务器直接返回 200 和最新内容。</li><li>当在开发者工具 <code>Network</code> 面板下设置了 <code>Disabled cache</code> 禁用缓存后，浏览器将不会从 <code>memory cache</code> 或者 <code>disk cache</code> 中读取缓存，而是直接发起网络请求。</li></ul><h2 id="缓存应用"><a href="#缓存应用" class="headerlink" title="缓存应用"></a>缓存应用</h2><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>比如页面引入了一个 <code>JQuery</code>，对于页面来说这个脚本就是一个工具库，基本上是不会发生变化的，对于这种资源可以将它的缓存时间设置得长一点，比如如下这个地址的脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>你会看到它的响应头里设置了，<code>max-age=2592000</code> 直接缓存 30 天：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: public, max-age&#x3D;2592000</span><br></pre></td></tr></table></figure><h3 id="频繁变化的资源"><a href="#频繁变化的资源" class="headerlink" title="频繁变化的资源"></a>频繁变化的资源</h3><p>对于频繁变化的资源，比如某个页面经常需要调整，那么这个页面就需要在每次请求的时候都进行验证，可以在响应头这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: no-cache</span><br></pre></td></tr></table></figure><h3 id="不进行缓存"><a href="#不进行缓存" class="headerlink" title="不进行缓存"></a>不进行缓存</h3><p>当然并不是所有请求都能被缓存，无法被浏览器缓存的请求如下：</p><ol><li><code>HTTP</code> 信息头中包含 <code>Cache-Control: no-cache</code> ，<code>pragma: no-cache（HTTP1.0）</code>，或 <code>Cache-Control: max-age=0</code> 等告诉浏览器不用缓存的请求；</li><li>需要根据 <code>Cookie</code>、认证信息等决定输入内容的动态请求是不能被缓存的；</li><li>经过 <code>HTTPS</code> 安全加密的请求；</li><li><code>POST</code> 请求无法被缓存；</li><li><code>HTTP</code> 响应头中不包含 <code>Last-Modified/Etag</code>，也不包含 <code>Cache-Control/Expires</code> 的请求无法被缓存；</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/ljianshu/Blog/issues/23">深入理解浏览器的缓存机制</a></li><li><a href="https://juejin.cn/post/6844903747357769742">一文读懂前端缓存</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service_Worker_API</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器缓存一直是个老生常谈的话题，也是面试官常常用来鉴别面试者的利器，作为前端来讲这块知识是属于必须掌握的，再者利用好缓存也是做性能优化的有效方法。本文将从缓存原因、缓存读写顺序，缓存位置以及缓存策略这几个角度介绍浏览器缓存，并且最后给出实践的应用举例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_015.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么要缓存&quot;&gt;&lt;a href=&quot;#为什么要缓存&quot; class=&quot;headerlink&quot; title=&quot;为什么要缓存&quot;&gt;&lt;/a&gt;为什么要缓存&lt;/h2&gt;&lt;p&gt;很多同学知道缓存的位置和字段，知道怎么用，但是你有没有想过为什么我们的页面需要浏览器缓存呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存可以减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定是比从服务器请求更快的；&lt;/li&gt;
&lt;li&gt;减少网络带宽消耗：对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。试想一下如果可以使用缓存，只会产生极小的网络流量，这将有效的降低运营成本。&lt;/li&gt;
&lt;li&gt;降低服务器压力：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从输入 URL 到页面显示发生了什么</title>
    <link href="https://bubuzou.com/2020/12/16/browser-url/"/>
    <id>https://bubuzou.com/2020/12/16/browser-url/</id>
    <published>2020-12-16T01:49:25.000Z</published>
    <updated>2021-01-14T02:01:49.390Z</updated>
    
    <content type="html"><![CDATA[<p>读了李兵老师的 <a href="https://time.geekbang.org/column/article/117637">浏览器的工作原理与实践</a>，让我对浏览器的工作原理有了更加深刻的理解，尤其是从用户输入 URL 到页面显示这一过程发生的事情，以往看的文章都是点到为止，而他却说得面面俱到非常详细，遂我把内容总结了一下分享给大家，值得你花个 5 分钟阅读一下。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_002.png"></p><a id="more"></a><h2 id="用户输入阶段"><a href="#用户输入阶段" class="headerlink" title="用户输入阶段"></a>用户输入阶段</h2><ol><li>合成 <code>URL</code>：用户输入 <code>URL</code>，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容 + 默认搜索引擎合成新的 <code>URL</code>；如果用户输入的内容符合 <code>URL</code> 规则，浏览器就会根据 <code>URL</code> 协议，在这段内容上加上协议合成合法的 <code>URL</code>；</li><li>加载：用户输入完内容，按下回车键，浏览器导航栏显示 <code>loading</code> 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得；</li></ol><h2 id="发起URL请求阶段"><a href="#发起URL请求阶段" class="headerlink" title="发起URL请求阶段"></a>发起URL请求阶段</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_001.png"></p><ol><li>构建请求：浏览器进程首先会构建请求行信息，然后通过进程间通信（<code>IPC</code>）将 <code>URL</code> 请求发送给网络进程；</li><li>查找缓存：网络进程获取到 <code>URL</code>，先去本地缓存中查找是否有缓存资源，如果有则拦截请求，直接将缓存资源返回给浏览器进程；否则，进入网络请求阶段；</li><li><code>DNS</code> 解析：网络进程请求首先会从 <code>DNS</code> 数据缓存服务中查找是否缓存过当前域名信息，有则直接返回；否则，会进行 <code>DNS</code> 解析返回域名对应的 <code>IP</code> 和端口号，如果没有指定端口号，<code>http</code> 默认 80 端口，<code>https</code> 默认 443。如果是 <code>https</code> 请求，还需要建立 <code>TLS</code> 连接；</li><li>等待 <code>TCP</code> 队列：<code>Chrome</code> 有个机制，同一个域名同时最多只能建立 6 个 <code>TCP</code> 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立 <code>TCP</code> 连接；</li><li>建立 <code>TCP</code> 连接：<code>TCP</code> 三次握手与服务器建立连接，然后进行数据的传输，最后；</li><li>发送 <code>HTTP</code> 请求：浏览器首先会向服务器发送请求行，它包含了请求方法、请求 <code>URI</code> 和 <code>HTTP</code> 协议的版本；另外还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核，请求域名、<code>Cookie</code> 等；如果需要传递参数，则还需要发送请求体；</li><li>服务器处理请求：服务器首先返回响应行，包括协议版本和状态码，比如状态码 200 表示继续处理该请求；（如果是 301，则表示重定向，将会在响应头的 <code>Locaiton</code> 字段中加上重定向的地址信息，接下来浏览器获取这个地址，将会重新导航。）服务器也会向浏览器发送响应头，包含了一些信息，比如服务器生成返回数据的时间、返回的数据类型（<code>JSON</code>、<code>HTML</code>、流媒体等类型），以及服务器要在客户端保存的 <code>Cookie</code> 等；继续发送响应体的数据；</li><li>断开 <code>TCP</code> 连接：数据传输完成，正常情况下 <code>TCP</code> 将四次挥手断开连接。但是如果浏览器或者服务器在HTTP头部加上 <code>Connection: keep-alive</code>，<code>TCP</code> 就会一直保持连接。保持 <code>TCP</code> 连接可以省下下次需要建立连接的时间，提示资源加载速度；</li></ol><h2 id="准备渲染进程阶段"><a href="#准备渲染进程阶段" class="headerlink" title="准备渲染进程阶段"></a>准备渲染进程阶段</h2><ol><li>网络进程将获取到的数据包进行解析，根据响应头中的 <code>Content-type</code> 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 <code>text/html</code> 类型，就通知浏览器进程获取到的是 <code>HTML</code>，应该准备渲染进程了；</li><li>正常情况下每个浏览器的 tab 会对应一个渲染进程，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程，否则就会创建一个新的渲染进程；</li></ol><h2 id="提交文档阶段"><a href="#提交文档阶段" class="headerlink" title="提交文档阶段"></a>提交文档阶段</h2><ol><li>渲染进程准备好后，浏览器会发出 “提交文档” 的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的 “管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程；</li><li>浏览器收到 “确认提交” 的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 <code>URL</code>、前进后退的历史状态，并更新 <code>web</code> 页面，此时的 <code>web</code> 页面是空白页；</li></ol><h2 id="页面渲染阶段"><a href="#页面渲染阶段" class="headerlink" title="页面渲染阶段"></a>页面渲染阶段</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_010.png"></p><ol><li><p>文档一旦提交，渲染进程将开始页面解析和子资源加载；渲染阶段比较复杂，所以将分为多个子阶段，按照渲染的时间顺序可以分为：构建 <code>DOM</code> 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成；</p></li><li><p>构建 <code>DOM</code> 树：<code>HTML</code> 经过解析后输出一个以 <code>document</code> 为顶层节点的树状结构的 <code>DOM</code>；</p></li><li><p>样式计算：这里有 3 个步骤：</p><ul><li>将 3 个来源（<code>&lt;link&gt;</code> 标签引入的外部样式、<code>&lt;style&gt;</code> 标签里定义的样式、以及元素的 <code>style</code> 属性上的样式）的 <code>CSS</code> 转化成浏览器能够理解的结构 <code>styleSheets</code>；</li><li>转换样式表中的属性值，使其标准化；比如 <code>font-weight: bold;</code> 会转成 <code>font-weight: 700;</code>、<code>color: blue;</code> 会转成 <code>color: rgb(0, 0, 255);</code> 等；</li><li>依据 <code>CSS</code> 的继承和层叠规则计算出 <code>DOM</code> 树中每个节点的具体样式；</li></ul></li><li><p>布局阶段：<code>DOM</code> 树中依然存在许多不可见的元素（比如 <code>head</code>），这些元素对于布局是丝毫没用的，所以又会生成一棵只包含可见元素的布局树；然后再根据布局树的每个节点计算出其具体位置和尺寸大小；</p></li><li><p>分层：页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 <code>z-index</code> 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树；关于层叠上下文的知识，具体可以参考这里<a href="https://juejin.cn/post/6844903667175260174">彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index</a>；</p></li><li><p>绘制：为每个图层生成绘制列表，并将其提交到合成线程；</p></li><li><p>光栅化：通常一个页面很大，而视口很局限，所以合成线程会按照视口附近的图块来优先生成位图，并在光栅化线程池中将图块转换成位图；</p></li><li><p>合成：一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 <code>DrawQuad</code>，然后将该命令提交给浏览器进程；之后浏览器将开始生成显示页面。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读了李兵老师的 &lt;a href=&quot;https://time.geekbang.org/column/article/117637&quot;&gt;浏览器的工作原理与实践&lt;/a&gt;，让我对浏览器的工作原理有了更加深刻的理解，尤其是从用户输入 URL 到页面显示这一过程发生的事情，以往看的文章都是点到为止，而他却说得面面俱到非常详细，遂我把内容总结了一下分享给大家，值得你花个 5 分钟阅读一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_002.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器专题之事件机制</title>
    <link href="https://bubuzou.com/2020/12/11/browser-event/"/>
    <id>https://bubuzou.com/2020/12/11/browser-event/</id>
    <published>2020-12-11T01:49:25.000Z</published>
    <updated>2021-01-14T02:01:38.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>在早期 <code>IE</code> 和 <code>Netscape</code> 团队在开发第四代浏览器的时候，遇到一个问题：当点击一个按钮的时候，是应该先处理父级的事件呢？还是应该先处理按钮的事件呢？<code>IE</code> 和 <code>Netscape</code> 给出了 2 种完全相反的答案，<code>IE</code> 提出事件冒泡的概念，而 <code>Netscape</code> 则支持事件捕获。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡认为事件应该由最具体的元素开始触发，然后层层往父级传播：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/eventFlow1.png"></p><a id="more"></a><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>而事件捕获则相反，认为最外层的元素应该最先收到事件，然后层层往下级传递：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/eventFlow2.png"></p><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>为了在浏览器中兼容这 2 种事件流，在 <code>DOM2 Events</code> 规范中将事件流分为 3 个阶段：事件捕获阶段、到底目标阶段、事件冒泡阶段。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/eventFlow3.png"></p><p>可以通过指定 <code>addEventListener</code> 的第三个参数为 <code>true</code> 来设置事件是在捕获阶段调用事件处理程序，默认是 <code>false</code> 指在冒泡阶段调用事件处理程序。</p><blockquote><p>所有现代浏览器都支持 <code>DOM</code> 事件流，只有 IE8 及更早版本不支持。</p></blockquote><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><h3 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h3><p>就是将事件处理程序直接绑定到 <code>HTML</code> 的属性中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;hello world&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">方式二</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;print(event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">e</span>) </span>&#123; &#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>HTML</code> 事件处理程序修改事件相对麻烦，可能需要同时修改 <code>HTML</code> 和 <code>JS</code>，所以大家都不爱使用这种方式绑定事件。</p><h3 id="DOM0-事件处理程序"><a href="#DOM0-事件处理程序" class="headerlink" title="DOM0 事件处理程序"></a>DOM0 事件处理程序</h3><p>将一个函数赋值给 <code>DOM</code> 元素的一个事件处理程序属性，比如 <code>onclick</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line">btn.onclick = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="DOM2-事件处理程序"><a href="#DOM2-事件处理程序" class="headerlink" title="DOM2 事件处理程序"></a>DOM2 事件处理程序</h3><p>通过 <code>addEventListener</code> 可以添加 <code>DOM2</code> 级别的事件处理程序，它接收 3 个参数：事件名、事件处理程序和 <code>useCapture</code> （它是一个可选参数，是个布尔值，默认为 <code>false</code> 表示在冒泡阶段调用事件处理程序）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>和 <code>DOM0</code> 事件处理程序的区别：</p><ul><li><code>addEventListener</code> 可以改变事件流，即可以在捕获阶段触发事件，而 <code>DOM0</code> 是不行的；</li><li><code>addEventListener</code> 可以为同一个元素多次添加同一类型的事件处理程序，先添加的事件处理程序会先触发，而 <code>DOM0</code> 如果给同一个元素绑定多个相同类型的事件处理程序的话，则后面添加的会覆盖前面定义的；</li></ul><p>它有几个注意事项：</p><ul><li>如果不需要在捕获阶段进行拦截操作，则 <code>useCapture</code> 即第三个参可以不传；</li><li>通过 <code>addEventListener</code> 添加的事件处理程序只能通过 <code>removeEventListener</code> 移除，而且绑定的事件处理程序必须是同一个。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler)</span><br><span class="line">btn.removeEventListener(<span class="string">&quot;click&quot;</span>, handler)</span><br></pre></td></tr></table></figure><h3 id="IE-事件处理函数"><a href="#IE-事件处理函数" class="headerlink" title="IE 事件处理函数"></a>IE 事件处理函数</h3><p>由于 <code>addEventListener</code> 无法兼容 IE8 及更早版本，所以此时就可以使用 <code>attachEvent</code> 添加事件处理程序和用 <code>detachEvent</code> 移除事件处理程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;)</span><br></pre></td></tr></table></figure><p>它有这么几个注意事项：</p><ul><li>注册的事件名和 <code>DOM0</code> 一样，需要带上 <code>on</code>，比如 <code>onclick</code>；</li><li>在通过 <code>attachEvent</code> 添加的事件处理程序内部 <code>this</code> 会指向 <code>window</code>，而 <code>DOM0</code> 和 <code>DOM2</code> 的 <code>this</code> 会指向元素本身；</li><li>和 <code>addEventListener</code> 一样， <code>attachEvent</code> 也可以针对同一元素多次添加同一个事件类型的处理程序，但是触发顺序是后定义的先触发；</li><li>通过 <code>detachEvent</code> 移除事件处理程序的时候，处理函数必须是和注册的同一个，这点和 <code>addEventListener</code> 保持一致；</li></ul><p><code>attachEvent</code> 和 <code>detachEvent</code> 是 <code>IE</code> 专属的 <code>API</code>，所以如果有兼容性要求，我们可以写出跨浏览器的事件处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">            element.attachEvent(<span class="string">&quot;on&quot;</span> + type, handler)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">            element.detachEvent(<span class="string">&quot;on&quot;</span> + type, handler)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>通过不同的事件处理程序添加的事件，<code>event</code> 对象的属性略有不同，我们不需要记住他们的差异，只需要在平时写代码的时候养成一个写兼容代码的习惯即可，如下是一个兼容各种 <code>event</code> 对象的事件处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 事件对象</span></span><br><span class="line">    <span class="keyword">let</span> event = event || <span class="built_in">window</span>.event</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标元素</span></span><br><span class="line">    <span class="keyword">let</span> target = event.target || event.srcElement</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阻止默认事件触发</span></span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">        event.preventDefault()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event.returnValue = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阻止事件冒泡</span></span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">        event.stopPropagation()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event.cancelBubble = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p><code>DOM3 Events</code> 定义了如下事件类型：</p><ul><li>用户界面事件(<code>UIEvent</code>)：涉及与 <code>BOM</code> 交互的通用浏览器事件，比如 <code>onload</code>、<code>resize</code>、<code>scroll</code>、<code>input</code>、<code>select</code> 等；</li><li>焦点事件(<code>FocusEvent</code>)：在元素获得和失去焦点时触发，比如 <code>focus</code>、<code>blur</code>；</li><li>鼠标事件(<code>MouseEvent</code>)：使用鼠标在页面上执行某些操作时触发，比如 <code>click</code>、<code>mousedown</code>、<code>mouseover</code> 等；</li><li>滚轮事件(<code>WheelEvent</code>)：使用鼠标滚轮(或类似设备)时触发，比如 <code>mousewheel</code>；</li><li>输入事件(<code>InputEvent</code>)：向文档中输入文本时触发，比如 <code>textInput</code>；</li><li>键盘事件(<code>KeyboardEvent</code>)：使用键盘在页面上执行某些操作时触发，比如 <code>keydown</code>、<code>keypress</code>；</li><li>合成事件(<code>CompositionEvent</code>)：在使用某种 <code>IME</code>(<code>Input Method Editor</code>，输入法编辑器)输入字符时触发，比如 <code>compositionstart</code>。</li></ul><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托是指将多个元素上绑定的事件通过利用事件冒泡的原理从而转移到他们共同的父级上去绑定，从而在一定程度上起到优化的作用，有的人也喜欢叫它事件代理。比如在 <code>Vue</code> 中经常会将事件绑定到每个列表项中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick(item)&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">其实更好的做法是利用事件委托，将事件绑定到 `ul` 上：</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:data-item</span>=<span class="string">&quot;item&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleClick(event) &#123;</span><br><span class="line">    <span class="keyword">let</span> target = event.target</span><br><span class="line">    <span class="keyword">if</span> (target === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = target.dataset.item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h2&gt;&lt;p&gt;在早期 &lt;code&gt;IE&lt;/code&gt; 和 &lt;code&gt;Netscape&lt;/code&gt; 团队在开发第四代浏览器的时候，遇到一个问题：当点击一个按钮的时候，是应该先处理父级的事件呢？还是应该先处理按钮的事件呢？&lt;code&gt;IE&lt;/code&gt; 和 &lt;code&gt;Netscape&lt;/code&gt; 给出了 2 种完全相反的答案，&lt;code&gt;IE&lt;/code&gt; 提出事件冒泡的概念，而 &lt;code&gt;Netscape&lt;/code&gt; 则支持事件捕获。&lt;/p&gt;
&lt;h3 id=&quot;事件冒泡&quot;&gt;&lt;a href=&quot;#事件冒泡&quot; class=&quot;headerlink&quot; title=&quot;事件冒泡&quot;&gt;&lt;/a&gt;事件冒泡&lt;/h3&gt;&lt;p&gt;事件冒泡认为事件应该由最具体的元素开始触发，然后层层往父级传播：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/eventFlow1.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器专题之安全篇</title>
    <link href="https://bubuzou.com/2020/12/04/web-security/"/>
    <id>https://bubuzou.com/2020/12/04/web-security/</id>
    <published>2020-12-04T01:49:25.000Z</published>
    <updated>2021-03-10T15:27:17.919Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_safe.png"></p><h2 id="同源策略（Same-Origin-Policy）"><a href="#同源策略（Same-Origin-Policy）" class="headerlink" title="同源策略（Same Origin Policy）"></a>同源策略（Same Origin Policy）</h2><p>如果两个 <code>URL</code> 的协议、域名和端口都相同，我们就称这两个 <code>URL</code> 同源。</p><p>比如，这个 <code>http://store.company.com/dir/page.html</code> 和下面这些 <code>URL</code> 相比源的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;store.company.com&#x2F;dir2&#x2F;other.html         &#x2F;&#x2F; 同源，只有路径不同</span><br><span class="line">http:&#x2F;&#x2F;store.company.com&#x2F;dir&#x2F;inner&#x2F;another.html  &#x2F;&#x2F; 同源，只有路径不同</span><br><span class="line">https:&#x2F;&#x2F;store.company.com&#x2F;secure.html            &#x2F;&#x2F; 失败，协议不同</span><br><span class="line">http:&#x2F;&#x2F;news.company.com&#x2F;dir&#x2F;other.html           &#x2F;&#x2F; 失败，域名不同</span><br><span class="line">http:&#x2F;&#x2F;store.company.com:81&#x2F;dir&#x2F;etc.html         &#x2F;&#x2F; 失败，端口不同 ( http:&#x2F;&#x2F; 默认端口是80)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="同源策略的限制"><a href="#同源策略的限制" class="headerlink" title="同源策略的限制"></a>同源策略的限制</h3><ul><li>限制了来自不同源的 <code>JavaScript</code> 脚本对当前 <code>DOM</code> 对象读和写的操作；</li><li>限制了不同源的站点读取当前站点的 <code>Cookie</code>、<code>IndexDB</code>、<code>LocalStorage</code> 等数据；</li><li>限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li></ul><p>由于浏览器同源策略的限制使得 Web 项目难以开发和使用，所以为了既保证安全性又能够灵活开发 Web 应用，<strong>从而出现了一些新技术</strong></p><ul><li>页面中可以引用第三方资源，不过这也暴露了很多诸如 <code>XSS</code> 的安全问题，因此又在这种开放的基础之上引入了内容安全策略 <code>CSP</code> 来限制其自由程度；</li><li>使用 <code>XMLHttpRequest</code> 和 <code>Fetch</code> 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略 <code>CORS</code>，让其可以安全地进行跨域操作；</li><li>两个不同源的 <code>DOM</code>是不能相互操纵的，因此浏览器中又实现了跨文档消息机制，让其可以比较安全地通信，可以通过 <code>window.postMessage</code> 的 <code>JavaScript</code> 接口来和不同源的 <code>DOM</code> 进行通信。</li></ul><h2 id="内容安全策略（CSP）"><a href="#内容安全策略（CSP）" class="headerlink" title="内容安全策略（CSP）"></a>内容安全策略（CSP）</h2><p>内容安全策略（<code>Content Security Policy</code>）简称 <code>CSP</code>，通过它可以明确的告诉客户端浏览器当前页面的哪些外部资源可以被加载执行，而哪些又是不可以的。</p><h3 id="2-种方式启用-CSP"><a href="#2-种方式启用-CSP" class="headerlink" title="2 种方式启用 CSP"></a>2 种方式启用 CSP</h3><ul><li>通过 <code>HTTP</code> 头配置 <code>Content-Security-Policy</code>，以下配置说明该页面只允许当前源和 <code>https://apis.google.com</code> 这 2 个源的脚本加载和执行：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src &#39;self&#39; https:&#x2F;&#x2F;apis.google.com</span><br></pre></td></tr></table></figure><ul><li>通过页面 <code>&lt;meta&gt;</code> 标签配置：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;script-src &#x27;self&#x27; https://apis.google.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSP-的限制"><a href="#CSP-的限制" class="headerlink" title="CSP 的限制"></a>CSP 的限制</h3><p><code>CSP</code> 提供了丰富的限制，<strong>除了能限制脚本的加载和执行，对其他资源也有限制</strong>，比如：</p><ul><li><code>font-src</code>：字体来源；</li><li><code>img-src</code>：图片来源；</li><li><code>style-src</code>：样式来源；</li></ul><p>以上只是列举了一些常见的外部资源的限制，想要查看更多资源限制<a href="https://developers.google.com/web/fundamentals/security/csp">可以看这里</a>。</p><p>默认情况下，这些指令的适用范围很广。如果您不为某条指令（例如，<code>font-src</code>）设置具体的策略，则默认情况下，该指令在运行时假定您指定 <code>*</code> 作为有效来源（例如，您可以从任意位置加载字体，没有任何限制。</p><p>另外你可以通过 <code>default-src</code> 设置资源限制的默认行为，但它只适用于 <code>-src</code> 结尾的所有指令，比如设置了如下的 <code>CSP</code> 规则，则只允许从 <code>https://cdn.example.net</code> 加载脚本、字体、图片、样式等资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src https:&#x2F;&#x2F;cdn.example.net</span><br></pre></td></tr></table></figure><h3 id="CSP-配置事项"><a href="#CSP-配置事项" class="headerlink" title="CSP 配置事项"></a>CSP 配置事项</h3><p>如果要配置多个同一类型的资源限制，需要将它们进行合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src https:&#x2F;&#x2F;host1.com https:&#x2F;&#x2F;host2.com</span><br></pre></td></tr></table></figure><p>不同的资源类型之间需要用分号分隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src https:&#x2F;&#x2F;host1.com; img-src https:&#x2F;&#x2F;host2.com</span><br></pre></td></tr></table></figure><p>可以通过以下值来灵活配置来源列表：</p><ul><li>协议：<code>https:</code>、<code>data:</code>；</li><li>主机名：<code>example.com</code>、<code>example.com:443</code>；</li><li>路径名：<code>example.com/js</code>；</li><li>通配符：<code>*://*.example.com:*</code>。</li></ul><p>还可以给来源列表指定关键字，包含如下 4 个关键字，使用关键字需要加上单引号：</p><ul><li><code>&#39;none&#39;</code>：不执行任何匹配；</li><li><code>&#39;self&#39;</code>：与当前来源（而不是其子域）匹配；</li><li><code>&#39;unsafe-inline&#39;</code>：允许使用内联 <code>JavaScript</code> 和 <code>CSS</code>；</li><li><code>&#39;unsafe-eval&#39;</code>：允许使用类似 <code>eval</code> 的 <code>text-to-JavaScript</code> 机制。</li></ul><h3 id="CSP-应用举例"><a href="#CSP-应用举例" class="headerlink" title="CSP 应用举例"></a>CSP 应用举例</h3><p>让我们假设一下，您在运行一个银行网站，并希望确保只能加载您自己写入的资源。 在此情形下，首先设置一个阻止所有内容的默认政策 (<code>default-src &#39;none&#39;</code>)，然后在此基础上逐步构建。</p><p>假设此银行网站在 <code>https://cdn.mybank.net</code> 上加载所有来自 <code>CDN</code> 的图像、样式和脚本，并通过 <code>XHR</code> 连接到 <code>https://api.mybank.com/</code> 以抽取各种数据。可使用帧，但仅用于网站的本地页面（无第三方来源）。 网站上没有 <code>Flash</code>，也没有字体和 <code>Extra</code>。 我们能够发送的最严格的 <code>CSP</code> 标头为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#39;none&#39;; script-src https:&#x2F;&#x2F;cdn.mybank.net; style-src https:&#x2F;&#x2F;cdn.mybank.net; img-src https:&#x2F;&#x2F;cdn.mybank.net; connect-src https:&#x2F;&#x2F;api.mybank.com; child-src &#39;self&#39;</span><br></pre></td></tr></table></figure><h2 id="安全沙箱（Sandbox）"><a href="#安全沙箱（Sandbox）" class="headerlink" title="安全沙箱（Sandbox）"></a>安全沙箱（Sandbox）</h2><p>我们知道早期的浏览器是单进程架构的，这样当某个标签页挂了之后，将影响到整个浏览器。所以出现了多进程架构，它通过给每个标签页分配一个渲染进程解决了这个问题。</p><p>而渲染进程的工作是进行 <code>HTML</code>、<code>CSS</code> 的解析，<code>JavaScript</code> 的执行等，而这部分内容是直接暴露给用户的，所以也是最容易被黑客利用攻击的地方，如果黑客攻击了这里就有可能获取到渲染进程的权限，进而威胁到操作系统。所以需要一道墙用来把不可信任的代码运行在一定的环境中，限制不可信代码访问隔离区之外的资源，而这道墙就是浏览器的安全沙箱。</p><p>多进程的浏览器架构将主要分为两块：浏览器内核和渲染内核。而安全沙箱能限制了渲染进程对操作系统资源的访问和修改，同时渲染进程内部也没有读写操作系统的能力，而这些都是在浏览器内核中一一实现了，包括持久存储、网络访问和用户交互等一系列直接与操作系统交互的功能。浏览器内核和渲染内核各自职责分明，当他们需要进行数据传输的时候会通过 <code>IPC</code> 进行。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_0042.png" alt="浏览器内核和渲染进程各自职责"></p><blockquote><p>安全沙箱的存在是为了保护客户端操作系统免受黑客攻击，但是阻止不了 XSS 和 CSRF。</p></blockquote><h2 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h2><p>跨站脚本攻击（<code>Cross Site Scripting</code>）本来缩写是 <code>CSS</code>，但是为了和层叠样式表（<code>Cascading Style Sheet</code>）的简写区分开来，所以在安全领域被称为 <code>XSS</code>。它是指黑客往 <code>HTML</code> 文件中或者 <code>DOM</code> 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p><p><strong>可以通过 3 种方式注入恶意脚本</strong></p><h3 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h3><ul><li>首先黑客利用站点漏洞将一段恶意 <code>JavaScript</code> 代码提交到网站的数据库中，比如在表单输入框中输入这样一段内容：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://tod.cn/ReFgeasE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>然后用户向网站请求包含了恶意 <code>JavaScript</code> 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本可以通过 <code>document.cookie</code> 获取到页面 <code>Cookie</code> 信息，然后通过 <code>XMLHttpRequest</code> 将这些信息发送给恶意服务器，恶意服务器拿到用户的 <code>Cookie</code> 信息之后，就可以在其他电脑上模拟用户的登录，然后进行操作。</li></ul><h3 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h3><p>恶意 <code>JavaScript</code> 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 <code>JavaScript</code> 脚本返回给用户。当恶意 <code>JavaScript</code> 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</p><h3 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h3><p>通常是由于是前端代码不够严谨，把不可信的内容插入到了页面。在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等 <code>API</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等代替。比如对于如下代码：当输入 <code>&quot; onclick=alert(&#39;xss&#39;) </code> 且点击生成的链接的时候，就会提示 <code>xss</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;test()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> text = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;text&#x27;</span>).value</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>).innerHTML = <span class="string">`&lt;a href=&quot;<span class="subst">$&#123;text&#125;</span>&quot;&gt;链接&lt;/a&gt;`</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="阻止-XSS-攻击的措施"><a href="#阻止-XSS-攻击的措施" class="headerlink" title="阻止 XSS 攻击的措施"></a>阻止 XSS 攻击的措施</h3><ul><li>服务器对输入脚本进行过滤或转码，比如：<code>&lt;script&gt;</code> 转成 <code>&amp;lt;script&amp;gt;</code> 后脚本就无法执行了；</li><li>使用 <code>HttpOnly</code> 属性，服务器通过响应头来将某些重要的 <code>Cookie</code> 设置为 <code>HttpOnly</code> 值，限制了客户端浏览器可以通过 <code>document.cookie</code> 获取这些重要的 <code>Cookie</code> 信息；</li><li>充分利用 <code>CSP</code>，可以通过 <code>&lt;meta&gt;</code> 来配置 <code>CSP</code>，这也是前端用于防止 <code>XSS</code> 的最合适手段。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h2><p>跨站请求伪造（<code>Cross-site request forgery</code>）简称是 <code>CSRF</code>：是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。</p><h3 id="CSRF-是怎么攻击的"><a href="#CSRF-是怎么攻击的" class="headerlink" title="CSRF 是怎么攻击的"></a>CSRF 是怎么攻击的</h3><p>一个典型的 <code>CSRF</code> 攻击过程应该是这样子的：</p><ul><li>用户登录 A 网站，并且保留了登录信息（<code>Cookie</code>）；</li><li>被黑客诱导访问了 B 网站，从 A 跳转到 B；</li><li>B 网站对 A 网站发出请求（这个就是下面将介绍的几种伪造请求的方式），浏览器请求头中会默认携带 A 网站的 <code>Cookie</code>；</li><li>A 网站服务器收到请求后，经过验证发现用户是登录了的，所以会处理请求。</li></ul><p>下面将举一个例子来模拟几种伪造请求的方式。假设：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;platforma.com&#x2F;withdraw?account&#x3D;账户名&amp;money&#x3D;转账金额&#96;</span><br></pre></td></tr></table></figure><p>这是某个资金平台 A 的转账接口，黑客知道这个接口后就可以通过以下方式进行攻击：</p><p><strong>1. 自动发起 <code>GET</code> 请求</strong></p><p>黑客在他自己网站的页面上加载了一张图片，而链接地址是指向那个转账接口。所以需要做的就是，只要某个用户在资金平台 A 上刚登录过，且此时被诱导点击了黑客的页面，一进入这个页面就会自动发起 <code>GET</code> 请求去加载图片，实而是去请求去执行转账接口。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://platforma.com/withdraw?account=hacker名&amp;money=1000&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 自动发起 <code>POST</code> 请求</strong></p><p>这类其实就是表单的自动提交。以下是黑客网站上的代码，一旦跳转到黑客指定的页面就会自动提交表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://platforma.com/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3. 点击链接来触发请求</strong></p><p>这种伪造请求的方式和第一种很像，不过是将请求的接口放到了 <code>&lt;a&gt;</code> 链接上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;美女图片的链接&quot;</span> /&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;https://platforma.com/withdraw?account=hacker名&amp;money=1000&quot;</span>&gt;</span><br><span class="line">    点击查看更多美女图片</span><br><span class="line">&lt;a/&gt;</span><br></pre></td></tr></table></figure><h3 id="如何预防-CSRF-攻击"><a href="#如何预防-CSRF-攻击" class="headerlink" title="如何预防 CSRF 攻击"></a>如何预防 CSRF 攻击</h3><p><strong>1. 给 Cookie 设置合适的 SameSite</strong></p><p>当从 A 网站登录后，会从响应头中返回服务器设置的 <code>Cookie</code> 信息，而如果 <code>Cookie</code> 携带了 <code>SameSite=strict</code> 则表示完全禁用第三方站点请求头携带 <code>Cookie</code>，比如当从 B 网站请求 A 网站接口的时候，浏览器的请求头将不会携带该 <code>Cookie</code>。<code>SameSite</code> 还有另外 2 个属性值：</p><ul><li><code>Lax</code> 是默认值，允许第三方站点的 <code>GET</code> 请求携带；</li><li><code>None</code> 任何情况下都会携带；</li></ul><p>以下是一个响应头的 <code>Set-Cookie</code> 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: flavor&#x3D;choco; SameSite&#x3D;strict</span><br></pre></td></tr></table></figure><p><strong>2. 同源检测</strong></p><p>在服务端，通过请求头中携带的 <code>Origin</code> 或者 <code>Referer</code> 属性值进行判断请求是否来源同一站点，同时服务器应该优先检测 <code>Origin</code>。为了安全考虑，相比于 <code>Referer</code>，<code>Origin</code> 只包含了域名而不带路径。</p><p><strong>3. CSRF Token</strong></p><p>大概过程是可以分成 2 步骤：</p><ul><li>在浏览器向服务器发起请求时，服务器生成一个 <code>CSRF Token</code>。<code>CSRF Token</code> 其实就是服务器生成的随机字符串，然后将该字符串植入到返回的页面中，通常是放到表单的隐藏输入框中，这样能够很好的保护 <code>CSRF Token</code> 不被泄漏；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://platforma.com/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf-token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;nc98P987b&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>当浏览器再次发送请求的时候（比如转账），就需要携带这个 <code>CSRF Token</code> 值一并提交；</li><li>服务器验证 <code>CSRF Token</code> 是否一致；从第三方网站发出的请求是无法获取用户页面中的 <code>CSRF Token</code> 值的。</li></ul><h2 id="点击劫持（ClickJacking）"><a href="#点击劫持（ClickJacking）" class="headerlink" title="点击劫持（ClickJacking）"></a>点击劫持（ClickJacking）</h2><p>点击劫持（<code>Clickjacking</code>）是一种通过视觉欺骗的手段来达到攻击目的手段。往往是攻击者将目标网站通过 <code>iframe</code> 嵌入到自己的网页中，通过 <code>opacity</code> 等手段设置 <code>iframe</code> 为透明的，使得肉眼不可见，这样一来当用户在攻击者的网站中操作的时候，比如点击某个按钮（这个按钮的顶层其实是 <code>iframe</code>），从而实现目标网站被点击劫持。</p><p><strong>防护手段</strong>即不希望自己网站的页面被嵌入到别人的网站中。</p><h3 id="frame-busting"><a href="#frame-busting" class="headerlink" title="frame busting"></a>frame busting</h3><p>如果 A 页面通过 <code>iframe</code> 被嵌入到 B 页面，那么在 A 页面内部<code>window</code> 对象将指向 <code>iframe</code>，而 <code>top</code> 将指向最顶层的网页这里是 B。所以可以依据这个原理来判断自己的页面是被 <code>iframe</code> 引入而嵌入到别人页面，如果是的话，则通过如下的判断会使得 B 页面将直接替换 A 的内容而显示，从而让用户发觉自己被骗。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (top.location != <span class="built_in">window</span>.location) &#123;</span><br><span class="line">    top.location = <span class="built_in">window</span>.location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h3><p>通过给页面响应头里设置 <code>X-Frame-Options</code> 为某个属性值，就能达到控制该页面是否可以通过 <code>iframe</code> 的方式被嵌入到别人的网站中。 它有 3 个属性值：</p><ul><li><code>deny</code> 表示该页面不允许嵌入到任何页面，包括同一域名页面也不允许；</li><li><code>sameorigin</code> 表示只允许嵌入到同一域名的页面；</li><li><code>allow-from uri</code> 表示可以嵌入到指定来源的页面中。</li></ul><p>点击劫持中的本质就是通过视觉来欺骗用户，顺着这个思路，还有一个攻击方法也和这个类似，那就是<strong>图片覆盖攻击</strong>大概的原理就是通过样式把图片覆盖在攻击者所希望的任意位置，比如盖在一个网站的 <code>logo</code> 上，当用户点击图片的时候就会被链接到攻击者的站点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">src</span>=<span class="string">&quot;https://hacker.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; left: 100; top: 100; z-index: 100;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这种攻击方式，预防的手段就是需要用户在提交的 <code>HTML</code> 中检查，<code>&lt;img&gt;</code> 标签是否有可能导致浮出。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://time.geekbang.org/column/article/117637">浏览器的工作原理与实践</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">Same-origin_policy</a></li><li><a href="https://developers.google.com/web/fundamentals/security/csp">CSP</a></li><li><a href="https://book.douban.com/subject/10546925/">白帽子讲Web安全</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_safe.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;同源策略（Same-Origin-Policy）&quot;&gt;&lt;a href=&quot;#同源策略（Same-Origin-Policy）&quot; class=&quot;headerlink&quot; title=&quot;同源策略（Same Origin Policy）&quot;&gt;&lt;/a&gt;同源策略（Same Origin Policy）&lt;/h2&gt;&lt;p&gt;如果两个 &lt;code&gt;URL&lt;/code&gt; 的协议、域名和端口都相同，我们就称这两个 &lt;code&gt;URL&lt;/code&gt; 同源。&lt;/p&gt;
&lt;p&gt;比如，这个 &lt;code&gt;http://store.company.com/dir/page.html&lt;/code&gt; 和下面这些 &lt;code&gt;URL&lt;/code&gt; 相比源的结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;store.company.com&amp;#x2F;dir2&amp;#x2F;other.html         &amp;#x2F;&amp;#x2F; 同源，只有路径不同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;store.company.com&amp;#x2F;dir&amp;#x2F;inner&amp;#x2F;another.html  &amp;#x2F;&amp;#x2F; 同源，只有路径不同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https:&amp;#x2F;&amp;#x2F;store.company.com&amp;#x2F;secure.html            &amp;#x2F;&amp;#x2F; 失败，协议不同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;news.company.com&amp;#x2F;dir&amp;#x2F;other.html           &amp;#x2F;&amp;#x2F; 失败，域名不同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;store.company.com:81&amp;#x2F;dir&amp;#x2F;etc.html         &amp;#x2F;&amp;#x2F; 失败，端口不同 ( http:&amp;#x2F;&amp;#x2F; 默认端口是80)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="安全" scheme="https://bubuzou.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>「建议收藏」送你一份精心总结的3万字ES6实用指南（全）</title>
    <link href="https://bubuzou.com/2020/11/17/es6/"/>
    <id>https://bubuzou.com/2020/11/17/es6/</id>
    <published>2020-11-17T07:53:04.000Z</published>
    <updated>2024-06-12T09:26:57.393Z</updated>
    
    <content type="html"><![CDATA[<p>写本篇文章目的是为了夯实基础，基于阮一峰老师的著作 <a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a> 以及 <a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">tc39-finished-proposals</a> 这两个知识线路总结提炼出来的重点和要点，涉及到从 <code>ES2015</code> 到 <code>ES2021</code> 的几乎所有知识，基本上都是按照一个知识点配上一段代码的形式来展示，所以篇幅较长，也正是因为篇幅过长，所以就没把 <code>Stage 2</code> 和 <code>Stage 3</code> 阶段的提案写到这里，后续 <code>ES2021</code> 更新了我再同步更新。</p><blockquote><p>有 5 个提案已经列入 Expected Publication Year in 2021 所以本篇中暂且把他们归为 ES2021。</p></blockquote><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es6.png"></p><a id="more"></a><h2 id="ES6-前言"><a href="#ES6-前言" class="headerlink" title="ES6 前言"></a>ES6 前言</h2><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><p>能写好 <code>JS</code> 固然是重要的，但是作为一个前端，我们也要了解自己所使用语言的发展历程，这里强烈推荐看 <a href="https://cn.history.js.org/index.html">《JavaScript 20 年》</a>，本书详细记载和解读了自 1995 年语言诞生到 2015 年 <code>ES6</code> 规范制定为止，共计 20 年的 <code>JavaScript</code> 语言演化历程。</p><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><p>2011 年，发布了 <code>ECMAScript 5.1</code> 版，而 2015 年 6 月发布了 <code>ES6</code> 的第一个版本又叫 <code>ES2015</code>。<code>ES6</code> 其实是一个泛指，指代 5.1 版本以后的下一代标准。<code>TC39</code> 规定将于每年的 6 月发布一次正式版本，版本号以当年的年份为准，比如当前已经发布了 <code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>、<code>ES2019</code>、<code>ES2020</code> 等版本。</p><h3 id="提案发布流程"><a href="#提案发布流程" class="headerlink" title="提案发布流程"></a>提案发布流程</h3><p>任何人都可以向 <code>TC39</code> 提案，要求修改语言标准。一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 <code>TC39</code> 委员会批准。</p><ul><li><code>Stage 0</code> - <code>Strawperson</code>（展示阶段）</li><li><code>Stage 1</code> - <code>Proposal</code>（征求意见阶段）</li><li><code>Stage 2</code> - <code>Draft</code>（草案阶段）</li><li><code>Stage 3</code> - <code>Candidate</code>（候选人阶段）</li><li><code>Stage 4</code> - <code>Finished</code>（定案阶段）</li></ul><p>一个提案只要能进入 <code>Stage 2</code>，就差不多肯定会包括在以后的正式标准里面。<code>ECMAScript</code> 当前的所有提案，可以在这里查看 <a href="https://github.com/tc39/ecma262">ecma262</a>。关于提案流程可以在这里 <a href="https://tc39.es/process-document/">TC39_Process</a> 看到更加详细的信息。</p><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2015.png"></p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><code>const</code>：声明一个常量，<code>let</code>：声明一个变量；<code>const/let</code> 声明的常量/变量都只能作用于代码块（块级作用域或函数作用域）里；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><code>const/let</code> 不存在变量提升，所以在代码块里必须先声明然后才可以使用，这叫暂时性死区；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br></pre></td></tr></table></figure><p><code>const/let</code> 不允许在同一个作用域内，重复声明；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span> <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const</code> 声明时必须初始化，且后期不能被修改，但如果初始化的是一个对象，那么不能修改的是该对象的内存地址；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person.name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br><span class="line">person = <span class="string">&#x27;&#x27;</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p><code>const/let</code> 在全局作用域中声明的常量/变量不会挂到顶层对象（浏览器中是 window ）的属性中；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name) <span class="comment">// &#x27;布兰&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p><strong>解构类型</strong>：</p><ul><li><p>字符串解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c = <span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;12&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// &#x27;1&#x27; &#x27;2&#x27; &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数值解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toFixed</span>: tf &#125; = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(tf.call(<span class="built_in">Math</span>.PI, <span class="number">2</span>)) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure></li><li><p>布尔值解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: ts &#125; = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(ts.call(<span class="literal">false</span>)) <span class="comment">// &#x27;false&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数组解构：等号右侧的数据具有 <code>Iterator</code> 接口可以进行数组形式的解构赋值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构不成功的变量值为 undefined</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1, 2, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以设置默认值</span></span><br><span class="line"><span class="keyword">let</span> [x, y, z = <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z) <span class="comment">// 1, 2, null</span></span><br></pre></td></tr></table></figure><blockquote><p>什么样的数据具有 <code>Iterator</code> 接口呢？如果一个对象能够通过 [Symbol.iterator] 访问，且能够返回一个符合迭代器协议的对象，那么该对象就是可迭代的。目前内置的可迭代对象有：String、Array、TypeArray、Map、Set、arguments 和 NodeList 等。</p></blockquote></li><li><p>对象解构：与数组按照索引位置进行解构不同，对象解构是按照属性名进行解构赋值，如果在当前对象属性匹配不成功则会去对象的原型属性上查找：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认写法</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name, <span class="attr">age</span>: age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改名且设置默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name1, <span class="attr">age</span>: age1 = <span class="number">12</span> &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name1, age1) <span class="comment">// &#x27;布兰&#x27; 12</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数解构：其实就是运用上面的对象解构和数组解构规则；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123; x = <span class="number">0</span>, y = <span class="number">0</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([x, y])</span><br><span class="line">  <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">move() <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>解构要点</strong>：</p><ul><li>只要等号两边的模式相同（同是对象或同是数组），则左边的变量会被赋予对应的值；</li><li>解构不成功的变量值为 <code>undefined</code>；</li><li>默认值生效的前提是当等号右边对应的值全等于 undefined 的时候；</li><li>只要等号右边的值不是对象或者数组，则会进行自动装箱将其转成对象；</li><li><code>null</code> 和 <code>undefined</code> 都无法转成对象，所以无法解构。</li></ul><p><strong>解构应用</strong>：</p><ul><li><p>交换变量的值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span></span><br><span class="line">;[x, y] = [y, x]</span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure></li><li><p>通过函数返回对象属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = getParams()</span><br></pre></td></tr></table></figure></li><li><p>通过定义函数参数来声明变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line">init(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; name, age &#125; = person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简洁用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">&#123; name, age &#125;</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定函数参数默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPerson</span>(<span class="params">&#123; name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age)</span><br><span class="line">&#125;</span><br><span class="line">initPerson() <span class="comment">// &#x27;布兰&#x27; 12</span></span><br><span class="line">initPerson(&#123; <span class="attr">age</span>: <span class="number">20</span> &#125;) <span class="comment">// &#x27;布兰&#x27; 20</span></span><br></pre></td></tr></table></figure></li><li><p>提取 <code>JSON</code> 数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> responseData = &#123;</span><br><span class="line">  code: <span class="number">1000</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  message: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; code, data = &#123;&#125; &#125; = responseData</span><br></pre></td></tr></table></figure></li><li><p>遍历 Map 结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">map.set(<span class="string">&#x27;xiamen&#x27;</span>, <span class="string">&#x27;厦门&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输入模块的指定方法和属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile, writeFile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li><p>可以使用 <code>Unicode</code> 编码来表示一个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下写法都可以用来表示字符 z</span></span><br><span class="line"><span class="string">&#x27;\z&#x27;</span> <span class="comment">// 转义</span></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> <span class="comment">// 十进制表示法</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> <span class="comment">// 十六进制表示法</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> <span class="comment">// Unicode 普通表示法</span></span><br><span class="line"><span class="string">&#x27;\u&#123;7A&#125;&#x27;</span> <span class="comment">// Unicode 大括号表示法</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.52unicode.com/">www.52unicode.com</a> 这个网站可以查询到常见符号的 Unicode 编码。</p></blockquote></li><li><p>可以使用 <code>for...of</code> <strong>正确遍历</strong>字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;😀🤣😜😍🤗🤔&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> emoji <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(emoji) <span class="comment">// 😀🤣😜😍🤗🤔</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = str.length; i &lt; l; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str[i]) <span class="comment">// 不能正确输出表情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模板字符串使用两个反引号标识（``），可以用来定义多行字符串，或者使用它在字符串中插入变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;hero&#x27;</span></span><br><span class="line"><span class="keyword">let</span> tips = <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, </span></span><br><span class="line"><span class="string">    welcome to my world.`</span></span><br><span class="line">alert(tips)</span><br></pre></td></tr></table></figure></li><li><p>标签模板：在函数名后面接一个模板字符串相当于给函数传入了参数进行调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  age = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> tips = parse<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, are you <span class="subst">$&#123;age&#125;</span> years old this year?`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">stringArr, ...variable</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于传递如下参数进行调用 parse 函数</span></span><br><span class="line">parse([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27;, are you &#x27;</span>, <span class="string">&#x27; years old this year?&#x27;</span>], name, age)</span><br></pre></td></tr></table></figure></li><li><p><code>String.fromCodePoint()</code> 用于从 <code>Unicode</code> 码点返回对应字符，可以支持 <code>0xFFFF</code> 的码点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x1f600</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f600</span>) <span class="comment">// &quot;😀&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>String.raw()</code> 返回把字符串所有变量替换且对斜杠进行转义的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span> + <span class="number">3</span>&#125;</span>!`</span> <span class="comment">// &quot;Hi\n5!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>codePointAt()</code> 返回字符的十进制码点，对于 <code>Unicode</code> 大于 <code>0xFFFF</code> 的字符，会被认为是 2 个字符，十进制码点转成十六进制可以使用 <code>toString(16)</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emoji = <span class="string">&#x27;🤣&#x27;</span></span><br><span class="line">emoji.length <span class="comment">// 2</span></span><br><span class="line">emoji.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// &#x27;d83d&#x27;</span></span><br><span class="line">emoji.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>) <span class="comment">// &#x27;de00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0xd83d</span>, <span class="number">0xde00</span>) === <span class="string">&#x27;🤣&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>normalize()</code> 方法会按照指定的一种 <code>Unicode</code> 正规形式将当前字符串正规化。（如果该值不是字符串，则首先将其转换为一个字符串）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;\u00F1&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;\u006E\u0303&#x27;</span></span><br><span class="line"></span><br><span class="line">str1 <span class="comment">//  ñ</span></span><br><span class="line">str2 <span class="comment">//  ñ</span></span><br><span class="line">str1 === str2 <span class="comment">// false</span></span><br><span class="line">str1.length === str2.length <span class="comment">// false</span></span><br><span class="line">str1.normalize() === str2.normalize() <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>字符串是否包含子串：</p><ul><li>includes()：返回布尔值，表示是否找到了参数字符串。</li><li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line"></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line"></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，使用第二个参数 <code>n</code> 时，<code>endsWith</code> 的行为与其他两个方法有所不同。它针对前 <code>n</code> 个字符，而其他两个方法针对从第 <code>n</code> 个位置直到字符串结束。</p></li><li><p><code>repeat(n)</code> 将当前字符串重复 <code>n</code> 次后，返回一个新字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">2</span>) <span class="comment">// &#x27;xx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">1.9</span>) <span class="comment">// &#x27;x&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="literal">undefined</span>) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="string">&#x27;2a&#x27;</span>) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">-0.6</span>) <span class="comment">// &#x27;&#x27;，解释：0 ~ 1 之间的小数相当于 0</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">-2</span>) <span class="comment">// RangeError</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="literal">Infinity</span>) <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li><p>二进制（0b）和八进制（0o）表示法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> b = num.toString(<span class="number">2</span>) <span class="comment">// 二进制的100：1100100</span></span><br><span class="line"><span class="keyword">let</span> o = num.toString(<span class="number">8</span>) <span class="comment">// 八进制的100：144</span></span><br><span class="line"><span class="number">0b1100100</span> === <span class="number">100</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o144</span> === <span class="number">100</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isFinite()</code> 判断一个数是否是有限的数，入参如果不是数值一律返回 <code>false</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">-2.9</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">false</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isNaN()</code> 判断一个数值是否为 <code>NaN</code>，如果入参不是 <code>NaN</code> 那结果都是 <code>false</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;a&#x27;</span> / <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;NaN&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>数值转化：<code>Number.parseInt()</code> 和 <code>Number.parseFloat()</code>，非严格转化，从左到右解析字符串，遇到非数字就停止解析，并且把解析的数字返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12a&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;a12&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xA&#x27;</span>) <span class="comment">// 10，0x开头的将会被当成十六进制数</span></span><br></pre></td></tr></table></figure><p><code>parseInt()</code> 默认是用十进制去解析字符串的，其实他是支持传入第二个参数的，表示要以多少进制的 基数去解析第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1010&#x27;</span>, <span class="number">2</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>) <span class="comment">// 255</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.im/post/6855129005121765390#heading-13">parseInt</a></p></li><li><p><code>Number.isInteger()</code> 判断一个数值是否为整数，入参为非数值则一定返回 <code>false</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger() <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">&#x27;15&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">3.0000000000000002</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>如果对数据精度的要求较高，不建议使用 Number.isInteger() 判断一个数值是否为整数。</p></blockquote></li><li><p><code>Number.EPSILON</code> 表示一个可接受的最小误差范围，通常用于浮点数运算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>) &lt; <span class="built_in">Number</span>.EPSILON <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isSafeInteger()</code> 用来判断一个数是否在最大安全整数（<code>Number.MAX_SAFE_INTEGER</code>）和最小安全整数（<code>Number.MIN_SAFE_INTEGER</code>）之间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">2</span> ** <span class="number">53</span> - <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">&#x27;2&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>Math.trunc()</code>：返回数值整数部分</p></li><li><p><code>Math.sign()</code>：返回数值类型(正数 1、负数 -1、零 0)</p></li><li><p><code>Math.cbrt()</code>：返回数值立方根</p></li><li><p><code>Math.clz32()</code>：返回数值的 32 位无符号整数形式</p></li><li><p><code>Math.imul()</code>：返回两个数值相乘</p></li><li><p><code>Math.fround()</code>：返回数值的 32 位单精度浮点数形式</p></li><li><p><code>Math.hypot()</code>：返回所有数值平方和的平方根</p></li><li><p><code>Math.expm1()</code>：返回 <code>e^n - 1</code></p></li><li><p><code>Math.log1p()</code>：返回 1 + n 的自然对数(<code>Math.log(1 + n)</code>)</p></li><li><p><code>Math.log10()</code>：返回以 10 为底的 n 的对数</p></li><li><p><code>Math.log2()</code>：返回以 2 为底的 n 的对数</p></li><li><p><code>Math.sinh()</code>：返回 n 的双曲正弦</p></li><li><p><code>Math.cosh()</code>：返回 n 的双曲余弦</p></li><li><p><code>Math.tanh()</code>：返回 n 的双曲正切</p></li><li><p><code>Math.asinh()</code>：返回 n 的反双曲正弦</p></li><li><p><code>Math.acosh()</code>：返回 n 的反双曲余弦</p></li><li><p><code>Math.atanh()</code>：返回 n 的反双曲正切</p></li></ul><h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li><p>数组扩展运算符（…）将数组展开成用逗号分隔的参数序列，只能展开一层数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：函数传参</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>] <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：浅克隆</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> clone = [...a]</span><br><span class="line">a === clone <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用四：数组解构</span></span><br><span class="line"><span class="keyword">const</span> [x, ...y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.from()</code> 可以将类数组对象（ <code>NodeList</code>，<code>arguments</code>）和可迭代对象转成数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：字符串转数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并去重</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(merge)) <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：arguments 转数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果 <code>Array.from()</code> 带第二个参数 <code>mapFn</code>，将对生成的新数组执行一次 <code>map</code> 操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x) <span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> ++i) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.of()</code> 将一组参数转成数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayOf</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(params)</span><br><span class="line">&#125;</span><br><span class="line">arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.copyWithin()</code> 在当前数组内部，将制定位置的成员复制到其他位置（会覆盖原来位置的成员），最后返回一个新数组。接收 3 个参数，参数为负数表示右边开始计算：</p><ul><li><code>target</code>（必选）：替换位置的索引；</li><li><code>start</code>（可选）：从该位置开始读取数据，默认为 0；</li><li><code>end</code>（可选）：从该位置结束读取数据（不包括该位置的数据），默认为原数组长度；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  .copyWithin(<span class="number">-1</span>) <span class="comment">// [1, 2, 3, 4, 1]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)].copyWithin(<span class="number">1</span>) <span class="comment">// [1, 1, 2, 3, 4]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)].copyWithin(<span class="number">0</span>, <span class="number">-3</span>, <span class="number">-1</span>) <span class="comment">// [3, 4, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>查找第一个出现的子成员：<code>find()</code> 和 <code>findIndex()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出第一个偶数</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line">  .find(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// 找出第一个偶数的索引位置</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>)</span><br><span class="line">  ].findIndex(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>fill()</code> 使用给定的值来填充数组，有 3 个参数：</p><ul><li><code>value</code>：填充值；</li><li><code>start</code>（可选），开始索引，默认为 0；</li><li><code>end</code>（可选）：结束索引，默认为数组长度，不包括该索引位置的值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化空数组</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">  .fill(<span class="number">1</span>) <span class="comment">// [1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)].fill(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>) <span class="comment">// [1, 2, &#x27;a&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <code>keys()</code>（键名）、<code>entries()</code>（键值）和 <code>values()</code>（键值对） 获取数组迭代器对象，可以被 <code>for...of</code> 迭代，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v) <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e) <span class="comment">// [0, &#x27;a&#x27;] [0, &#x27;b&#x27;] [0, &#x27;c&#x27;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组空位，是指数组没有值，比如：<code>[,,]</code>，而像这种 <code>[undefined]</code> 是不包含空位的。由于 <code>ES6</code> 之前的一些 <code>API</code> 对空位的处理规则很不一致，所以实际操作的时候应该尽量避免空位的出现，而为了改变这个现状，<code>ES6</code> 的 <code>API</code> 会默认将空位处理成 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="number">1</span>, , <span class="number">3</span>].values()]  <span class="comment">// [1, undefined, 3]</span></span><br><span class="line">[<span class="number">1</span>, , <span class="number">3</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x === <span class="literal">undefined</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li><p>对象属性简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性名表达式：在用对象字面量定义对象的时候，允许通过属性名表达式来定义对象属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [name]: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    [<span class="string">&#x27;get&#x27;</span>+ name]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法的 <code>name</code> 属性，存在好几种情况，这里仅列出常见的几种：</p><p>情况一：普通对象方法的 <code>name</code> 属性直接返回方法名，函数声明亦是如此，函数表达式返回变量名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  hi() &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">person.hi.name <span class="comment">// &#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure><p>情况二：构造函数的 <code>name</code> 为 <code>anonymous</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>().name <span class="comment">// &#x27;anonymous&#x27;</span></span><br></pre></td></tr></table></figure><p>情况三：绑定函数的 <code>name</code> 将会在函数名前加上 <code>bound</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// &#x27;bound foo&#x27;</span></span><br></pre></td></tr></table></figure><p>情况四：如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则 <code>name</code> 属性不是在该方法上面，而是该方法的属性的描述对象的 <code>get</code> 和 <code>set</code> 属性上面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>() &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">x</span>) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">o.foo.name <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">descriptor.get.name <span class="comment">// &quot;get foo&quot;</span></span><br><span class="line">descriptor.set.name <span class="comment">// &quot;set foo&quot;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name">function_name</a></p></li><li><p>属性的可枚举性</p><p>对象的每个属性都有一个描述对象（<code>Descriptor</code>），用来控制该属性的行为。可以通过 <code>Object.getOwnPropertyDescriptor()</code> 来获取对象某个属性的描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     value: &quot;布兰&quot;,</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>enumerable</code> 就是对象某个属性的可枚举属性，如果某个属性的 <code>enumerable</code> 值为 <code>false</code> 则表示该属性不能被枚举，所以该属性会被如下 4 种操作忽略：</p><ul><li><code>for...in</code> ：只遍历对象自身的和继承的可枚举的属性；</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名；</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性；</li><li><code>Object.assign()</code>： 只拷贝对象自身的可枚举的属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="number">12</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line">person <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作都将忽略 person 对象的 age 属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(person) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(person) <span class="comment">// &#x27;&#123;&quot;name&quot;: &quot;布兰&quot;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, person) <span class="comment">// &#123; name: &#x27;布兰&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p><code>Reflect.ownKeys(obj)</code>： 返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 <code>Symbol</code> 或字符串，也不管是否可枚举：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(person) <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>super</code> 关键字，指向对象的原型对象，只能用于对象的方法中，其他地方将报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.name</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, &#123; <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span> &#125;)</span><br><span class="line">person.getName() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下几种 super 的使用将报错</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  foo: <span class="built_in">super</span>.foo,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  foo: <span class="function">() =&gt;</span> <span class="built_in">super</span>.foo,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.foo</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.is()</code> 用来判断两个值是否相等，表现基本和 <code>===</code> 一样，除了以下两种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.assign()</code> 用于对象的合并，将源对象（<code>source</code>）的所有可枚举属性，复制到目标对象（<code>target</code>），如果有同名属性，则后面的会直接替换前面的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> source1 = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="number">1</span>, <span class="attr">f</span>: <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: &#123; <span class="attr">g</span>: <span class="number">3</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2)</span><br><span class="line">target <span class="comment">// &#123; a: 3, b: 3, c: 4, d: &#123;g: 3&#125; &#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code> 实行的是浅拷贝，如果源对象某个属性是对象，那么拷贝的是这个对象的引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;</span><br><span class="line"><span class="keyword">let</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line">target.a.b = <span class="number">3</span></span><br><span class="line">source.a.b <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>__proto__</code> 属性是用来读取和设置当前对象的原型，而由于其下划线更多的是表面其是一个内部属性，所以建议不在正式场合使用它，而是用下面的 <code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p></li><li><p><code>Object.setPrototypeOf()</code> 用于设置对象原型，<code>Object.getPrototypeOf()</code> 用于读取对象原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, &#123; <span class="attr">name</span>: <span class="string">&#x27;动物&#x27;</span> &#125;)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) <span class="comment">// &#123;name: &#x27;动物&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li><p><code>RegExp</code> 构造函数，允许首参为正则表达式，第二个参数为修饰符，如果有第二个参数，则修饰符以第二个为准：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xYz\d+/gi</span>, i)</span><br><span class="line">reg.flags <span class="comment">// &#x27;i&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>正则方法调用变更：字符串对象的 <code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code> 内部调用转为调用 <code>RegExp</code> 实例对应的 <code>RegExp.prototype[Symbol.方法]</code>；</p></li><li><p><code>u</code> 修饰符：含义为 <code>Unicode</code> 模式，用来正确处理大于 <code>\uFFFF</code> 的 <code>Unicode</code> 字符。也就是说，如果待匹配的字符串中可能包含有大于 <code>\uFFFF</code> 的字符，就必须加上 <code>u</code> 修饰符，才能正确处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上 u 修饰符才能让 . 字符正确识别大于 \uFFFF 的字符</span></span><br><span class="line">/^.$/.test(<span class="string">&#x27;🤣&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(<span class="string">&#x27;🤣&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大括号 Unicode 字符表示法必须加上 u 修饰符</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">&#x27;a&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有 u 修饰符，量词才能正确匹配大于 \uFFFF 的字符</span></span><br><span class="line">/🤣&#123;<span class="number">2</span>&#125;/.test(<span class="string">&#x27;🤣🤣&#x27;</span>)  <span class="comment">// false</span></span><br><span class="line">/🤣&#123;<span class="number">2</span>&#125;/u.test(<span class="string">&#x27;🤣🤣&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>RegExp.prototype.unicode</code> 属性表示正则是否设置了 <code>u</code> 修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/🤣/.unicode   <span class="comment">// false</span></span><br><span class="line">/🤣/u.unicode  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>y</code> 修饰符，与 <code>g</code> 修饰符类似也是全局匹配；不同的是 <code>g</code> 是剩余字符中匹配即可，而 <code>y</code> 则是必须在剩余的第一个字符开始匹配才行，所以 <code>y</code> 修饰符也叫黏连修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span></span><br><span class="line"><span class="keyword">let</span> r1 = <span class="regexp">/a+/g</span></span><br><span class="line"><span class="keyword">let</span> r2 = <span class="regexp">/a+/y</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><code>RegExp.prototype.sticky</code> 属性表示是否设置了 <code>y</code> 修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/abc/y</span>.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>RegExp.prototype.flags</code> 属性会返回当前正则的所有修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/abc🤣/iuy</span>.flags <span class="comment">// &#x27;iuy&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li><p>函数参数默认值。参数不能有同名的，函数体内不能用 <code>let</code> 和 <code>const</code> 声明同参数名的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params">name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>使用参数默认值的时候，参数不能有同名的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, x, y</span>) </span>&#123;&#125; <span class="comment">// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, x, y = <span class="number">1</span></span>) </span>&#123;&#125; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>函数体内不能用 <code>let</code> 和 <code>const</code> 声明同参数名的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的 <code>length</code> 属性会返回没有指定默认值的参数个数，且如果设置默认值的参数不是尾参数，则 <code>length</code> 不再计入后面的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;&#125;</span><br><span class="line">  .length(</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">1</span></span>) </span>&#123;&#125;</span><br><span class="line">  )</span><br><span class="line">  .length(</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;&#125;</span><br><span class="line">  ).length) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p>剩余（<code>rest</code>） 参数（…变量名）的形式，用于获取函数的剩余参数，注意 <code>rest</code> 参数必须放在最后一个位置，可以很好的代替 <code>arguments</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> y) &#123;</span><br><span class="line">    coonsole.log(val) <span class="comment">// 2 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>严格模式：只要函数参数使用了默认值、解构赋值或者扩展运算符，那么函数体内就不能显示的设定为严格模式，因为严格模式的作用范围包含了函数参数，而函数执行的顺序是先执行参数，然后再执行函数体，执行到函数体里的 <code>use strict</code> 的时候，那么此时因为函数参数已经执行完成了，那函数参数还要不要受到严格模式的限制呢？这就出现矛盾了。规避限制的办法有两个：设置全局的严格模式或者在函数体外在包一个立即执行函数并且声明严格模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二</span></span><br><span class="line"><span class="keyword">let</span> f = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li><p>箭头函数语法比函数表达式更简洁，并且没有自己的 <code>this</code>、<code>arguments</code>，不能用作构造函数和用作生成器。<br>几种箭头函数写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f1 = <span class="function">() =&gt;</span> &#123;&#125; <span class="comment">// 没有参数</span></span><br><span class="line"><span class="keyword">let</span> f2 = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;&#125; <span class="comment">// 1个参数</span></span><br><span class="line"><span class="keyword">let</span> f3 = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;&#125; <span class="comment">// 1个参数可以省略圆括号</span></span><br><span class="line"><span class="keyword">let</span> f4 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;&#125; <span class="comment">// 2个参数以上必须加上圆括号</span></span><br><span class="line"><span class="keyword">let</span> f5 = <span class="function">(<span class="params">x = <span class="number">1</span>, y = <span class="number">2</span></span>) =&gt;</span> &#123;&#125; <span class="comment">// 支持参数默认值</span></span><br><span class="line"><span class="keyword">let</span> f6 = <span class="function">(<span class="params">x, ...y</span>) =&gt;</span> &#123;&#125; <span class="comment">// 支持 rest 参数</span></span><br><span class="line"><span class="keyword">let</span> f7 = (&#123; x = <span class="number">1</span>, y = <span class="number">2</span> &#125; = &#123;&#125;) <span class="comment">// 支持参数解构</span></span><br></pre></td></tr></table></figure><p>箭头函数没有自己的 <code>this</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age++</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person() <span class="comment">// 1 秒后 Person &#123;age: 1&#125;</span></span><br></pre></td></tr></table></figure><p>通过 <code>call/apply</code> 调用箭头函数的时候将不会绑定第一个参数的作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> adder = &#123;</span><br><span class="line">  base: <span class="number">1</span>,</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="function">(<span class="params">v</span>) =&gt;</span> v + <span class="built_in">this</span>.base</span><br><span class="line">    <span class="keyword">return</span> f(a)</span><br><span class="line">  &#125;,</span><br><span class="line">  addThruCall: <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="function">(<span class="params">v</span>) =&gt;</span> v + <span class="built_in">this</span>.base</span><br><span class="line">    <span class="keyword">let</span> b = &#123;</span><br><span class="line">      base: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f.call(b, a)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">adder.add(<span class="number">1</span>) <span class="comment">// 输出 2</span></span><br><span class="line">adder.addThruCall(<span class="number">1</span>) <span class="comment">// 仍然输出 2</span></span><br></pre></td></tr></table></figure><p>箭头函数没有自己的 <code>arguments</code> 对象，不过可以使用 <code>rest</code> 参数代替：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> log = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数代替写法</span></span><br><span class="line"><span class="keyword">let</span> restLog = <span class="function">(<span class="params">...arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr) <span class="comment">// [2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line">restLog(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>箭头函数不能用作构造器，和 <code>new</code> 一起用会抛出错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure><p>箭头函数返回对象字面量，需要用圆括号包起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func2 = <span class="function">() =&gt;</span> (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow_functions</a></p></li><li><p>尾调用和尾递归</p><p>首先得知道什么是尾调用：函数的最后一步调用另外一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都不是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x)</span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x)</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  g(x)</span><br><span class="line">  <span class="comment">// 因为最后一步是 return: undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾调用有啥用？我们知道函数的相互调用是会生成“调用帧”的，而“调用帧”里存了各种信息比如函数的内部变量和调用函数的位置等，所有的“调用帧”组成了一个“调用栈”。如果在函数的最后一步操作调用了另外一个函数，因为外层函数里调用位置、内部变量等信息都不会再用到了，所有就无需保留外层函数的“调用帧”了，只要直接用内层函数的“调用帧”取代外层函数的“调用帧”即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> g(m + n)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这样一来就很明显的减少了调用栈中的帧数，内存占用就少了，所以这就是尾调用的优化作用。尾递归也是如此，递归如果次数多那就需要保留非常多的“调用帧”，所以经常会出现栈溢出错误，而使用了尾递归优化后就不会发生栈溢出的错误了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规递归的斐波那契函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fibonacci(<span class="number">100</span>) <span class="comment">// 超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归优化后的斐波那契函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span>(<span class="params">n, ac1 = <span class="number">1</span>, ac2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ac2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci2(n - <span class="number">1</span>, ac2, ac1 + ac2)</span><br><span class="line">&#125;</span><br><span class="line">s</span><br><span class="line">Fibonacci2(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul><li><p><code>Symbol</code> 是一个新的原始类型，用来表示一个独一无二的值，可以通过 <code>Symbol()</code> 函数来创建一个 <code>Symbol</code> 类型的值，为了加以区分，可以传入一个字符串作为其描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol</code> 类型无法通过数学运算符进行隐式类型转换，但是可以通过 <code>String()</code> 显示转成字符串或者通过 <code>Boolean()</code> 显示转成布尔值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">String</span>(s) <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line">s.toString() <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line"><span class="built_in">Boolean</span>(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>引入 <code>Symbol</code> 最大的初衷其实就是为了让它作为对象的属性名而使用，这样就可以有效避免属性名的冲突了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [foo]: <span class="string">&#x27;foo1&#x27;</span>,</span><br><span class="line">  foo: <span class="string">&#x27;foo2&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj[foo] <span class="comment">// &#x27;foo1&#x27;</span></span><br><span class="line">obj.foo <span class="comment">// &#x27;foo2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol</code> 属性的不可枚举性，不会被 <code>for...in</code>、<code>for...of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 等枚举：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(person) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(person) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(person) <span class="comment">// &#x27;&#123;&quot;name&quot;:&quot;布兰&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>但是可以通过 <code>Object.getOwnPropertySymbols()</code> 获取到对象的所有 <code>Symbol</code> 属性名，返回一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(person) <span class="comment">// [Symbol(age)]</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>静态方法</strong>：</p><ul><li><p><code>Symbol.for()</code> 按照描述去全局查找 <code>Symbol</code>，找不到则在全局登记一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Symbol.for()</code> 的这个全局登记特性，可以用在不同的 <code>iframe</code> 或 <code>service worker</code> 中取到同一个值。</p></li><li><p><code>Symbol.keyFor()</code> 根据已经在全局登记的 <code>Symbol</code> 查找其描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s) <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong><code>Symbol</code> 的内置值</strong>：</p><ul><li><code>Symbol.hasInstance</code>：指向一个内部方法，当其他对象使用 <code>instanceof</code> 运算符判断是否为此对象的实例时会调用此方法；</li><li><code>Symbol.isConcatSpreadable</code>：指向一个布尔，定义对象用于 <code>Array.prototype.concat()</code> 时是否可展开；</li><li><code>Symbol.species</code>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数；</li><li><code>Symbol.match</code>：指向一个函数，当实例对象被 <code>String.prototype.match()</code> 调用时会重新定义 match()的行为；</li><li><code>Symbol.replace</code>：指向一个函数，当实例对象被 <code>String.prototype.replace()</code> 调用时会重新定义 <code>replace()</code> 的行为；</li><li><code>Symbol.search</code>：指向一个函数，当实例对象被 <code>String.prototype.search()</code> 调用时会重新定义 <code>search()</code> 的行为；s</li><li><code>Symbol.split</code>：指向一个函数，当实例对象被 <code>String.prototype.split()</code> 调用时会重新定义 <code>split()</code> 的行为；</li><li><code>Symbol.iterator</code>：指向一个默认遍历器方法，当实例对象执行<code> for...of</code> 时会调用指定的默认遍历器；</li><li><code>Symbol.toPrimitive</code>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值；</li><li><code>Symbol.toStringTag</code>：指向一个函数，当实例对象被 <code>Object.prototype.toString()</code> 调用时其返回值会出现在 <code>toString()</code> 返回的字符串之中表示对象的类型；</li><li><code>Symbol.unscopables</code>：指向一个对象，指定使用 <code>with</code> 时哪些属性会被 <code>with</code> 环境排除；</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><p><code>Set</code> 是一种新的数据结构，类似数组，但是它没有键只有值，且值都是唯一的。可以通过构造函数生成一个新实例，接收一个数组或者可迭代数据结构作为参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// Set &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Set</code> 判断两个值是不是相等用的是 <a href="https://tc39.es/ecma262/#sec-samevaluezero">sameValueZero</a> 算法，类似于 <code>===</code>，唯一的区别是，在 <code>Set</code> 里 <code>NaN</code> 之间被认为是相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>相同对象的不同实例也被 <code>Set</code> 认为是不相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>Set</code> 是有顺序的，将按照插入的顺序进行迭代，可以使用 <code>for...of</code> 迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>)</span><br><span class="line">set.add(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>Set</code> 实例属性和方法</strong>：</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是 <code>Set</code> 函数；</li><li><code>Set.prototype.size</code>：返回 <code>Set</code> 实例的成员总数；</li><li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身；</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功；</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为 Set 的成员；</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值；</li><li><code>Set.prototype.keys()</code>：返回键名的遍历器；</li><li><code>Set.prototype.values()</code>：返回键值的遍历器；</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器；</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>) <span class="comment">// Set &#123;1, 3, 5&#125;</span></span><br><span class="line">set.size <span class="comment">// 3</span></span><br><span class="line">set.delete(<span class="number">1</span>) <span class="comment">// true，1 已被删除</span></span><br><span class="line">set.has(<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line">set.keys() <span class="comment">// SetIterator &#123;3, 5&#125;</span></span><br><span class="line">set.clear()</span><br><span class="line">set.size <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><strong><code>Set</code> 应用场景</strong>：</p><ul><li><p>数组去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;[...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>])] <span class="comment">// [1, 3, 6]</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// [1, 3, 6]</span></span><br></pre></td></tr></table></figure></li><li><p>字符串去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[...new <span class="built_in">Set</span>(<span class="string">&#x27;abcbacd&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &#x27;abcd&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>求两个集合的交集/并集/差集：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]) <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> b.has(x))) <span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.has(x))) <span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>遍历修改集合成员的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function">(<span class="params">val</span>) =&gt;</span> val * <span class="number">2</span>)) <span class="comment">// Set &#123;2, 3, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, <span class="function">(<span class="params">val</span>) =&gt;</span> val * <span class="number">2</span>)) <span class="comment">// Set &#123;2, 4, 6&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><ul><li><p><code>WeakSet</code> 对象允许将弱保持对象存储在一个集合中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">ws.add(foo) <span class="comment">// WeakSet &#123;&#123;&#125;&#125;</span></span><br><span class="line">ws.has(foo) <span class="comment">// true</span></span><br><span class="line">ws.delete(foo) <span class="comment">// WeakSet &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>和 <code>Set</code> 的区别</strong>：</p><ul><li><code>WeakSet</code> 只能是对象的集合，而不能是任何类型的任意值；</li><li><code>WeakSet</code> 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 <code>WeakSet</code> 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 <code>WeakSet</code> 中没有存储当前对象的列表。正因为这样，<code>WeakSet</code> 是不可枚举的，也就没有 <code>size</code> 属性，没有 <code>clear</code> 和遍历的方法。</li></ul><p><strong>实例方法</strong>：</p><ul><li><code>WeakSet.prototype.add(value)</code>：添加一个新元素 <code>value</code>；</li><li><code>WeakSet.prototype.delete(value)</code>：从该 <code>WeakSet</code> 对象中删除 <code>value</code> 这个元素；</li><li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值, 表示给定的值 <code>value</code> 是否存在于这个 <code>WeakSet</code> 中；</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><p><code>Map</code> 是一种类似于 <code>Object</code> 的这种键值对的数据结构，区别是对象的键只能是字符串或者 <code>Symbol</code>，而 <code>Map</code> 的键可以是任何类型（原始类型、对象或者函数），可以通过 <code>Map</code> 构造函数创建一个实例，入参是具有 <code>Iterator</code> 接口且每个成员都是一个双元素数组 <code>[key, value]</code> 的数据结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map1.set(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;布兰&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;age&#x27;</span>, <span class="number">12</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(arr)</span><br></pre></td></tr></table></figure></li><li><p><code>Map</code> 中的键和 <code>Set</code> 里的值一样也必须是唯一的，遵循 <a href="https://tc39.es/ecma262/#sec-samevaluezero">sameValueZero</a> 算法，对于同一个键后面插入的会覆盖前面的，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span> &#125;</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo1&#x27;</span>)</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo2&#x27;</span>)</span><br><span class="line">map.get(foo) <span class="comment">// &#x27;foo2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>对于键名同为 <code>NaN</code> 以及相同对象而不同实例的处理同 <code>Set</code> 的值一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(a, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(b, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">map.size <span class="comment">// 1</span></span><br><span class="line">map.get(a) <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> d = &#123; <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span> &#125;</span><br><span class="line">map.set(c, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">map.set(d, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">map.size <span class="comment">// 3</span></span><br><span class="line">map.get(c) <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>实例属性和方法</strong>：</p><ul><li><code>Map.prototype.size</code>：返回 <code>Map</code> 对象的键值对数量；</li><li><code>Map.prototype.set(key, value)</code>：设置 <code>Map</code> 对象中键的值。返回该 <code>Map</code> 对象；</li><li><code>Map.prototype.get(key)</code>： 返回键对应的值，如果不存在，则返回 <code>undefined</code>；</li><li><code>Map.prototype.has(key)</code>：返回一个布尔值，表示 <code>Map</code> 实例是否包含键对应的值；</li><li><code>Map.prototype.delete(key)</code>： 如果 <code>Map</code> 对象中存在该元素，则移除它并返回 <code>true</code>；</li><li><code>Map.prototype.clear()</code>： 移除 <code>Map</code> 对象的所有键/值对；</li><li><code>Map.prototype.keys()</code>：返回一个新的 <code>Iterator</code> 对象， 它按插入顺序包含了 <code>Map</code> 对象中每个元素的键；</li><li><code>Map.prototype.values()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map</code> 对象中每个元素的值；</li><li><code>Map.prototype.entries()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map</code> 对象中每个元素的 <code>[key, value]</code> 数组；</li><li><code>Map.prototype.forEach(callbackFn[, thisArg])</code>：按插入顺序遍历 <code>Map</code>；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125; &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125; &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><ul><li><p>类似于 <code>Map</code> 的结构，但是键必须是对象的弱引用，注意弱引用的是键名而不是键值，因而 <code>WeakMap</code> 是不能被迭代的；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;</span><br><span class="line">wm.set(foo, <span class="string">&#x27;a&#x27;</span>) <span class="comment">// Weak</span></span><br><span class="line">wm.get(foo) <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">wm.has(foo) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>虽然 <code>wm</code> 的键对 <code>foo</code> 对象有引用，但是丝毫不会阻止 <code>foo</code> 对象被 <code>GC</code> 回收。当引用对象 <code>foo</code> 被垃圾回收之后，<code>wm</code> 的 <code>foo</code> 键值对也会自动移除，所以不用手动删除引用。</p></li></ul><p><strong>实例方法</strong>：</p><ul><li><code>WeakMap.prototype.delete(key)</code>：移除 <code>key</code> 的关联对象；</li><li><code>WeakMap.prototype.get(key)</code>：返回 key 关联对象, 或者 undefined(没有 key 关联对象时)；</li><li><code>WeakMap.prototype.has(key)</code>：根据是否有 <code>key</code> 关联对象返回一个 <code>Boolean</code> 值；</li><li><code>WeakMap.prototype.set(key, value)</code>：在 <code>WeakMap</code> 中设置一组 <code>key</code> 关联对象，返回这个 <code>WeakMap</code> 对象；</li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul><li><p><code>Proxy</code> 用来定义基本操作的的自定义行为，可以理解为当对目标对象 <code>target</code> 进行某个操作之前会先进行拦截（执行 <code>handler</code> 里定义的方法），必须要对 <code>Proxy</code> 实例进行操作才能触发拦截，对目标对象操作是不会拦截的，可以通过如下方式定义一个代理实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;target.name&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">instance.name <span class="comment">// &#x27;hello, 布兰&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>如果 <code>handle</code> 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;)</span><br><span class="line">proxy.name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">target.name <span class="comment">// &#x27;布兰&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>目标对象被 <code>Proxy</code> 代理的时候，内部的 <code>this</code> 会指向代理的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === proxy)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">target.m() <span class="comment">// false</span></span><br><span class="line">proxy.m() <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>静态方法</strong>：</p><ul><li><p><code>Proxy.revocable()</code> 用以定义一个可撤销的 <code>Proxy</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler)</span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">123</span></span><br><span class="line">proxy.foo <span class="comment">// 123</span></span><br><span class="line">revoke()</span><br><span class="line">proxy.foo <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></li></ul><p><strong><code>handle</code> 对象的方法</strong>：</p><ul><li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。</li><li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如 <code>proxy.foo = v或proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li><code>has(target, propKey)</code>：拦截 <code>propKey in proxy</code> 的操作，返回一个布尔值。<br><code>deleteProperty(target, propKey)</code>：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li><li><code>ownKeys(target)</code>：拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code> 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys()</code> 的返回结果仅包括目标对象自身的可遍历属性。</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li><code>defineProperty(target, propKey, propDesc)</code>：拦截 <code>Object.defineProperty(proxy, propKey, propDesc)</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li><code>preventExtensions(target)</code>：拦截 <code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li><code>getPrototypeOf(target)</code>：拦截 <code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li><code>isExtensible(target)</code>：拦截 <code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li><code>setPrototypeOf(target, proto)</code>：拦截 <code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li><code>apply(target, object, args)</code>：拦截 <code>Proxy</code> 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li><code>construct(target, args)</code>：拦截 <code>Proxy</code> 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code>。</li></ul><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul><li><code>Reflect</code> 是一个内置的对象，它提供拦截 <code>JavaScript</code> 操作的方法。这些方法与 <code>proxy handlers</code> 的方法相同。<code>Reflect</code> 不是一个函数对象，因此它是不可构造的。</li><li>设计的目的：<ul><li>将 <code>Object</code> 属于语言内部的方法放到 <code>Reflect</code> 上；</li><li>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理；</li><li>让 <code>Object</code> 操作变成函数行为；</li><li><code>Proxy handles</code> 与 <code>Reflect</code> 方法一一对应，前者用于定义自定义行为，而后者用于恢复默认行为；</li></ul></li></ul><p><strong>静态方法</strong>：</p><ul><li><code>Reflect.apply(target, thisArgument, argumentsList)</code> 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 <code>Function.prototype.apply()</code> 功能类似；</li><li><code>Reflect.construct(target, argumentsList[, newTarget])</code> 对构造函数进行 <code>new</code> 操作，相当于执行 <code>new target(...args)</code>；</li><li><code>Reflect.defineProperty(target, propertyKey, attributes)</code> 和 <code>Object.defineProperty()</code> 类似。如果设置成功就会返回 <code>true</code>；</li><li><code>Reflect.deleteProperty(target, propertyKey)</code> 作为函数的 <code>delete</code> 操作符，相当于执行 <code>delete target[name]</code>；</li><li><code>Reflect.get(target, propertyKey[, receiver])</code> 获取对象身上某个属性的值，类似于 <code>target[name]</code>；</li><li><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code> 类似于 <code>Object.getOwnPropertyDescriptor()</code>。如果对象中存在该属性，则返回对应的属性描述符, 否则返回 <code>undefined</code>；</li><li><code>Reflect.getPrototypeOf(target)</code> 类似于 <code>Object.getPrototypeOf()</code>；</li><li><code>Reflect.has(target, propertyKey)</code> 判断一个对象是否存在某个属性，和 <code>in</code> 运算符 的功能完全相同；</li><li><code>Reflect.isExtensible(target)</code> 类似于 <code>Object.isExtensible()</code>；</li><li><code>Reflect.ownKeys(target)</code> 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <code>Object.keys()</code>, 但不会受 <code>enumerable</code> 影响)；</li><li><code>Reflect.preventExtensions(target)</code> 类似于 <code>Object.preventExtensions()</code>。返回一个 <code>Boolean</code>；</li><li><code>Reflect.set(target, propertyKey, value[, receiver])</code> 将值分配给属性的函数。返回一个 <code>Boolean</code>，如果更新成功，则返回 <code>true</code>；</li><li><code>Reflect.setPrototypeOf(target, prototype)</code> 设置对象原型的函数. 返回一个 <code>Boolean</code>， 如果更新成功，则返回 <code>true</code>；</li></ul><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul><li><p>可以用 <code>class</code> 关键字来定义一个类，类是对一类具有共同特征的事物的抽象，就比如可以把小狗定义为一个类，小狗有名字会叫也会跳；类是特殊的函数，就像函数定义的时候有函数声明和函数表达式一样，类的定义也有类声明和类表达式，不过类声明不同于函数声明，它是无法提升的；类也有 <code>name</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  bark() &#123;&#125;</span><br><span class="line">  jump() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.name <span class="comment">// &#x27;Dog&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类表达式：可以命名（类的 name 属性取类名），也可以不命名（类的 name 属性取变量名）</span></span><br><span class="line"><span class="keyword">let</span> Animal2 = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">&#125;</span><br><span class="line">Animal2.name <span class="comment">// &#x27;Animal2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>JS</code> 中的类建立在原型的基础上（通过函数来模拟类，其实类就是构造函数的语法糖），和 <code>ES5</code> 中构造函数类似，但是也有区别，比如类的内部方法是不可被迭代的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  bark() &#123;&#125;</span><br><span class="line">  jump() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(Dog.prototype) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog2</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Dog2.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  bark() &#123;&#125;,</span><br><span class="line">  jump() &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(Dog2.prototype) <span class="comment">// [&#x27;constructor&#x27;, &#x27;bark&#x27;, &#x27;jump&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>基于原型给类添加新方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(Dog.prototype, &#123;</span><br><span class="line">  wag() &#123;&#125;, <span class="comment">// 摇尾巴</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，<code>getter</code>和 <code>setter</code> 都在严格模式下执行。</p></li><li><p>类内部的 <code>this</code> 默认指向类实例，所以如果直接调用原型方法或者静态方法会导致 <code>this</code> 指向运行时的环境，而类内部是严格模式，所以此时的 <code>this</code> 会是 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  bark() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is bark.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> jump() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is jump.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;大黄&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> &#123; bark &#125; = dog</span><br><span class="line"><span class="keyword">let</span> &#123; jump &#125; = Dog</span><br><span class="line">bark() <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line">jump() <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>方法和关键字</strong>：</p><ul><li><code>constructor</code> 方法是类的默认方法，通过 <code>new</code> 关键字生成实例的时候，会自动调用；一个类必须有<code>constructor</code> 方法，如果没有显示定义，则会自动添加一个空的；<code>constructor</code> 默认会返回实例对象：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>get</code> 和 <code>set</code> 关键字拦截某个属性的读写操作：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>用 <code>static</code> 关键字给类定义静态方法，静态方法不会存在类的原型上，所以不能通过类实例调用，只能通过类名来调用，静态方法和原型方法可以同名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  bark() &#123;&#125;</span><br><span class="line">  jump() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;原型方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> jump() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;静态方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Dog.prototype) <span class="comment">// [&#x27;constructor&#x27;, &#x27;bark&#x27;, &#x27;jump&#x27;]</span></span><br><span class="line">Dog.jump() <span class="comment">// &#x27;静态方法&#x27;</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.jump() <span class="comment">// &#x27;原型方法&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>公有字段和私有字段：</p><p>静态公有字段和静态方法一样只能通过类名调用；私有属性和私有方法只能在类的内部调用，外部调用将报错：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  age = <span class="number">12</span> <span class="comment">// 公有字段</span></span><br><span class="line">  <span class="keyword">static</span> sex = <span class="string">&#x27;male&#x27;</span> <span class="comment">// 静态公有字段</span></span><br><span class="line">  #secret = &#x27;我是人类的好朋友&#x27; // 私有字段</span><br><span class="line">  #getSecret() &#123;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    return this.#secret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.sex <span class="comment">// &#x27;male&#x27;</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.#getSecret() // SyntaxError</span><br></pre></td></tr></table></figure><blockquote><p>公共和私有字段声明是 JavaScript 标准委员会 TC39 提出的实验性功能（第 3 阶段）。浏览器中的支持是有限的，但是可以通过 Babel 等系统构建后使用此功能。</p></blockquote></li><li><p><code>new.target</code> 属性允许你检测函数、构造方法或者类是否是通过 <code>new</code> 运算符被调用的。在通过 <code>new</code> 运算符被初始化的函数或构造方法中，<code>new.target</code> 返回一个指向构造方法或函数的引用。在普通的函数调用中，<code>new.target</code> 的值是 <code>undefined</code>，子类继承父类的时候会返回子类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) <span class="keyword">return</span> <span class="string">&#x27;new target is undefined&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn is called by new&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog() <span class="comment">// &#x27;Dog&#x27;</span></span><br><span class="line">fn() <span class="comment">// &#x27;new target is undefined&#x27;</span></span><br><span class="line"><span class="keyword">new</span> fn() <span class="comment">// &#x27;fn is called by new&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>类的继承</strong>：</p><ul><li><p>类可以通过 <code>extends</code> 关键字实现继承，如果子类显示的定义了 <code>constructor</code> 则必须在内部调用 <code>super()</code> 方法，内部的 <code>this</code> 指向当前子类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is running.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name) <span class="comment">// 必须调用</span></span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  bark() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is barking.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;大黄&#x27;</span>)</span><br><span class="line">dog.run() <span class="comment">// &#x27;大黄 is running.&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <code>super()</code> 调用父类的构造函数或者通过 <code>super</code> 调用父类的原型方法；另外也可以在子类的静态方法里通过 <code>super</code> 调用父类的静态方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码改造</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="built_in">super</span>(name)  <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    bark() &#123;</span><br><span class="line">        <span class="built_in">super</span>.run()  <span class="comment">// 调用父类原型方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is barking.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.bark()s</span><br><span class="line"><span class="comment">// &#x27;大黄 is running.&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;大黄 is barking.&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>子类的 <code>__proto__</code> 属性，表示构造函数的继承，总是指向父类；子类 <code>prototype</code> 属性的 <code>__proto__</code> 属性，表示方法的继承，总是指向父类的 prototype 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dog.__proto__ === Animal <span class="comment">// true</span></span><br><span class="line">Dog.prototype.__proto__ === Animal.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>子类原型的原型指向父类的原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.__proto__.__proto__ === animal.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>extends</code> 还可以实现继承原生的构造函数，如下这些构造函数都可以被继承：</p><ul><li><code>String()</code></li><li><code>Number()</code></li><li><code>Boolean()</code></li><li><code>Array()</code></li><li><code>Object()</code></li><li><code>Function()</code></li><li><code>Date()</code></li><li><code>RegExp()</code></li><li><code>Error()</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> <span class="keyword">extends</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name)</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  welcome() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`hello <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ms = <span class="keyword">new</span> MyString(<span class="string">&#x27;布兰&#x27;</span>)</span><br><span class="line">ms.welcome() <span class="comment">// &#x27;hello 布兰&#x27;</span></span><br><span class="line">ms.length <span class="comment">// 2</span></span><br><span class="line">ms.indexOf(<span class="string">&#x27;兰&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul><li><p>浏览器传统加载模块方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步加载</span></span><br><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defer异步加载：顺序执行，文档解析完成后执行；</span></span><br><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span> defer&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async异步加载：乱序加载，下载完就执行。</span></span><br><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>浏览器现在可以按照模块（加上 <code>type=&quot;module&quot;</code>）来加载脚本，默认将按照 <code>defer</code> 的方式异步加载；<code>ES6</code> 的模块加载依赖于 <code>import</code> 和 <code>export</code> 这 2 个命令；模块内部自动采用严格模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块加载</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;test.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>export</code> 用于输出模块的对外接口，一个模块内只能允许一个 <code>export default</code> 存在，以下是几种输出模块接口的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="comment">// 写法一：单独导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：按需导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三：重命名后导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> name1, age <span class="keyword">as</span> age1 &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法四：默认导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name</span><br></pre></td></tr></table></figure></li><li><p><code>import</code> 用于输入其他模块的接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按需导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入后重命名</span></span><br><span class="line"><span class="keyword">import</span> &#123; name1 <span class="keyword">as</span> name, age1 <span class="keyword">as</span> age &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导入</span></span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> person <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合导入</span></span><br><span class="line"><span class="keyword">import</span> _, &#123; each &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br></pre></td></tr></table></figure><p><code>import</code> 导入的细节：</p><ul><li>导入的变量名必须与导出模块的名字一致，可以使用 <code>as</code> 进行重命名；</li><li>导入的变量都是只读的，不能改写；</li><li><code>import</code> 命令具有提升效果，会提升到整个模块的头部，首先执行；</li><li><code>import</code> 是编译时导入，所以不能将其写到代码块（比如 <code>if</code> 判断块里）或者函数内部；</li><li><code>import</code> 会执行所加载的模块的代码，如果重复导入同一个模块则只会执行一次模块；</li></ul></li><li><p><code>import</code> 和 <code>export</code> 的复合写法：<code>export</code> 和 <code>import</code> 语句可以结合在一起写成一行，相当于是在当前模块直接转发外部模块的接口，复合写法也支持用 <code>as</code> 重命名。以下例子中需要在 <code>hub.js</code> 模块中转发 <code>person.js</code> 的接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"><span class="comment">// 按需转发接口（中转模块：hub.js）</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; name, age &#125;</span><br><span class="line"><span class="comment">// 转发默认接口（中转模块：hub.js）</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> person</span><br></pre></td></tr></table></figure></li><li><p><code>ES6</code> 模块和 <code>CommonJS</code> 模块的差异：</p><ul><li><code>CommonJS</code> 模块输出的是一个值的拷贝（一旦输出一个值，模块内部的变化就影响不到这个值），<code>ES6</code> 模块输出的是值的引用（是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值）；</li><li><code>CommonJS</code> 模块是运行时加载，<code>ES6</code> 模块是编译时输出接口；</li><li><code>CommonJS</code> 模块的 <code>require()</code> 是同步加载模块，<code>ES6</code> 模块的 <code>import</code> 命令是异步加载，有一个独立的模块依赖的解析阶段；</li></ul></li></ul><h3 id="Iterator-和-for…of"><a href="#Iterator-和-for…of" class="headerlink" title="Iterator 和 for…of"></a>Iterator 和 for…of</h3><ul><li><p><code>Iterator</code> 迭代器协议，为各种数据结构提供了一种统一按照某种顺序进行访问的机制。通常部署在一个可迭代数据结构内部或其原型上。一个对象要能够成为迭代器，它必须有一个 <code>next()</code> 方法，每次执行 <code>next()</code> 方法会返回一个对象，这个对象包含了一个 <code>done</code> 属性（是个布尔值，<code>true</code> 表示可以继续下次迭代）和一个 <code>value</code> 属性（每次迭代的值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> makeIterator = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">return</span> index &lt; arr.length</span><br><span class="line">        ? &#123;</span><br><span class="line">            value: arr[index++],</span><br><span class="line">            done: <span class="literal">false</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        : &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>iterable</code> 可迭代数据结构：内部或者原型上必须有一个 <code>Symbol.iterator</code> 属性（如果是异步的则是 <code>Symbol.asyncIterator</code>），这个属性是一个函数，执行后会生成一个迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      index: <span class="number">0</span>,</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.index &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="built_in">this</span>.index++, done: <span class="literal">false</span> &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的一些可迭代数据结构有：<code>String</code>、<code>Array</code>、<code>TypedArray</code>、<code>Map</code> 和 <code>Set</code>、<code>arguments</code>、<code>NodeList</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> si = <span class="string">&#x27;hi&#x27;</span>[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">si <span class="comment">// StringIterator</span></span><br><span class="line">si.next() <span class="comment">// &#123;value: &#x27;h&#x27;, done: false&#125;</span></span><br><span class="line">si.next() <span class="comment">// &#123;value: &#x27;i&#x27;, done: false&#125;</span></span><br><span class="line">si.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>for...of</code>：用于遍历可迭代数据结构：</p><ul><li>遍历字符串：<code>for...in</code> 获取索引，<code>for...of</code> 获取值；</li><li>遍历数组：<code>for...in</code> 获取索引，<code>for...of</code> 获取值；</li><li>遍历对象：<code>for...in</code> 获取键，<code>for...of</code> 需自行部署 <code>[Symbol.iterator]</code> 接口；</li><li>遍历 <code>Set</code>：<code>for...of</code> 获取值， <code>for (const v of set)</code>；</li><li>遍历 <code>Map</code>：<code>for...of</code> 获取键值对，<code>for (const [k, v] of map)</code>；</li><li>遍历类数组：包含 <code>length</code> 的对象、<code>arguments</code> 对象、<code>NodeList</code>对象(无 <code>Iterator</code> 接口的类数组可用 <code>Array.from()</code> 转换)；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">&#x27;abc&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">//  &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 Set</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;布兰&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;age&#x27;</span>, <span class="number">12</span>],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27;: &#x27;</span> + value) <span class="comment">// &#x27;name: 布兰&#x27; &#x27;age: 12&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>for...of</code> 和 <code>for...in</code> 对比</p><p>共同点：能够通过 <code>break</code>、<code>continue</code> 和 <code>return</code> 跳出循环；<br>不同点：</p><ul><li><code>for...in</code> 的特点：只能遍历键，会遍历原型上属性，遍历无顺序，适合于对象的遍历；</li><li><code>for...of</code> 的特点：能够遍历值（某些数据结构能遍历键和值，比如 <code>Map</code>），不会遍历原型上的键值，遍历顺序为数据的添加顺序，适用于遍历可迭代数据结构；</li></ul></li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><code>Promise</code> 这块知识可以直接看我之前写的一篇文章：<a href="https://juejin.im/post/6886247841686093837">深入理解 Promise</a> 非常完整。</p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul><li><p><code>function*</code> 会定义一个生成器函数，调用生成器函数不会立即执行，而是会返回一个 <code>Generator</code> 对象，这个对象是符合可迭代协议和迭代器协议的，换句话说这个 <code>Generator</code> 是可以被迭代的。</p></li><li><p>生成器函数内部通过 <code>yield</code> 来控制暂停，而 <code>next()</code> 将把它恢复执行，它的运行逻辑是如下这样的：</p><ul><li>遇到 <code>yield</code> 表达式，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值作为返回的对象的 <code>value</code> 属性值；</li><li>下一次调用 <code>next</code> 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 表达式；</li><li>如果没有再遇到新的 <code>yield</code> 表达式，就一直运行到函数结束，直到 <code>return</code> 语句为止，并将 <code>return</code> 语句后面的表达式的值，作为返回的对象的 <code>value</code> 属性值；</li><li>如果该函数没有 <code>return</code> 语句，则返回的对象的 <code>value</code> 属性值为 <code>undefined</code>；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next() <span class="comment">// &#123;value: &#x27;hello&#x27;, done: false&#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123;value: &#x27;world&#x27;, done: false&#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123;value: &#x27;end&#x27;, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在生成器函数内部可以使用 <code>yield*</code> 表达式委托给另一个 <code>Generator</code> 或可迭代对象，比如数组、字符串等；<code>yield*</code> 表达式本身的值是当迭代器关闭时返回的值（即 <code>done</code> 为 <code>true</code> 时）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* inner()</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line">g.next()</span><br><span class="line">g.next()</span><br></pre></td></tr></table></figure></li></ul><p><strong>实例方法</strong>：</p><ul><li><p><code>Generator.prototype.next()</code>：返回一个包含属性 <code>done</code> 和 <code>value</code> 的对象。该方法也可以通过接受一个参数用以向生成器传值。如果传入了参数，那么这个参数会传给上一条执行的 <code>yield</code> 语句左边的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">12</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> a</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = f()</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">&#x27;c&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123;value: 12, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: &#x27;b&#x27;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Generator.prototype.throw()</code>：用来向生成器抛出异常，如果内部捕获了则会恢复生成器的执行（即执行下一条 <code>yield</code> 表达式），并且返回带有 <code>done</code> 及 <code>value</code> 两个属性的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">    yiele <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line">g.throw(<span class="string">&#x27;error a&#x27;</span>)</span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;error a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;b&quot;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;c&quot;, done: false&#125;</span></span><br></pre></td></tr></table></figure><p>如果内部没有捕获异常，将中断内部代码的继续执行（类似 <code>throw</code> 抛出的异常，如果没有捕获，则后面的代码将不会执行），此时异常会抛到外部，可以被外部的 <code>try...catch</code> 块捕获，此时如果再执行一次 <code>next()</code>，会返回一个值为 <code>done</code> 属性为 <code>true</code> 的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  g.throw(<span class="string">&#x27;error a&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;error a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Generator.prototype.return()</code>：返回给定的值并结束生成器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>应用</strong>：</p><ul><li><p>将异步操作同步化，比如同时有多个请求，多个请求之间是有顺序的，只能等前面的请求完成了才请求后面的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res1 = <span class="keyword">yield</span> request(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res1)</span><br><span class="line">  <span class="keyword">let</span> res2 = <span class="keyword">yield</span> request(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line">  <span class="keyword">let</span> res3 = <span class="keyword">yield</span> request(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟异步请求</span></span><br><span class="line">    it.next(url)</span><br><span class="line">  &#125;, <span class="number">300</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = main()</span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>给对象部署 <code>Iterator</code> 接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i]</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;foo&#x27; 3</span></span><br><span class="line"><span class="comment">// &#x27;bar&#x27; 7</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2016.png"></p><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><p>判断一个数组是否包含某个元素，之前一般是这么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (~arr.indexOf(el)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而现在你可以这么做了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.includes(el)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>indexOf</code> 会返回找到元素在数组中的索引位置，判断的逻辑是是否严格相等，所以他在遇到 <code>NaN</code> 的时候不能正确返回索引，但是 <code>includes</code> 解决了这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>]</span><br><span class="line">  .indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>)].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="求幂运算符（-）"><a href="#求幂运算符（-）" class="headerlink" title="求幂运算符（**）"></a>求幂运算符（**）</h3><p><code>x ** y</code> 是求 <code>x</code> 的 <code>y</code> 次幂，和 <code>Math.pow(x, y)</code> 功能一致：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x ** y</span></span><br><span class="line"><span class="keyword">let</span> squared = <span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 2 * 2 = 4</span></span><br><span class="line"><span class="keyword">let</span> cubed = <span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 2 * 2 * 2 = 8</span></span><br></pre></td></tr></table></figure><p><code>x **= y</code> 表示求 <code>x</code> 的 <code>y</code> 次幂，并且把结果赋值给 <code>x</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x **= y</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line">x **= <span class="number">3</span> <span class="comment">// x 最后等于 8</span></span><br></pre></td></tr></table></figure><h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2017.png"></p><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p>返回一个由对象自身所有可遍历属性的属性值组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">12</span>,</span><br><span class="line">  enumrable: <span class="literal">false</span>, <span class="comment">// age 属性将不可遍历</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(person)) <span class="comment">// [&#x27;布兰&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似 str.split(&#x27;&#x27;) 效果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(<span class="string">&#x27;abc&#x27;</span>)) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>返回一个由对象自身所有可遍历属性的键值对组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(person)) <span class="comment">// [[&quot;name&quot;, &quot;布兰&quot;], [&quot;age&quot;, 12]]</span></span><br></pre></td></tr></table></figure><p>利用这个方法可以很好的将对象转成正在的 <code>Map</code> 结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(person))</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptor()</code> 会返回指定对象某个自身属性的的描述对象，而 <code>Object.getOwnPropertyDescriptors()</code> 则是返回指定对象自身所有属性的描述对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person))</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  name: &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;,</span></span><br><span class="line"><span class="comment">//  age: &#123;configurable: false, enumerable: false, value: 12, writable: false&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>配合 <code>Object.create()</code> 可以实现浅克隆：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Object</span>.create(</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="String-prototype-padStart"><a href="#String-prototype-padStart" class="headerlink" title="String.prototype.padStart()"></a>String.prototype.padStart()</h3><p><code>str.padStart(length [, padStr])</code> 会返回一个新字符串，该字符串将从 <code>str</code> 字符串的左侧开始填充某个字符串 <code>padStr</code>（非必填，如果不是字符串则会转成字符串, 传入 <code>undefined</code> 和不传这个参数效果一致）直到达到指定位数 <code>length</code> 为止：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>, <span class="number">2</span>) <span class="comment">// &#x27;22abc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>, <span class="literal">undefined</span>) <span class="comment">// &#x27;  abc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>, &#123;&#125;) <span class="comment">// &#x27;[oabc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>) <span class="comment">// &#x27;  abc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abcde&#x27;</span>.padStart(<span class="number">2</span>, <span class="string">&#x27;f&#x27;</span>) <span class="comment">// &#x27;abcde&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-padEnd"><a href="#String-prototype-padEnd" class="headerlink" title="String.prototype.padEnd()"></a>String.prototype.padEnd()</h3><p>规则和 <code>padStart</code> 类似，但是是从字符串右侧开始填充：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padEnd(<span class="number">5</span>, <span class="number">2</span>) <span class="comment">// &#x27;abc22&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="函数参数尾逗号"><a href="#函数参数尾逗号" class="headerlink" title="函数参数尾逗号"></a>函数参数尾逗号</h3><p>允许函数在定义和调用的时候时候最后一个参数后加上逗号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">param1, param2</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">init(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Async-函数"><a href="#Async-函数" class="headerlink" title="Async 函数"></a>Async 函数</h3><ul><li><p>使用 <code>async</code> 可以声明一个 <code>async</code> 函数，结合 <code>await</code> 可以用一种很简介的方法写成基于 <code>Promise</code> 的异步行为，而不需要刻意的链式调用。<code>await</code> 表达式会暂停整个 <code>async</code> 函数的执行进程并出让其控制权，只有当其等待的基于 <code>Promise</code> 的异步操作被兑现或被拒绝之后才会恢复进程。<code>async</code> 函数有如下几种定义形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法</span></span><br><span class="line">lef obj = &#123;</span><br><span class="line">    <span class="keyword">async</span> foo() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">async</span> bark() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>async</code> 函数一定会返回一个 <code>Promise</code> 对象，所以它可以使用 <code>then</code> 添加处理函数。如果一个 <code>async</code> 函数的返回值看起来不是<code>Promise</code>，那么它将会被隐式地包装在一个 <code>Promise</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>内部如果发生错误，或者显示抛出错误，那么 <code>async</code> 函数会返回一个 <code>rejected</code> 状态的 <code>Promsie</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo().catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err) <span class="comment">// Error: error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>返回的 <code>Promise</code> 对象必须等到内部所有 <code>await</code> 命令 <code>Promise</code> 对象执行完才会发生状态改变，除非遇到 <code>return</code> 语句或抛出错误；任何一个 <code>await</code> 命令返回的 <code>Promise</code> 对象变 <code>为rejected</code> 状态，整个 <code>Async</code> 函数都会中断后续执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a_&#x27;</span> + a)</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b_&#x27;</span> + b) <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 不会执行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#x27;a_success&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;fail&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>所以为了保证 <code>async</code> 里的异步操作都能完成，我们需要将他们放到 <code>try...catch()</code> 块里或者在 <code>await</code> 返回的 <code>Promise</code> 后跟一个 <code>catch</code> 处理函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;a fail&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a_&#x27;</span> + a) <span class="comment">// 不会执行</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e) <span class="comment">// &#x27;a fail&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;b fail&#x27;</span>).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e) <span class="comment">// &#x27;b fail&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b_&#x27;</span> + b) <span class="comment">// &#x27;bundefined&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 不会执行</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>async</code> 函数里的多个异步操作之间没有依赖关系，建议将他们写到一起减少执行时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo()</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar()</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise</span><br></pre></td></tr></table></figure></li><li><p><code>await</code> 命令只能用在 <code>async</code> 函数之中，如果用在普通函数，就会报错。</p></li></ul><h3 id="共享内存和-Atomics-对象"><a href="#共享内存和-Atomics-对象" class="headerlink" title="共享内存和 Atomics 对象"></a>共享内存和 Atomics 对象</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/arraybuffer#SharedArrayBuffer">SharedArrayBuffer</a></li><li><a href="https://es6.ruanyifeng.com/#docs/arraybuffer#Atomics-%E5%AF%B9%E8%B1%A1">Atomics</a></li></ul><h2 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2018.png"></p><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>Promise.prototype.finally()</code> 用于给 <code>Promise</code> 对象添加 <code>onFinally</code> 函数，这个函数主要是做一些清理的工作，<strong>只有状态变化</strong>的时候才会执行该 <code>onFinally</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">888</span>) <span class="comment">// 并不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;).finally(onFinally)</span><br></pre></td></tr></table></figure><p><code>finally()</code> 会生成一个 <code>Promise</code> 新实例，finally 一般会原样后传父 Promise，无论父级实例是什么状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = p3.finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3) <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>上面说的是一般，但是也有特殊情况，比如 <code>finally</code> 里返回了一个非 <code>fulfilled</code> 的 <code>Promise</code> 或者抛出了异常的时候，则会返回对应状态的新实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3) <span class="comment">// Promise &#123;&lt;rejected&gt;: 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = p1.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4) <span class="comment">// Promise &#123;&lt;rejected&gt;: Error: error&#125;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.im/post/6886247841686093837#heading-9">深入理解 Promise</a></p><h3 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h3><p>想要了解异步迭代器最好的方式就是和同步迭代器进行对比。我们知道可迭代数据的内部都是有一个 <code>Symbol.iterator</code> 属性，它是一个函数，执行后会返回一个迭代器对象，这个迭代器对象有一个 <code>next()</code> 方法可以对数据进行迭代，<code>next()</code> 执行后会返回一个对象，包含了当前迭代值 <code>value</code> 和 标识是否完成迭代的 <code>done</code> 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = [<span class="number">1</span>, <span class="number">2</span>][<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefinde, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面这里的 <code>next()</code> 执行的是同步操作，所以这个是同步迭代器，但是如果 <code>next()</code> 里需要执行异步操作，那就需要异步迭代了，可异步迭代数据的内部有一个 <code>Symbol.asyncIterator</code> 属性，基于此我们来实现一个异步迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(iterable) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = iterable</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">this</span>.data.length,</span><br><span class="line">      index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> done = index &gt;= length</span><br><span class="line">        <span class="keyword">const</span> value = !done ? <span class="built_in">this</span>.data[index++] : <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(&#123; value, done &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步迭代器的 <code>next()</code> 会进行异步的操作，通常是返回一个 <code>Promise</code>，所以需要对应的处理函数去处理结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> asyncIterator = emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">asyncIterator.next().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line">asyncIterator.next().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line">asyncIterator.next().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>另外也可以使用 <code>for await...of</code> 来迭代异步可迭代数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> asyncIterable = <span class="keyword">new</span> Emitter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> asyncIterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount()</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>另外还可以通过异步生成器来创建异步迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(iterable) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = iterable</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">this</span>.data.length,</span><br><span class="line">      index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; length) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">this</span>.data[index++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">  <span class="keyword">const</span> asyncIterable = emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> asyncIterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount()</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration_protocols</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for-await...of">for-await…of</a></li></ul><h3 id="s-修饰符-dotAll-模式"><a href="#s-修饰符-dotAll-模式" class="headerlink" title="s 修饰符(dotAll 模式)"></a>s 修饰符(dotAll 模式)</h3><p>正则表达式新增了一个 <code>s</code> 修饰符，使得 <code>.</code> 可以匹配任意单个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/foo.bar/</span>.test(<span class="string">&#x27;foo\nbar&#x27;</span>) / <span class="comment">// false</span></span><br><span class="line">  foo.bar /</span><br><span class="line">  s.test(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面这又被称为 <code>dotAll</code> 模式，表示点（<code>dot</code>）代表一切字符。所以，正则表达式还引入了一个 dotAll 属性，返回一个布尔值，表示该正则表达式是否处在 dotAll 模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/foo.bar/</span>s.dotAll <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="具名组匹配"><a href="#具名组匹配" class="headerlink" title="具名组匹配"></a>具名组匹配</h3><p>正则表达式可以使用捕获组来匹配字符串，但是想要获取某个组的结果只能通过对应的索引来获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> result = re.exec(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="comment">// result[0] === &#x27;2015-01-02&#x27;</span></span><br><span class="line"><span class="comment">// result[1] === &#x27;2015&#x27;</span></span><br><span class="line"><span class="comment">// result[2] === &#x27;01&#x27;</span></span><br><span class="line"><span class="comment">// result[3] === &#x27;02&#x27;</span></span><br></pre></td></tr></table></figure><p>而现在我们可以通过给捕获组 <code>(?&lt;name&gt;...)</code> 加上名字 <code>name</code> ，通过名字来获取对应组的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> result = re.exec(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="comment">// result.groups.year === &#x27;2015&#x27;</span></span><br><span class="line"><span class="comment">// result.groups.month === &#x27;01&#x27;</span></span><br><span class="line"><span class="comment">// result.groups.day === &#x27;02&#x27;</span></span><br></pre></td></tr></table></figure><p>配合解构赋值可以写出非常精简的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  groups: &#123; year, month, day &#125;,</span><br><span class="line">&#125; = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>.exec(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(year, month, day) <span class="comment">// 2015 01 02</span></span><br></pre></td></tr></table></figure><p>具名组也可以通过传递给 <code>String.prototype.replace</code> 的替换值中进行引用。如果该值为字符串，则可以使用 <code>$&lt;name&gt;</code> 获取到对应组的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">&#x27;2015-01-02&#x27;</span>.replace(re, <span class="string">&#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// result === &#x27;02/01/2015&#x27;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/tc39/proposal-regexp-named-groups">proposal-regexp-named-groups</a></p><h3 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h3><p>后行断言： <code>(?&lt;=y)x</code>，<code>x</code> 只有在 <code>y</code> 后面才能匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/(?&lt;=\$)\d+/</span>.exec(<span class="string">&#x27;I have $100.&#x27;</span>) <span class="comment">// [&#x27;100&#x27;]</span></span><br></pre></td></tr></table></figure><p>后行否定断言： <code>(?&lt;!y)x</code>，<code>x</code> 只有不在 <code>y</code> 后面才能匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/(?&lt;!\$)\d+/</span>.exec(<span class="string">&#x27;I have $100.&#x27;</span>) <span class="comment">// [&#x27;00&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="Unicode-属性转义"><a href="#Unicode-属性转义" class="headerlink" title="Unicode 属性转义"></a>Unicode 属性转义</h3><p>允许正则表达式匹配符合 <code>Unicode</code> 某种属性的所有字符，<code>\p&#123;...&#125;</code> 是匹配包含，<code>\P&#123;...&#125;</code> 是匹配不包含的字符，且必须搭配 <code>/u</code> 修饰符才会生效：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\p&#123;Emoji&#125;+<span class="regexp">/u.exec(&#x27;😁😭笑死我了🤣😂不行了&#x27;)  /</span><span class="regexp">/ [&#x27;😁😭&#x27;]</span></span><br><span class="line"><span class="regexp">/</span>\P&#123;Emoji&#125;+<span class="regexp">/u.exec(&#x27;😁😭笑死我了🤣😂不行了&#x27;)  /</span><span class="regexp">/ [&#x27;笑死我了&#x27;]</span></span><br></pre></td></tr></table></figure><p>这里可以查询到更多的 <code>Unicode</code> 的属性 <a href="http://unicode.org/reports/tr18/#Full_Properties">Full_Properties</a></p><h3 id="对象扩展运算符"><a href="#对象扩展运算符" class="headerlink" title="对象扩展运算符"></a>对象扩展运算符</h3><p>对象的扩展运算符可以用到解构赋值上，且只能应用到最后一个变量上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, ...y &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">// &#123;a: 2, b: 3&#125;</span></span><br></pre></td></tr></table></figure><p>对象扩展运算符不能解构原型上的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">obj.__proto__ = &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123; ...a &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(a.y) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>应用一：可以实现浅拷贝，但是不会拷贝原始属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(&#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;)</span><br><span class="line">person.age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝写法一</span></span><br><span class="line"><span class="keyword">let</span> &#123; ...pClone1 &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(pClone1) <span class="comment">// &#123; age: 12 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(pClone1.name) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝写法二</span></span><br><span class="line"><span class="keyword">let</span> pClone2 = &#123; ...person &#125;</span><br><span class="line"><span class="built_in">console</span>.log(pClone2) <span class="comment">// &#123; age: 12 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(pClone2.name) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>应用二：合并两个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b)</span><br></pre></td></tr></table></figure><p>应用三：重写对象属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure><p>应用四：给新对象设置默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;</span><br></pre></td></tr></table></figure><p>应用五：利用扩展运算符的解构赋值可以扩展函数参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> baseFunction(restConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md">Object Spread Initializer</a></li><li><a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Rest.md">Object Rest Destructuring</a></li></ul><h3 id="放松对标签模板里字符串转义的限制"><a href="#放松对标签模板里字符串转义的限制" class="headerlink" title="放松对标签模板里字符串转义的限制"></a>放松对标签模板里字符串转义的限制</h3><p><a href="https://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%99%90%E5%88%B6">ECMAScript 6 入门</a></p><h2 id="ES2019"><a href="#ES2019" class="headerlink" title="ES2019"></a>ES2019</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2019.png"></p><h3 id="允许省略-catch-里的参数"><a href="#允许省略-catch-里的参数" class="headerlink" title="允许省略 catch 里的参数"></a>允许省略 catch 里的参数</h3><p>异常被捕获的时候如果不需要做操作，甚至可以省略 <code>catch(err)</code> 里的参数和圆括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON-stringify-变动"><a href="#JSON-stringify-变动" class="headerlink" title="JSON.stringify()变动"></a>JSON.stringify()变动</h3><p><code>UTF-8</code> 标准规定，<code>0xD800</code> 到 <code>0xDFFF</code> 之间的码点，不能单独使用，必须配对使用。<br>所以 <code>JSON.stringify()</code> 对单个码点进行操作，如果码点符合 <code>UTF-8</code> 标准，则会返回对应的字符，否则会返回对应的码点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;1f600&#125;&#x27;</span>) <span class="comment">// &quot;&quot;😀&quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="comment">// &quot;&quot;\ud834&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h3><p><code>Symbol</code> 实例新增了一个描述属性 <code>description</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">symbol.description <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h3><p>函数的 <code>toString()</code> 会原样输出函数定义时候的样子，不会省略注释和空格。</p><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.fromEntries()</code> 方法是 <code>Object.entries()</code> 的逆操作，用于将一个键值对数组转为对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> keyValueArr = <span class="built_in">Object</span>.entries(person) <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(arr) <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>常用可迭代数据结构之间的装换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 -&gt; 键值对数组</span></span><br><span class="line"><span class="keyword">let</span> keyValueArr = <span class="built_in">Object</span>.entries(person) <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对数组 -&gt; Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(keyValueArr) <span class="comment">// Map &#123;&quot;name&quot;: &quot;布兰&quot;, &quot;age&quot;: 12&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map -&gt; 键值对数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(map) <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对数组 -&gt; 对象</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Array</span>.from(arr).reduce(</span><br><span class="line">  (acc, [key, val]) =&gt; <span class="built_in">Object</span>.assign(acc, &#123; [key]: val &#125;),</span><br><span class="line">  &#123;&#125;</span><br><span class="line">) <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/tc39/proposal-object-from-entries">Object.fromEntries</a></p><h3 id="字符串可直接输入行分隔符和段分隔符"><a href="#字符串可直接输入行分隔符和段分隔符" class="headerlink" title="字符串可直接输入行分隔符和段分隔符"></a>字符串可直接输入行分隔符和段分隔符</h3><p><code>JavaScript</code> 规定有 5 个字符，不能在字符串里面直接使用，只能使用转义形式。</p><ul><li><code>U+005C</code>：反斜杠（reverse solidus)</li><li><code>U+000D</code>：回车（carriage return）</li><li><code>U+2028</code>：行分隔符（line separator）</li><li><code>U+2029</code>：段分隔符（paragraph separator）</li><li><code>U+000A</code>：换行符（line feed）</li></ul><p>但是由于 <code>JSON</code> 允许字符串里可以使用 <code>U+2028</code> 和 <code>U+2029</code>，所以使得 <code>JSON.parse()</code> 去解析字符串的时候可能会报错，所以 <code>ES2019</code> 允许模板字符串里可以直接这两个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;\u2028&quot;&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;\u2029&quot;&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;\u005C&quot;&#x27;</span>) <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-trimStart"><a href="#String-prototype-trimStart" class="headerlink" title="String.prototype.trimStart"></a>String.prototype.trimStart</h3><p>消除字符串头部空格，返回一个新字符串；浏览器还额外增加了它的别名函数 <code>trimLeft()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;  hello world &#x27;</span></span><br><span class="line"><span class="keyword">let</span> newStr = str.trimStart()</span><br><span class="line"><span class="built_in">console</span>.log(newStr, newStr === str)</span><br><span class="line"><span class="comment">// &#x27;hello world &#x27;  false</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-trimEnd"><a href="#String-prototype-trimEnd" class="headerlink" title="String.prototype.trimEnd"></a>String.prototype.trimEnd</h3><p>消除字符串尾部空格，返回一个新字符串；浏览器还额外增加了它的别名函数 <code>trimRight()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;  hello world &#x27;</span></span><br><span class="line"><span class="keyword">let</span> newStr = str.trimEnd()</span><br><span class="line"><span class="built_in">console</span>.log(newStr, newStr === str)</span><br><span class="line"><span class="comment">// &#x27;  hello world&#x27;  false</span></span><br></pre></td></tr></table></figure><h3 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h3><p><code>arr.flat(depth)</code> 按照 <code>depth</code> （不传值的话默认是 1）深度拍平一个数组，并且将结果以新数组形式返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// depth 默认是 1</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.flat()) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Infinity，可展开任意深度的嵌套数组；自动跳过空数组；</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, , [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr2.flat(<span class="literal">Infinity</span>))</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>用 <code>reduce</code> 实现拍平一层数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> newStr = arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.concat(cur), [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> flattened = <span class="function">(<span class="params">arr</span>) =&gt;</span> [].concat(...arr)</span><br><span class="line">flattened(arr)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">flat</a></p><h3 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h3><p><code>flatMap(callback)</code> 使用映射函数 <code>callback</code> 映射每个元素，<code>callback</code> 每次的返回值组成一个数组，并且将这个数组执行类似 <code>arr.flat(1)</code> 的操作进行拍平一层后最后返回结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// 将 [[2], [4], [6], [8]] 数组拍平一层得到最终结果：[2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap">flatMap</a></p><h2 id="ES2020"><a href="#ES2020" class="headerlink" title="ES2020"></a>ES2020</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2020.png"></p><h3 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll()"></a>String.prototype.matchAll()</h3><p><code>String.prototype.matchAll()</code> 方法，可以一次性取出所有匹配。不过，它返回的是一个 <code>RegExpStringIterator</code> 迭代器同是也是一个可迭代的数据结构，所以可以通过 <code>for...of</code> 进行迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;test1test2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span></span><br><span class="line"><span class="keyword">let</span> iterable = str.matchAll(regexp)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;test1&#x27;, &#x27;e&#x27;, &#x27;st1&#x27;, &#x27;1&#x27;, index: 0, input: &#x27;test1test1&#x27;, groups: undefined]</span></span><br><span class="line"><span class="comment">// [&#x27;test2&#x27;, &#x27;e&#x27;, &#x27;st2&#x27;, &#x27;2&#x27;, index: 5, input: &#x27;test1test2&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意当使用 matchAll(regexp) 的时候，正则表达式必须加上 /g 修饰符。</p></blockquote><p>也可以将这个可迭代数据转成数组形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">;[...str.matchAll(regexp)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="built_in">Array</span>.from(str.matchAll(regexp))</span><br></pre></td></tr></table></figure><h3 id="动态-import"><a href="#动态-import" class="headerlink" title="动态 import()"></a>动态 import()</h3><p>标准用法的 <code>import</code> 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。</p><p>比如按需加载一个模块可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xxx) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module.js&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>import()</code> 是异步导入的，结果会返回一个 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;/module.js&#x27;</span>).then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something with the module.</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>动态 <code>import()</code> 的应用场景挺多的，比如 <code>Vue</code> 中的路由懒加载就是使用的动态导入组件。另外由于动态性不便于静态分析工具和 <code>tree-shaking</code> 工作，所以不能滥用。</p><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p><code>BigInt</code> 是一种内置对象，它提供了一种方法来表示大于 $2^{53}$ - 1 的整数。这原本是 <code>Javascript</code> 中可以用 <code>Number</code> 表示的最大数字。<code>BigInt</code> 可以表示任意大的整数。</p><p>为了区分 <code>Number</code>，定义一个 <code>BigInt</code> 需要在整数后面加上一个 <code>n</code>，或者用函数直接定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = <span class="number">10n</span></span><br><span class="line"><span class="keyword">const</span> num2 = BigInt(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><code>Number</code> 和 <code>BigInt</code> 之间能进行比较，但他们之间是宽松相等；且由于他们表示的是不同类型的数字，所以不能直接进行四则运算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10n</span> == <span class="number">10</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">10n</span> === <span class="number">10</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">10n</span> &gt; <span class="number">8</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">10</span> + <span class="built_in">Number</span>(<span class="number">10n</span>) <span class="comment">// 20</span></span><br><span class="line"><span class="number">10</span> + <span class="number">10n</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p><code>Promise.allSettled(iterable)</code> 当所有的实例都已经 <code>settled</code>，即状态变化过了，那么将返回一个新实例，该新实例的内部值是由所有实例的值和状态组合成的数组，数组的每项是由每个实例的状态和内部值组成的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.allSettled([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">9</span>)</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">6</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  init(),</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: undefined&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, reason: 6&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 3&#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>只要所有实例中包含一个 <code>pending</code> 状态的实例，那么 <code>Promise.allSettled()</code> 的结果为返回一个这样 <code>Promise &#123;&lt;pending&gt;&#125;</code> 的实例。</p><h3 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h3><p>在以前，从不同的 <code>JavaScript</code> 环境中获取全局对象需要不同的语句。在 <code>Web</code> 中，可以通过 <code>window</code>、<code>self</code> 或者 <code>frames</code> 取到全局对象，但是在 <code>Web Workers</code> 中，只有 <code>self</code> 可以。在 <code>Node.js</code> 中，它们都无法获取，必须使用 <code>global</code>。</p><p>而现在只需要使用 <code>globalThis</code> 即可获取到顶层对象，而不用担心环境问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line">globalThis === <span class="built_in">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="import-meta"><a href="#import-meta" class="headerlink" title="import.meta"></a>import.meta</h3><p><code>import.meta</code> 是一个给 <code>JavaScript</code> 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 <code>URL</code>，<code>import.meta</code> 必须在一个模块里使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有声明 type=&quot;module&quot;，就使用 import.meta 会报错</span></span><br><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在module.js里</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">import</span>.meta)</span><br><span class="line"><span class="comment">// &#123;url: &quot;http://localhost/3ag/js/module.js&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>如果需要在配置了 <code>Webpack</code> 的项目，比如 <code>Vue</code> 里使用 <code>import.meta</code> 需要加一个包且配置一下参数，否则项目编译阶段会报错。</p><p>包配置详情参考：<a href="https://www.npmjs.com/package/@open-wc/webpack-import-meta-loader">@open-wc/webpack-import-meta-loader</a></p><p>比如我用的是 <code>4.x</code> 版本的 <code>vue-cli</code>，那我需要在 <code>vue.config.js</code> 里配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">      .test(<span class="regexp">/\.js$/</span>)</span><br><span class="line">      .use(<span class="string">&#x27;@open-wc/webpack-import-meta-loader&#x27;</span>)</span><br><span class="line">      .loader(<span class="string">&#x27;@open-wc/webpack-import-meta-loader&#x27;</span>)</span><br><span class="line">      .end()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选链操作符（-）"><a href="#可选链操作符（-）" class="headerlink" title="可选链操作符（?.）"></a>可选链操作符（?.）</h3><p>通常我们获取一个深层对象的属性会需要写很多判断或者使用逻辑与 <code>&amp;&amp;</code> 操作符，因为对象的某个属性如果为 <code>null</code> 或者 <code>undefined</code> 就有可能报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  first: &#123;</span><br><span class="line">    second: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> name1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.first) &#123;</span><br><span class="line">    name1 = obj.first.second</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> name2 = obj &amp;&amp; obj.first &amp;&amp; obj.first.second</span><br></pre></td></tr></table></figure><p><code>?.</code> 操作符允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。如果某个属性为 <code>null</code> 或者 <code>undefined</code> 则结果直接为 <code>undefined</code>。有了可选链操作符就可以使得表达式更加简明了，对于上面例子用可选链操作符可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name3 = obj?.first?.second</span><br></pre></td></tr></table></figure><h3 id="空值合并操作符（-）"><a href="#空值合并操作符（-）" class="headerlink" title="空值合并操作符（??）"></a>空值合并操作符（??）</h3><p>对于逻辑或 <code>||</code> 运算符，当对运算符左侧的操作数进行装换为 <code>Boolean</code> 值的时候，如果为 <code>true</code>，则取左边的操作数为结果，否则取右边的操作数为结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// &#x27;布兰&#x27;</span></span><br></pre></td></tr></table></figure><p>我们都知道 <code>&#39;&#39;</code>、<code>0</code>、<code>null</code>、<code>undefined</code>、<code>false</code>、<code>NaN</code> 等转成 <code>Boolean</code> 值的时候都是 <code>false</code>，所以都会取右边的操作数。这个时候如果要给变量设置默认值，如果遇到本身值就可能是 <code>&#39;&#39;</code> 或 <code>0</code> 的情况那就会出错了，会被错误的设置为默认值了。</p><p>而 <code>??</code> 操作符就是为了解决这个问题而出现的，<code>x ?? y</code> 只有左侧的操作数为 <code>null</code> 或 <code>undefined</code> 的时候才取右侧操作数，否则取左侧操作数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span> ?? <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="ES2021"><a href="#ES2021" class="headerlink" title="ES2021"></a>ES2021</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2021.png"></p><p>如下这几个提案已经确定了会在 2021 年发布，所以把他们归到 <code>ES2021</code> 中。</p><h3 id="String-prototype-replaceAll"><a href="#String-prototype-replaceAll" class="headerlink" title="String.prototype.replaceAll"></a>String.prototype.replaceAll</h3><p>之前需要替换一个字符串里的全部匹配字符可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = <span class="string">&#x27;q=query+string+parameters&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">const</span> withSpaces1 = queryString.replace(<span class="regexp">/\+/g</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> withSpaces2 = queryString.split(<span class="string">&#x27;+&#x27;</span>).join(<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>而现在只需要这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withSpace3 = queryString.replaceAll(<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>replaceAll 的第一个参数可以是字符串也可以是正则表达式，当是正则表达式的时候，必须加上全局修饰符 /g，否则报错。</p></blockquote><p>参考：<a href="https://github.com/tc39/proposal-string-replaceall">string-replaceall</a></p><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h3><p><code>Promsie.any()</code> 和 <code>Promise.all()</code> 一样接受一个可迭代的对象，然后依据不同的入参会返回不同的新实例：</p><ul><li><p>传一个空的可迭代对象或者可迭代对象所有 <code>Promise</code> 都是 <code>rejected</code> 状态的，则会抛出一个 <code>AggregateError</code> 类型的错误，同时返回一个 <code>rejected</code> 状态的新实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.any([])</span><br><span class="line"><span class="keyword">let</span> p2.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;rejected&gt;: AggregateError: All promises were rejected&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>只要可迭代对象里包含任何一个 <code>fulfilled</code> 状态的 <code>Promise</code>，则会返回第一个 <code>fulfilled</code> 的实例，并且以它的值作为新实例的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.any([</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">2</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line">])</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>其他情况下，都会返回一个 <code>pending</code> 状态的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.any([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">2</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;),</span><br><span class="line">])</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;pending&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="WeakRef"><a href="#WeakRef" class="headerlink" title="WeakRef"></a>WeakRef</h3><p>我们知道一个普通的引用（默认是强引用）会将与之对应的对象保存在内存中。只有当该对象没有任何的强引用时，<code>JavaScript</code> 引擎 <code>GC</code> 才会销毁该对象并且回收该对象所占的内存空间。</p><p><code>WeakRef</code> 对象允许你保留对另一个对象的弱引用，而不会阻止被弱引用的对象被 <code>GC</code> 回收。<code>WeakRef</code> 的实例方法 <code>deref()</code> 可以返回当前实例的 <code>WeakRef</code> 对象所绑定的 <code>target</code> 对象，如果该 <code>target</code> 对象已被 <code>GC</code> 回收则返回 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> wr = <span class="keyword">new</span> WeakRef(person)</span><br><span class="line"><span class="built_in">console</span>.log(wr.deref())</span><br><span class="line"><span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>正确使用 WeakRef 对象需要仔细的考虑，最好尽量避免使用。这里面有诸多原因，比如：GC 在一个 JavaScript 引擎中的行为有可能在另一个 JavaScript 引擎中的行为大相径庭，或者甚至在同一类引擎，不同版本中 GC 的行为都有可能有较大的差距。GC 目前还是 JavaScript 引擎实现者不断改进和改进解决方案的一个难题。</p></blockquote><p>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef">WeakRef</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">内存管理</a></li></ul><h3 id="逻辑赋值符"><a href="#逻辑赋值符" class="headerlink" title="逻辑赋值符"></a>逻辑赋值符</h3><p>逻辑赋值符包含 3 个：</p><ul><li><code>x &amp;&amp;= y</code>：逻辑与赋值符，相当于 <code>x &amp;&amp; (x = y)</code></li><li><code>x ||= y</code>：逻辑或赋值符，相当于 <code>x || (x = y)</code></li><li><code>x ??= y</code>：逻辑空赋值符，相当于 <code>x ?? (x = y)</code></li></ul><p>看如下示例，加深理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line">x &amp;&amp;= <span class="number">1</span> <span class="comment">// x: 0</span></span><br><span class="line">x ||= <span class="number">1</span> <span class="comment">// x: 1</span></span><br><span class="line">x ??= <span class="number">2</span> <span class="comment">// x: 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">1</span></span><br><span class="line">y &amp;&amp;= <span class="number">0</span> <span class="comment">// y: 0</span></span><br><span class="line">y ||= <span class="literal">null</span> <span class="comment">// y: null</span></span><br><span class="line">y ??= <span class="number">2</span> <span class="comment">// y: 2</span></span><br></pre></td></tr></table></figure><h3 id="数值分隔符（-）"><a href="#数值分隔符（-）" class="headerlink" title="数值分隔符（_）"></a>数值分隔符（_）</h3><p>对于下面一串数字，你一眼看上去不确定它到底是多少吧？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1000000000</span></span><br></pre></td></tr></table></figure><p>那现在呢？是不是可以很清楚的看出来它是 10 亿：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1</span>_000_000_000</span><br></pre></td></tr></table></figure><p>数值分隔符（<code>_</code>）的作用就是为了让数值的可读性更强。除了能用于十进制，还可以用于二级制，十六进制甚至是 <code>BigInt</code> 类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> binarary = <span class="number">0b1010</span>_0001_1000_0101</span><br><span class="line"><span class="keyword">let</span> hex = <span class="number">0xa0</span>_b0_c0</span><br><span class="line"><span class="keyword">let</span> budget = <span class="number">1</span>_000_000_000_000n</span><br></pre></td></tr></table></figure><p>使用时必须注意 <code>_</code> 的两边必须要有类型的数值，否则会报错，以下这些都是无效的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>_</span><br><span class="line"><span class="keyword">let</span> binarary = <span class="number">0b1011</span>_</span><br><span class="line"><span class="keyword">let</span> hex = <span class="number">0</span>x_0A0B</span><br><span class="line"><span class="keyword">let</span> budget = <span class="number">1</span>_n</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://es6.ruanyifeng.com/">ECMAScript6 入门</a></li><li><a href="https://juejin.im/post/6844903959283367950">1.5 万字概括 ES6 全部特性(已更新 ES2020)</a></li><li><a href="https://juejin.im/post/6844903775329583112">近一万字的 ES6 语法知识点补充</a></li><li><a href="https://juejin.im/post/6886247841686093837#heading-9">深入理解 Promise</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for-await...of">for-await…of</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration_protocols</a></li><li><a href="https://github.com/tc39/proposal-object-from-entries">Object.fromEntries</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef">WeakRef</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">内存管理</a></li><li><a href="https://github.com/doodlewind/jshistory-cn">jshistory-cn</a></li><li><a href="https://tc39.es/ecma262/#sec-samevaluezero">sameValueZero</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写本篇文章目的是为了夯实基础，基于阮一峰老师的著作 &lt;a href=&quot;https://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6 入门&lt;/a&gt; 以及 &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;tc39-finished-proposals&lt;/a&gt; 这两个知识线路总结提炼出来的重点和要点，涉及到从 &lt;code&gt;ES2015&lt;/code&gt; 到 &lt;code&gt;ES2021&lt;/code&gt; 的几乎所有知识，基本上都是按照一个知识点配上一段代码的形式来展示，所以篇幅较长，也正是因为篇幅过长，所以就没把 &lt;code&gt;Stage 2&lt;/code&gt; 和 &lt;code&gt;Stage 3&lt;/code&gt; 阶段的提案写到这里，后续 &lt;code&gt;ES2021&lt;/code&gt; 更新了我再同步更新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有 5 个提案已经列入 Expected Publication Year in 2021 所以本篇中暂且把他们归为 ES2021。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es6.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Promise</title>
    <link href="https://bubuzou.com/2020/10/22/promise/"/>
    <id>https://bubuzou.com/2020/10/22/promise/</id>
    <published>2020-10-22T02:11:30.000Z</published>
    <updated>2020-10-22T02:16:34.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从异步编程说起"><a href="#从异步编程说起" class="headerlink" title="从异步编程说起"></a>从异步编程说起</h2><p>我们都知道 <code>JavaScript</code> 的代码执行的时候是跑在单线程上的，可以理解为只能按照代码的出现顺序，从上到下一行一行的执行，但是遇到了异步的行为，比如定时器（一定时间之后才去执行），那就需要等同步代码执行完成后的一段时间里再去执行异步代码。</p><p>对于同步行为，如下面的代码，我们能够很清楚的知道每一行会发生什么，这是因为后面的指令总是等到前面的指令执行完成后才去执行，所以这里的第二行里的变量 <code>x</code> 在内存里已经是定义过的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y = x + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>但是对于异步代码，我们就不好推断到底什么时候会执行完成了。比如举一个实际的例子，我们去动态加载某个脚本，会这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = src</span><br><span class="line">    <span class="built_in">document</span>.head.append(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个脚本加载完成的时候会去执行定义在脚本里的一些函数，比如初始化函数 <code>init</code>，那么我们可以会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = src</span><br><span class="line">    <span class="built_in">document</span>.head.append(script)</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">&#x27;./js/script.js&#x27;</span>)</span><br><span class="line">init()  <span class="comment">// 定义在 ./js/script.js 里的函数</span></span><br></pre></td></tr></table></figure><p>但是实际执行后却发现，这样根本不行，因为加载脚本是需要花时间的，是一个异步的行为，浏览器执行 <code>JavaScript</code> 的时候并不会等到脚本加载完成的时候再去调用 <code>init</code> 函数。</p><p>以往，对于这种异步编程的做法通常就是通过给函数传递一个回调函数来处理，上面那个例子可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, success, fail</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = src</span><br><span class="line">    script.onload = success</span><br><span class="line">    script.onerror = fail</span><br><span class="line">    <span class="built_in">document</span>.head.append(script)</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">&#x27;./js/script.js&#x27;</span>, success, fail)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    init()  <span class="comment">// 定义在 ./js/script.js 中的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这样做能够保证在脚本加载完成的时候，再去执行脚本里的函数。但是多考虑一个问题，如果 <code>success</code> 里又需要加载别的 <code>js</code> 文件呢，那岂不是需要多层嵌套了。是的，这样的多层嵌套会使得代码层次变得更加深入，难以阅读以及后期维护成本非常高，尤其是当里面加上了很多的判断逻辑的时候情况会更加糟糕，这就是所谓的 “回调地狱”，且又因为它的代码形状很像躺着的金字塔，所以有的人也喜欢叫它 “噩运金字塔”。</p><p>而为了避免这类 “回调地狱” 问题，目前最好的做法之一就是使用 <code>Promise</code>。</p><h2 id="Promise正篇"><a href="#Promise正篇" class="headerlink" title="Promise正篇"></a>Promise正篇</h2><p>使用 <code>Promise</code> 可以很好的解决上面提到的 “回调地狱” 问题，直接来看结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.src = src;</span><br><span class="line">        script.onload = <span class="function">() =&gt;</span> resolve(script);</span><br><span class="line">        script.onerror = <span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error for <span class="subst">$&#123;src&#125;</span>`</span>));</span><br><span class="line">        <span class="built_in">document</span>.head.append(script);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">&#x27;./scripts.js&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>, res);</span><br><span class="line">    init()</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里通过使用 <code>Promise</code> 实例的 <code>then</code> 和 <code>catch</code> 函数将多层嵌套的代码改成了同步处理流程，看起来效果还是不错的，那什么是 <code>Promise</code> 呢？</p><p><code>Promise</code> 首先是一个对象，它通常用于描述现在开始执行，一段时间后才能获得结果的行为（异步行为），内部保存了该异步行为的结果。然后，它还是一个有状态的对象：</p><ul><li><code>pending</code>：待定</li><li><code>fulfilled</code>：兑现，有时候也叫解决（<code>resolved</code>）</li><li><code>rejected</code>：拒绝</li></ul><p>一个 <code>Promise</code> 只有这 3 种状态，且状态的转换过程有且仅有 2 种：</p><ul><li><code>pending</code> 到 <code>fulfilled</code></li><li><code>pending</code> 到 <code>rejected</code></li></ul><p>可以通过如下的 <code>Promise</code> 对象构造器来创建一个 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>传递给 <code>new Promise</code> 的是 <code>executor</code> 执行器。当 <code>Promise</code> 被创建的时候，<code>executor</code> 会立即同步执行。<code>executor</code> 函数里通常做了 2 件事情：初始化一个异步行为和控制状态的最终转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上代码所示，<code>setTimeout</code> 函数用来描述一个异步行为，而 <code>resolve</code> 用来改变状态。<br><code>executor</code> 函数包含 2 个参数，他们都是回调函数，用于控制 <code>Promise</code> 的状态转换：</p><ul><li><code>resolve</code>：用来将状态 <code>pending</code> 转换成 <code>fulfilled</code></li><li><code>reject</code>：用来将状态 <code>pending</code> 转换成 <code>rejected</code></li></ul><p>一个 <code>Promise</code> 的状态一旦被转换过，则无法再变更：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;第一次 resolve&#x27;</span>)</span><br><span class="line">        resolve(<span class="string">&#x27;第二次 resolve&#x27;</span>)  <span class="comment">// 将被忽略</span></span><br><span class="line">        reject(<span class="string">&#x27;第一次 reject&#x27;</span>)  <span class="comment">// 将被忽略</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">1000</span>, p)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: &quot;第一次 resolve&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到执行了 2 次 <code>resolve</code> 函数和 1 次 <code>reject</code> 函数，但是 <code>promise</code> 的最终结果是取的第一次 <code>resolve</code> 的结果，印证了上面的结论。</p><p>由 <code>new Promise</code> 构造器返回的 <code>Promise</code> 对象具有如下内部属性：</p><ul><li><code>PromiseState</code>：最初是 <code>pending</code>，<code>resolve</code> 被调用的时候变为 <code>fulfilled</code>，或者 <code>reject</code> 被调用时会变为 <code>rejected</code>；</li><li><code>PromiseResult</code>：最初是 <code>undefined</code>，<code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li></ul><p>比如上面例子中打印出来的 <code>Promise</code> 对象结果中，<code>fulfilled</code> 是其内部的 <code>PromiseState</code>，而 “第一次 resolve” 是其 <code>PromiseResult</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: &quot;第一次 resolve&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Promise实例方法"><a href="#Promise实例方法" class="headerlink" title="Promise实例方法"></a>Promise实例方法</h2><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p><code>Promise.prototype.then()</code> 将用于为 <code>Promise</code> 实例添加处理程序的函数。它接受 2 个可选的参数：</p><ul><li><code>onResolved</code>：状态由 <code>pending</code> 转换成 <code>fulfilled</code> 时执行；</li><li><code>onRejected</code>：状态由 <code>pending</code> 转换成 <code>rejected</code> 时执行。</li></ul><p>它可以写成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span> + res)  <span class="comment">// resolved3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span> + err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;).then(onResolved, onRejected)</span><br></pre></td></tr></table></figure><p>或者写成更简单的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span> + res)  <span class="comment">// resolved3</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span> + err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为状态的变化只有 2 种，所以 <code>onResolved</code> 和 <code>onRejected</code> 在执行的时候必定是互斥。</p><p>上面介绍到了 <code>then()</code> 的参数是可选的，当只有 <code>onResolved</code> 的时候可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>当参数只有 <code>onRejected</code> 的时候，需要把第一个参数设置为 <code>null</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).then(<span class="literal">null</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>如果给 <code>then()</code> 函数传递来了非函数参数，则会默认忽略。</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><code>Promise.prototype.catch()</code> 用于给 <code>Promise</code> 对象添加拒绝处理程序。只接受一个参数：<code>onRejected</code> 函数。实际上，下面这两种写法是等效的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).catch(onRejected)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).then(<span class="literal">null</span>, onRejected)</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>Promise.prototype.finally()</code> 用于给 <code>Promise</code> 对象添加 <code>onFinally</code> 函数，这个函数主要是做一些清理的工作，只有状态变化的时候才会执行该 <code>onFinally</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">888</span>)  <span class="comment">// 并不会执行  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;).finally(onFinally)</span><br></pre></td></tr></table></figure><p>因为 <code>onFinally</code> 函数是没有任何参数的，所以在其内部其实并不知道该 <code>Promise</code> 的状态是怎么样的。</p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>链式调用里涉及到的知识点很多，我们不妨先看看下面这道题，你能正确输出其打印顺序嘛？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我不给出答案，希望你能动手敲一敲代码，然后思考下为什么？容我讲完这部分知识，相信你能自己理解其中缘由。</p><p>从上面这串代码里，我们看到 <code>new Promise</code> 后面接了很多的 <code>.then()</code> 处理程序，这个其实就是 <code>Promise</code> 的链式调用，那它为什么能链式调用呢？</p><h3 id="基于onResolved生成一个新的Promise"><a href="#基于onResolved生成一个新的Promise" class="headerlink" title="基于onResolved生成一个新的Promise"></a>基于onResolved生成一个新的Promise</h3><p>因为 <code>Promise.prototype.then()</code> 会返回一个新的 <code>Promise</code>，来看下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function">() =&gt;</span> <span class="number">6</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 6&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>p1</code> 和 <code>p2</code> 的内部 <code>PromiseResult</code> 是不一样的，说明 <code>p2</code> 是一个新的 <code>Promise</code> 实例。 </p><p>新产生的 <code>Promise</code> 会基于 <code>onResolved</code> 的返回值进行构建，构建的时候其实是把返回值传递给 <code>Promise.resolve()</code> 生成的新实例，比如上面那串代码里 <code>p1.then(() =&gt; 6)</code> 这里的 <code>onResolved</code> 函数返回了一个 6 ，所以新的 <code>Promise</code> 的内部值会是 6。</p><p>如果 <code>.then()</code> 没有提供 <code>onResolved</code> 这个处理程序，则 <code>Promise.resolve()</code> 会基于上一个实例 <code>resolve</code> 后的值来初始化一个新的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>如果 <code>onResolved</code> 处理程序没有返回值，那么返回的新实例的内部值会是 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure><p>如果在 <code>onResolved</code> 处理程序里抛出异常，则会返回一个新的 <code>rejected</code> 状态的 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;rejected&gt;: 这是一个错误&#125;</span></span><br></pre></td></tr></table></figure><h3 id="基于onRejected生成一个新的Promise"><a href="#基于onRejected生成一个新的Promise" class="headerlink" title="基于onRejected生成一个新的Promise"></a>基于onRejected生成一个新的Promise</h3><p>基于 <code>onRejected</code> 的返回值也会返回一个新的 <code>Promise</code>，而且处理逻辑也是一样的，也是通过把返回值传递给 <code>Promise.resolve()</code> 产生一个新的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 `onRejected` 处理程序时，会原样向后传，不过是新实例</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function">() =&gt;</span> &#123;&#125;)  s</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;rejected&gt;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为undefined时</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;&#125;) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值有实际值的时候</span></span><br><span class="line"><span class="keyword">let</span> p4 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="number">6</span>) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当返回值是Promise时，会保留当前Promise</span></span><br><span class="line"><span class="keyword">let</span> p5 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject()) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p5)  <span class="comment">// Promise &#123;&lt;rejected&gt;: undefined&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当遇到一个错误的时候</span></span><br><span class="line"><span class="keyword">let</span> p6 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p6)  <span class="comment">// Promise &#123;&lt;rejected&gt;: error&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当返回值是一个错误时</span></span><br><span class="line"><span class="keyword">let</span> p7 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p7)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Error: error&#125; </span></span><br></pre></td></tr></table></figure><p>这里你会不会有个疑惑？实例 <code>resolve()</code> 的时候，状态由 <code>pending</code> 变成 <code>rejected</code>，从而调用 <code>onRejected</code> 进行处理，但是为什么有时候会返回一个 <code>fulfilled</code> 的新实例呢？试着想一下，如果 <code>onRejected</code> 返回了一个 <code>pending</code> 的或者 <code>rejected</code> 状态的新实例，那后续的链式调用就进行不下去了，看下面例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果 A 处理函数这里返回了一个 <code>pending</code> 状态的新实例，那么后续所有的链式操作都无法执行；或者返回的是一个 <code>rejected</code> 状态的新实例，那么后续的 B 和 C 也就无法执行了，那居然都不能执行 B 和 C 所在处理程序，那定义来干嘛呢？链式操作就毫无链式可言。又，<code>onRejected</code> 的存在的根本意义无非就是用于捕获 <code>Promise</code> 产生的错误，从而不影响程序的正常执行，所以默认情况下理应返回一个 <code>fulfilled</code> 的新实例。</p><p><code>Promise.prototype.catch()</code> 也会生成一个新的 <code>Promise</code>，其生成规则和 <code>onRejected</code> 是一样的。</p><h3 id="finally生成一个新的Promise"><a href="#finally生成一个新的Promise" class="headerlink" title="finally生成一个新的Promise"></a>finally生成一个新的Promise</h3><p>没想到吧，<code>Promise.prototype.finally()</code> 也能生成一个 <code>Promise</code>。<code>finally</code> 里的操作是和状态无关的，一般用来做后续代码的处理工作，所以 <code>finally</code> 一般会原样后传父 <code>Promise</code>，无论父级实例是什么状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = p3.finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>上面说的是一般，但是也有特殊情况，比如 <code>finally</code> 里返回了一个非 <code>fulfilled</code> 的 <code>Promise</code> 或者抛出了异常的时候，则会返回对应状态的新实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)  <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3)  <span class="comment">// Promise &#123;&lt;rejected&gt;: 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = p1.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4)  <span class="comment">// Promise &#123;&lt;rejected&gt;: Error: error&#125;</span></span><br></pre></td></tr></table></figure><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>先来看一段简单的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"><span class="comment">// 打印结果：A B D C</span></span><br></pre></td></tr></table></figure><p>上面这串代码的输出顺序是：A B D C。从上面章节介绍的知识点我们知道，<code>executor</code> 执行器会在 <code>new Promise</code> 调用的时候立即同步执行的，所以先后打印 A B 是没问题的。当执行 <code>resolve()/reject()</code> 的时候，会将 <code>Promise</code> 对应的处理程序推入微任务队列，稍等这里提到的对应的处理程序具体是指什么？</p><ul><li><code>resolve()</code> 对应 <code>.then()</code> 里的第一个入参，即 <code>onResolved</code> 函数；</li><li><code>reject()</code> 对应 <code>.then()</code> 里的第二个入参，即 <code>onRejected</code> 函数；或者 <code>Promise.prototype.catch()</code> 里的回调函数；</li></ul><p>所以当执行 <code>resolve(3)</code> 的时候（此时下面定义的这个箭头函数其实就是 <code>onResolved</code> 函数），<code>onResolved</code> 函数将被推入微任务队列，然后打印 D，此时所有同步任务执行完成，浏览器会去检查微任务队列，发现存在一个，所以最后会去调用 <code>onResolved</code> 函数，打印出 C。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onResolved = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实除了 <code>onResolved</code>、<code>onRejected</code> 以及 <code>Promise.prototype.catch()</code> 里的处理程序外，<code>Promise.prototype.finally()</code> 的处理程序 <code>onFinally</code> 也是异步执行的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment">// 打印结果：A C B</span></span><br></pre></td></tr></table></figure><p><code>Promise</code> 链式调用的基础就是因为 <code>onResolved</code>、<code>onRejected</code>、<code>catch()</code> 的处理程序以及 <code>onFinally</code> 会产生一个新的 <code>Promise</code> 实例，且又因为他们都是异步执行的，所以在链式调用的时候，对于它们执行顺序会稀里糊涂琢磨不透就是这个原因。</p><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p>那下面我们就来看点复杂的例子，先来分析下这章开篇提到的题目：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印结果：A </span></span><br></pre></td></tr></table></figure><p>为了方便分析，我们把上面的这串代码写得好看一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(executor).then(onResolvedA).then(onResolvedD)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(executor).then(onResolvedB).then(onResolvedC)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedD</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><ul><li>执行 <code>new Promise()</code>，立即同步执行 <code>executor</code> 函数，调用 <code>resolve()</code>，此时会将 <code>onResolvedA</code> 推入微任务队列 1，截止目前所有同步代码执行完成；</li><li>检查微任务队列，执行 <code>onResolvedA</code> 函数，打印 A，执行 <code>new Promise(executor)</code>，调用 <code>resolve()</code> 函数，此时将 <code>onResolvedB</code> 推入微任务队列 2；</li><li>截止目前微任务队列 1 的代码全部执行完成，即 <code>onResolvedA</code> 函数执行完成。我们知道 <code>onResolved</code> 函数会基于返回值生成一个新的 <code>Promise</code>，而 <code>onResolvedA</code> 函数没有显示的返回值，所以其返回值为 <code>undefined</code>，那么经过 <code>Promise.resolve(undefined)</code> 初始化后会生成一个这样的新实例：<code>Promise &#123;&lt;fulfilled&gt;: undefined&#125;</code>；由于这个新的实例状态已经变成 <code>fulfilled</code>，所以会立即将其处理函数 <code>onResolvedD</code> 推入微任务队列 3；</li><li>开始执行微任务队列 2 里的内容，打印 B，同上一条原理，由于 <code>onResolvedB</code> 函数的返回值为 <code>undefined</code>，所以生成了一个 <code>resolved</code> 的新实例，则会立即将 <code>onResolvedC</code> 推入微任务队列 4；</li><li>执行微任务队列 3，打印 D；</li><li>执行微任务队列 4，打印 C；</li><li>至此全部代码执行完成，最终的打印结果为：A B D C。</li></ul><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印结果：A C B D</span></span><br></pre></td></tr></table></figure><p>应该很多人会和我当初一样好奇：为什么打印结果不是 A B C D 呢？<br>这里涉及到一个知识点：如果给 <code>Promise</code> 实例添加了多个处理函数，当实例状态变化的时候，那么执行的过程就是按照添加时的顺序而执行的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(onResolvedA).finally(onFinally)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果： A B</span></span><br></pre></td></tr></table></figure><p>对于上面这串代码，其实 <code>finally()</code> 处理程序执行的时候已经不是通过 <code>new Promise()</code> 初始化的实例，而是执行完 <code>onResolvedA</code> 函数的时候生成的新实例，不信我们将上面代码中的函数 <code>onResolvedA</code> 稍微改动下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(onResolvedA).finally(onFinally)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolvedA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果： A</span></span><br></pre></td></tr></table></figure><p>由于 <code>onResolvedA</code> 返回了一个这样的 <code>Promise &#123;&lt;pending&gt;&#125;</code> 新实例，这个新实例的状态没有发生变化，所以不会执行 <code>finally</code> 处理程序 <code>onFinally</code>，所以不会打印 B。这个就说明了，链式调用的时候处理程序的执行是一步一步来的，只要前面的执行完了，生成了新的实例，然后根据新实例的状态变化，才去执行后续的处理程序。</p><p>所以拿最开始那道题来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印结果：A C B D</span></span><br></pre></td></tr></table></figure><p>他的执行过程应该是这样的：</p><ul><li>执行 <code>resolve(1)</code>，将处理程序 A 推入微任务队列 1；</li><li>执行 <code>resolve(2)</code>，将处理程序 C 推入微任务队列 2；</li><li>同步任务执行完成，执行微任务队列 1 里的内容，打印 A，A 所在函数执行完成后生成了一个 <code>fulfilled</code> 的新实例，由于新实例状态变化，所以会立即执行 <code>finally()</code> 处理程序 B 推入微任务队列 3；</li><li>执行微任务队列 2 的内容，打印 C，C 所在函数执行完成后，同上条原理会将处理程序 D 推入微任务队列 4；</li><li>执行微任务队列 3 的内容，打印 B；</li><li>执行微任务队列 4 的内容，打印 D；</li><li>代码全部执行完成，最终打印：A C B D。</li></ul><p>题目就先做到这里，相信你和我一样，对 <code>Promise</code> 的执行过程应该有更深入的理解了。接下来我们将继续学习 <code>Promise</code> 的相关 <code>API</code>。</p><h2 id="Promise与错误处理"><a href="#Promise与错误处理" class="headerlink" title="Promise与错误处理"></a>Promise与错误处理</h2><p>平时我们写代码遇到错误，都习惯用 <code>try/catch</code> 块来处理，但是对于 <code>Promise</code> 产生的错误，用这个是处理不了的，看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    &#125;)  </span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// C </span></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error</span></span><br></pre></td></tr></table></figure><p>从执行结果我们可以看到，报错的信息出现在打印 C 之后，说明抛出错误这个动作是在异步任务中做的，所以 <code>catch</code> 捕获不到该错误就在情理之中了，否则就不会打印 C 了。可见，传统的 <code>try/catch</code> 语句并不能捕获 <code>Promise</code> 产生的错误，而需要使用 <code>onRejected</code> 处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;) </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2)</span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// Error: error</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure><p><code>onRejected</code> 捕获了上面抛出的错误后，使得程序正常执行，最后还生成了一个 <code>fulfilled</code> 的新实例。</p><p>除了以上这种直接在 <code>executor</code> 里通过 <code>throw</code> 主动抛出一个错误外，还可以通过以下方式产出需要 <code>onRejected</code> 处理的错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    init() <span class="comment">// 被动出错，调用了不存在的函数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject())</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意，如果只是产生了一个错误，却没有抛出来是不会报错的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Error</span>())</span><br></pre></td></tr></table></figure><p><code>Promise</code> 出现了错误就需要使用 <code>onRejected</code> 处理程序处理，否则程序就会报错，执行不下去了。</p><h2 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h2><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>并非所有的 <code>Promise</code> 的初始状态都是 <code>pending</code>，可以通过 <code>Promise.resolve(value)</code> 来初始化一个状态为 <code>fulfilled</code>，值为 <code>value</code> 的 <code>Promise</code> 实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>这个操作和下面这种创建一个 <code>fulfilled</code> 的 <code>Promise</code> 在效果上是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>使用这个静态方法，理论上可以把任何一个值转换成 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve())  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>))  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125; 多余的参数将被忽略</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)))  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Error: error&#125;</span></span><br></pre></td></tr></table></figure><p>这个被转换的值甚至可以是一个 <code>Promise</code> 对象，如果是这样，<code>Promise.resolve</code> 会将其原样输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.resolve(p))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>和 <code>Promise.resolve()</code> 类似，<code>Promise.reject()</code> 会实例化一个 <code>rejected</code> 状态的 <code>Promise</code>，且会抛出一个错误，该错误只能通过拒绝处理程序捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span></span><br><span class="line">    .reject(<span class="number">3</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)  <span class="comment">// 3</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>对于初始化一个 <code>rejected</code> 状态的实例，以下两种写法都可以达到这个目的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject()</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject())</span><br></pre></td></tr></table></figure><p>与 <code>Promise.resolve()</code> 不同的是，如果给 <code>Promise.reject()</code> 传递一个 <code>Promise</code> 对象，则这个对象会成为新 <code>Promise</code> 的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.reject(p))  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><code>Promise.all(iterable)</code> 用来将多个 <code>Promise</code> 实例合成一个新实例。参数必须是一个可迭代对象，通常是数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">6</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>可迭代对象里的所有元素都会通过 <code>Promise.resolve()</code> 转成 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>所有 <code>Promise</code> 都 <code>resolve</code> 后，<code>Promise.all()</code> 才会生成一个 <code>fulfilled</code> 的新实例。且新实例的内部值是由所有 <code>Promise</code> 解决后的值组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;3&#x27;</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// [&quot;3&quot;, undefined, 6]</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: Array(3)&#125;</span></span><br></pre></td></tr></table></figure><p>所有 <code>Promise</code> 中，只要出现一个 <code>pending</code> 状态的实例，那么合成的新实例也是 <code>pending</code> 状态的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">])</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>所有 <code>Promise</code> 中，只要出现一个 <code>rejected</code> 状态的实例，那么合成的新实例也是 <code>rejected</code> 状态的，且新实例的内部值是第一个拒绝 <code>Promise</code> 的内部值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="number">9</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;rejected&gt;: 6&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><code>Promise.race(iterable)</code> 会返回一个由所有可迭代实例中第一个 <code>fulfilled</code> 或 <code>rejected</code> 的实例包装后的新实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">9</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>来将上面这串代码变动下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">9</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="number">6</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    init(),</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;rejected&gt;: 6&#125;</span></span><br></pre></td></tr></table></figure><p>想要知道 <code>Promise.race()</code> 的结果，无非是要知道到底谁才是第一个状态变化的实例，让我们来具体分析下代码执行过程：</p><ul><li>迭代第一个元素，执行同步代码 <code>resolve(9)</code>，由 <code>new Promise</code> 初始化的实例的状态已经变为了 <code>fulfilled</code>，所以第一个状态变化的实例已经出现了吗？其实并没有，因为迭代第一个元素的代码还没执行完成呢，然后会将 <code>return &#39;A&#39;</code> 所在函数的这段处理程序推入微任务队列 1；</li><li>迭代第二个元素，执行 <code>reject(6)</code>，所以由 <code>new Promise</code> 初始化的实例的状态已经变为 <code>rejected</code>，由于该实例没有处理函数，所以迭代第二个元素的代码已经全部执行完成，此时，第一个状态变化的实例已经产生；</li><li>迭代第三个元素，是一个函数，执行同步代码打印出 3，然后用 <code>Promise.resolve</code> 将函数返回值 3 转成一个 <code>Promise &#123;&lt;fulfilled&gt;: 3&#125;</code> 的新实例，这是第二个状态发生变化的实例；</li><li>此时所有迭代对象遍历完成，即同步代码执行完成，开始执行微任务队列 1 的内容，打印 <code>res</code>，其值是 9，然后处理程序返回了 ‘A’，此时根据之前提到的知识点，这里会新生成一个 <code>Promise &#123;&lt;fulfilled&gt;: &#39;A&#39;&#125;</code> 的实例，这是第三个状态发生变化的实例。此时，第一个迭代元素的代码已经全部执行完成，所以第一个迭代元素最终生成的实例是第三次状态发生变化的这个；</li><li>此时 <code>p1</code> 已经产生，它是 <code>Promise &#123;&lt;rejected&gt;: 6&#125;</code>，所以会将它的处理程序 <code>console.log(err)</code> 所在函数推入微任务队列 2；</li><li>执行微任务队列 2 的内容，打印 <code>err</code>，其值是 6；</li><li>所有微任务执行完成，开始执行 <code>setTimeout</code> 里的宏任务，打印 <code>p1</code>，至此全部代码执行完成。</li></ul><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h3><p><code>Promise.allSettled(iterable)</code> 当所有的实例都已经 <code>settled</code>，即状态变化过了，那么将返回一个新实例，该新实例的内部值是由所有实例的值和状态组合成的数组，数组的每项是由每个实例的状态和内部值组成的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.allSettled([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">9</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="number">6</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    init()</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: undefined&#125;, </span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, reason: 6&#125;, </span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 3&#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>只要所有实例中包含一个 <code>pending</code> 状态的实例，那么 <code>Promise.allSettled()</code> 的结果为返回一个这样 <code>Promise &#123;&lt;pending&gt;&#125;</code> 的实例。</p><blockquote><p>Promise.allSettled() 是 ES2020 中新增的方法，所以有一些浏览器可能还暂时不支持。</p></blockquote><p>对于不支持的浏览器，可以写 <code>polyfill</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Promise</span>.allSettled) &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises.map(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(p)</span><br><span class="line">            .then(<span class="function"><span class="params">value</span> =&gt;</span> (&#123;</span><br><span class="line">                status: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                value</span><br><span class="line">            &#125;), <span class="function"><span class="params">reason</span> =&gt;</span> (&#123;</span><br><span class="line">                status: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                reason</span><br><span class="line">            &#125;))</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从异步编程说起&quot;&gt;&lt;a href=&quot;#从异步编程说起&quot; class=&quot;headerlink&quot; title=&quot;从异步编程说起&quot;&gt;&lt;/a&gt;从异步编程说起&lt;/h2&gt;&lt;p&gt;我们都知道 &lt;code&gt;JavaScript&lt;/code&gt; 的代码执行的时候是跑在单线程上的，可以理解为只能按照代码的出现顺序，从上到下一行一行的执行，但是遇到了异步的行为，比如定时器（一定时间之后才去执行），那就需要等同步代码执行完成后的一段时间里再去执行异步代码。&lt;/p&gt;
&lt;p&gt;对于同步行为，如下面的代码，我们能够很清楚的知道每一行会发生什么，这是因为后面的指令总是等到前面的指令执行完成后才去执行，所以这里的第二行里的变量 &lt;code&gt;x&lt;/code&gt; 在内存里已经是定义过的。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; y = x + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>详细设计一个文章页目录插件</title>
    <link href="https://bubuzou.com/2020/10/14/article-catalog/"/>
    <id>https://bubuzou.com/2020/10/14/article-catalog/</id>
    <published>2020-10-14T02:19:26.000Z</published>
    <updated>2020-10-14T03:16:39.189Z</updated>
    
    <content type="html"><![CDATA[<p>在说这个插件之前，可以先去 <a href="https://bubuzou.com/2020/09/21/vue-operate/">https://bubuzou.com/</a> 这个网站体验下这个插件的效果，好有个大概的印象。</p><p>通过阅读这篇文章，你可以收获什么？</p><ol><li>用 <code>JS</code> 直接操作 <code>DOM</code></li><li>浏览器 <code>BOM</code> 相关知识</li><li>性能优化思考</li><li>插件设计思考</li></ol><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>平时我们在用 <code>Markdown</code> 写的文章，如果放到自己的博客或者投稿到掘金等平台，其内容会被浏览器解析成 <code>HTML</code>。而 <code>Markdown</code> 里面的一级（#）、二级（##）、三级标题（###）分别对应于页面的文章标题、一级目录、二级目录。基于此，就可以很好的利用该生成的页面实现一个目录，便于更直观方便的的浏览文章内容，而这就是最初我想为博客里的文章页实现一个目录功能的理由。</p><blockquote><p>这个插件是基于 <code>Hexo</code> 生成的网页来实现的，且目前只支持一级和二级目录，因为作为一篇文章来说有两个层级已经可以很好的将一块内容划分细说得很清楚了。</p></blockquote><a id="more"></a><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/catalog.png"></p><p>首先我打算将文章的目录放置在文章内容的右侧，且是悬浮固定在那里不随浏览器的滚动而滚动。因为我们都习惯从上到下从左到右的去浏览文章，所以我希望首先映入眼帘的是文章内容而不是文章目录；另外因为我的博客的首页和文章列表页都是左侧是浏览区域而右侧是操作区域，所以把目录放到右侧能保持整站的布局统一以及操作的便利性。</p><h3 id="需要做什么"><a href="#需要做什么" class="headerlink" title="需要做什么"></a>需要做什么</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/highlight.png"></p><ol><li>首先需要根据文章内容的二级和三级标题生成目录；</li><li>然后，页面从上到下滚动过程中，需要在右侧目录里高亮当前的标题，而高亮的原则是当前标题所在的位置到浏览器可视区域顶部的距离需要小于或等于一个固定值，如上图所示；</li><li>在合适的时候滚动目录列表，使得当前高亮的子目录会出现在滚动区域内部，且尽量处于滚动区域的中间区域；</li><li>当点击某个子目录的时候需要高亮当前点击的目录，且文章内容滚动到对应目录的位置，使得点击目录对应的文章标题所在的位置距离可视区域顶部的距离刚好等于一个固定值。</li></ol><h3 id="滚动目录的机制是怎样的"><a href="#滚动目录的机制是怎样的" class="headerlink" title="滚动目录的机制是怎样的"></a>滚动目录的机制是怎样的</h3><p>对于的第三点提到在合适的时候滚动目录，那什么时候才算合适呢？目录能不能滚动，以及怎么滚动总共分为以下 5 种情况：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_top.png"></p><ol><li>当目录能在滚动区域完全显示的时候，即滚动区域高度大于所有目录子项高度总和的时候，不进行目录滚动，如上面的图 ① ；</li><li>当目录不能在滚动区域完全显示的时候，目录需要滚动。所以需要做的就是在一个划定的区域内滚动目录，超出该区域的目录子项将会自动隐藏。通过滚动目录，我们可以实现目录列表的头尾两个目录子项都能很好的在划定区域里显示出来。随着页面的滚动，目录将从头滚到尾，那么滚动的范围是从第一个子目录贴着滚动区域的顶部到最后一个子目录贴着滚动区域的底部为止；</li><li>当页面在最顶部的时候，当前高亮的子目录肯定是第一个，随着页面的向下滚动，高亮的位置也在不断下移，当高亮位置移动到在目录滚动区域的上半部分之前，这段不进行目录滚动，如上面的图 ② 到 图 ③ 的变化过程；</li><li>当第一个子目录贴着滚动区域的顶部，且高亮位置在中位往下继续滚动的时候，需要进行目录滚动，滚动的距离是当前高亮目录所在位置距离滚动区域中间位置的高度差，如上面的图 ③ 到图 ④ 的变化过程；</li><li>如果这个高度差过于大，使得滚动后最后一个子元素不能贴着滚动区域底部的时候，则不按照这个高度差进行滚动，而真实需要滚动的距离是最后一个子目录到滚动区域底部的距离，如上面的图 ④ 到图 ⑤ 的变化过程。</li></ol><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>由于文章页是由 <code>Hexo</code> 基于 <code>Markdown</code> 生成而来的，所以它有自己特定的 <code>HTML</code> 格式，它的格式大概是如下这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;7种组件通信方式随你选&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;headerlink&quot;</span> <span class="attr">title</span>=<span class="string">&quot;7种组件通信方式随你选&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    7种组件通信方式随你选</span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是部分文章内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;props-on-emit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;headerlink&quot;</span> <span class="attr">title</span>=<span class="string">&quot;props/@on+$emit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    props/@on+$emit</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是部分文章内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;$attrs和$listeners&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;headerlink&quot;</span> <span class="attr">title</span>=<span class="string">&quot;$attrs和$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    $attrs和$listeners</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是部分文章内容 --&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到所有的二级标题（H2）和三级标题（H3）都是在同一个父元素下面，且每个标题下面都包含了一个带有 <code>headerlink</code> 类名的链接，另外还有标题属性。</p><p>这个时候我们就能很容易的获取到所有的标题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arContentAnchor = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.headerlink&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面这串代码的结果会返回一个 <code>NodeList</code>，有了它我们就可以去生成目录了。</p><h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/catalog_show.png"></p><p>生成目录无非就是产生一串 <code>HTML</code>，除此之外还有哪些要做的呢？<br>首先要确定下，目录都包含了哪些部分，如上图所示这里大概是包含了 3 部分：目录条、序号和标题。那么就可以先确定好 <code>HTML</code> 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-body&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-tack1 on&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-index&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>7种组件通信方式随你选<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;arCatalog-dot&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>arCatalog-line</code> 表示目录条，<code>arCatalog-body</code> 是滚动区域，<code>dl</code> 是滚动列表，<code>dd</code> 是目录子项，<code>arCatalog-index</code> 是目录序号，链接里放的是子目录标题。有了 <code>HTML</code> ，接下来要做的就是把目录的样式写好，写完后样式比较多，所以就不在这里贴出来了。</p><p>生成目录到这里就完事了吗？并没有，由于浏览器可视区域是不固定的，所以我们需要计算出目录所在滚动区域的高度。</p><p>滚动高度 = n个目录子项 * 子项的实际高度</p><p>先说子项的实际高度，对于目录子项的样式上，我这里没有用内间距和外边距，而是通过 <code>line-height</code> 来控制他们之间的间隙，那么：</p><p>子项的实际高度 = 子项的行高</p><p>再说 <code>n</code> 个目录子项，那到底 <code>n</code> 是多少呢？在目录的 <code>Y</code> 轴方向上，除了有目录，还有顶部的菜单，以及为了美观还需要适当的留白，所以：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_height.png"></p><p>n = (视口高度 - （顶部菜单高度 + 留白高度））/ 子项行高</p><p>所以，最终我们可以计算出滚动高度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> DEFAULT = &#123;</span><br><span class="line">    lineHeight: <span class="number">28</span>,           <span class="comment">// 每个菜单的行高是 28</span></span><br><span class="line">    moreHeight: <span class="number">10</span>,           <span class="comment">// 菜单左侧的线比菜单多出的高度</span></span><br><span class="line">    surplusHeight: <span class="number">180</span>,       <span class="comment">// 除了菜单高度+留白高度</span></span><br><span class="line">    delay: <span class="number">200</span>,               <span class="comment">// 防抖的延迟时间</span></span><br><span class="line">    duration: <span class="number">200</span>,            <span class="comment">// 滚动的动画持续时间</span></span><br><span class="line">    toTopDistance: <span class="number">80</span>,        <span class="comment">// 距离视口顶部多少高度之内时候触发高亮</span></span><br><span class="line">    selector: <span class="string">&#x27;.headerlink&#x27;</span>,  <span class="comment">// 文章内容中标题标签的 selector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxCatalogCount 就是上面提到的 n 个目录子项中的 n</span></span><br><span class="line"><span class="keyword">let</span> maxCatalogCount = <span class="built_in">Math</span>.floor((<span class="built_in">window</span>.innerHeight - DEFAULT.surplusHeight) / DEFAULT.lineHeight)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动区域高度</span></span><br><span class="line"><span class="keyword">let</span> catalogHeight = arContentAnchor.length &gt; maxCatalogCount ? maxCatalogCount * DEFAULT.lineHeight : arContentAnchor.length * DEFAULT.lineHeight;</span><br></pre></td></tr></table></figure><p>完整的生成目录的函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成目录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateCatalog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> catalogHeight = arContentAnchor.length &gt; maxCatalogCount ? maxCatalogCount * DEFAULT.lineHeight : arContentAnchor.length * DEFAULT.lineHeight;</span><br><span class="line">    <span class="keyword">let</span> retStr = <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;arCatalog&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;arCatalog-line&quot; </span></span><br><span class="line"><span class="string">        style=&quot;height: <span class="subst">$&#123;catalogHeight + DEFAULT.moreHeight&#125;</span>px&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;arCatalog-body&quot; </span></span><br><span class="line"><span class="string">        style=&quot;max-height: <span class="subst">$&#123;catalogHeight&#125;</span>px; height: <span class="subst">$&#123;catalogHeight&#125;</span>px&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;dl style=&quot;margin-top: <span class="subst">$&#123;marginTop&#125;</span>px&quot;&gt;`</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> h2Index = <span class="number">0</span>,</span><br><span class="line">        h3Index = <span class="number">1</span>,</span><br><span class="line">        acIndex = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        tagName = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> currNode <span class="keyword">of</span> arContentAnchor) &#123;</span><br><span class="line">        tagName = currNode.parentElement.tagName</span><br><span class="line">        <span class="keyword">if</span> ( tagName === <span class="string">&#x27;H3&#x27;</span> ) &#123;</span><br><span class="line">            acIndex = <span class="string">`<span class="subst">$&#123;h2Index&#125;</span>.<span class="subst">$&#123;h3Index++&#125;</span>`</span></span><br><span class="line">            className = <span class="string">&#x27;arCatalog-tack2&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            acIndex = ++h2Index</span><br><span class="line">            h3Index = <span class="number">1</span></span><br><span class="line">            className = <span class="string">&#x27;arCatalog-tack1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        retStr += <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;dd class=&quot;<span class="subst">$&#123;className&#125;</span> <span class="subst">$&#123;index++ === lastOnIndex ? <span class="string">&#x27;on&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;span class=&quot;arCatalog-index&quot;&gt;<span class="subst">$&#123;acIndex&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">            &lt;a href=&quot;#&quot;&gt;<span class="subst">$&#123;currNode.title&#125;</span>&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;span class=&quot;arCatalog-dot&quot;&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">            &lt;/dd&gt;`</span></span><br><span class="line">    &#125;;</span><br><span class="line">    retStr += <span class="string">`&lt;/dl&gt;&lt;/div&gt;&lt;/div&gt;`</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;arAnchorBar&#x27;</span>).innerHTML = retStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置滚动监听事件"><a href="#设置滚动监听事件" class="headerlink" title="设置滚动监听事件"></a>设置滚动监听事件</h3><p>给 <code>window</code> 加上滚动事件，用于监听当滚动的时候去做一些操作，这里的操作就是设置高亮和滚动目录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setHighlight()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有目录总数超过滚动区域可容纳最大目录数的时候，目录才需要滚动</span></span><br><span class="line"><span class="keyword">if</span> (catalogLength &gt; maxCatalogCount) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        scrollCatalog()</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上这样就能监听浏览器滚动事件，从而做一些事情啦。但是这样会导致函数被频繁调用，从而存在性能问题，其实我们更希望当滚动开始到滚动结束的时候，只执行一次函数即可，那这个直接上防抖即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖：触发高频事件 n 秒后只会执行一次，如果 n 秒内事件再次触发，则会重新计时。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(fn.id)</span><br><span class="line">        fn.id = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply(_this, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们只需要把 <code>scroll</code> 监听回调里的函数对应换成如下的即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    debounce(setHighlight, DEFAULT.delay)()</span><br><span class="line">    debounce(resetStatus, DEFAULT.delay)()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (catalogLength &gt; maxCatalogCount) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        debounce(scrollCatalog, DEFAULT.delay)()</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高亮当前目录"><a href="#高亮当前目录" class="headerlink" title="高亮当前目录"></a>高亮当前目录</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bcr.png"></p><p>这部分内容开始前，我们先来复习一个 <code>API</code>，该方法会返回元素的大小及其相对于视口的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getBoundingClientRect()</span><br></pre></td></tr></table></figure><p>需求分析的时候有提到，高亮的原则是当前标题所在的位置到浏览器可视区域顶部的距离需要小于或等于一个固定值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arContentAnchor[index].getBoundingClientRect().top &lt;= DEFAULT.toTopDistance</span><br></pre></td></tr></table></figure><p>所以当遍历 <code>arContentAnchor</code> 这个列表，某项的位置小于固定值，且差值最小的时候，该项对应的目录就应该被设置为高亮：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curr = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>)</span><br><span class="line">curr.classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextOnIndex = <span class="number">0</span>,</span><br><span class="line">    currNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nextOnIndex &lt; arContentAnchor.length) &#123;</span><br><span class="line">    currNode = arContentAnchor[nextOnIndex]</span><br><span class="line">    <span class="keyword">if</span> (currNode.getBoundingClientRect().top &lt;= DEFAULT.toTopDistance) &#123;</span><br><span class="line">        nextOnIndex++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">nextOnIndex = nextOnIndex === arContentAnchor.length ? nextOnIndex - <span class="number">1</span> : nextOnIndex;</span><br><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>)</span><br><span class="line">catalogDd[nextOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure><p>到此一切都看起来很美好，但是上面这段代码存在性能问题，只要页面一滚动就会从第一个目录到最后一个目录之间进行查找，知道找到那个符合要求的为止，这样的话遍历次数太多了。</p><p>我们知道页面滚动无非就是在当前这个位置的前提下，往上滚动或者向下滚动，如果我们把 <code>nextOnIndex</code> 记为滚动前的索引，在根据滚动方向进行加加减减不就可以很好的减少遍历次数嘛？想法貌似不错，来试一下。</p><p>首先我们要判断当前滚动是向上还是向下滚动，可以根据两次滚动前后的偏移量来判断：</p><p>向上滚动 = 滚动后偏移量 &lt; 滚动前偏移量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastSH = <span class="built_in">window</span>.pageYOffset</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最近一次页面的滚动方向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollDirection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sh = <span class="built_in">window</span>.pageYOffset, ret = <span class="string">&#x27;bottom&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (sh &lt; lastSH) &#123;</span><br><span class="line">        ret = <span class="string">&#x27;top&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    lastSH = sh</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了滚动方向，我们就可以很好的写出设置高亮的优化代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curr = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> nextOnIndex = onIndex;</span><br><span class="line"><span class="keyword">if</span> (defaultDirec === <span class="string">&#x27;bottom&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextOnIndex &lt; catalogLength) &#123;</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">        <span class="keyword">if</span> ( currTop &gt; DEFAULT.toTopDistance &amp;&amp; nextOnIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nextOnIndex--</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        nextOnIndex++</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextOnIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">        <span class="keyword">if</span> ( currTop &lt;= DEFAULT.toTopDistance)&#123;</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        nextOnIndex--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">nextOnIndex = nextOnIndex === arContentAnchor.length ? nextOnIndex - <span class="number">1</span> : nextOnIndex &lt; <span class="number">0</span> ? <span class="number">0</span> : nextOnIndex </span><br><span class="line">catalogDd[nextOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure><p>优化后的遍历次数明显减少，而且遍历次数基本上是小于或等于滚动前后目录索引的差值。<br>虽然经过优化后，已经明显的减少了遍历次数，但是我还想再优化一下。纳尼？</p><p>很多文章页很长，所以有回到顶部这种功能，试想一下，如果当前页面已经滚动到最底部，这个时候来一下回到顶部，那刚刚写的优化代码会遍历几次？答案是：遍历次数将会是目录子项的总数。文章最开始提到的那个体验地址的那篇文章 <a href="https://bubuzou.com/2020/09/21/vue-operate/">34条我能告诉你的Vue之实操篇</a> 有 43 个子目录，所以需要遍历 43 次，真的不能接受结果，所以再来优化一次。</p><p>二次优化主要是处理边际问题，即滚动到头尾部的时候加上判断，最终二次优化后的高亮当前目录函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高亮当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHighlight</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    defaultDirec = getScrollDirection()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hasStopSetHighlight) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">        scrollTop,</span><br><span class="line">    &#125; = <span class="built_in">document</span>.scrollingElement;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> curr = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> onIndex = [].indexOf.call(catalogDd, curr),  <span class="comment">// 当前高亮索引</span></span><br><span class="line">        nextOnIndex = onIndex;  <span class="comment">// 滚动后高亮索引</span></span><br><span class="line">        </span><br><span class="line">    curr.classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> scrollHeight = <span class="built_in">document</span>.documentElement.scrollHeight || <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">    <span class="keyword">if</span> (arContentAnchor[catalogLength - <span class="number">1</span>].getBoundingClientRect().top &lt;= DEFAULT.toTopDistance || </span><br><span class="line">        <span class="built_in">window</span>.innerHeight + <span class="built_in">window</span>.pageYOffset === scrollHeight) &#123;  <span class="comment">// 尾部</span></span><br><span class="line">        lastOnIndex = catalogLength - <span class="number">1</span></span><br><span class="line">        catalogDd[lastOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scrollTop &lt;= firstDdTop) &#123;  <span class="comment">// 顶部</span></span><br><span class="line">        catalogDd[<span class="number">0</span>].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">        lastOnIndex = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 中间：使用缓存，直接从上一次索引（onIndex）位置开始查找</span></span><br><span class="line">        <span class="keyword">if</span> (defaultDirec === <span class="string">&#x27;bottom&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nextOnIndex &lt; catalogLength) &#123;</span><br><span class="line">                <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">                <span class="keyword">if</span> ( currTop &gt; DEFAULT.toTopDistance &amp;&amp; nextOnIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    nextOnIndex--</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                nextOnIndex++</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (nextOnIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> currTop = arContentAnchor[nextOnIndex].getBoundingClientRect().top</span><br><span class="line">                <span class="keyword">if</span> ( currTop &lt;= DEFAULT.toTopDistance)&#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                nextOnIndex--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nextOnIndex = nextOnIndex === catalogLength ? nextOnIndex - <span class="number">1</span> : nextOnIndex &lt; <span class="number">0</span> ? <span class="number">0</span> : nextOnIndex </span><br><span class="line">        lastOnIndex = nextOnIndex</span><br><span class="line">        catalogDd[nextOnIndex].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滚动目录"><a href="#滚动目录" class="headerlink" title="滚动目录"></a>滚动目录</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_to_bottom.png"></p><p>根据之前需求分析里的说明，我们可以知道当浏览器向下滚动的时候，会分成 3 种情况：</p><ol><li>滚动后的高亮子目录处于于滚动区域上半部分，即中位线以上，此时目录不进行滚动，如上图 ①；</li><li>滚动后的高亮子目录处于滚动区域的下半部分，即中位线以下，此时目录的滚动距离将是滚动后高亮子目录的底部位置到中位线的高度差，如上图 ②；</li><li>滚动后的高亮目录处于中位线以下且最后一个子目录需要贴着滚动区域底部，此时目录的滚动距离将是滚动列表底部到滚动区域底部的高度差，如上图 ③。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catalogBody = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog-body&#x27;</span>),</span><br><span class="line">    initBodyTop = catalogBody..getBoundingClientRect().top,</span><br><span class="line">    bodyMidBottom = initBodyTop + <span class="built_in">Math</span>.ceil((maxCatalogCount / <span class="number">2</span> )) * DEFAULT.lineHeight;  <span class="comment">// 中位线位置</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (curr.bottom + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= bodyBCR.bottom) &#123;  <span class="comment">// 上半部分</span></span><br><span class="line">    <span class="comment">// 不滚动</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.bottom - bodyMidBottom &lt; list.bottom - bodyBCR.bottom) &#123;  <span class="comment">// 中位以下</span></span><br><span class="line">    marginTop += -<span class="built_in">Math</span>.floor((curr.bottom - bodyMidBottom ) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyBCR.bottom &lt;= list.bottom) &#123;  <span class="comment">// 当剩余滚动距离</span></span><br><span class="line">    marginTop = bodyBCR.bottom - initDlBottom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，当浏览器向上滚动的时候，也能很好的得出其滚动逻辑：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/scroll_to_top.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bodyBCR.top + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= curr.top) &#123;</span><br><span class="line">    <span class="comment">// 不滚动</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyMidBottom - curr.top &lt; bodyBCR.top - list.top) &#123;</span><br><span class="line">    marginTop += <span class="built_in">Math</span>.floor((bodyMidBottom - curr.top) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.top &lt;= bodyBCR.top) &#123;</span><br><span class="line">    marginTop = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的滚动目录函数完整代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动滚动目录树，使得当前高亮目录在可视范围内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollCatalog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentCatalog = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> curr = currentCatalog.getBoundingClientRect(),</span><br><span class="line">        list = catalogDl.getBoundingClientRect();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (defaultDirec === <span class="string">&#x27;bottom&#x27;</span>) &#123;  <span class="comment">// 向下滚动</span></span><br><span class="line">        <span class="keyword">if</span> (curr.bottom + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= bodyBCR.bottom) &#123;  <span class="comment">// 上半部分</span></span><br><span class="line">            <span class="comment">// 不滚动</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.bottom - bodyMidBottom &lt; list.bottom - bodyBCR.bottom)&#123;  <span class="comment">// 中位以下</span></span><br><span class="line">            marginTop += -<span class="built_in">Math</span>.floor((curr.bottom - bodyMidBottom ) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyBCR.bottom &lt;= list.bottom) &#123;  <span class="comment">// 当剩余滚动距离</span></span><br><span class="line">            marginTop = bodyBCR.bottom - initDlBottom</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 向上滚动</span></span><br><span class="line">        <span class="keyword">if</span> (bodyBCR.top + (maxCatalogCount / <span class="number">2</span>) * DEFAULT.lineHeight &lt;= curr.top) &#123;</span><br><span class="line">            <span class="comment">// 不滚动</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyMidBottom - curr.top &lt; bodyBCR.top - list.top) &#123;</span><br><span class="line">            marginTop += <span class="built_in">Math</span>.floor((bodyMidBottom - curr.top) / DEFAULT.lineHeight) * DEFAULT.lineHeight</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.top &lt;= bodyBCR.top) &#123;</span><br><span class="line">            marginTop = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catalogDl.style.marginTop = marginTop + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子目录点击事件"><a href="#子目录点击事件" class="headerlink" title="子目录点击事件"></a>子目录点击事件</h3><p>当点击子目录的时候需要做 2 件事情，第一是滚动页面到对应的目录位置，然后是高亮当前点击的目录；</p><p>滚动页面到对应的目录位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给目录子项绑定事件</span></span><br><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">    curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollTop = <span class="built_in">document</span>.body.scrollTop = currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样实现页面的滚动是没什么问题，就是体验不太好，突然从一个位置滚动到另外一个位置，显得突兀，能不能来点动画效果？类似 <code>jQuery</code> 的 <code>animate()</code> ？没问题，我们来尝试着实现一下。</p><p>用 <code>JS</code> 实现动画效果，一定离不开定时器，诸如 <code>setTimeout</code>、<code>setInterval</code> 之类，但是这次我不打算用他们，而是用 <code>HTML5</code> 中增加的 <code>requestAnimationFrame</code>，这是一个专门为浏览器实现动画而提供的 <code>API</code>。它虽然也是个定时器，但是相比于另外两个，他不需要传递时间，因为传递的回调函数里自带了参数 <code>DOMHighResTimeStamp</code>，这个参数表示回调函数被触发的时间。</p><p>除此之外，<code>requestAnimationFrame</code> 中的回调函数执行次数通常是每秒60次，即大概每 16.6 毫秒执行一次回调函数，但在大多数遵循 <code>W3C</code> 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。好了，对于 <code>requestAnimationFrame</code> 的介绍就到这里，下面我们直接来说下动画实现滚动的核心原理：</p><p>每次滚动距离 = ( 滚动距离 / 动画持续时间 ) * 每次动画执行时间距离第一次执行时间的差值 + 当前滚动距离</p><p>直接来看完整的动画实现滚动的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动到目标位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollToDest</span>(<span class="params">destScrollTop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> startTime;   </span><br><span class="line">    <span class="keyword">let</span> currScrollTop = <span class="built_in">window</span>.pageYOffset;</span><br><span class="line">    <span class="keyword">let</span> duration = <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!startTime) &#123;</span><br><span class="line">            startTime = timestamp</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> elapsed = <span class="built_in">Math</span>.round(timestamp - startTime)</span><br><span class="line">        <span class="keyword">const</span> distance = elapsed * ((<span class="built_in">Math</span>.floor(destScrollTop) - currScrollTop) / duration) + currScrollTop</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollTop = <span class="built_in">document</span>.body.scrollTop = distance</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (elapsed &lt; duration) &#123;</span><br><span class="line">            <span class="built_in">window</span>.requestAnimationFrame(step)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在有了动画函数，我们需要改写下子目录的点击事件，给滚动加上过渡效果，让人体验起来更加舒服：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>);</span><br><span class="line"></span><br><span class="line">catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">    curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">        scrollToDest(currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一件事已经做好，接下来做第二件事，高亮当前点击某个子目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给目录子项绑定事件</span></span><br><span class="line"><span class="keyword">let</span> catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>);</span><br><span class="line"></span><br><span class="line">catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">    curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        hasStopSetHighlight = <span class="literal">true</span></span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>).classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">        catalogDd[index].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">        lastOnIndex = index</span><br><span class="line">        <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">        scrollToDest(currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上即可，但是由于点击了某个子目录，页面会进行滚动，而页面滚动又会触发 <code>setHighlight</code> 函数对目录进行高亮，所以我这里的做法是用了一个全局变量 <code>hasStopSetHighlight</code> 用来控制当点击子目录的时候，不进行 <code>setHighlight</code> 设置高亮操作。</p><h3 id="浏览器视口高度变了怎么办"><a href="#浏览器视口高度变了怎么办" class="headerlink" title="浏览器视口高度变了怎么办"></a>浏览器视口高度变了怎么办</h3><p>因为我们的滚动高度是根据浏览器视口高度计算出来的，如果浏览器视口高度变化了，那这个时候再去滚动页面，那肯定会出问题的。所以需要做的就是把和视口高度有关的逻辑抽离出来，统一放到一个函数里，当监听到视口高度变化的时候，再去执行这个函数。</p><p>先来写监听函数，同样用上了防抖函数处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    debounce(initCatalog, DEFAULT.delay)()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>然后去把相关逻辑抽离出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCatalog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tempHeight = <span class="built_in">window</span>.innerHeight</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (viewPortHeight !== tempHeight) &#123;</span><br><span class="line">        viewPortHeight = tempHeight</span><br><span class="line">        maxCatalogCount = <span class="built_in">Math</span>.floor((viewPortHeight - DEFAULT.surplusHeight) / DEFAULT.lineHeight)</span><br><span class="line">        </span><br><span class="line">        generateCatalog()</span><br><span class="line">        </span><br><span class="line">        catalogLength = arContentAnchor.length</span><br><span class="line">        lastSH = <span class="built_in">window</span>.pageYOffset</span><br><span class="line">        catalogBody = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog-body&#x27;</span>)</span><br><span class="line">        catalogDl = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog dl&#x27;</span>)</span><br><span class="line">        catalogDd = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.arCatalog dd&#x27;</span>)</span><br><span class="line">        bodyBCR = catalogBody.getBoundingClientRect()</span><br><span class="line">        initBodyTop = bodyBCR.top</span><br><span class="line">        initDlBottom = initDlBottom || catalogDl.getBoundingClientRect().bottom</span><br><span class="line">        firstDdTop = firstDdTop || catalogDd[<span class="number">0</span>].getBoundingClientRect().top,</span><br><span class="line">        bodyMidBottom = initBodyTop + <span class="built_in">Math</span>.ceil((maxCatalogCount / <span class="number">2</span> )) * DEFAULT.lineHeight;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给目录子项绑定事件</span></span><br><span class="line">        catalogDd.forEach(<span class="function">(<span class="params">curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">            curr.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                e.preventDefault()</span><br><span class="line">                hasStopSetHighlight = <span class="literal">true</span></span><br><span class="line">                <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arCatalog .on&#x27;</span>).classList.remove(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">                catalogDd[index].classList.add(<span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">                lastOnIndex = index</span><br><span class="line">                <span class="keyword">let</span> currTop = arContentAnchor[index].getBoundingClientRect().top</span><br><span class="line">                scrollToDest(currTop + <span class="built_in">window</span>.pageYOffset - DEFAULT.toTopDistance)</span><br><span class="line">            &#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器视口高度变化后，这里有个细节需要提一下，那就是滚动目录的 <code>margin-top</code> 以及高亮位置是希望变化的，所以我们需要使用全局变量进行提前保存起来，分别用到的全局变量是 <code>marginTop</code> 和 <code>lastOnIndex</code>。</p><h3 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h3><p>上面的代码都是把不同的功能点提取到函数里进行操作，看起来比较散乱，所以我们需要看看一个完整的目录插件应该是什么样子？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * articleCatalog v2.0</span></span><br><span class="line"><span class="comment"> * Copyright(c) 2016 by bulandent</span></span><br><span class="line"><span class="comment"> * Date: 2017-5-27 16:10:41</span></span><br><span class="line"><span class="comment"> * Updated: 2020-10-10 17:40:04</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> articleCatalog = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.headerlink&#x27;</span>).length === <span class="number">0</span> || <span class="built_in">window</span>.innerWidth &lt; <span class="number">900</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> DEFAULT = &#123;</span><br><span class="line">        lineHeight: <span class="number">28</span>,           <span class="comment">// 每个菜单的行高是 28</span></span><br><span class="line">        moreHeight: <span class="number">10</span>,           <span class="comment">// 菜单左侧的线比菜单多出的高度</span></span><br><span class="line">        surplusHeight: <span class="number">180</span>,       <span class="comment">// 除了菜单高度+留白高度</span></span><br><span class="line">        delay: <span class="number">200</span>,               <span class="comment">// 防抖的延迟时间</span></span><br><span class="line">        duration: <span class="number">200</span>,            <span class="comment">// 滚动的动画持续时间</span></span><br><span class="line">        toTopDistance: <span class="number">80</span>,        <span class="comment">// 距离视口顶部多少高度之内时候触发高亮</span></span><br><span class="line">        selector: <span class="string">&#x27;.headerlink&#x27;</span>,  <span class="comment">// 文章内容中标题标签的 selector</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        DEFAULT = <span class="built_in">Object</span>.assign(DEFAULT, args)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> arContentAnchor = <span class="built_in">document</span>.querySelectorAll(DEFAULT.selector),</span><br><span class="line">            catalogLength = arContentAnchor.length,</span><br><span class="line">            maxCatalogCount = <span class="number">0</span>,          <span class="comment">// 视口内能容纳的最大目录个数</span></span><br><span class="line">            viewPortHeight = <span class="number">0</span>,           <span class="comment">// 当前视口的高度</span></span><br><span class="line">            marginTop = <span class="number">0</span>,                <span class="comment">// 菜单的初始滚动距离</span></span><br><span class="line">            defaultDirec = <span class="string">&#x27;bottom&#x27;</span>,      <span class="comment">// 默认滚动方向</span></span><br><span class="line">            lastSH = <span class="number">0</span>,                   <span class="comment">// 获取页面初始滚动距离</span></span><br><span class="line">            lastOnIndex = <span class="number">0</span>,              <span class="comment">// 上次高亮的目录索引</span></span><br><span class="line">            catalogBody = [],             <span class="comment">// .arCatalog-body</span></span><br><span class="line">            catalogDl = <span class="literal">null</span>,             <span class="comment">// .arCatalog-body dl</span></span><br><span class="line">            catalogDd = [],                 <span class="comment">// .arCatalog-body dd</span></span><br><span class="line">            initBodyTop = <span class="number">0</span>,              <span class="comment">// 目录可视区域的 top</span></span><br><span class="line">            initDlBottom = <span class="number">0</span>,             <span class="comment">// 目录 dl 的 bottom</span></span><br><span class="line">            firstDdTop = <span class="number">0</span>,               <span class="comment">// 第一个 dd 的 top</span></span><br><span class="line">            bodyMidBottom = <span class="number">0</span>,            <span class="comment">// 目录可视区域的中间位置的 dd 的 bottom</span></span><br><span class="line">            bodyBCR = <span class="literal">null</span>,                  <span class="comment">// 目录可视区域的边界值</span></span><br><span class="line">            hasStopSetHighlight = <span class="literal">false</span>;  <span class="comment">// 在点击目录子项的时候直接高亮当前目录，而不通过 scroll 事件触发 setHighlight 函数</span></span><br><span class="line">            </span><br><span class="line">        initCatalog()</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            debounce(setHighlight, DEFAULT.delay)()</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (catalogLength &gt; maxCatalogCount) &#123;</span><br><span class="line">            <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                debounce(scrollCatalog, DEFAULT.delay)()</span><br><span class="line">            &#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            debounce(initCatalog, DEFAULT.delay)()</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 此处声明初始化函数 initCatalog</span></span><br><span class="line">        <span class="comment">// 此处声明生成目录函数 generateCatalog</span></span><br><span class="line">        <span class="comment">// 此处声明设置高亮函数 setHighlight</span></span><br><span class="line">        <span class="comment">// 此处声明滚动目录函数 scrollCatalog</span></span><br><span class="line">        <span class="comment">// 此处声明动画实现滚动函数 scrollToDest</span></span><br><span class="line">        <span class="comment">// 此处声明防抖函数 debounce</span></span><br><span class="line">        <span class="comment">// 此处声明获取滚动方向函数 getScrollDirection</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resetStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (hasStopSetHighlight) &#123;</span><br><span class="line">                hasStopSetHighlight = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>然后在实际页面里使用的时候，只需要引入 <code>articleCatalog.js</code>，然后直接用调用函数即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">articleCatalog()</span><br></pre></td></tr></table></figure><p>当然调用的时候也支持传入一些参数，参数说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">articleCatalog(&#123;</span><br><span class="line">    lineHeight: 28,           &#x2F;&#x2F; 每个菜单的行高是 28</span><br><span class="line">    moreHeight: 10,           &#x2F;&#x2F; 菜单左侧的线比菜单多出的高度</span><br><span class="line">    surplusHeight: 180,       &#x2F;&#x2F; 除了菜单高度+留白高度</span><br><span class="line">    delay: 200,               &#x2F;&#x2F; 防抖的延迟时间</span><br><span class="line">    duration: 200,            &#x2F;&#x2F; 滚动的动画持续时间</span><br><span class="line">    toTopDistance: 80,        &#x2F;&#x2F; 距离视口顶部多少高度之内时候触发高亮</span><br><span class="line">    selector: &#39;.headerlink&#39;,  &#x2F;&#x2F; 文章内容中标题标签的 selector</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意传入参数也是瞎传的，需要配合该插件的样式，否则容易程问题。比如明明页面中子目录的真实行高是 <code>28px</code>，你却传入 <code>lineHeight: 24</code>，那肯定是不行的。</p><blockquote><p>使用这个插件是有前提的，那就是其文章页的 HTML 结构必须满足上面提到的那种结构才行，且只支持两级子目录。</p></blockquote><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202009/gzh.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在说这个插件之前，可以先去 &lt;a href=&quot;https://bubuzou.com/2020/09/21/vue-operate/&quot;&gt;https://bubuzou.com/&lt;/a&gt; 这个网站体验下这个插件的效果，好有个大概的印象。&lt;/p&gt;
&lt;p&gt;通过阅读这篇文章，你可以收获什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用 &lt;code&gt;JS&lt;/code&gt; 直接操作 &lt;code&gt;DOM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;浏览器 &lt;code&gt;BOM&lt;/code&gt; 相关知识&lt;/li&gt;
&lt;li&gt;性能优化思考&lt;/li&gt;
&lt;li&gt;插件设计思考&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;平时我们在用 &lt;code&gt;Markdown&lt;/code&gt; 写的文章，如果放到自己的博客或者投稿到掘金等平台，其内容会被浏览器解析成 &lt;code&gt;HTML&lt;/code&gt;。而 &lt;code&gt;Markdown&lt;/code&gt; 里面的一级（#）、二级（##）、三级标题（###）分别对应于页面的文章标题、一级目录、二级目录。基于此，就可以很好的利用该生成的页面实现一个目录，便于更直观方便的的浏览文章内容，而这就是最初我想为博客里的文章页实现一个目录功能的理由。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个插件是基于 &lt;code&gt;Hexo&lt;/code&gt; 生成的网页来实现的，且目前只支持一级和二级目录，因为作为一篇文章来说有两个层级已经可以很好的将一块内容划分细说得很清楚了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>34条我能告诉你的Vue之实操篇</title>
    <link href="https://bubuzou.com/2020/09/21/vue-operate/"/>
    <id>https://bubuzou.com/2020/09/21/vue-operate/</id>
    <published>2020-09-21T02:22:22.564Z</published>
    <updated>2021-09-06T09:58:02.807Z</updated>
    
    <content type="html"><![CDATA[<p>这是我学习整理的关于 <code>Vue.js</code> 系列文章的第一篇，另外还有两篇分别是关于优化和原理的。希望读完这 3 篇文章，你能对 <code>Vue</code> 有个更深入的认识。</p><h2 id="7-种组件通信方式随你选"><a href="#7-种组件通信方式随你选" class="headerlink" title="7 种组件通信方式随你选"></a>7 种组件通信方式随你选</h2><p>组件通信是 <code>Vue</code> 的核心知识，掌握这几个知识点，面试开发一点问题都没有。</p><h3 id="props-on-emit"><a href="#props-on-emit" class="headerlink" title="props/@on+$emit"></a>props/@on+$emit</h3><p>用于实现父子组件间通信。通过 <code>props</code> 可以把父组件的消息传递给子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.vue</span></span><br><span class="line">props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来 <code>this.title</code> 就直接拿到从父组件中传过来的 <code>title</code> 的值了。注意，你不应该在子组件内部直接改变 <code>prop</code>，这里就不多赘述，<a href="https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">可以直接看官网介绍</a>。</p><p>而通过 <code>@on+$emit</code> 组合可以实现子组件给父组件传递信息：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> @<span class="attr">changeTitle</span>=<span class="string">&quot;changeTitle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;changeTitle&#x27;</span>, <span class="string">&#x27;bubuzou.com&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="attrs和-listeners"><a href="#attrs和-listeners" class="headerlink" title="$attrs和$listeners"></a>$attrs和$listeners</h3><p><code>Vue_2.4</code> 中新增的 <code>$attrs/$listeners</code> 可以进行跨级的组件通信。<br><code>$attrs</code> 包含了父级作用域中不作为 <code>prop</code> 的属性绑定（<code>class</code> 和 <code>style</code> 除外），好像听起来有些不好理解？没事，看下代码就知道是什么意思了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 index.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span> <span class="attr">class</span>=<span class="string">&quot;list-box&quot;</span> <span class="attr">title</span>=<span class="string">&quot;标题&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;描述&quot;</span> <span class="attr">:list</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件 list.vue</span></span><br><span class="line">props: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$attrs)  <span class="comment">// &#123;title: &quot;标题&quot;, desc: &quot;描述&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的父组件 <code>index.vue</code> 中我们给子组件 <code>list.vue</code> 传递了 4 个参数，但是在子组件内部 <code>props</code> 里只定义了一个 <code>list</code>，那么此时 <code>this.$attrs</code> 的值是什么呢？首先要去除 <code>props</code> 中已经绑定了的，然后再去除 <code>class</code> 和 <code>style</code>，最后剩下 <code>title</code> 和 <code>desc</code> 结果和打印的是一致的。<br>基于上面代码的基础上，我们在给 <code>list.vue</code> 中加一个子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 list.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">detail</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">detial</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孙子组件 detail.vue</span></span><br><span class="line"><span class="comment">// 不定义props，直接打印 $attrs</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$attrs)  <span class="comment">// &#123;title: &quot;标题&quot;, desc: &quot;描述&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子组件中我们定义了一个 <code>v-bind=&quot;$attrs&quot;</code> 可以把父级传过来的参数，去除 <code>props</code>、<code>class</code> 和 <code>style</code> 之后剩下的继续往下级传递，这样就实现了跨级的组件通信。</p><p><code>$attrs</code> 是可以进行跨级的参数传递，实现父到子的通信；同样的，通过 <code>$listeners</code> 用类似的操作方式可以进行跨级的事件传递，实现子到父的通信。<code>$listeners</code> 包含了父作用域中不含 <code>.native</code> 修饰的 <code>v-on</code> 事件监听器，通过 <code>v-on=&quot;$listeners&quot;</code> 传递到子组件内部。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 index.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span> @<span class="attr">change</span>=<span class="string">&quot;change&quot;</span> @<span class="attr">update.native</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件 list.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">detail</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">detail</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孙子组件 detail.vue</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">this</span>.$listeners.change()</span><br><span class="line">    <span class="built_in">this</span>.$listeners.update() <span class="comment">// TypeError: this.$listeners.update is not a function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="provide-inject-组合拳"><a href="#provide-inject-组合拳" class="headerlink" title="provide/inject 组合拳"></a>provide/inject 组合拳</h3><p><code>provide/inject</code> 组合以允许一个祖先组件向其所有子孙后代注入一个依赖，可以注入属性和方法，从而实现跨级父子组件通信。在开发高阶组件和组件库的时候尤其好用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件 index.vue</span></span><br><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        title: <span class="string">&#x27;bubuzou.com&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">provide() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        detail: &#123;</span><br><span class="line">            title: <span class="built_in">this</span>.title,</span><br><span class="line">            change: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log( val )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 孙子组件 detail.vue</span></span><br><span class="line">inject: [<span class="string">&#x27;detail&#x27;</span>],</span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.detail.title)  <span class="comment">// bubuzou.com</span></span><br><span class="line">    <span class="built_in">this</span>.detail.title = <span class="string">&#x27;hello world&#x27;</span>  <span class="comment">// 虽然值被改变了，但是父组件中 title 并不会重新渲染</span></span><br><span class="line">    <span class="built_in">this</span>.detail.change(<span class="string">&#x27;改变后的值&#x27;</span>)  <span class="comment">// 执行这句后将打印：改变后的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>provide</code> 和 <code>inject</code> 的绑定对于原始类型来说并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。这也就是为什么在孙子组件中改变了 <code>title</code>，但是父组件不会重新渲染的原因。</p></blockquote><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>以上三种方式都是只能从父到子方向或者子到父方向进行组件的通信，而我就比较牛逼了 😀，我还能进行兄弟组件之间的通信，甚至任意 2 个组件间通信。利用 <code>Vue</code> 实例实现一个 <code>EventBus</code> 进行信息的发布和订阅，可以实现在任意 2 个组件之间通信。有两种写法都可以初始化一个 <code>eventBus</code> 对象：</p><ol><li><p>通过导出一个 <code>Vue</code> 实例，然后再需要的地方引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p>使用 <code>EventBus</code> 订阅和发布消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; EventBus &#125; <span class="keyword">from</span> <span class="string">&#x27;../utils/eventBus.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅处</span></span><br><span class="line">EventBus.$on(<span class="string">&#x27;update&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布处</span></span><br><span class="line">EventBus.$emit(<span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;更新信息&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>在 <code>main.js</code> 中初始化一个全局的事件总线：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$eventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要订阅的地方</span></span><br><span class="line"><span class="built_in">this</span>.$eventBus.$on(<span class="string">&#x27;update&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要发布信息的地方</span></span><br><span class="line"><span class="built_in">this</span>.$eventBus.$emit(<span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;更新信息&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><p>如果想要移除事件监听，可以这样来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$eventBus.$off(<span class="string">&#x27;update&#x27;</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure><p>上面介绍了两种写法，推荐使用第二种全局定义的方式，可以避免在多处导入 <code>EventBus</code> 对象。这种组件通信方式只要订阅和发布的顺序得当，且事件名称保持唯一性，理论上可以在任何 2 个组件之间进行通信，相当的强大。但是方法虽好，可不要滥用，建议只用于简单、少量业务的项目中，如果在一个大型繁杂的项目中无休止的使用该方法，将会导致项目难以维护。</p><h3 id="Vuex-进行全局的数据管理"><a href="#Vuex-进行全局的数据管理" class="headerlink" title="Vuex 进行全局的数据管理"></a>Vuex 进行全局的数据管理</h3><p><code>Vuex</code> 是一个专门服务于 <code>Vue.js</code> 应用的状态管理工具。适用于中大型应用。<code>Vuex</code> 中有一些专有概念需要先了解下：</p><ul><li><code>State</code>：用于数据的存储，是 <code>store</code> 中的唯一数据源；</li><li><code>Getter</code>：类似于计算属性，就是对 <code>State</code> 中的数据进行二次的处理，比如筛选和对多个数据进行求值等；</li><li><code>Mutation</code>：类似事件，是改变 <code>Store</code> 中数据的唯一途径，只能进行同步操作；</li><li><code>Action</code>：类似 <code>Mutation</code>，通过提交 <code>Mutation</code> 来改变数据，而不直接操作 <code>State</code>，可以进行异步操作；</li><li><code>Module</code>：当业务复杂的时候，可以把 <code>store</code> 分成多个模块，便于维护；</li></ul><p>对于这几个概念有各种对应的 <code>map</code> 辅助函数用来简化操作，比如 <code>mapState</code>，如下三种写法其实是一个意思，都是为了从 <code>state</code> 中获取数据，并且通过计算属性返回给组件使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        count: <span class="function"><span class="params">state</span> =&gt;</span> state.count</span><br><span class="line">    &#125;),</span><br><span class="line">    ...mapState([<span class="string">&#x27;count&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>又比如 <code>mapMutations</code>， 以下两种函数的定义方式要实现的功能是一样的，都是要提交一个 <code>mutation</code> 去改变 <code>state</code> 中的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapMutations([<span class="string">&#x27;increment&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就用一个极简的例子来展示 <code>Vuex</code> 中任意 2 个组件间的状态管理。<br>1、 新建 <code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement(state) &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、 创建一个带 <code>store</code> 的 <code>Vue</code> 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./utils/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>3、 任意组件 <code>A</code> 实现点击递增</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>click to increment：&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; mapState, mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      ...mapState([<span class="string">&#x27;count&#x27;</span>]),</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      ...mapMutations([<span class="string">&#x27;increment&#x27;</span>]),</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、 任意组件 <code>B</code> 实现点击递减</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>click to decrement：&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; mapState, mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      ...mapState([<span class="string">&#x27;count&#x27;</span>]),</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      ...mapMutations([<span class="string">&#x27;decrement&#x27;</span>]),</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上只是用最简单的 <code>vuex</code> 配置去实现组件通信，当然真实项目中的配置肯定会更复杂，比如需要对 <code>State</code> 数据进行二次筛选会用到 <code>Getter</code>，然后如果需要异步的提交那么需要使用 <code>Action</code>，再比如如果模块很多，可以将 <code>store</code> 分模块进行状态管理。对于 <code>Vuex</code> 更多复杂的操作还是建议去看<a href="https://vuex.vuejs.org/zh/">Vuex 官方文档</a>，然后多写例子。</p><h3 id="Vue-observable-实现-mini-vuex"><a href="#Vue-observable-实现-mini-vuex" class="headerlink" title="Vue.observable 实现 mini vuex"></a>Vue.observable 实现 mini vuex</h3><p>这是一个 <code>Vue2.6</code> 中新增的 <code>API</code>，用来让一个对象可以响应。我们可以利用这个特点来实现一个小型的状态管理器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = Vue.observable(&#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        state.count++</span><br><span class="line">    &#125;</span><br><span class="line">    decrement() &#123;</span><br><span class="line">        state.count--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; state &#125; <span class="keyword">from</span> <span class="string">&#x27;../store&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    computed: &#123;</span><br><span class="line">      count() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> state.count</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; mutations &#125; <span class="keyword">from</span> <span class="string">&#x27;../store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      mutations.increment()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="refs-children-parent-root"><a href="#refs-children-parent-root" class="headerlink" title="$refs/$children/$parent/$root"></a>$refs/$children/$parent/$root</h3><p>通过给子组件定义 <code>ref</code> 属性可以使用 <code>$refs</code> 来直接操作子组件的方法和属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如子组件有一个 <code>getList</code> 方法，可以通过如下方式进行调用，实现父到子的通信：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$refs.list.getList()</span><br></pre></td></tr></table></figure><p>除了 <code>$refs</code> 外，其他 3 个都是自 <code>Vue</code> 实例创建后就会自动包含的属性，使用和上面的类似。</p><h2 id="6-类可以掌握的修饰符"><a href="#6-类可以掌握的修饰符" class="headerlink" title="6 类可以掌握的修饰符"></a>6 类可以掌握的修饰符</h2><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><p>表单类的修饰符都是和 <code>v-model</code> 搭配使用的，比如：<code>v-model.lazy</code>、<code>v-model.trim</code> 以及 <code>v-model.number</code> 等。</p><ul><li><p><code>.lazy</code>：对表单输入的结果进行延迟响应，通常和 <code>v-model</code> 搭配使用。正常情况下在 <code>input</code> 里输入内容会在 <code>p</code> 标签里实时的展示出来，但是加上 <code>.lazy</code> 后则需要在输入框失去焦点的时候才触发响应。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>.trim</code>：过滤输入内容的首尾空格，这个和直接拿到字符串然后通过 <code>str.trim()</code> 去除字符串首尾空格是一个意思。</p></li><li><p><code>.number</code>：如果输入的第一个字符是数字，那就只能输入数字，否则他输入的就是普通字符串。</p></li></ul><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p><code>Vue</code> 的事件修饰符是专门为 <code>v-on</code> 设计的，可以这样使用： <code>@click.stop=&quot;handleClick&quot;</code>，还能串联使用：<code>@click.stop.prevent=&quot;handleClick&quot;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;doDiv&quot;</span>&gt;</span></span><br><span class="line">  click div</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">&quot;doP&quot;</span>&gt;</span>click p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>.stop</code>：阻止事件冒泡，和原生 <code>event.stopPropagation()</code> 是一样的效果。如上代码，当点击 <code>p</code> 标签的时候，<code>div</code> 上的点击事件也会触发，加上 <code>.stop</code> 后事件就不会往父级传递，那父级的事件就不会触发了。</p></li><li><p><code>.prevent</code>：阻止默认事件，和原生的 <code>event.preventDefault()</code> 是一样的效果。比如一个带有 <code>href</code> 的链接上添加了点击事件，那么事件触发的时候也会触发链接的跳转，但是加上 <code>.prevent</code> 后就不会触发链接跳转了。</p></li><li><p><code>.capture</code>：默认的事件流是：捕获阶段-目标阶段-冒泡阶段，即事件从最具体目标元素开始触发，然后往上冒泡。而加上 <code>.capture</code> 后则是反过来，外层元素先触发事件，然后往深层传递。</p></li><li><p><code>.self</code>：只触发自身的事件，不会传递到父级，和 <code>.stop</code> 的作用有点类似。</p></li><li><p><code>.once</code>：只会触发一次该事件。</p></li><li><p><code>.passive</code>：当页面滚动的时候就会一直触发 <code>onScroll</code> 事件，这个其实是存在性能问题的，尤其是在移动端，当给他加上 <code>.passive</code> 后触发的就不会那么频繁了。</p></li><li><p><code>.native</code>：现在在组件上使用 <code>v-on</code> 只会监听自定义事件 (组件用 <code>$emit</code> 触发的事件)。如果要监听根元素的原生事件，可以使用 <code>.native</code> 修饰符，比如如下的 <code>el-input</code>，如果不加 <code>.native</code> 当回车的时候就不会触发 <code>search</code> 函数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> @<span class="attr">keyup.enter.native</span>=<span class="string">&quot;search&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>串联使用事件修饰符的时候，需要注意其顺序，同样 2 个修饰符进行串联使用，顺序不同，结果大不一样。<code>@click.prevent.self</code> 会阻止所有的点击事件，而 <code>@click.self.prevent</code> 只会阻止对自身元素的点击。</p></blockquote><h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul><li><code>.left</code>：鼠标左键点击；</li><li><code>.right</code>：鼠标右键点击；</li><li><code>.middle</code>：鼠标中键点击；</li></ul><h3 id="键盘按键修饰符"><a href="#键盘按键修饰符" class="headerlink" title="键盘按键修饰符"></a>键盘按键修饰符</h3><p><code>Vue</code> 提供了一些常用的按键码：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>另外，你也可以直接将 <code>KeyboardEvent.key</code> 暴露的任意有效按键名转换为 <code>kebab-case</code> 来作为修饰符，比如可以通过如下的代码来查看具体按键的键名是什么：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup</span>=<span class="string">&quot;onKeyUp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onKeyUp(event) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.key)  <span class="comment">// 比如键盘的方向键向下就是 ArrowDown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a>.exact 修饰符</h3><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h3><p><code>.sync</code> 修饰符常被用于子组件更新父组件数据。直接看下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:title.sync</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;update:title&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><p>子组件可以直接通过 <code>update:title</code> 的形式进行更新父组件中声明了 <code>.sync</code> 的 <code>prop</code>。<br>上面父组件中的写法其实是下面这种写法的简写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span> @<span class="attr">update:title</span>=<span class="string">&quot;title = $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用</p></blockquote><p>如果需要设置多个 <code>prop</code>，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:name.sync</span>=<span class="string">&quot;name&quot;</span> <span class="attr">:age.sync</span>=<span class="string">&quot;age&quot;</span> <span class="attr">:sex.sync</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过 <code>v-bind.sync</code> 简写成这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind.sync</span>=<span class="string">&quot;person&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person: &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">    age: <span class="number">21</span>,</span><br><span class="line">    sex: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Vue</code> 内部会自行进行解析把 <code>person</code> 对象里的每个属性都作为独立的 <code>prop</code> 传递进去，各自添加用于更新的 <code>v-on</code> 监听器。而从子组件进行更新的时候还是保持不变，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;update:name&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="6-种方式编写可复用模块"><a href="#6-种方式编写可复用模块" class="headerlink" title="6 种方式编写可复用模块"></a>6 种方式编写可复用模块</h2><p>今天需求评审了一个需求，需要实现一个详情页，这个详情页普通用户和管理员都能进去，但是展示的数据有稍有不同，但绝大部分是一样的；最主要的区别是详情对于普通用户是纯展示，而对于管理员要求能够编辑，然后管理员还有一些别的按钮权限等。需求看到这里，如果在排期的时候把用户的详情分给开发 A 做，而把管理员的详情分给 B 去做，那这样做的结果就是开发 A 写了一个详情页，开发 B 写了一个详情页，这在开发阶段、提测后的修改 <code>bug</code> 阶段以及后期迭代阶段，都需要同时维护这 2 个文件，浪费了时间浪费了人力，所以你可以从中意识到编写可复用模块的重要性。</p><p>而 <code>Vue</code> 作者尤大为了让开发者更好的编写可复用模块，提供了很多的手段，比如：组件、自定义指令、渲染函数、插件以及过滤器等。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是 <code>Vue</code> 中最精髓的地方，也是我们平时编写可复用模块最常用的手段，但是由于这块内容篇幅很多，所以不在这里展开，后续会写相关的内容进行详述。</p><h3 id="使用混入-mixins"><a href="#使用混入-mixins" class="headerlink" title="使用混入 mixins"></a>使用混入 mixins</h3><p>什么是混入呢？ 从代码结构上来看，混入其实就是半个组件，一个 <code>Vue</code> 组件可以包括 <code>template</code>、<code>script</code> 和 <code>style</code> 三部分，而混入其实就是 <code>script</code> 里面的内容。一个混入对象包含任意组件选项，比如 <code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code> 、生命周期钩子函数、甚至是 <code>mixins</code> 自己等，混入被设计出来就是旨在提高代码的灵活性、可复用性。</p><p>什么时候应该使用混入呢？当可复用逻辑只是 <code>JS</code> 代码层面的，而无 <code>template</code> 的时候就可以考虑用混入了。比如需要记录用户在页面的停留的时间，那我们就可以把这段逻辑抽出来放在 <code>mixins</code> 里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> statMixin = &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    enterPage() &#123;&#125;,</span><br><span class="line">    leavePage() &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">this</span>.enterPage()</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroyed() &#123;</span><br><span class="line">    <span class="built_in">this</span>.leavePage()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在需要统计页面停留时间的地方加上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; statMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;../common/mixins&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mixins: [statMixin],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用混入的时候要注意和组件选项的合并规则，可以分为如下三类：</p><ul><li><p><code>data</code> 将进行递归合并，对于键名冲突的以组件数据为准：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixinA 的 data</span></span><br><span class="line">data() &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">        name: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// component A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mixins: [mixinA],</span><br><span class="line">    data()&#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">            name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">            age: <span class="number">21</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="built_in">this</span>.obj )  <span class="comment">// &#123; name: &#x27;bubuzou&#x27;, &#x27;age&#x27;: 21 &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于生命周期钩子函数将会合并成一个数组，混入对象的钩子将先被执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixin A</span></span><br><span class="line"><span class="keyword">const</span> mixinA = &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;第一个执行&#x27;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mixin B</span></span><br><span class="line"><span class="keyword">const</span> mixinB = &#123;</span><br><span class="line">    mixins: [mixinA]</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;第二个执行&#x27;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// component A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mixins: [mixinB]</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;最后一个执行&#x27;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p></li></ul><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>除了 <code>Vue</code> 内置的一些指令比如 <code>v-model</code>、<code>v-if</code> 等，<code>Vue</code> 还允许我们自定义指令。在 <code>Vue2.0</code> 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 <code>DOM</code> 元素进行底层操作，这时候就会用到自定义指令。比如我们可以通过自定义一个指令来控制按钮的权限。我们期望设计一个如下形式的指令来控制按钮权限：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-auth</span>=<span class="string">&quot;[&#x27;user&#x27;]&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过在按钮的指令里传入一组权限，如果该按钮只有 <code>admin</code> 权限才可以提交，而我们传入一个别的权限，比如 <code>user</code>，那这个按钮就不应该显示了。<br>接下来我们去注册一个全局的指令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auth.js</span></span><br><span class="line"><span class="keyword">const</span> AUTH_LIST = [<span class="string">&#x27;admin&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAuth</span>(<span class="params">auths</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> AUTH_LIST.some(<span class="function">(<span class="params">item</span>) =&gt;</span> auths.includes(item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  Vue.directive(<span class="string">&#x27;auth&#x27;</span>, &#123;</span><br><span class="line">    inserted(el, binding) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!checkAuth(binding.value)) &#123;</span><br><span class="line">        el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; install &#125;</span><br></pre></td></tr></table></figure><p>然后我们需要在 <code>main.js</code> 里通过安装插件的方式来启用这个指令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Auth <span class="keyword">from</span> <span class="string">&#x27;./utils/auth&#x27;</span></span><br><span class="line">Vue.use(Auth)</span><br></pre></td></tr></table></figure><h3 id="使用渲染函数"><a href="#使用渲染函数" class="headerlink" title="使用渲染函数"></a>使用渲染函数</h3><p>这里将使用渲染函数实现上面介绍过的的权限按钮。<br>使用方式如下，把需要控制权限的按钮包在权限组件 <code>authority</code> 里面，如果有该权限就显示，没有就不显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authority</span> <span class="attr">:auth</span>=<span class="string">&quot;[&#x27;admin&#x27;]&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authority</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们用渲染函数去实现一个 <code>authority</code> 组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">const</span> AUTH_LIST = [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;org&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAuth</span>(<span class="params">auths</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AUTH_LIST.some(<span class="function"><span class="params">item</span> =&gt;</span> auths.includes(item))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    functional: <span class="literal">true</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        auth: &#123;</span><br><span class="line">            type: <span class="built_in">Array</span>,</span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h, context) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; props,  scopedSlots&#125; = context</span><br><span class="line">        <span class="keyword">return</span> checkAuth(props.auth) ? scopedSlots.default() : <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>全局注册这个组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Authority <span class="keyword">from</span> <span class="string">&#x27;./components/authority&#x27;</span></span><br><span class="line">Vue.component(<span class="string">&#x27;authority&#x27;</span>, Authority)</span><br></pre></td></tr></table></figure><h3 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a>使用过滤器</h3><p><code>Vue</code> 提供了自定义过滤器的功能，主要应用场景是想要将数据以某种格式展示出来，而原始数据又不符合这种格式的时候。比如有一组关于人的数据，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;张茂&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;population&quot;</span>: <span class="string">&quot;young&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;王丽&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;population&quot;</span>: <span class="string">&quot;middle&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;郝鹏程&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;population&quot;</span>: <span class="string">&quot;child&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中有一项是关于按照年龄划分的群体类型 <code>population</code>，而它是用 <code>code</code> 进行标识的，我们希望在展示的时候能够显示成对应的中文意思，比如 <code>young</code> 显示成青年。那我们就可以定义一个如下的局部过滤器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  filters: &#123;</span><br><span class="line">    popuFilters(value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;未知&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> index = [<span class="string">&#x27;child&#x27;</span>, <span class="string">&#x27;lad&#x27;</span>, <span class="string">&#x27;young&#x27;</span>, <span class="string">&#x27;middle&#x27;</span>, <span class="string">&#x27;wrinkly&#x27;</span>].indexOf(value)</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        (index &gt; <span class="number">0</span> &amp;&amp; [<span class="string">&#x27;儿童&#x27;</span>, <span class="string">&#x27;少年&#x27;</span>, <span class="string">&#x27;青年&#x27;</span>, <span class="string">&#x27;中年&#x27;</span>, <span class="string">&#x27;老年&#x27;</span>][index]) || <span class="string">&#x27;未知&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用过滤器的时候只要在 <code>template</code> 中这样使用即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; item.population | popuFilters &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><p>在某些情况下，我们封装的内容可能不需要使用者对其内部代码结构进行了解，其只需要熟悉我们提供出来的相应方法和 <code>api</code> 即可，这需要我们更系统性的将公用部分逻辑封装成插件，来为项目添加全局功能，比如常见的 <code>loading</code> 功能、弹框功能等。</p><p>开发 <code>Vue</code> 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象。可以通过如下 4 种方式来自定义插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  Vue.directive(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要在入口文件，比如 <code>main.js</code> 中注册插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyPlugin <span class="keyword">from</span> <span class="string">&#x27;./plugins/plugins.js&#x27;</span></span><br><span class="line">Vue.use(MyPlugin)</span><br></pre></td></tr></table></figure><h2 id="3-种方式手写优雅代码"><a href="#3-种方式手写优雅代码" class="headerlink" title="3 种方式手写优雅代码"></a>3 种方式手写优雅代码</h2><p>平时写项目的时候我们都是在第一时间完成需求功能的开发、提测修改 <code>bug</code> 等，然后开开心心的等待着发布生产以为没啥事情了。其实回过头来细细的看我们平时写的代码，可能会发现很多地方都是值得优化的，比如对于很多重复性很强的代码，比如对于某些写得很繁杂的地方。优雅的代码可以化机械为自动、化繁为简，看人开了如沐春风，心情大好。这里列了几个在 <code>Vue</code> 中一定会遇到的问题，然后通过优雅的方式进行解决。</p><h3 id="自动化导入模块"><a href="#自动化导入模块" class="headerlink" title="自动化导入模块"></a>自动化导入模块</h3><p>在开发一个稍微大点的项目的时候，会习惯将路由按照模块来划分，然后就可能会出现如下这种代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">// 导入了一大堆路由文件</span></span><br><span class="line"><span class="keyword">import</span> mediator <span class="keyword">from</span> <span class="string">&#x27;./mediator&#x27;</span></span><br><span class="line"><span class="keyword">import</span> judges <span class="keyword">from</span> <span class="string">&#x27;./judges&#x27;</span></span><br><span class="line"><span class="keyword">import</span> disputeMediation <span class="keyword">from</span> <span class="string">&#x27;./disputeMediation&#x27;</span></span><br><span class="line"><span class="keyword">import</span> onlineMediation <span class="keyword">from</span> <span class="string">&#x27;./onlineMediation&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useraction <span class="keyword">from</span> <span class="string">&#x27;./useraction&#x27;</span></span><br><span class="line"><span class="keyword">import</span> organcenter <span class="keyword">from</span> <span class="string">&#x27;./organcenter&#x27;</span></span><br><span class="line"><span class="keyword">import</span> admin <span class="keyword">from</span> <span class="string">&#x27;./admin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> routeList = []</span><br><span class="line">routeList.push(</span><br><span class="line">  mediator,</span><br><span class="line">  judges,</span><br><span class="line">  disputeMediation,</span><br><span class="line">  onlineMediation,</span><br><span class="line">  useraction,</span><br><span class="line">  organcenter,</span><br><span class="line">  admin</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  routes: routeList,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其实真实的远远不止这么点，就我本地项目而言就有 20 几个路由文件，写了一大堆的导入代码，显得很臃肿，更无奈的是每当需要新增一个路由模块，还得再次 <code>import</code> 再次 <code>push</code>，那么有没有什么办法可以解决这个问题呢？答案自然是有的。</p><p>利用 <code>webpack</code> 的 <a href="https://webpack.js.org/guides/dependency-management/#requirecontext"><code>require.context</code></a> 就可以很优雅的解决这个问题，使用语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(</span><br><span class="line">  directory, <span class="comment">// 搜索的目录</span></span><br><span class="line">  (useSubdirectories = <span class="literal">true</span>), <span class="comment">// 是否搜索子目录</span></span><br><span class="line">  (regExp = <span class="regexp">/^\.\/.*$/</span>), <span class="comment">// 匹配的目标文件格式</span></span><br><span class="line">  (mode = <span class="string">&#x27;sync&#x27;</span>) <span class="comment">// 同步还是异步</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>有了这个语法，我们就能很容易的写出下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> routeList = []</span><br><span class="line"><span class="keyword">let</span> importAll = <span class="built_in">require</span>.context(<span class="string">&#x27;@/publicResource/router&#x27;</span>, <span class="literal">false</span>, <span class="regexp">/\.js$/</span>)</span><br><span class="line">importAll.keys().map(<span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 因为 index.js 也在 @/publicResource/router 目录下，所以需要排除</span></span><br><span class="line">  <span class="keyword">if</span> (!path.includes(<span class="string">&#x27;index.js&#x27;</span>)) &#123;</span><br><span class="line">    <span class="comment">//兼容处理：.default 获取 ES6 规范暴露的内容; 后者获取 commonJS 规范暴露的内容</span></span><br><span class="line">    <span class="keyword">let</span> router = importAll(path).default || importAll(path)</span><br><span class="line">    routeList(router)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  routes: routeList,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其实不仅仅只是用在导入路由模块这里，对于项目里任何需要导入大量本地模块的地方都可以使用这种方式来解决。</p><h3 id="模块化注册插件"><a href="#模块化注册插件" class="headerlink" title="模块化注册插件"></a>模块化注册插件</h3><p>相信写 <code>Vue</code> 的同学们都知道 <code>element-ui</code> 这个组件库，在使用这个组件库的时候大部分都是只使用某些个别的组件，所以基本上都是按需引入需要的组件，然后就有如下一堆 <code>Vue.use()</code> 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Input,</span><br><span class="line">  Radio,</span><br><span class="line">  RadioGroup,</span><br><span class="line">  Checkbox,</span><br><span class="line">  CheckboxGroup,</span><br><span class="line">  Select,</span><br><span class="line">  <span class="comment">// 还有很多组件</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Input)</span><br><span class="line">Vue.use(Radio)</span><br><span class="line">Vue.use(RadioGroup)</span><br><span class="line">Vue.use(Checkbox)</span><br><span class="line">Vue.use(CheckboxGroup)</span><br><span class="line">Vue.use(Select)</span><br></pre></td></tr></table></figure><p>这样写是没任何问题的，就是看着不够简洁舒服，那更优雅的做法是把这块逻辑抽到一个文件里，然后通过注册插件的方式来使用他们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elementComponent.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Input,</span><br><span class="line">  Radio,</span><br><span class="line">  RadioGroup,</span><br><span class="line">  Checkbox,</span><br><span class="line">  CheckboxGroup,</span><br><span class="line">  Select,</span><br><span class="line">  <span class="comment">// 还有很多组件</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = &#123;</span><br><span class="line">  Input,</span><br><span class="line">  Radio,</span><br><span class="line">  RadioGroup,</span><br><span class="line">  Checkbox,</span><br><span class="line">  CheckboxGroup,</span><br><span class="line">  Select,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(components).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> Vue.use(components[key]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; install &#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>main.js</code> 里使用这个插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> elementComponent <span class="keyword">from</span> <span class="string">&#x27;./config/elementComponent&#x27;</span></span><br><span class="line">Vue.use(elementComponent)</span><br></pre></td></tr></table></figure><h3 id="优雅导出请求接口"><a href="#优雅导出请求接口" class="headerlink" title="优雅导出请求接口"></a>优雅导出请求接口</h3><p>不知道大伙是如何定义请求接口的，就我目前这个项目而言，是这么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api.js</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;./config/httpServer.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 登入页面获取公钥 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getPublicKey = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> http(&#123; <span class="attr">url</span>: <span class="string">&#x27;/userGateway/user/getPublicKey&#x27;</span> &#125;, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> login = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> http(&#123; <span class="attr">url</span>: <span class="string">&#x27;/userGateway/userSentry/login&#x27;</span> &#125;, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证码登录</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loginByCode = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> http(&#123; <span class="attr">url</span>: <span class="string">&#x27;/userGateway/userSentry/loginByCode&#x27;</span> &#125;, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中使用接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; getPublicKey &#125; <span class="keyword">from</span> <span class="string">&#x27;./config/api.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        getPublicKey().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// xxx</span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// xxx</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这一切都很正常，但，我们这个项目总共有 200 多个接口，按照上面这种定义方式的话，一个接口定义加上空行需要占用 5 行，所以如果把全部接口都定义到这个 <code>api.js</code> 里需要占用 1000 行左右，看了实在让人心很慌呀。所以觉得应该这个地方应该可以优化一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/userGateway/user/getPublicKey</span><br></pre></td></tr></table></figure><p>上面这是一个后端给接口路径，斜杆把这个路径划分成 3 个子串，而最后一个子串必定是唯一的，所以我们可以从中做文章。于是乎就有了下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api.js</span></span><br><span class="line"><span class="keyword">const</span> apiList = [</span><br><span class="line">  <span class="string">&#x27;/userGateway/user/getPublicKey&#x27;</span>, <span class="comment">// 登入页面获取公钥</span></span><br><span class="line">  <span class="string">&#x27;/userGateway/userSentry/login&#x27;</span>, <span class="comment">// 用户登录</span></span><br><span class="line">  <span class="string">&#x27;/userGateway/userSentry/loginByCode&#x27;</span>, <span class="comment">// 验证码登录</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apiName,</span><br><span class="line">  API = &#123;&#125;</span><br><span class="line">apiList.forEach(<span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用正则取到接口路径的最后一个子串，比如: getPublicKey</span></span><br><span class="line">  apiName = <span class="regexp">/(?&lt;=\/)[^/]+$/</span>.exec(path)[<span class="number">0</span>]</span><br><span class="line">  API[apiName] = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http(&#123; <span class="attr">url</span>: path &#125;, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> &#123; API &#125;</span><br></pre></td></tr></table></figure><p>这样大概就把定义一个接口需要占用 5 行缩小到只需要 1 行了，大大减小了文件内容。在浏览这个文件的时候，我的鼠标滚轮也不会一直在滚滚滚了。</p><p>如果是这样定义接口的话，那在使用的时候还需要做点变化的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; API &#125; <span class="keyword">from</span> <span class="string">&#x27;./config/api.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        API.getPublicKey().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// xxx</span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// xxx</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="4-种-event-传参方式"><a href="#4-种-event-传参方式" class="headerlink" title="4 种$event 传参方式"></a>4 种$event 传参方式</h2><p>在进行实际项目开发的时候经常会需要通过事件传递参数，这里总结了 4 种应用场景。</p><h3 id="用于组件通信"><a href="#用于组件通信" class="headerlink" title="用于组件通信"></a>用于组件通信</h3><p>比如子组件通过 <code>$emit</code> 来调用父组件方法的时候，可以在父组件中用 <code>$event</code> 接收到从子组件传递过来的参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;changeText&#x27;, &#x27;18px&#x27;)&quot;</span>&gt;</span>点击加大字号<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> @<span class="attr">changeText</span>=<span class="string">&quot;changeText(&#x27;article&#x27;, $event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">changeText(type, value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(type, value)  <span class="comment">// &#x27;article&#x27; &#x27;18px&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子组件传递过来的参数有多个，这个时候用 <code>$event</code> 就不太行了，此时可以用 <code>arguments</code> 代替：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;changeText&#x27;, &#x27;red&#x27;, &#x27;18px&#x27;)&quot;</span>&gt;</span>点击改变样式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> @<span class="attr">changeText</span>=<span class="string">&quot;changeText(...arguments, &#x27;article&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">changeText(...value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( value )  <span class="comment">// [&#x27;red&#x27;, &#x27;18px&#x27;, &#x27;article&#x27;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递原生-DOM-事件对象"><a href="#传递原生-DOM-事件对象" class="headerlink" title="传递原生 DOM 事件对象"></a>传递原生 DOM 事件对象</h3><p>比如我们需要获取到当前的点击元素，就可以通过给点击事件传递 <code>$event</code> 参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;submit(&#x27;first&#x27;, $event)&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">submit(type, event) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = event.target.tagName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用于第三方类库事件回调"><a href="#用于第三方类库事件回调" class="headerlink" title="用于第三方类库事件回调"></a>用于第三方类库事件回调</h3><p>比如有一个组件里使用了好几个 <code>element-ui</code> 的分页组件，每个分页都有一个 <code>current-change</code> 事件，用来处理当分页改变之后的事情，这样的话我们就需要写多个回调函数，但是如果用以下方式，我们就也可以只写一个函数，通过 <code>type</code> 来判断是哪个分页的回调，而 <code>$event</code> 则用来传递 <code>current-change</code> 回调默认的参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面列表的分页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span> @<span class="attr">current-change</span>=<span class="string">&quot;changePage(&#x27;main&#x27;, $event)&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 弹窗A列表的分页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span> @<span class="attr">current-change</span>=<span class="string">&quot;changePage(&#x27;modalA&#x27;, $event)&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 弹窗B列表的分页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span> @<span class="attr">current-change</span>=<span class="string">&quot;changePage(&#x27;modalB&#x27;, $event)&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">changePage(type, page) &#123;</span><br><span class="line">    <span class="keyword">const</span> types = [<span class="string">&#x27;main&#x27;</span>, <span class="string">&#x27;modalA&#x27;</span>, <span class="string">&#x27;modalB&#x27;</span>]</span><br><span class="line">    types[type] &amp;&amp; (<span class="built_in">this</span>[types[type]].pageIndex = page) &amp;&amp; <span class="built_in">this</span>.getList(type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用箭头函数处理"><a href="#使用箭头函数处理" class="headerlink" title="使用箭头函数处理"></a>使用箭头函数处理</h3><p>对于第三种场景，使用第三方类库组件的时候，需要给事件回调增加额外的参数，如果默认的回调参数只有 1 个那么我们就可以使用上面的那种方式，但是如果回调参数有多个的话，用 <code>$event</code> 就不好处理了，可以使用箭头函数。比如文件上传的时候，有个 <code>on-change</code> 属性，当文件变化的时候就会触发回调，正常情况下我们这样写是没问题的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span> <span class="attr">:on-change</span>=<span class="string">&quot;changeFile&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">changeFile(file, fileList) &#123;&#125;</span><br></pre></td></tr></table></figure><p>但是如果一个组件里有多个文件上传，而我们又不想写多个 <code>changeFile</code>，那就需要传递额外的参数 <code>type</code> 了 ：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span> <span class="attr">:on-change</span>=<span class="string">&quot;(file, fileList) =&gt; changeFile(&#x27;org&#x27;, file, fileList)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">changeFile(type, file, fileList) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="3-种深入-watch-的用法"><a href="#3-种深入-watch-的用法" class="headerlink" title="3 种深入 watch 的用法"></a>3 种深入 watch 的用法</h2><h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><p><code>watch</code> 是 <code>Vue</code> 中的侦听器，可以侦听一个 <code>Vue</code> 实例上的数据，当数据变动的时候，就会触发该侦听器。所以他的应用场景就是：当某个数据变动后需要做什么的时候就可以使用 <code>watch</code> 啦。<br>对于 <code>watch</code>，平常我们写得最多的估计是如下这种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    list: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getMsg()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们希望组件初始化的时候就执行一次 <code>getMsg</code> 方法，可以直接在 <code>mounted</code> 里调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">this</span>.getMsg()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，还有一种更加简便的写法，通过给 <code>watch</code> 设置 <code>immediate: true</code> ，即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    list: &#123;</span><br><span class="line">        handler(val) &#123;  <span class="comment">// 注意别写错成 handle</span></span><br><span class="line">            <span class="built_in">this</span>.getMsg()</span><br><span class="line">        &#125;,</span><br><span class="line">        immediate: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度监听"><a href="#深度监听" class="headerlink" title="深度监听"></a>深度监听</h3><p>侦听器对于属性变更后会自动调用一次，但是仅限于该属性本身，如果变更的是属性的属性，则不会触发侦听回调，如果想要实现这个功能可以给 <code>watch</code> 加上 ‘deep: true’ 即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">        handler(val) &#123; <span class="comment">// do something &#125;,</span></span><br><span class="line">        deep: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">this</span>.obj.name = <span class="string">&#x27;bubuzou&#x27;</span>  <span class="comment">// 将触发 handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个-handlers"><a href="#多个-handlers" class="headerlink" title="多个 handlers"></a>多个 handlers</h3><p>实际上，<code>watch</code> 可以设置为数组，支持类型为 <code>String</code>、<code>Object</code> 和 <code>Function</code>。触发后，多个处理函数都将被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    obj: [</span><br><span class="line">        <span class="string">&#x27;print&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            handler: <span class="string">&#x27;print&#x27;</span>,</span><br><span class="line">            deep: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">val, oldValue</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(val)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-个其他开发小技巧"><a href="#5-个其他开发小技巧" class="headerlink" title="5 个其他开发小技巧"></a>5 个其他开发小技巧</h2><p>掌握 <code>Vue</code> 的开发小技巧，在一些特定的场景下真的很管用，这里列了一些常用的小技巧。</p><h3 id="函数式组件实现零时变量"><a href="#函数式组件实现零时变量" class="headerlink" title="函数式组件实现零时变量"></a>函数式组件实现零时变量</h3><p>我们在使用插槽的时候，知道有一个叫做插槽 <code>prop</code> 的知识，今天我们用他和函数式组件结合在一块，实现一个零时变量的组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tempvar.vue</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    functional: <span class="literal">true</span>,</span><br><span class="line">    render(h, context) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; props,  scopedSlots&#125; = context</span><br><span class="line">        <span class="keyword">return</span> scopedSlots.default &amp;&amp; scopedSlots.default(props || &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>定义好了函数式组件，我们就可以在需要的地方引入且使用他：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tempvar</span> <span class="attr">:var1</span>=<span class="string">&quot;`hello $&#123;user.name&#125;`&quot;</span> <span class="attr">:var2</span>=<span class="string">&quot;user.age ? user.age : &#x27;18&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123;var1, var2&#125;&quot;</span>&gt;</span></span><br><span class="line">      姓名： &#123;&#123; var1 &#125;&#125; 年龄：&#123;&#123; var2 &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tempvar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> tempvar <span class="keyword">from</span> <span class="string">&#x27;@/components/tempvar.vue&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">      data() &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line">              user: &#123;</span><br><span class="line"><span class="javascript">                  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span></span><br><span class="line">                  age: 12,</span><br><span class="line">              &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      components: &#123;</span><br><span class="line">          tempvar</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可能细心的小伙伴发现了，要把名字前加个 <code>hello</code>、默认年龄设置为 <code>18</code> 用计算属性就可以了呀？为啥还要搞那么复杂，专门用一个函数式组件去实现呢？其实这个小技巧还是很有必要存在的，当许多组件都有这种数据的重新计算的时候，如果没有使用这个技巧，那么就需要写很多很多的计算属性，而有了函数式组件 <code>tempvar</code> 后，只需要在组件里引入他，然后写插槽就好了。就相当于把写计算属性的功夫花在了写插槽上了。总而言之，两种方式都可以实现类似的属性计算功能，该怎么选，随你喜欢啦。</p><h3 id="调试-template（不推荐）"><a href="#调试-template（不推荐）" class="headerlink" title="调试 template（不推荐）"></a>调试 template（不推荐）</h3><p>在开发调试的时候经常会需要通过 <code>console.log</code> 来打印出某个数据对象来查看其内部的结构或者字段值，但是这样做肯定不必在 <code>template</code> 里将其输出更直接。比如有这样一个数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj: &#123;</span><br><span class="line">    name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">    age: <span class="number">21</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模板中展示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面渲染完成后会看到：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;name&quot;: &quot;bubuzou&quot;, &quot;age&quot;: 21 &#125;</span><br></pre></td></tr></table></figure><p>对于这样的渲染结果虽然没什么问题，但是如果这个 <code>obj</code> 是层级很深且字段很多的数据，显示出来就会一堆数据砸在一块，丝毫没有阅读体验。</p><p>因此基于这个背景，我们可以将 <code>console.log</code> 挂载在 <code>Vue</code> 的实例原型上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$log = <span class="built_in">window</span>.console.log</span><br></pre></td></tr></table></figure><p>然后就可以开开心心在模板中使用他了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; $log( obj ) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样会在浏览器控制台输出当前的数据对象，在显示效果上和 <code>console.log</code> 直接打印别无二致。</p><p>但说了这么多，使用 <code>Vue</code> 进行开发调试还是强烈推荐官方的<a href="https://github.com/vuejs/vue-devtools">vue-devtools</a> 工具，谁用谁知道。</p><h3 id="监听子组件的钩子函数"><a href="#监听子组件的钩子函数" class="headerlink" title="监听子组件的钩子函数"></a>监听子组件的钩子函数</h3><p>通常如果我们想在子组件钩子函数触发的时候通知父组件，我们可以这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> @<span class="attr">mounted</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;mounted&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其实还有一种更加简单的写法，那就是使用 <code>hookEvent</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> @<span class="attr">hook:mounted</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>钩子函数除了以上用法，还可以通过动态注册做一些别的事情，比如组件销毁前进行资源的释放：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">let</span> setIntervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">888</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.$once(<span class="string">&quot;hook:beforeDestroy&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(setIntervalId)</span><br><span class="line">        setIntervalId = <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由参数解耦"><a href="#路由参数解耦" class="headerlink" title="路由参数解耦"></a>路由参数解耦</h3><p>参数解耦，啥意思呢？别着急，我们先来看比如对于这么一串路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home/:type/:id&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>当前页面的路径是 <code>http://xxx/detail/preview/21?sex=male</code>，平时我们写代码的时候或多或少的会写出这种代码，在组件里使用 <code>$route</code> 给组件传参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.$route.params.type === <span class="string">&#x27;preview&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.isPreview = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isPreview = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.id = <span class="built_in">this</span>.$route.params.id</span><br><span class="line">    <span class="built_in">this</span>.sex = <span class="built_in">this</span>.$route.query.sex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子写本身没什么问题，就是会使得组件和路由高度耦合，让组件只能在含有特定 <code>URL</code> 的页面中使用，限制了组件的通用性。其实，我们可以通过 <code>props</code> 传参，来解耦路由参数，将上面的路由配置改成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home/:type/:id&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    props: <span class="function">(<span class="params">route</span>) =&gt;</span> (&#123;</span><br><span class="line">      type: route.params.type,</span><br><span class="line">      id: route.params.id,</span><br><span class="line">      sex: route.query.sex,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后在组件 <code>props</code> 加上参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]</span><br></pre></td></tr></table></figure><p>组件里使用参数的时候就不需要用 <code>this.$route</code>，而是可以直接 <code>this.type</code> 即可。这样一来，这个组件就可以在任何地方使用了。</p><h3 id="深度作用选择器"><a href="#深度作用选择器" class="headerlink" title="深度作用选择器"></a>深度作用选择器</h3><p>当给 <code>style</code> 加上 <code>scoped</code>，页面渲染完成后会给 <code>html</code> 和 <code>css</code> 选择器加上哈希值用于表示唯一性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span> <span class="attr">data-v-fae5bece</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-v-fae5bece</span> <span class="attr">class</span>=<span class="string">&quot;el-button el-button-primary&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.home</span> <span class="selector-class">.el-button</span><span class="selector-attr">[data-v-fae5bece]</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于在 <code>style</code> 中被加了 <code>scoped</code> 的组件，其样式将只能作用于组件内部，不会对其子组件造成影响。比如有这样一个组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>父按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.home</span> <span class="selector-class">.el-button</span> &#123;</span></span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>子按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当页面渲染出来后，会是如下结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span> <span class="attr">data-v-fae5bece</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-v-fae5bece</span> <span class="attr">class</span>=<span class="string">&quot;el-button el-button-primary&quot;</span>&gt;</span>父按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span> <span class="attr">data-v-fae5bece</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;el-button el-button-primary&quot;</span>&gt;</span>子按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据上面的 <code>html</code>，我们可以看到 <code>.home .el-button[data-v-fae5bece]</code> 这个选择器作用不到子按钮这个 <code>button</code>。</p><p>在实际项目中，我们有时候需要让父组件的样式能作用到子组件，即使父组件的 <code>style</code> 上加了 <code>scoped</code>，那这个时候就需要用到深度作用选择器 <code>&gt;&gt;&gt;</code>，比如在刚刚的例子上可以给父组件样式加上深度作用选择器。</p><blockquote><p>深度作用选择器会被 <code>Vue Loader</code> 处理，且只能在有预处理器的地方使用。由于某些预处理器比如 <code>Sass</code> 不能正确解析 <code>&gt;&gt;&gt;</code>，所以我们可以使用它的别名：<code>/deep/</code> 或 <code>::v-deep</code> 来替代。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line"><span class="selector-class">.home</span> &#123;</span><br><span class="line">    /deep/ .el-button &#123;</span><br><span class="line">        <span class="selector-tag">font-size</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>加上深度作用选择器后，选择器会由原来的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.home</span> <span class="selector-class">.el-button</span><span class="selector-attr">[data-v-fae5bece]</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变成如下的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.home</span><span class="selector-attr">[data-v-fae5bece]</span> <span class="selector-class">.el-button</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.im/post/6844903686926254087">vue 篇之事件总线（EventBus）</a></li><li>《Vue 开发实战》</li></ul><h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><p>如果本文对你有帮助的话，给本文点个在看吧</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202009/gzh.png" alt="大海我来了"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我学习整理的关于 &lt;code&gt;Vue.js&lt;/code&gt; 系列文章的第一篇，另外还有两篇分别是关于优化和原理的。希望读完这 3 篇文章，你能对 &lt;code&gt;Vue&lt;/code&gt; 有个更深入的认识。&lt;/p&gt;
&lt;h2 id=&quot;7-种组件通信方式随你选&quot;&gt;&lt;a href=&quot;#7-种组件通信方式随你选&quot; class=&quot;headerlink&quot; title=&quot;7 种组件通信方式随你选&quot;&gt;&lt;/a&gt;7 种组件通信方式随你选&lt;/h2&gt;&lt;p&gt;组件通信是 &lt;code&gt;Vue&lt;/code&gt; 的核心知识，掌握这几个知识点，面试开发一点问题都没有。&lt;/p&gt;
&lt;h3 id=&quot;props-on-emit&quot;&gt;&lt;a href=&quot;#props-on-emit&quot; class=&quot;headerlink&quot; title=&quot;props/@on+$emit&quot;&gt;&lt;/a&gt;props/@on+$emit&lt;/h3&gt;&lt;p&gt;用于实现父子组件间通信。通过 &lt;code&gt;props&lt;/code&gt; 可以把父组件的消息传递给子组件：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- parent.vue --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;:title&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;child&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://bubuzou.com/categories/vue/"/>
    
    
      <category term="vue" scheme="https://bubuzou.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>小程序升级WePY2踩坑记</title>
    <link href="https://bubuzou.com/2020/08/06/wepy2/"/>
    <id>https://bubuzou.com/2020/08/06/wepy2/</id>
    <published>2020-08-06T13:39:57.000Z</published>
    <updated>2021-09-09T02:01:11.004Z</updated>
    
    <content type="html"><![CDATA[<p>最近有个小程序项目需要迭代，但是迭代任务不多，时间比较充裕。而这个小程序最早是在 18 年的时候开发的，用的开发框架是 <code>WePY</code> 的 <code>1.7.2</code> 版本，去年也就是 <code>19</code> 年的时候 <code>WePY</code> 框架进行了升级，到了 <code>2.0</code> 版本。升级之后的 <code>WePY</code>，用 <a href="https://wepyjs.github.io/wepy-docs/2.x/#/"><code>WePY</code></a> 官方文档的话来说：通过优化细节，引入 <code>Promise</code>、<code>Async Functions</code> 等让开发小程序项目变得更加简单，高效。基于这些背景，我和小伙伴一拍即合，决定对我们的项目进行框架升级，体验下到底 <code>WePY2</code> 能给我们带来什么。</p><p>本文将以项目改动为出发点，基于当前这个项目的结构和编码方式来考虑到底升级 <code>WePY2</code> 后，哪里需要改，怎么改以及有哪些需要注意的地方，通过对比 <code>2</code> 个版本的写法差异这个思路来写，不会去太较真 <code>WePY2</code> 相对于 <code>WePY1</code> 实现或原理上的区别。下面我将一条一条的列出来需要改动的点。</p><blockquote><p>本篇文章记录的是我和小伙伴这次升级框架遇到的需要改动的地方和坑，所使用的是 <code>wepy</code> 的 <code>2.1.0</code> 版本，后续如果版本升级后，本篇记录到的坑如果已经被修复了，请自行忽略本文所述的问题。另外下文中所说到的 <code>2.x</code> 版本都是指 <code>wepy_v2.1.0</code>。</p></blockquote><a id="more"></a><h2 id="初始化一个-WePY2-的-demo"><a href="#初始化一个-WePY2-的-demo" class="headerlink" title="初始化一个 WePY2 的 demo"></a>初始化一个 WePY2 的 demo</h2><p>由于本地还有其他项目用的是 <code>WePY_v1.7.2</code>，所以我们不能把 <code>WePY2</code> 的 <code>CLI</code> 工具安装在全局环境中，只能安装在当前项目中。官方推荐是直接用 <code>1.7.x</code> 的 <code>CLI</code> 去初始化 <code>2.0.x</code> 的项目:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wepy init standard#2.0.x zzodr</span><br></pre></td></tr></table></figure><p>这样就能够在本地初始化一个 <code>wepy2</code> 的项目模板，但是 <code>@wepy/core</code> 是 <code>2.0.0-alpha.16</code> 版本的，将它更新到最新的 <code>2.1.0</code> 版本，这里也一起更新下整个旧项目和新模板所用到的依赖，下面直接贴出来：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@wepy/core&quot;</span>: <span class="string">&quot;^v2.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@wepy/use-intercept&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@wepy/use-promisify&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@wepy/x&quot;</span>: <span class="string">&quot;^2.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;miniprogram-slide-view&quot;</span>: <span class="string">&quot;0.0.3&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@babel/core&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/preset-env&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@wepy/babel-plugin-import-regenerator&quot;</span>: <span class="string">&quot;0.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@wepy/cli&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@wepy/compiler-babel&quot;</span>: <span class="string">&quot;^2.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@wepy/compiler-sass&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@wepy/plugin-define&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-eslint&quot;</span>: <span class="string">&quot;^7.2.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cross-env&quot;</span>: <span class="string">&quot;^5.1.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span>: <span class="string">&quot;^3.18.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-config-standard&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-friendly-formatter&quot;</span>: <span class="string">&quot;^2.0.7&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-plugin-html&quot;</span>: <span class="string">&quot;^2.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-plugin-promise&quot;</span>: <span class="string">&quot;^3.5.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-plugin-standard&quot;</span>: <span class="string">&quot;^2.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;wepy-eslint&quot;</span>: <span class="string">&quot;^1.5.3&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来操作主要是删除模板里的代码，然后把项目的结构和代码搬过去。</p><h2 id="wpy-文件代码结构调整"><a href="#wpy-文件代码结构调整" class="headerlink" title="wpy 文件代码结构调整"></a>wpy 文件代码结构调整</h2><p><code>WePy</code> 单文件组件主要由 <code>&lt;script&gt;</code>、<code>&lt;template&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;config&gt;</code> 四部分组成（也包括小程序 <code>&lt;wxs&gt;</code> 标签）。所以需要把 <code>WePY 1.7.2</code> 中定义在 <code>&lt;script&gt;</code> 中的 <code>config</code> 配置需要独立到外层的 <code>&lt;config&gt;</code> 中。<br><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">    config = &#123;</span><br><span class="line"><span class="javascript">      navigationBarTitleText: <span class="string">&#x27;首页&#x27;</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span> &#123; navigationBarTitleText: &#x27;首页&#x27; &#125; <span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="程序-页面-组件注册方式调整"><a href="#程序-页面-组件注册方式调整" class="headerlink" title="程序/页面/组件注册方式调整"></a>程序/页面/组件注册方式调整</h2><p>注册方式将不再使用继承的方式，而是改成直接调用对应的实例方法。<br><code>1.7.2</code> 写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">app</span> </span>&#123;&#125;  <span class="comment">// 注册程序</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;&#125;  <span class="comment">// 注册页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">LIST</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">component</span> </span>&#123;&#125;  <span class="comment">// 注册组件</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wepy.app(&#123;&#125;) <span class="comment">// 注册程序</span></span><br><span class="line">wepy.page(&#123;&#125;) <span class="comment">// 注册页面</span></span><br><span class="line">wepy.component(&#123;&#125;) <span class="comment">// 注册组件</span></span><br></pre></td></tr></table></figure><h2 id="代码结构由类结构变成对象结构"><a href="#代码结构由类结构变成对象结构" class="headerlink" title="代码结构由类结构变成对象结构"></a>代码结构由类结构变成对象结构</h2><p>由于注册方式的改变，那么自然的代码结构也要有所调整。<br><code>1.7.2</code> 写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span><br><span class="line">  data = &#123;&#125;</span><br><span class="line">  methods = &#123;&#125;</span><br><span class="line">  onLoad() &#123;&#125;</span><br><span class="line">  onShow() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wepy.page(&#123;</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  onLoad() &#123;&#125;,</span><br><span class="line">  onShow() &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面仅仅只是以页面做为例子，<code>wepy.app()</code> 和 <code>wepy.component()</code> 也要对应调整。</p><h2 id="自定义方法和组件事件处理函数需要移到-methods-里"><a href="#自定义方法和组件事件处理函数需要移到-methods-里" class="headerlink" title="自定义方法和组件事件处理函数需要移到 methods 里"></a>自定义方法和组件事件处理函数需要移到 methods 里</h2><p>在 <code>WePY 1.7.2</code> 中注册的页面或者组件函数有这么几种类型：</p><ul><li>生命周期函数，比如 <code>onLoad</code>、<code>onShow</code> 等；</li><li><code>wxml</code> 事件处理函数，即在 <code>wxml</code> 中绑定的事件，这类函数需要定义在 <code>methods</code>，比如：<code>bindtap</code>、<code>bindchange</code> 等；</li><li>组件间事件处理函数，响应组件之间通过 <code>$broadcast</code>、<code>$emit</code>、<code>$invoke</code> 所传递的事件函数，这类函数需要定义在 <code>events</code> 对象里；</li><li>自定义函数，即用于被其他函数直接调用的函数，需要定义在和 <code>methods</code> 同级的位置。</li></ul><p>而在 <code>WePY 2</code> 中需要将组件处理函数和自定义函数都放到 <code>methods</code> 里。下面假设 <code>HOME</code> 页面有一个子组件 <code>child</code>，且子组件里会执行这句 <code>this.$emit(&#39;updateList)</code>，基于这个背景看下 <code>2</code> 个版本下的写法差异：</p><p><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">&quot;tapBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line"><span class="javascript">    onLoad() &#123;&#125; <span class="comment">// 生命周期函数</span></span></span><br><span class="line"><span class="javascript">    onShow() &#123;&#125; <span class="comment">// 生命周期函数</span></span></span><br><span class="line">    events = &#123;</span><br><span class="line"><span class="javascript">      updateList: <span class="function">() =&gt;</span> &#123;&#125;, <span class="comment">// 组件间事件处理函数</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    methods = &#123;</span><br><span class="line">      tapBox() &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// wxml事件处理函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.getMsg()</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    getMsg() &#123;&#125; <span class="comment">// 自定义函数</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> @<span class="attr">tap</span>=<span class="string">&quot;tapBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  wepy.page(&#123;</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line"><span class="javascript">    onLoad() &#123;&#125;, <span class="comment">// 生命周期函数</span></span></span><br><span class="line"><span class="javascript">    onShow() &#123;&#125;, <span class="comment">// 生命周期函数</span></span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      tapBox() &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// wxml事件处理函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.getMsg()</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      updateList() &#123;&#125;, <span class="comment">// 组件间事件处理函数</span></span></span><br><span class="line"><span class="javascript">      getMsg() &#123;&#125;, <span class="comment">// 自定义函数</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件引入方式变更"><a href="#组件引入方式变更" class="headerlink" title="组件引入方式变更"></a>组件引入方式变更</h2><p>在 <code>2.x</code> 版本中组件引入不再通过 <code>import</code> 进行导入，而是直接定义在页面的配置 <code>&lt;config&gt;</code> 中。<br><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&#x27;./components/child.wpy&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">    components = &#123;</span><br><span class="line">      child: Child,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  wepy.page(&#123;&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span> &#123; usingComponents: &#123; &#x27;child&#x27;: &#x27;./components/child.wpy&#x27;, &#125; &#125; <span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，<code>2.x</code> 中已经再不支持在 <code>app.wpy</code> 里定义全局组件，而 <code>1.7.2</code> 中是可以的。</p><h2 id="生命周期函数调整"><a href="#生命周期函数调整" class="headerlink" title="生命周期函数调整"></a>生命周期函数调整</h2><p>在 <code>2.x</code> 中生命周期函数基本和原生保持一致，和 <code>1.7.2</code> 相比，只是需要把组件中的 <code>onLoad</code> 改成了 <code>ready</code> 即可，其他无需变动。</p><table><thead><tr><th align="center">级别</th><th align="center">1.7.2</th><th align="center">2.x</th></tr></thead><tbody><tr><td align="center">app</td><td align="center">onLaunch</td><td align="center">onLaunch</td></tr><tr><td align="center">app</td><td align="center">onShow</td><td align="center">onShow</td></tr><tr><td align="center">page</td><td align="center">onLoad</td><td align="center">onLoad</td></tr><tr><td align="center">page</td><td align="center">onShow</td><td align="center">onShow</td></tr><tr><td align="center">page</td><td align="center">onReady</td><td align="center">onReady</td></tr><tr><td align="center">component</td><td align="center">-</td><td align="center">created</td></tr><tr><td align="center">component</td><td align="center">-</td><td align="center">attached</td></tr><tr><td align="center">component</td><td align="center">onLoad</td><td align="center">ready</td></tr></tbody></table><p><code>2.x</code> 生命周期执行顺序：</p><p><code>app onLaunch</code> -&gt; <code>app onShow</code> -&gt; <code>component created</code> -&gt; <code>component attached</code> -&gt; <code>page onLoad</code> -&gt; <code>page onShow</code> -&gt; <code>component ready</code> -&gt; <code>page onReady</code> -&gt; <code>page onUnload</code> -&gt; <code>component detached</code></p><blockquote><p><code>page onHide</code> 在当前页面通过 <code>wx.navigateTo</code> 打开新页面的时候会执行，而如果是在当前页面点击返回上一个页面或者 <code>wx.redirectTo</code> 并不会执行。</p></blockquote><h2 id="不再支持请求拦截器（坑）"><a href="#不再支持请求拦截器（坑）" class="headerlink" title="不再支持请求拦截器（坑）"></a>不再支持请求拦截器（坑）</h2><p>在 <code>1.7.2</code> 中可以在 <code>wepy.app</code> 的构造函数里通过配置拦截器可以对请求进行拦截，请求被拦截后可以加上更多的请求参数以及请求响应后可以进行统一的错误处理，功能还是挺好用的。但是在 <code>2.x</code> 中这个功能至少从文档上是没看到，虽然源码里提供了一个 <a href="https://github.com/Tencent/wepy/tree/master/packages/use-intercept">use-intercept</a>拦截器的包，但是经过我几番尝试之后还是报错，所以就打算弃用拦截器了，直接在请求里进行参数增加和错误处理。<br><code>request.js</code> 这里贴一份大概的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wepy <span class="keyword">from</span> <span class="string">&#x27;@wepy/core&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; HOST &#125; <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">url, data, handler = toast, header = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 头参数添加</span></span><br><span class="line">  header[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  header[<span class="string">&#x27;cType&#x27;</span>] = <span class="string">&#x27;WECHAT&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wepy.wx</span><br><span class="line">    .request(&#123;</span><br><span class="line">      <span class="comment">// 这里 wepy.wx.request 这种写法，需要在app.wpy里配置promisify，</span></span><br><span class="line">      method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      data: data || &#123;&#125;,</span><br><span class="line">      header,</span><br><span class="line">      url: <span class="string">`<span class="subst">$&#123;HOST&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 请求成功处理代码放这儿</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 错误处理代码放这儿</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>wepy.wx.request</code> 这种写法需要在 <code>app.wpy</code> 里配置 <code>promisify</code>，可以参考这里 <a href="https://github.com/Tencent/wepy/tree/master/packages/use-promisify">use-promisify</a></p><h2 id="标签属性的值必须被双引号包裹"><a href="#标签属性的值必须被双引号包裹" class="headerlink" title="标签属性的值必须被双引号包裹"></a>标签属性的值必须被双引号包裹</h2><p>在 <code>1.7.2</code> 中对单引号和双引号没有强制要求，但是在 <code>2.x</code> 中必须是双引号，不然编译会报错。<br><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;change&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">       &lt;view class&#x3D;&quot;title&quot; bindtap&#x3D;&quot;change&quot;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h2 id="调用原生事件需要传入参数-wx"><a href="#调用原生事件需要传入参数-wx" class="headerlink" title="调用原生事件需要传入参数$wx"></a>调用原生事件需要传入参数$wx</h2><p>小程序原生事件会传递一个 event 参数。而 <code>WePY</code> 的事件分发器在处理事件时会有一个 <code>$event</code> 参数。 <code>$event</code> 参数是对 <code>event</code> 进行了一层包装，目地是为了无侵入地对齐 <code>Web Event</code> 标准属性。而其中 <code>$event.$wx === event</code>。 因此，<code>WePY</code> 中响应事件获得的事件参数均是指 <code>$event</code>。如果想拿到原生事件参数，请使用 <code>$event.$wx</code>。<br><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">bindinput</span>=<span class="string">&quot;setInput&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;name&#125;&#125;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">    data = &#123;</span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">    methods = &#123;</span><br><span class="line">      setInput(e) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.name = e.detail.value</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法，只需要将 <code>bindinput=&quot;setInput&quot;</code> 改成 <code>@input=&quot;setInput($wx)&quot;</code> 即可。</p><h2 id="模板语法修改"><a href="#模板语法修改" class="headerlink" title="模板语法修改"></a>模板语法修改</h2><p><code>2.x</code> 的模板语法继承了 <code>WXML</code> 的基本模板语法，并支持大部分 <code>Vue</code> 模板语法。<br>对于标签：<code>2.x</code> 支持绝大部分的 <code>HTML</code> 标签，经过编译后会转成标准的 <code>WXML</code> 模板语法。但是对于 <code>1.7.2</code> 中的有一个标签 <code>&lt;repeat&gt;</code> 不再支持，需要将其替换成 <code>&lt;view&gt;</code> 并且用 <code>v-for</code> 进行循环渲染。</p><p>下面是一些常用的模板语法对于 <code>2</code> 个版本之间写法的对比：<br><code>1.7.2</code> 写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 属性绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">&quot;&#123;&#123; id &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 事件绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">&quot;change(&#123;&#123; index &#125;&#125;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- class绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;change &#123;&#123;hasData ? &#x27;has-data&#x27; : &#x27;&#x27; &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- style绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;&#123;&#123; &#x27;color:&#x27; + color + &#x27;;&#x27; + &#x27;font-size:&#x27; + fontSize + &#x27;;&#x27; &#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 条件判断 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123; flag1 &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123; flag2 &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 显示判断 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">hidden</span>=<span class="string">&quot;&#123;&#123; !isShow &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 列表渲染，默认是：item、index --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123; array &#125;&#125;&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;idx&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;itemName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 属性绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">:id</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 事件绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> @<span class="attr">tap</span>=<span class="string">&quot;change( index )&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- class绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;change&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; &#x27;has-data&#x27;: hasData &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- style绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;&#x27;color&#x27;: color, &#x27;font-size&#x27;: fontSize &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 条件判断 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-if</span>=<span class="string">&quot;flag1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-else-if</span>=<span class="string">&quot;flag2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 显示判断 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 列表渲染，默认是：item、index --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in array&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于 <code>v-for</code> 循环列表的时候这里有一个（坑）不得不提一下，<a href="https://github.com/Tencent/wepy/issues/2673#issue-673257402">github issues</a>直接看下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">v-for</span>=<span class="string">&quot;item in array&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> @<span class="attr">tap</span>=<span class="string">&quot;tapItem(index)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于上面的代码，<code>&lt;view&gt;&#123;&#123; index &#125;&#125;&lt;/view&gt;</code> 可以正常显示索引值 <code>index</code>，但是 <code>tapItem</code> 传的参数却是 <code>undefined</code>，这所以我们需要显示的声明索引 <code>v-for=&quot;(item, index) in array&quot;</code> 即可。</p><h2 id="表单双向绑定调整"><a href="#表单双向绑定调整" class="headerlink" title="表单双向绑定调整"></a>表单双向绑定调整</h2><p><code>2.x</code> 中直接用 <code>v-model</code> 进行表单绑定，而不需要再定义一个函数对其进行赋值操作。<br><code>1.7.2</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; name &#125;&#125;&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;setInput&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">    data = &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">    methods = &#123;</span><br><span class="line">        bindtap(e) &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.name = e.detail.value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">wepy.page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="全局数据属性获取方式调整"><a href="#全局数据属性获取方式调整" class="headerlink" title="全局数据属性获取方式调整"></a>全局数据属性获取方式调整</h2><p>我们有时候需要在 <code>app.wpy</code> 里定义全局数据属性 <code>globalData</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">app</span> </span>&#123;</span><br><span class="line">  globalData = &#123;</span><br><span class="line">    isBack: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>2.x</code> 中定义方式没变，但是获取方式有所调整：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.7.2 获取方式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.globalData.isBack)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.x 获取方式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$app.$options.globalData.isBack)</span><br></pre></td></tr></table></figure><h2 id="全局样式对组件无效"><a href="#全局样式对组件无效" class="headerlink" title="全局样式对组件无效"></a>全局样式对组件无效</h2><p><code>2.x</code> 中对组件的实现方式保留了很多原生小程序的特性，比如这一条，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html">组件样式</a> 中明确说明：除继承样式外， <code>app.wxss</code> 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项），虽然可以通过更改组件样式隔离选项使得组件可以被全局样式作用到，但有时候也会带来弊端，比如在标签的属性 <code>class</code> 前面加上 <code>~</code>，可以使组件获取全局样式，但是这样一来也带来一个问题，就是定义在组件里的该 <code>class</code> 样式会失效 😭。这样的升级真的让写样式很难受，所以为了让样式写得尽量方便简单，我还是老老实实的把组件的样式就定义在组件里，不从全局拿样式了。</p><h2 id="组件通信不再支持-broadcast"><a href="#组件通信不再支持-broadcast" class="headerlink" title="组件通信不再支持$broadcast"></a>组件通信不再支持$broadcast</h2><p>父组件给子组件传递数据可以通过设置静态或者动态的 <code>prop</code> 属性或者通过广播 <code>$broadcast</code> 来让所有子组件都收到父组件的信息，而子组件给父组件通信可以通过在父级自定义事件，在子组件中通过 <code>$emit</code> 来通信。但是在 <code>2.x</code> 中不再支持父级给子组件进行事件广播了，而是可以通过给子组件加上 <code>ref</code> 属性后，通过 <code>this.$refs</code> 来直接操作子组件函数来达成通信的目的，如下代码：<br><code>parent.wpy</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  wepy.page(&#123;</span><br><span class="line">    onLoad() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$refs.child.getList()</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>child.wpy</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">wepy.component(&#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getList() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="组件-prop-不再支持双向绑定"><a href="#组件-prop-不再支持双向绑定" class="headerlink" title="组件 prop 不再支持双向绑定"></a>组件 prop 不再支持双向绑定</h2><p>在 <code>1.7.2</code> 中可以通过可以通过设置 <code>prop</code> 给子组件传参，如果设置的时候加上 <code>.sync</code> 那么当父组件参数更新的时候，传递给子组件的也会自动更新，而如果在子组件的 <code>prop</code> 里加上 <code>twoWay: true</code> 则子组件数据可以绑定到父组件。从而实现组件数据的双向绑定。功能还是挺好用的，但遗憾的是在 <code>2.x</code> 中已经不再支持通过 <code>twoWay: true</code> 的方式从子组件绑定数据到父组件，父到子是可以的，但是不再需要设置 <code>sync</code>。那子组件需要更新父组件的数据，只能通过自定义事件，然后在子组件通过 <code>$emit</code> 进行更新数据了。<br><code>1.7.2</code> 写法：<br>父页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:title.sync</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tempalte</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export default class CHILD extends wepy.component &#123; props = &#123; title: &#123; type:</span><br><span class="line">String, default: &#x27;&#x27;, twoWay: true &#125; &#125; &#125;</span><br></pre></td></tr></table></figure><p><code>2.x</code> 写法：<br>父页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span> @<span class="attr">changeTitle</span>=<span class="string">&quot;changeTitle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tempalte</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HOME</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">        data = &#123;</span><br><span class="line"><span class="javascript">            title: <span class="string">&#x27;最开始的标题&#x27;</span>,</span></span><br><span class="line">        &#125;</span><br><span class="line">        events = &#123;</span><br><span class="line">            changeTitle(val) &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.title = val</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wepy.page(&#123; props: &#123; title: &#123; type: String, default: &#x27;&#x27;, &#125; &#125;, onLoad()&#123;</span><br><span class="line">this.$emit(&#x27;changeTitle&#x27;, &#x27;改变之后的标题&#x27;) &#125; &#125;)</span><br></pre></td></tr></table></figure><h2 id="组件插槽-slot-代码插入后层级错乱问题（坑）"><a href="#组件插槽-slot-代码插入后层级错乱问题（坑）" class="headerlink" title="组件插槽 slot 代码插入后层级错乱问题（坑）"></a>组件插槽 slot 代码插入后层级错乱问题（坑）</h2><p>这个问题已经提到 <a href="https://github.com/Tencent/wepy/issues/2649#issue-655560396">github issues</a> 中，且已经被作者标记为 <code>bug</code>。<br>原始代码：<br><code>parent.wpy</code> 父页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>child view<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>child.wpy</code> 子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>child<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>期望的编译后（正确）的 <code>template</code> 是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>child<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>child view<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而实际 <code>2.x</code> 编译后的 <code>template</code> 是会将对应的内容插入到子组件与根元素并列那级：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>child<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span>child view<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>针对老项目里用到 <code>slot</code> 的地方，我只能改写代码来避开这个坑了。</p><h2 id="资源引入调整"><a href="#资源引入调整" class="headerlink" title="资源引入调整"></a>资源引入调整</h2><p>资源引入方式调整主要是介绍组件引入和图片引入两种。首先来看组件引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;config&gt;</span><br><span class="line">&#123;</span><br><span class="line">  usingComponents: &#123;</span><br><span class="line">    <span class="string">&#x27;load-more&#x27;</span>: <span class="string">&#x27;/components/loadMore&#x27;</span>,  <span class="comment">// 绝对路径</span></span><br><span class="line">    <span class="string">&#x27;btn&#x27;</span>: <span class="string">&#x27;../btn&#x27;</span>,  <span class="comment">// 相对路径</span></span><br><span class="line">    <span class="string">&#x27;list&#x27;</span>: <span class="string">&#x27;~@/components/list&#x27;</span>,  <span class="comment">// 通过wepy.config.js配置别名@指向src，实际上也是绝对路径</span></span><br><span class="line">    <span class="string">&#x27;van-icon&#x27;</span>: <span class="string">&#x27;module:van-icon&#x27;</span>,  <span class="comment">// 模块引入</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure><p>对于图片引入，存在两种方式：一种是静态的，程序在编译的时候就知道需要把哪些图片加载出来，另一种是动态的，只有在程序执行的时候才知道要加载哪些图片。对于第一种方式，通过相对路径、绝对路径或者 <code>@</code> 都可以引入到图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;../bg.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/images/icon.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;@/images/nodata.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于第二种方式，需要将动态的图片放置在某个固定的位置，比如 <code>/src/images/static</code>，然后再 <code>wepy.config.js</code> 里配置 <code>static: [&#39;/src/images/static&#39;]</code> 这样在编译的时候就会把这个路径下的文件都拷贝到输出后的目录，从而能够准确引用这些动态图片。<br><code>wepy.config.js</code> 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">static</span>: [<span class="string">&#x27;src/images/static&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">:src</span>=<span class="string">&quot;&#x27;../images/static/&#x27; + fileType + &#x27;.png&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">:src</span>=<span class="string">&quot;imgSrc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  wepy.page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      imgSrc: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onLoad() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.imgSrc = <span class="string">&#x27;/images/static/icon.png&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>静态图片特殊处理：单独放到一个目录里，然后再 WePY.config.js 里配置 static</p><h2 id="scss-里如果引入-wxss-文件会直接终止编译进程"><a href="#scss-里如果引入-wxss-文件会直接终止编译进程" class="headerlink" title="scss 里如果引入.wxss 文件会直接终止编译进程"></a>scss 里如果引入.wxss 文件会直接终止编译进程</h2><p>下面的代码是一个页面的 <code>scss</code> 样式里，引入了 <code>wxss</code> 文件，最终会导致编译进程终止。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;./btn.scss&quot;</span>;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;./styles/common.wxss&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;./btn.scss&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style lang=&quot;wxss&quot; type=&quot;text/wxss&quot;&gt;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;./styles/common.wxss&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="scss-样式里存在特殊字符会导致编译报错（坑）"><a href="#scss-样式里存在特殊字符会导致编译报错（坑）" class="headerlink" title="scss 样式里存在特殊字符会导致编译报错（坑）"></a>scss 样式里存在特殊字符会导致编译报错（坑）</h2><p>这里的特殊字符其实也是正常的需求，比如引入了字体图标，那可能会有这种样式 <code>content: &#39;\6499&#39;</code>, 然后因为有反斜杠会直接导致报错编译错误。解决思路是把这种带有特殊字符的样式放到 <code>wxss</code> 里，然后通过另外一个 <code>style</code> 引入进来，编译器进行编译的时候会对 <code>scss</code> 样式进行编译处理，但是对于 <code>wxss</code> 会直接拷贝到输入目录，而不进行编译处理，所以能绕过这个坑。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; type=&quot;text/scss&quot;&gt;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;./btn.scss&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style lang=&quot;wxss&quot; type=&quot;text/wxss&quot;&gt;</span><br><span class="line">    <span class="selector-class">.icon-success</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&#x27;\e8921&#x27;</span>;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="数据绑定机制调整"><a href="#数据绑定机制调整" class="headerlink" title="数据绑定机制调整"></a>数据绑定机制调整</h2><p><code>1.7.2</code> 中用脏检查进行数据绑定，通过 <code>$apply()</code> 方法使得数据能够及时更新，页面重新渲染。在 <code>2.x</code> 中使用了 <code>Vue Observer</code> 实现数据绑定，告别 <code>$apply()</code>，但是遇到一个问题，某个数组项的某个属性更新后，数组虽然是更新了，但是不能够触发页面进行重新渲染，即使使用 <code>splice</code> 也不行。不过可以通过浅拷贝一个引用类型，重新赋值，从而触发页面重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">wepy.page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    list: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">        hasBorder: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">&#x27;bbb&#x27;</span>,</span><br><span class="line">        hasBorder: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      <span class="built_in">this</span>.list[<span class="number">1</span>].hasBorder = <span class="literal">true</span> <span class="comment">// 不会重新渲染页面</span></span><br><span class="line">      <span class="built_in">this</span>.list.splice(<span class="number">1</span>, <span class="number">1</span>, &#123;</span><br><span class="line">        <span class="comment">// 也不会重新渲染页面</span></span><br><span class="line">        name: <span class="string">&#x27;bbb&#x27;</span>,</span><br><span class="line">        hasBorder: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">this</span>.list = [...this.list] <span class="comment">// 浅拷贝，使得this.list的引用地址变化了，使得页面重新渲染</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有个小程序项目需要迭代，但是迭代任务不多，时间比较充裕。而这个小程序最早是在 18 年的时候开发的，用的开发框架是 &lt;code&gt;WePY&lt;/code&gt; 的 &lt;code&gt;1.7.2&lt;/code&gt; 版本，去年也就是 &lt;code&gt;19&lt;/code&gt; 年的时候 &lt;code&gt;WePY&lt;/code&gt; 框架进行了升级，到了 &lt;code&gt;2.0&lt;/code&gt; 版本。升级之后的 &lt;code&gt;WePY&lt;/code&gt;，用 &lt;a href=&quot;https://wepyjs.github.io/wepy-docs/2.x/#/&quot;&gt;&lt;code&gt;WePY&lt;/code&gt;&lt;/a&gt; 官方文档的话来说：通过优化细节，引入 &lt;code&gt;Promise&lt;/code&gt;、&lt;code&gt;Async Functions&lt;/code&gt; 等让开发小程序项目变得更加简单，高效。基于这些背景，我和小伙伴一拍即合，决定对我们的项目进行框架升级，体验下到底 &lt;code&gt;WePY2&lt;/code&gt; 能给我们带来什么。&lt;/p&gt;
&lt;p&gt;本文将以项目改动为出发点，基于当前这个项目的结构和编码方式来考虑到底升级 &lt;code&gt;WePY2&lt;/code&gt; 后，哪里需要改，怎么改以及有哪些需要注意的地方，通过对比 &lt;code&gt;2&lt;/code&gt; 个版本的写法差异这个思路来写，不会去太较真 &lt;code&gt;WePY2&lt;/code&gt; 相对于 &lt;code&gt;WePY1&lt;/code&gt; 实现或原理上的区别。下面我将一条一条的列出来需要改动的点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本篇文章记录的是我和小伙伴这次升级框架遇到的需要改动的地方和坑，所使用的是 &lt;code&gt;wepy&lt;/code&gt; 的 &lt;code&gt;2.1.0&lt;/code&gt; 版本，后续如果版本升级后，本篇记录到的坑如果已经被修复了，请自行忽略本文所述的问题。另外下文中所说到的 &lt;code&gt;2.x&lt;/code&gt; 版本都是指 &lt;code&gt;wepy_v2.1.0&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="https://bubuzou.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="wepy" scheme="https://bubuzou.com/tags/wepy/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的数据类型</title>
    <link href="https://bubuzou.com/2020/07/29/js-datatype/"/>
    <id>https://bubuzou.com/2020/07/29/js-datatype/</id>
    <published>2020-07-29T06:11:02.000Z</published>
    <updated>2024-06-12T09:26:58.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-中有哪些数据类型？"><a href="#JavaScript-中有哪些数据类型？" class="headerlink" title="JavaScript 中有哪些数据类型？"></a>JavaScript 中有哪些数据类型？</h2><p>计算机世界中定义的数据类型其实就是为了描述现实世界中存在的事实而定义的。比如我们用人来举例：</p><ol><li><p>有没有人在房间里？这里的有和没有就是是或者非的概念，在 <code>JS</code> 中对应 <code>Boolean</code> 类型，<code>true</code> 表示是，<code>false</code> 表示非；</p></li><li><p>有几个人在房间里？这里的几个表示的是一个量级概念，在 <code>JS</code> 中对应 <code>Number</code> 类型，包含整数和浮点数，还有一些特殊的值，比如：<code>-Infinity</code> 表示负无穷大、<code>+Infinity</code> 表示正无穷大、<code>NaN</code> 表示不是一个数字；</p></li><li><p>房间里的这些人都是我的朋友。这是一句陈述语句，这种文本类的信息将会以字符串形式进行存储，在 <code>JS</code> 中对应 <code>String</code> 类型；</p></li><li><p>房间里没有人。这里的没有代表无和空的概念，在 <code>JS</code> 中 <code>null</code> 和 <code>undefined</code> 都可以表示这个意思；</p></li><li><p>现实世界中所有人都是独一无二的，这在 <code>JS</code> 中对应 <code>Symbol</code> 类型，表示唯一且不可改变；</p></li><li><p><code>Number</code> 所表示的整数是有范围的，超出范围的数据就没法用 <code>Number</code> 表示了，于是 <code>ES10</code> 中提出了一种新的数据类型 <code>BigInt</code>，能表示任何位数的整数；</p></li><li><p>以上提到的 <code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>null</code>、<code>undefined</code>、<code>Symbol</code> 和 <code>BigInt</code> 等 7 种类型都是 <code>JavaScript</code> 中的原始类型，还有一种是非原始类型叫做对象类型；比如：一个人是对象，这个人有名字、性别、年龄等；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">  sex: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  age: <span class="number">26</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h2 id="为什么要区分原始类型和对象类型？他们之间有什么区别？"><a href="#为什么要区分原始类型和对象类型？他们之间有什么区别？" class="headerlink" title="为什么要区分原始类型和对象类型？他们之间有什么区别？"></a>为什么要区分原始类型和对象类型？他们之间有什么区别？</h2><h3 id="原始类型的不可变性"><a href="#原始类型的不可变性" class="headerlink" title="原始类型的不可变性"></a>原始类型的不可变性</h3><p>在回答这个问题之前，我们先看一下变量在内存中是如何存储的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="keyword">let</span> name2 = name1.concat(<span class="string">&#x27;.com&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(name1) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure><p>执行完上面这段代码，我们发现变量 <code>name1</code> 的值还是不变，依然是 <code>bubuzou</code>。这就说明了字符串的不可变性。但是你看了下面的这段代码，你就会产生疑问了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">name1 += <span class="string">&#x27;.com&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(name1) <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure><p>你说字符串是不可变的，那现在不是变了嘛？<br>其实这只是变量的值变了，但是存在内存中的字符串依然不变。这就涉及到变量在内存中的存储了。<br>在 <code>JavaScript</code> 中，变量在内存中有 2 种存储方式：存在栈中和存在堆中。那么栈内存和堆内存有啥区别呢？</p><p>栈内存：</p><ul><li>顺序存储结构，特点是先进后出。就像一个兵乒球盒子一样，兵乒球从外面一个个的放入盒子里，最先取出来的一定是最后放入盒子的那个。</li><li>存储空间固定</li><li>可以直接操作其保存的值，执行效率高</li></ul><p>堆内存：</p><ul><li>无序的存储结构</li><li>存储空间可以动态变化</li><li>无法直接操作其内部的存储，需要通过引用地址操作</li></ul><p>了解完变量在内存中的存储方式有 2 种，那我们继续以上面那串代码为例，画出变量的存储结构图：<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype01.png" alt="js_datatype_01-w548"><br>然后我们可以描述下当计算机执行这段代码时候的发生了什么？首先定义了一个变量 <code>name1</code> 并且给其赋值 <code>bubuzou</code> 这个时候就会在内存中开辟一块空间用来存储字符串 <code>bubuzou</code>，然后变量指向了这个内存空间。然后再执行第二行代码 <code>let name2 = name1.concat(&#39;.com&#39;)</code> 这里的拼接操作其实是产生了一个新字符串 <code>bubuzou.com</code>，所以又会为这个新字符串创建一块新内存，并且把定义的变量 <code>name2</code> 指向这个内存地址。 所以我们看到其实整个操作 <code>bubuzou</code> 这个字符串所在的内存其实是没有变化的，即使在第二段代码中执行了 <code>name1 += &#39;.com&#39;</code> 操作，其实也只是变量 <code>name1</code> 指向了新的字符串 <code>bubuzou.com</code> 而已，旧的字符串 <code>bubuzou</code> 依然存在内存中，不过一段时间后由于该字符串没有被变量所引用，所以会被当成垃圾进行回收，从而释放掉该块内存空间。</p><p>从而我们得出结论：原始类型的值都是固定的，而对象类型则是由原始类型的键值对组合成一个复杂的对象；他们在内存中的存储方式是不一样的，原始类型的值直接存在栈内存中，而对象类型的实际值是存在堆内存中的，在栈内存中保存了一份引用地址，这个地址指向堆内存中的实际值，所以对象类型又习惯被叫做引用类型。</p><blockquote><p>想一个问题为什么引用类型的值要存储到堆内存中？能不能存到栈内存中呢？答案一：因为引用类型大小不固定，而栈的大小是固定的，堆空间的大小是可以动态变化的，所以引用类型的值适合存在堆中；答案二：在代码执行过程中需要频繁的切换执行上下文的时候，如果把引用类型的值存到栈中，将会造成非常大的内存开销。</p></blockquote><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>当我们对两个变量进行比较的时候，不同类型的变量是有不同表现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1 === str2) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person1 === person2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们定义了 2 个字符串变量和 2 个对象变量，他们都长一模一样，但是字符串变量会相等，对象变量却不相等。这是因为在 <code>JavaScript</code> 中，原型类型进行比较的时候比较的是存在栈中的值是否相等；而引用类型进行比较的时候，是比较栈内存中的引用地址是否相等。<br>如上几个变量在内存中的存储模型如图所示：<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype02.png" alt="js_datatype_02"></p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>变量进行复制的时候，原始类型和引用类型变量也是有区别的，来看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = str1</span><br><span class="line">str2 = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1) <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype03.png" alt="js_datatype_02"></p><ol><li><code>let str1 = &#39;hello&#39;</code>: 复制前，定义了一个变量 <code>str1</code>，并且给其赋值 <code>hello</code>，这个时候 <code>hello</code> 这个字符串就会在栈内存中被分配一块空间进行存储，然后变量 <code>str1</code> 会指向这个内存地址；</li><li><code>let str2 = str1</code>：复制后，把 <code>str1</code> 的值赋值给 <code>str2</code>，这个时候会在栈中新开辟一块空间用来存储 <code>str2</code> 的值；</li><li><code>str2 = &#39;world&#39;</code>：给 <code>str2</code> 赋值了一个新的字符串 <code>world</code>，那么将新建一块内存用来存储 <code>world</code>，同时 <code>str2</code> 原来的值 <code>hello</code> 的内存空间因为没有变量所引用，所以一段时间后建被当成垃圾回收；</li><li><code>console.log( str1 )</code>：因为 <code>str1</code> 和 <code>str2</code> 的栈内存地址是不一样的，所以即使 <code>str2</code> 的值被改变，也不会影响到 <code>str1</code>。</li></ol><p>然后我们继续往下，看下引用类型的复制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let person1 &#x3D; &#123;</span><br><span class="line">    name: &#39;bubuzou&#39;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line">let person2 &#x3D; person1</span><br><span class="line">person2.name &#x3D; &#39;bubuzou.com&#39;</span><br><span class="line">console.log( person1.name)  &#x2F;&#x2F; &#39;bubuzou.com&#39;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype04.png" alt="js_datatype_02"><br>原始类型进行复制的时候是变量的值进行重新赋值，而如上图所示：引用类型进行复制的时候是把变量所指向的引用地址进行赋值给新的变量，所以复制后 <code>person1</code> 和 <code>person2</code> 都指向堆内存中的同一个值，所以当改变 <code>person2.name</code> 的时候， <code>person1.name</code> 也会被改变就是这个原因。</p><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>先说一下结论，在 <code>JavaScript</code> 中，所有函数的参数传递都是按值进行传递的。看如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">changeName(name)</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure><p>定义了一个变量 <code>name</code>，并赋值为 <code>bubuzou</code>，函数调用的时候传入 <code>name</code>，这个时候会在函数内部创建一个局部变量 <code>name</code> 并且把全局变量的值 <code>bubuzou</code> 传递给他，这个操作其实是在内存里新建了一块空间用来存放局部变量的值，然后又把局部变量的值改成了 <code>bubuzou.com</code>，这个时候其实内存中会有 3 块地址空间分别用来存放全局变量的值 <code>bubuzou</code>、局部变量原来的值 <code>bubuzou</code>、和局部变量新的值 <code>bubuzou.com</code>；一旦函数调用结束，局部变量将被销毁，一段时间后由于局部变量新旧值没有变量引用，那这两块空间将被回收释放；所以这个时候全局 <code>name</code> 的值依然是 <code>bubuzou</code>。</p><p>再来看看引用类型的传参，会不会有所不同呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changePerosn</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  person.name = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">changePerosn(person)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure><p>引用类型进行函数传参的时候，会把引用地址复制给局部变量，所以全局的 <code>person</code> 和函数内部的局部变量 <code>person</code> 是指向同一个堆地址的，所以一旦一方改变，另一方也将被改变，所以至此我们是不是可以下结论说：当函数进行传参的时候如果参数是引用类型那么就是引用传递嘛？</p><p>将上面的例子改造下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changePerosn</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  person.name = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line">  person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;hello world&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">changePerosn(person)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// &#x27;bubuzou.com&#x27;</span></span><br></pre></td></tr></table></figure><p>如果 <code>person</code> 是引用传递的话，那就会自动指向值被改为 <code>hello world</code> 的新对象；事实上全局变量 <code>person</code> 的引用地址自始至终都没有改变，倒是局部变量 <code>person</code> 的引用地址发生了改变。</p><h2 id="null-和-undefined-傻傻分不清？"><a href="#null-和-undefined-傻傻分不清？" class="headerlink" title="null 和 undefined 傻傻分不清？"></a>null 和 undefined 傻傻分不清？</h2><p><code>null</code> 在 <code>JavaScript</code> 中自成一种原始类型，只有一个值 <code>null</code>，表示无、空、值未知等特殊值。可以直接给一个变量赋值为 <code>null</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><code>undefined</code> 和 <code>null</code> 一样也是自成一种原始类型，表示定义了一个变量，但是没有赋值，则这个变量的值就是 <code>undefined</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s</span><br><span class="line"><span class="built_in">console</span>.log(s) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>虽然可以给变量直接赋值为 <code>undefined</code> 也不会报错，但是原则上如果一个变量值未定，或者表示空，则直接赋值为 <code>null</code> 比较合适，不建议给变量赋值 <code>undefined</code>。<br><code>null</code> 和 <code>undefined</code> 在进行逻辑判断的时候都是会返回 <code>false</code> 的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>,</span><br><span class="line">  b</span><br><span class="line"><span class="built_in">console</span>.log(a ? <span class="string">&#x27;a&#x27;</span> : b ? <span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;c&#x27;</span>) <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><p><code>null</code> 在转成数字类型的时候会变成 <code>0</code>，而 <code>undefined</code> 会变成 <code>NaN</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>,</span><br><span class="line">  b</span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(+b) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="认识新的原始类型-Symbol"><a href="#认识新的原始类型-Symbol" class="headerlink" title="认识新的原始类型 Symbol"></a>认识新的原始类型 Symbol</h2><p><code>Symbol</code> 值表示唯一标识符，是 <code>ES6</code> 中新引进的一种原始类型。可以通过 <code>Symbol()</code> 来创建一个重要的值，也可以传入描述值；其唯一性体现在即使是传入一样的描述，他们两者之间也是不会相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="全局的-Symbol"><a href="#全局的-Symbol" class="headerlink" title="全局的 Symbol"></a>全局的 Symbol</h3><p>那还是不是任意 2 个描述一样的 <code>Symbol</code> 都是不相等的呢？答案是否定的。可以通过 <code>Symbol.for()</code> 来查找或新建一个 <code>Symbol</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用 <code>Symbol.for()</code> 可以在根据传入的描述在全局范围内进行查找，如果没找到则新建一个 <code>Symbol</code>，并且返回；所以当执行第二行代码 <code>Symbol.for(&#39;bubuzou&#39;)</code> 的时候，就会找到全局的那个描述为 <code>bubuzou</code> 的 <code>Symbol</code>，所以这里 <code>a</code> 和 <code>b</code> 是会绝对相等的。</p><p>居然可以通过描述找到 <code>Symbol</code>， 那是否可以通过 <code>Symbol</code> 来找到描述呢？答案是肯定的，但是必须是全局的 <code>Symbol</code>，如果没找到则会返回 <code>undefined</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> desc = <span class="built_in">Symbol</span>.keyFor(a)</span><br><span class="line"><span class="built_in">console</span>.log(desc) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure><p>但是对于任何一个 <code>Symbol</code> 都有一个属性 <code>description</code>，表示这个 <code>Symbol</code> 的描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.description) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-作为对象属性"><a href="#Symbol-作为对象属性" class="headerlink" title="Symbol 作为对象属性"></a>Symbol 作为对象属性</h3><p>我们知道对象的属性键可以是字符串，但是不能是 <code>Number</code> 或者 <code>Boolean</code>；<code>Symbol</code> 被设计出来其实最大的初衷就是用于对象的属性键：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="built_in">Symbol</span>(<span class="string">&#x27;20&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">  [age]: <span class="string">&#x27;20&#x27;</span>, <span class="comment">// 在对象字面量中使用 `Symbol` 的时候需要使用中括号包起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给 <code>person</code> 定义了一个 <code>Symbol</code> 作为属性键的属性，这个相比于用字符串作为属性键有啥好处呢？最明显的好处就是如果这个 <code>person</code> 对象是多个开发者进行开发维护，那么很容易再给 <code>person</code> 添加属性的时候出现同名的，如果是用字符串作为属性键那肯定是冲突了，但是如果用 <code>Symbol</code> 作为属性键，就不会存在这个问题了，因为它是唯一标识符，所以可以使对象的属性受到保护，不会被意外的访问或者重写。</p><p>注意一点，如果用 <code>Symbol</code> 作为对象的属性键的时候，<code>for in</code> 、<code>Object.getOwnPropertyNames</code>、或 <code>Object.keys()</code> 这里循环是无法获取 <code>Symbol</code> 属性键的，但是可以通过 <code>Object.getOwnPropertySymbols()</code> 来获取；在上面的代码基础上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o) <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(person)) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(person)) <span class="comment">// [Symbol(20)]</span></span><br></pre></td></tr></table></figure><h2 id="你可能不知道的-Number-类型"><a href="#你可能不知道的-Number-类型" class="headerlink" title="你可能不知道的 Number 类型"></a>你可能不知道的 Number 类型</h2><p><code>JavaScript</code> 中的数字涉及到了两种类型：一种是 <code>Number</code> 类型，以 <code>64</code> 位的格式 <code>IEEE-754</code> 存储，也被称为双精度浮点数，就是我们平常使用的数字，其范围是 $2^{52}$ 到 -$2^{52}$；第二种类型是 <code>BigInt</code>，能够表示任意长度的整数，包括超出 $2^{52}$ 到 -$2^{52}$ 这个范围外的数。这里我们只介绍 <code>Number</code> 数字。</p><h3 id="常规数字和特殊数字"><a href="#常规数字和特殊数字" class="headerlink" title="常规数字和特殊数字"></a>常规数字和特殊数字</h3><p>对于一个常规的数字，我们直接写即可，比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>但是还有一种位数特别多的数字我们习惯用科学计数法的表示方法来写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> billion = <span class="number">1000000000</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1e9</span></span><br></pre></td></tr></table></figure><p>以上两种写法是一个意思， <code>1e9</code> 表示 1 x $10^9$；如果是 <code>1e-3</code> 表示 1 / $10^3$ = 0.001。<br>在 <code>JavaScript</code> 中也可以用数字表示不同的进制，比如：十进制中的 <code>10</code> 在 二、八和十六进制中可以分别表示成 <code>0b1010</code>、<code>0o12</code> 和 <code>0xa</code>；其中的 <code>0b</code> 是二进制前缀，<code>0o</code> 是八进制前缀，而 <code>ox</code> 是十六进制的前缀。</p><p>我们也可以通过 <code>toString(base)</code> 方法来进行进制之间的转换， <code>base</code> 是进制的基数，表示几进制，默认是 <code>10</code> 进制的，会返回一个转换数值的字符串表示。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)) <span class="comment">// &#x27;1010&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>)) <span class="comment">// &#x27;12&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>)) <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>数字也可以直接调用方法，<code>10..toString( 2 )</code> 这里的 2 个 <code>.</code> 号不是写错了，而是必须是 2 个，否则会报 <code>SyntaxError</code> 错误。第一个点表示小数点，第二个才是调用方法。点符号首先会被认为是数字常量的一部分，其次再被认为是属性访问符，如果只写一个点的话，计算机无法知道这个是表示一个小数呢还是去调用函数。数字直接调用函数还可以有以下几种写法：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="number">10</span>).toString(<span class="number">2</span>) <span class="comment">// 将10用括号包起来</span></span><br><span class="line">;(<span class="number">10.0</span>).toString(<span class="number">2</span>) <span class="comment">// 将10写成10.0的形式</span></span><br><span class="line">;(<span class="number">10</span>).toString(<span class="number">2</span>) <span class="comment">// 空格加上点符号调用</span></span><br></pre></td></tr></table></figure><p><code>Number</code> 类型除了常规数字之外，还包含了一些特殊的数字：</p><ul><li><p><code>NaN</code>：表示不是一个数字，通常是由不合理的计算导致的结果，比如数字除以字符串 <code>1 / &#39;a&#39;</code>;<br><code>NaN</code> 和任何数进行比较都是返回 <code>false</code>，包括他自己： <code>NaN == NaN</code> 会返回 <code>false</code>;<br>如何判断一个数是不是 <code>NaN</code> 呢？有四种方法：</p><pre><code>方法一：通过 `isNaN()` 函数，这个方法会对传入的字符串也返回 `true`，所以判断不准确，不推荐使用：&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;isNaN&lt;/span&gt;( &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;isNaN&lt;/span&gt;( &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt; )  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;方法二：通过 `Number.isNaN()`，推荐使用：&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.isNaN( &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.isNaN( &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt; )  &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;方法三：通过 `Object.is(a, isNaN)`:&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.is( &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;/&lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NaN&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.is( &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NaN&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;方法四：通过判断 `n !== n`，返回 `true`， 则 `n` 是 `NaN` :&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; s = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( s !== s )  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre></li><li><p><code>+Infinity</code>：表示正无穷大，比如 <code>1/0</code> 计算的结果, <code>-Infinity</code> 表示负无穷大，比如 <code>-1/0</code> 的结果。</p></li><li><p><code>+0</code> 和 <code>-0</code>，<code>JavaScript</code> 中的数字都有正负之分，包括零也是这样，他们会绝对相等：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="为什么-0-1-0-2-不等于-0-3"><a href="#为什么-0-1-0-2-不等于-0-3" class="headerlink" title="为什么 0.1 + 0.2 不等于 0.3"></a>为什么 0.1 + 0.2 不等于 0.3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>有没有想过为什么上面的会不相等？因为数字在 <code>JavaScript</code> 内部是用二进制进行存储的，其遵循 <code>IEEE 754</code> 标准的，用 <code>64</code> 位来存储一个数字，<code>64</code> 位又被分隔成 <code>1</code>、<code>11</code> 和 <code>52</code> 位来分别表示符号位、指数位和尾数位。<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202007/jsdatatype05.png" alt="js_datatype_05"><br>比如十进制的 <code>0.1</code> 转成二进制后是多少？我们手动计算一下，十进制小数转二进制小数的规则是“乘 2 取整，顺序排列”，具体做法是：用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 * 2 &#x3D; 0.2  &#x2F;&#x2F; 第1步：整数为0，小数0.2</span><br><span class="line">0.2 * 2 &#x3D; 0.4  &#x2F;&#x2F; 第2步：整数为0，小数0.4</span><br><span class="line">0.4 * 2 &#x3D; 0.8  &#x2F;&#x2F; 第3步：整数为0，小数0.8</span><br><span class="line">0.8 * 2 &#x3D; 1.6  &#x2F;&#x2F; 第4步：整数为1，小数0.6</span><br><span class="line">0.6 * 2 &#x3D; 1.2  &#x2F;&#x2F; 第5步：整数为1，小数0.2</span><br><span class="line">0.2 * 2 &#x3D; 0.4  &#x2F;&#x2F; 第6步：整数为0，小数0.4</span><br><span class="line">0.4 * 2 &#x3D; 0.8  &#x2F;&#x2F; 第7步：整数为0，小数0.8</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们这样依次计算下去之后发现得到整数的顺序排列是 <code>0001100110011001100....</code> 无限循环，所以理论上十进制的 <code>0.1</code> 转成二进制后会是一个无限小数 <code>0.0001100110011001100...</code>，用科学计数法表示后将是 <code>1.100110011001100...</code> x $2^{-4}$ ，但是由于 <code>IEEE 754</code> 标准规定了一个数字的存储位数只能是 <code>64</code> 位，有效位数是 <code>52</code> 位，所以将会对 <code>1100110011001100....</code> 这个无限数字进行舍入总共 <code>52</code> 位作为有效位，然后二进制的末尾取舍规则是看后一位数如果是 <code>1</code> 则进位，如果是 <code>0</code> 则直接舍去。那么由于 <code>1100110011001100....</code> 这串数字的第 <code>53</code> 位刚好是 <code>1</code> ，所以最终的会得到的数字是 <code>1100110011001100110011001100110011001100110011001101</code>，即<br><code>1.100110011001100110011001100110011001100110011001101</code> x $2^{-4}$。<br>十进制转二进制也可以用 <code>toString</code> 来进行转化:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">0.1</span>).toString(<span class="number">2</span>)) <span class="comment">// &#x27;0.0001100110011001100110011001100110011001100110011001101&#x27;</span></span><br></pre></td></tr></table></figure><p>我们发现十进制的 <code>0.1</code> 在转化成二进制小数的时候发生了精度的丢失，由于进位，它比真实的值更大了。而 <code>0.2</code> 其实也有这样的问题，也会发生精度的丢失，所以实际上 <code>0.1 + 0.2</code> 不会等于 <code>0.3</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>) <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>那是不是没办法判断两个小数是否相等了呢？答案肯定是否定的，想要判断 2 个小数 <code>n1</code> 和 <code>n2</code> 是否相等可以如下操作：</p><ul><li><p>方法一：两小数之差的绝对值如果比 <code>Number.EPSILON</code> 还小，那么说明两数是相等的。</p><p><code>Number.EPSILON</code> 是 <code>ES6</code> 中的误差精度，实际值可以认为等于 $2^{-52}$。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.abs(n1 - n2) &lt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;n1 和 n2 相等&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：通过 <code>toFixed(n)</code> 对结果进行舍入，<code>toFixed()</code> 将会返回字符串，我们可以用 一元加 <code>+</code> 将其转成数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="built_in">console</span>.log(+sum.toFixed(<span class="number">2</span>) === <span class="number">0.3</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数值的转化"><a href="#数值的转化" class="headerlink" title="数值的转化"></a>数值的转化</h3><p>对数字进行操作的时候将常常遇到数值的舍入和字符串转数字的问题，这里我们巩固下基础。先来看舍入的：</p><ul><li><p><code>Math.floor()</code>，向下舍入，得到一个整数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">2.2</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">2.8</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>Math.ceil()</code>，向上舍入，得到一个整数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">2.2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">2.8</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>Math.round()</code>，对第一位小数进行四舍五入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(<span class="number">2.26</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">2.46</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">2.5</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.prototype.toFixed(n)</code>，和 <code>Math.round()</code> 一样会进行四舍五入，将数字舍入到小数点后 <code>n</code> 位，并且以字符串的形式返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="number">12</span>).toFixed(<span class="number">2</span>) <span class="comment">// &#x27;12.00&#x27;</span></span><br><span class="line">;(<span class="number">12.14</span>).toFixed(<span class="number">1</span>) <span class="comment">// &#x27;12.1&#x27;</span></span><br><span class="line">;(<span class="number">12.15</span>).toFixed(<span class="number">1</span>) <span class="comment">// &#x27;12.2&#x27;</span></span><br></pre></td></tr></table></figure><p>为什么 <code>6.35.toFixed(1)</code> 会等于 <code>6.3</code> ？因为 <code>6.35</code> 其实是一个无限小数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="number">6.35</span>).toFixed(<span class="number">20</span>) <span class="comment">// &quot;6.34999999999999964473&quot;</span></span><br></pre></td></tr></table></figure><p>所以在 <code>6.35.toFixed(1)</code> 求值的时候会得到 <code>6.3</code>。</p></li></ul><p>再来看看字符串转数字的情况：</p><ul><li><p><code>Number(n)</code> 或 <code>+n</code>，直接将 <code>n</code> 进行严格转化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27; &#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;010&#x27;</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;010&#x27;</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;12a&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;12a&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li><p><code>parseInt()</code>，非严格转化，从左到右解析字符串，遇到非数字就停止解析，并且把解析的数字返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12a&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;a12&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xA&#x27;</span>) <span class="comment">// 10，0x开头的将会被当成十六进制数</span></span><br></pre></td></tr></table></figure><p><code>parseInt()</code> 默认是用十进制去解析字符串的，其实他是支持传入第二个参数的，表示要以多少进制的 基数去解析第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1010&#x27;</span>, <span class="number">2</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>) <span class="comment">// 255</span></span><br></pre></td></tr></table></figure></li></ul><p>如何判断一个数是不是整数？介绍两种方法：</p><ul><li><p>方法一：通过 <code>Number.isInteger()</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">12.0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">12.2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>方法二：<code>typeof num == &#39;number&#39; &amp;&amp; num % 1 == 0</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInteger</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> num == <span class="string">&#x27;number&#x27;</span> &amp;&amp; num % <span class="number">1</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>除了原始类型外，还有一个特别重要的类型：引用类型。高程里这样描述他：引用类型是一种数据结构， 用于将数据和功能组织在一起。到目前为止，我们看到最多的引用类型就是 <code>Object</code>，创建一个 <code>Object</code> 有两种方式：</p><ul><li><p>方式一：通过 <code>new</code> 操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">person.age = <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p>方式二：通过对象字面量，这是我们最喜欢用的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bubuzou&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="内置的引用类型"><a href="#内置的引用类型" class="headerlink" title="内置的引用类型"></a>内置的引用类型</h3><p>除了 <code>Object</code> 外，在 <code>JavaScript</code> 中还有别的内置的引用类型，比如：</p><ul><li><code>Array</code> 数组</li><li><code>Date</code> 日期</li><li><code>RegExp</code> 正则表达式</li><li><code>Function</code> 函数</li></ul><p>他们的原型链的顶端都会指向 <code>Object</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">console</span>.log(d.__proto__.__proto__.constructor) <span class="comment">// ƒ Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>先来看一个问题，为什么原始类型的变量没有属性和方法，但是却能够调用方法呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">str.substring(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// &#x27;bub&#x27;</span></span><br></pre></td></tr></table></figure><p>因为 <code>JavaScript</code> 为了更好地操作原始类型，设计出了几个对应的包装类型，他们分别是：</p><ul><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li></ul><p>上面那串代码的执行过程其实是这样的：</p><ol><li>创建 String 类型的一个实例;</li><li>在实例上调用指定的方法;</li><li>销毁这个实例</li></ol><p>用代码体现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line">str.substring(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">str = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>原始类型调用函数其实就是自动进行了装箱操作，将原始类型转成了包装类型，然后其实原始类型和包装类型是有本质区别的，原始类型是原始值，而包装类型是对象实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str1 === str2) <span class="comment">// fasle</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str1) <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str2) <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><p>居然有装箱操作，那肯定也有拆箱操作，所谓的拆箱就是包装类型转成原始类型的过程，又叫 <code>ToPromitive</code>，来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  toString: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(+obj) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj&#125;</span>`</span>) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br></pre></td></tr></table></figure><p>在拆箱操作的时候，默认会尝试调用包装类型的 <code>toString()</code> 和 <code>valueOf()</code> 方法，对于不同的 <code>hint</code> 调用顺序会有所区别，如果 <code>hint</code> 是 <code>string</code> 则优先调用 <code>toString()</code>，否则的话，则优先调用 <code>valueOf()</code>。<br>默认情况下，一个 <code>Object</code> 对象具有 <code>toString()</code> 和 <code>valueOf()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.valueOf()) <span class="comment">// &#123;&#125;，valueOf会返回对象本身</span></span><br></pre></td></tr></table></figure><h2 id="类型装换"><a href="#类型装换" class="headerlink" title="类型装换"></a>类型装换</h2><p><code>Javascript</code> 是弱类型的语音，所以对变量进行操作的时候经常会发生类型的转换，尤其是隐式类型转换，可能会让代码执行结果出乎意料之外，比如如下的代码你能理解其执行结果嘛？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;[] + &#123;&#125; <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">;+[] <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h3><p>所以我们需要知道类型转换的规则，以下整理出一个表格，列出了常见值和类型以及转换之后的结果，仅供参考。</p><table><thead><tr><th align="center">转换前的值</th><th align="center">转换前类型</th><th align="center">toBoolean</th><th align="center">toNumber</th><th align="center">toString</th></tr></thead><tbody><tr><td align="center">true</td><td align="center">Boolean</td><td align="center">-</td><td align="center">1</td><td align="center">“true”</td></tr><tr><td align="center">false</td><td align="center">Boolean</td><td align="center">-</td><td align="center">0</td><td align="center">“false”</td></tr><tr><td align="center">null</td><td align="center">Null</td><td align="center">false</td><td align="center">0</td><td align="center">“null”</td></tr><tr><td align="center">undefined</td><td align="center">Undefined</td><td align="center">false</td><td align="center">NaN</td><td align="center">“undefined”</td></tr><tr><td align="center">123</td><td align="center">Number</td><td align="center">true</td><td align="center">-</td><td align="center">“123”</td></tr><tr><td align="center">Infinity</td><td align="center">Number</td><td align="center">true</td><td align="center">-</td><td align="center">“Infinity”</td></tr><tr><td align="center">0</td><td align="center">Number</td><td align="center">false</td><td align="center">-</td><td align="center">“0”</td></tr><tr><td align="center">NaN</td><td align="center">Number</td><td align="center">false</td><td align="center">-</td><td align="center">“NaN”</td></tr><tr><td align="center">“”</td><td align="center">String</td><td align="center">false</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">“ “</td><td align="center">String</td><td align="center">true</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">“0”</td><td align="center">String</td><td align="center">true</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">“123”</td><td align="center">String</td><td align="center">true</td><td align="center">123</td><td align="center">-</td></tr><tr><td align="center">“123abc”</td><td align="center">String</td><td align="center">true</td><td align="center">NaN</td><td align="center">-</td></tr><tr><td align="center">Symbol()</td><td align="center">Symbol</td><td align="center">true</td><td align="center">TypeError</td><td align="center">TypeError</td></tr><tr><td align="center">{}</td><td align="center">Object</td><td align="center">true</td><td align="center">NaN</td><td align="center">“[object Object]”</td></tr><tr><td align="center">[]</td><td align="center">Object</td><td align="center">true</td><td align="center">0</td><td align="center">“”</td></tr><tr><td align="center">[“0”]</td><td align="center">Object</td><td align="center">true</td><td align="center">0</td><td align="center">“0”</td></tr><tr><td align="center">[“0”, “a”]</td><td align="center">Object</td><td align="center">true</td><td align="center">NaN</td><td align="center">“0,a”</td></tr><tr><td align="center">[“0”, undefined, “a”]</td><td align="center">Object</td><td align="center">true</td><td align="center">Nan</td><td align="center">“0,,a”</td></tr></tbody></table><h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><p>我们平时写代码的时候应该尽量让写出来的代码通俗易懂，让别人能阅读后知道你是要做什么，所以在对类型进行判断的时候应该尽量显示的处理。<br>比如将字符串转成数字，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;21&#x27;</span>) <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;21.8&#x27;</span>) + <span class="comment">// 21.8</span></span><br><span class="line">  <span class="string">&#x27;21&#x27;</span> <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>将数字显示转成字符串可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">21</span>) <span class="comment">// &#x27;21&#x27;</span></span><br><span class="line">;(<span class="number">21</span>).toString() <span class="comment">// &#x27;21&#x27;</span></span><br></pre></td></tr></table></figure><p>显示转成布尔类型可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;21&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&#x27;21&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>除了以上之外，还有一些关于类型转换的冷门操作，有时候也挺管用的：<br>直接用一元加操作符获取当前时间的毫秒数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;+<span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// 1595517982686</span></span><br></pre></td></tr></table></figure><p>用 <code>~</code> 配合 <code>indexOf()</code> 将操作结果直接转成布尔类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;bubuzou.com&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (~str.indexOf(<span class="string">&#x27;.com&#x27;</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;str如果包含了.com字符串，则会打印这句话&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>~~</code> 对字符或数字截取整数，和 <code>Math.floor()</code> 有稍许不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="number">21.1</span> <span class="comment">// 21</span></span><br><span class="line">~~<span class="number">-21.9</span> <span class="comment">// -21</span></span><br><span class="line">~~<span class="string">&#x27;1.2a&#x27;</span> <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">21.1</span>) <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">-21.9</span>) <span class="comment">// -22</span></span><br></pre></td></tr></table></figure><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换发生在 <code>JavaScript</code> 的运行时，通常是由某些操作符或语句引起的，有下面这几种情况：</p><ul><li><p>隐式转成布尔类型：</p><ol><li><code>if (..)</code>语句中的条件判断表达式。</li><li><code>for ( .. ; .. ; .. )</code>语句中的条件判断表达式(第二个)。</li><li><code>while (..)</code> 和 <code>do..while(..)</code> 循环中的条件判断表达式。</li><li><code>? :</code>中的条件判断表达式。</li><li>逻辑运算符 <code>||</code> (逻辑或)和 <code>&amp;&amp;</code> (逻辑与)左边的操作数(作为条件判断表达式)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">42</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="string">&#x27;bubuzou&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bubuzou&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">null</span> ? <span class="string">&#x27;存在&#x27;</span> : <span class="string">&#x27;不存在&#x27;</span> <span class="comment">// &#x27;不存在&#x27;</span></span><br></pre></td></tr></table></figure><p>上例中的非布尔值会被隐式强制类型转换为布尔值以便执行条件判断。<br>需要特别注意的是 <code>||</code> 和 <code>&amp;&amp;</code> 操作符。<code>||</code> 的操作过程是只有当左边的值返回 <code>false</code> 的时候才会对右边进行求值且将它作为最后结果返回，类似 <code>a ? a : b</code> 这种效果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;a&#x27;</span> || <span class="string">&#x27;b&#x27;</span> <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;c&#x27;</span> <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><p>而 <code>&amp;&amp;</code> 的操作过程是只有当左边的值返回 <code>true</code> 的时候才对右边进行求值且将右边的值作为结果返回，类似 <code>a ? b : a</code> 这种效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;a&#x27;</span> &amp;&amp; <span class="string">&#x27;b&#x27;</span> <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">&#x27;c&#x27;</span> <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数学操作符 <code>- * /</code> 会对非数字类型的会优先转成数字类型，但是对 <code>+</code> 操作符会比较特殊：</p><ol><li>当一侧为 <code>String</code> 类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li><li>当一侧为 <code>Number</code> 类型，另一侧为原始类型，则将原始类型转换为 <code>Number</code> 类型。</li><li>当一侧为 <code>Number</code> 类型，另一侧为引用类型，将引用类型和 <code>Number</code> 类型转换成字符串后拼接。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span> + <span class="string">&#x27;bubuzou&#x27;</span> <span class="comment">// &#x27;42bubuzou&#x27;</span></span><br><span class="line"><span class="number">42</span> + <span class="literal">null</span> <span class="comment">// 42</span></span><br><span class="line"><span class="number">42</span> + <span class="literal">true</span> <span class="comment">// 43</span></span><br><span class="line"><span class="number">42</span> + [] <span class="comment">// &#x27;42&#x27;</span></span><br><span class="line"><span class="number">42</span> + &#123;&#125; <span class="comment">// &#x27;42[object Object]&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>宽松相等和严格相等<br>宽松相等（<code>==</code>）和严格相等（<code>===</code>）在面试的时候经常会被问到，而回答一般是 <code>==</code> 是判断值是否相等，而 <code>===</code> 除了判断值会不会相等之外还会判断类型是否相等，这个答案不完全正确，更好的回答是：<code>==</code> 在比较过程中允许发生隐式类型转换，而 <code>===</code> 不会。 那 <code>==</code> 是怎么进行类型转换的呢？</p><ol><li><p>数字和字符串比，字符串将转成数字进行比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> == <span class="string">&#x27;20&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">20</span> === <span class="string">&#x27;20&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>别的类型和布尔类型比较，布尔类型将首先转成数字进行比较，<code>true</code> 转成数字 <code>1</code>, <code>false</code> 转成数字 <code>0</code>，注意这个是非常容易出错的一个点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;bubuzou&#x27;</span> == <span class="literal">true</span>  <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>  <span class="comment">// false,</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>  <span class="comment">// false</span></span><br><span class="line">[] == <span class="literal">true</span>  <span class="comment">// false</span></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>]  == <span class="literal">true</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以写代码进行判断的时候一定不要写成 <code>x == true</code> 或 <code>x == false</code> 这种，而应该直接 <code>if (x)</code> 判断。</p></li><li><p><code>null</code> 和 <code>undefined</code>: <code>null == undefined</code> 比较结果是 <code>true</code>，除此之外，<code>null</code>、<code>undefined</code> 和其他任何结果的比较值都为 <code>false</code>。可以认为在 <code>==</code> 的情况下，<code>null</code> 和 <code>undefined</code> 可以相互的进行隐式类型转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>原始类型和引用类型比较，引用类型会首先进行 <code>ToPromitive</code> 转成原始类型然后进行比较，规则参考上面介绍的拆箱操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;42&#x27;</span> == [<span class="number">42</span>] <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;1,2,3&#x27;</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;[object Object]&#x27;</span> == &#123;&#125; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == [<span class="literal">undefined</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>特殊的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>  <span class="comment">// false</span></span><br><span class="line">+<span class="number">0</span> == <span class="number">-0</span>  <span class="comment">// true</span></span><br><span class="line">[] == ![]  <span class="comment">// true，![]的优先级比==高，所以![]先转成布尔值变成false；即变成[] == false，false再转成数字0，[]转成数字0，所以[] == ![]</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;\n&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><h3 id="用-typeof-检测原始类型"><a href="#用-typeof-检测原始类型" class="headerlink" title="用 typeof 检测原始类型"></a>用 typeof 检测原始类型</h3><p><code>JavaScript</code> 中有 <code>null</code>、<code>undefined</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>Symbol</code> 等六种原始类型，我们可以用 <code>typeof</code> 来判断值是什么原始类型的，会返回类型的字符串表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;42&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><p>但是原始类型中有一个例外，<code>typeof null</code> 会得到 ‘object’，所以我们用 <code>typeof</code> 对原始值进行类型判断的时候不能得到一个准确的答案，那如何判断一个值是不是 <code>null</code> 类型的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="literal">null</span></span><br><span class="line">!o &amp;&amp; <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> <span class="comment">// 用于判断 o 是否是 null 类型</span></span><br></pre></td></tr></table></figure><blockquote><p><code>undefined</code> 和 <code>undeclared</code> 有什么区别？前者是表示在作用域中定义了但是没有赋值的变量，而后者是表示在作用域中没有定义的变量；分别表示 <code>undefined</code> 未定义、<code>undeclared</code> 未声明。</p></blockquote><p><code>typeof</code> 能够对原始类型进行判断，那是否也能判断引用类型呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>() <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>() <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面的结果我们可以得到这样一个结论： <code>typeof</code> 对引用类型判断的时候只有 <code>function</code> 类型可以正确判断，其他都无法正确判断具体是什么引用类型。</p><h3 id="用-instanceof-检测引用类型"><a href="#用-instanceof-检测引用类型" class="headerlink" title="用 instanceof 检测引用类型"></a>用 instanceof 检测引用类型</h3><p>我们知道 <code>typeof</code> 只能对部分原始类型进行检测，对引用类型毫无办法。<code>JavaScript</code> 提供了一个操作符 <code>instanceof</code>，我们来看下他是否能检测引用类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>  <span class="comment">// true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们发现数组即是 <code>Array</code> 的实例，也是 <code>Object</code> 的实例，因为所以引用类型原型链的终点都是 <code>Object</code>，所以 <code>Array</code> 自然是 <code>Object</code> 的实例。那么我们得出结论：<code>instanceof</code> 用于检测引用类型好像也不是很靠谱的选择。</p><h3 id="用-toString-进行类型检测"><a href="#用-toString-进行类型检测" class="headerlink" title="用 toString 进行类型检测"></a>用 toString 进行类型检测</h3><p>我们可以使用 <code>Object.prototype.toString.call()</code> 来检测任何变量值的类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) <span class="comment">// &#x27;[object Boolean]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// &#x27;[object Undefined]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// &#x27;[object Null]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">20</span>) <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;bubuzou&#x27;</span>) <span class="comment">// &#x27;[object String]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()) <span class="comment">// &#x27;[object Symbol]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) <span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// &#x27;[object Function]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// &#x27;[object Date]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) <span class="comment">// &#x27;[object RegExp]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>) <span class="comment">// &#x27;[object JSON]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(MATH) <span class="comment">// &#x27;[object MATH]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>)(</span><br><span class="line">  <span class="comment">// &#x27;[object Window]&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>) <span class="comment">// &#x27;[object Arguments]&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">)()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.im/post/5cec1bcff265da1b8f1aa08f">【JS 进阶】你真的掌握变量和类型了吗</a></li><li><a href="https://book.douban.com/subject/26854244/">你不知道的 JS 中卷-第四章</a></li><li><a href="https://juejin.im/post/5d116a9df265da1bb47d717b">JS 中的栈内存堆内存</a></li><li><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript-中有哪些数据类型？&quot;&gt;&lt;a href=&quot;#JavaScript-中有哪些数据类型？&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中有哪些数据类型？&quot;&gt;&lt;/a&gt;JavaScript 中有哪些数据类型？&lt;/h2&gt;&lt;p&gt;计算机世界中定义的数据类型其实就是为了描述现实世界中存在的事实而定义的。比如我们用人来举例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;有没有人在房间里？这里的有和没有就是是或者非的概念，在 &lt;code&gt;JS&lt;/code&gt; 中对应 &lt;code&gt;Boolean&lt;/code&gt; 类型，&lt;code&gt;true&lt;/code&gt; 表示是，&lt;code&gt;false&lt;/code&gt; 表示非；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有几个人在房间里？这里的几个表示的是一个量级概念，在 &lt;code&gt;JS&lt;/code&gt; 中对应 &lt;code&gt;Number&lt;/code&gt; 类型，包含整数和浮点数，还有一些特殊的值，比如：&lt;code&gt;-Infinity&lt;/code&gt; 表示负无穷大、&lt;code&gt;+Infinity&lt;/code&gt; 表示正无穷大、&lt;code&gt;NaN&lt;/code&gt; 表示不是一个数字；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;房间里的这些人都是我的朋友。这是一句陈述语句，这种文本类的信息将会以字符串形式进行存储，在 &lt;code&gt;JS&lt;/code&gt; 中对应 &lt;code&gt;String&lt;/code&gt; 类型；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;房间里没有人。这里的没有代表无和空的概念，在 &lt;code&gt;JS&lt;/code&gt; 中 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 都可以表示这个意思；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现实世界中所有人都是独一无二的，这在 &lt;code&gt;JS&lt;/code&gt; 中对应 &lt;code&gt;Symbol&lt;/code&gt; 类型，表示唯一且不可改变；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Number&lt;/code&gt; 所表示的整数是有范围的，超出范围的数据就没法用 &lt;code&gt;Number&lt;/code&gt; 表示了，于是 &lt;code&gt;ES10&lt;/code&gt; 中提出了一种新的数据类型 &lt;code&gt;BigInt&lt;/code&gt;，能表示任何位数的整数；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以上提到的 &lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;Symbol&lt;/code&gt; 和 &lt;code&gt;BigInt&lt;/code&gt; 等 7 种类型都是 &lt;code&gt;JavaScript&lt;/code&gt; 中的原始类型，还有一种是非原始类型叫做对象类型；比如：一个人是对象，这个人有名字、性别、年龄等；&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&amp;#x27;bubuzou&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sex: &lt;span class=&quot;string&quot;&gt;&amp;#x27;male&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  age: &lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
