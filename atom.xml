<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>步步走</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bubuzou.com/"/>
  <updated>2024-06-17T01:08:20.017Z</updated>
  <id>https://bubuzou.com/</id>
  
  <author>
    <name>typeR</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac 环境变量与 shell</title>
    <link href="https://bubuzou.com/2024/06/14/shell-mac/"/>
    <id>https://bubuzou.com/2024/06/14/shell-mac/</id>
    <published>2024-06-14T09:37:58.000Z</published>
    <updated>2024-06-17T01:08:20.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在 mac 上安装了 nginx 用来跑本地 web 服务。<br>但是启动的时候需要切换到 nginx 的安装目录下，然后执行命令才能启动。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 nginx 目录</span></span><br><span class="line">cd /usr/local/nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 nginx 服务</span></span><br><span class="line">sudo sbin/nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出 nginx</span></span><br><span class="line">sudo sbin/nginx -s quit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制停止 nginx</span></span><br><span class="line">sudo sbin/nginx -s stop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 nginx</span></span><br><span class="line">sudo sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>可以看到每次操作 nginx 都需要切到对应目录才能执行命令，挺不方便的。<br>有没有更便捷的方法呢？当然是有的，那就是使用环境变量。</p><a id="more"></a><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，如临时文件夹位置、系统文件夹位置以及某些应用软件文件的路径等等。环境变量相当于给系统或用户应用程序设置的一些参数，具体起什么作用这当然和具体的环境变量相关。</p><p>比如 Path，是告诉系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到哪些目录下去寻找。</p><h2 id="环境变量的配置文件"><a href="#环境变量的配置文件" class="headerlink" title="环境变量的配置文件"></a>环境变量的配置文件</h2><p>设置的环境变量需要生效，就必须要存起来，存到配置文件里。</p><p>在 Mac 中环境变量的配置文件有好几种类型。</p><p><strong>系统级别</strong></p><p>系统级别配置文件，系统启动就会加载，修改需要 Root 权限。</p><ul><li>/etc/paths ：任何用户登陆时都会读取该文件，全局建议修改这个文件 。</li><li>/etc/profile：为系统的每个用户设置环境信息和启动程序，其配置对所有登录的用户都有效，一般不建议修改该文件。</li></ul><p><strong>用户级别</strong></p><ul><li>~/.bash_profile：为当前用户设置专属的环境信息和启动程序，当用户登录时该文件执行一次。默认情况下，它用于设置环境变量，并执行当前用户的 .bashrc 文件，一般用户级环境变量会放到这个文件。</li><li>~/.bash_login 和 ~/.profile：这三个文件也是依次执行的，如果 bash_profile 文件存在，则后面的两个文件就会被忽略不读了，如 bash_profile 文件不存在，才会以此类推读取后面的文件。</li></ul><p><strong>shell 打开时加载</strong></p><ul><li>/etc/bashrc 或 /etc/zshrc：系统级配置，为每个运行 bash/zhs shell 的用户执行该文件，当 bash/zhs shell 打开时，该文件被执行，其配置对所有使用 bash 的用户打开的每个 bash 都有效。</li><li>~/.bashrc 或 ～/.zshrc：用户级配置，作用同上。它是 bash/zsh shell 打开的时候载入的，对当前用户打开的每个 bash 都有效。</li></ul><blockquote><p>如果系统默认 shell 使用的是 zsh 而不是 sh、bash，那么 zsh 是不加载 .bash_profile 文件的，而是加载 .zshrc。source .zshrc 在 zsh 环境下读取配置文件。</p></blockquote><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>上面多个地方提到了 shell，环境变量也是需要运行在 shell 上，那 shell 到底是什么呢？</p><h3 id="shell-的概念"><a href="#shell-的概念" class="headerlink" title="shell 的概念"></a>shell 的概念</h3><p>Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p><p>具体来说，Shell 这个词有多种含义。</p><p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（command line interface，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。</p><p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。</p><p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p><blockquote><p>以上这个 shell 概念来自阮一峰的 <a href="https://wangdoc.com/bash/intro">《Bash 脚本教程》</a></p></blockquote><h3 id="shell-的种类"><a href="#shell-的种类" class="headerlink" title="shell 的种类"></a>shell 的种类</h3><p>不同的程序员写出的程序风格不同，有的喜欢这么写，有的喜欢那样写，所以就形成了不同的规范，就有了多种类型的 shell 了，就好像每个人喜欢穿不同的衣服一样。</p><p>历史上，主要的 Shell 有下面这些。</p><ul><li>Bourne Shell（sh）</li><li>Bourne Again shell（bash）</li><li>C Shell（csh）</li><li>TENEX C Shell（tcsh）</li><li>Korn shell（ksh）</li><li>Z Shell（zsh）</li><li>Friendly Interactive Shell（fish）</li></ul><p>随着时间的推移，每个 mac 系统会内置一些不同的 shell，那么如何查看你的 mac 安装了哪些 shell 呢？其实它的答案藏在了 /etc/shells 这个文件里：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我的 mac 电脑内置的 shell</span></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><p>如何查看默认使用的是哪个 shell 呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前系统默认的 shell</span></span><br><span class="line">echo $SHELL</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前进程正在使用的 shell</span></span><br><span class="line">echo $0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zsh</span></span><br></pre></td></tr></table></figure><p>如果你想更改系统默认的 shell，你可以这么做：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以下将把 bash 设置为 默认 shell</span></span><br><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>通过上面的介绍，你知道了你系统默认的 shell 是什么了。<br>我的是 zsh，那我就可以把我的环境变量保存在 ~/.zshrc 配置文件里。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 同过 vim 打开 ~/.zshrc 文件</span></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置 nginx 的环境变量 <span class="variable">$PATH</span></span></span><br><span class="line">export PATH=$PATH:/usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>通过 vim 编辑保存该文件后，想让环境变量立即生效还需要执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 该命令的作用是读取并且执行该文件脚本</span></span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><blockquote><p>或者，可以把你的环境变量存在 ~/.bash_profile 里，然后在 ~/.zshrc 最后一行加上 source ~/.bash_profile，这样对于默认 shell 是 zsh 的用户来说，就可以让 ~/.bash_profile 里的配置生效了。</p></blockquote><p>环境变量配置好后，就可以测试是否生效了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果没有报错，那就说明 nginx 的环境变量已经生效了</span></span><br><span class="line">sudo nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在 mac 上安装了 nginx 用来跑本地 web 服务。&lt;br&gt;但是启动的时候需要切换到 nginx 的安装目录下，然后执行命令才能启动。比如：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 进入 nginx 目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd /usr/local/nginx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 启动 nginx 服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo sbin/nginx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 退出 nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo sbin/nginx -s quit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 强制停止 nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo sbin/nginx -s stop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 重启 nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo sbin/nginx -s reload&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以看到每次操作 nginx 都需要切到对应目录才能执行命令，挺不方便的。&lt;br&gt;有没有更便捷的方法呢？当然是有的，那就是使用环境变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web综合" scheme="https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="mac" scheme="https://bubuzou.com/tags/mac/"/>
    
      <category term="shell" scheme="https://bubuzou.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>如何反编译微信小程序</title>
    <link href="https://bubuzou.com/2024/06/12/decompile-applet/"/>
    <id>https://bubuzou.com/2024/06/12/decompile-applet/</id>
    <published>2024-06-12T09:37:58.000Z</published>
    <updated>2024-06-13T02:23:26.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是反编译"><a href="#什么是反编译" class="headerlink" title="什么是反编译"></a>什么是反编译</h2><p>微信小程序可以运行在手机微信或者 pc 版微信环境下，它是以一个应用包的形式存在的，这个应用包的后缀通常是 .wxapkg。如果想知道某个微信小程序的功能模块是如何实现的，就需要把这个包给解开，这个过程就叫反编译。</p><h2 id="获取小程序包"><a href="#获取小程序包" class="headerlink" title="获取小程序包"></a>获取小程序包</h2><p>要反编译微信小程序，那首先就需要获取微信小程序的应用包。</p><p>可以在 pc 版本微信上获取包，那么就需要在 pc 版微信上先运行某个小程序；运行完成后，就会在电脑某个目录下生成这个小程序的包，我们需要找到这个目录，那么就找到了这个包了。</p><p>windows 和 mac 环境不同，包的位置也会不一样。</p><p><em>windows 系统</em></p><p>打开微信设置-文件管理-就能看到微信的目录了，继续往下找到 /applet 这个目录，就能看到小程序的包了。示例：D:\软件\WeChat Files\WeChat Files\Applet\小程序 AppID__APP__.wxapkg</p><p><em>mac 系统</em></p><p>包通常是被放在：/System/Volumes/Data/Users/你的用户名/Library/Containers/com.tencent.xinWeChat/Data/.wxapplet/packages/小程序 AppID/随机数/<strong>APP</strong>.wxapkg</p><a id="more"></a><p>知道了目录后，就可以拿到包了。</p><p>在 mac 下进入某个目录可以这样做：</p><ul><li>访达-前往-前往文件夹-然后把目录路径贴到输入框，选择某个路径就可以进去了；</li><li>或者在终端用命令：open 目录路径；</li></ul><blockquote><p>如果 mac 系统的包不在刚刚说的目录下，还有一种方式可以找到。那就是通过微信小程序 AppID 来搜索目录。那就需要先知道某个微信小程序的 AppID 是什么。</p></blockquote><p>可以通过如下这张图的操作路径来获取 AppID：</p><p><img src="http://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202406/002.png" alt="获取AppID"></p><p>拿到了 AppID 后，就可以通过终端里输入命令来进行搜索了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name 某个AppID</span><br></pre></td></tr></table></figure><p><img src="http://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202406/001.png"></p><p>当搜索到这种路径的时候就说明找到了，就可以停止搜索了。</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>拿到了小程序应用包，接下来就需要通过代码把这个包给解开，然后还原成可以跑在微信开发者工具上的微信小程序项目代码了。</p><p>反编译使用的是 github 上的开源项目：<a href="https://github.com/threecha/wxappUnpacker">wxappUnpacker</a></p><p>把这个项目 clone 到本地后，安装好依赖，就可以使用如下命令进行反编译了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node wuWxapkg.js /System/Volumes/Data/Users/你的用户名/Library/Containers/com.tencent.xinWeChat/Data/.wxapplet/packages/小程序AppID/随机数/__APP__.wxapkg</span><br></pre></td></tr></table></figure><p>由于这个库的程序比较旧了，而小程序的项目结构或者语法再时时更新，所以在解包的时候有可能会报错，这个不用管。</p><p>解包完成后，会在 <strong>APP</strong>.wxapkg 的同级目录生成一个 <strong>APP</strong> 的文件夹，这个文件夹就是微信开发者工具的可识别的项目目录。把它复制到外面，好让微信开发者工具方便导入，导入项目过程中的 AppID 使用测试号即可。</p><p>在微信开发者加载代码的过程中，正常不会很顺利，我自己反编译了几个小程序也都会有问题。比如如下图：</p><p><img src="http://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202406/003.png" alt="报错"></p><p><strong>问题一：require(…)() is not a function</strong></p><p>比如如下文件 miniprogram_npm/@vant/weapp/wxs/utils.wxs 中的 require(…)() 改成 require(…) 即可。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-  var bem = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/bem.wxs&#x27;)();</span></span><br><span class="line"><span class="addition">+  var bem = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/bem.wxs&#x27;);</span></span><br><span class="line"><span class="deletion">-  var memoize = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/memoize.wxs&#x27;)();</span></span><br><span class="line"><span class="addition">+  var memoize = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/memoize.wxs&#x27;);</span></span><br><span class="line"><span class="deletion">-  var addUnit = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/add-unit.wxs&#x27;)();</span></span><br><span class="line"><span class="addition">+  var addUnit = require(&#x27;p_./miniprogram_npm/@vant/weapp/wxs/add-unit.wxs&#x27;);</span></span><br><span class="line">module.exports = (&#123;</span><br><span class="line">    bem: memoize(bem),</span><br><span class="line">    memoize: memoize,</span><br><span class="line">    addUnit: addUnit,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>问题二：_typeof2 is not a function</strong></p><p>这个错误文件是 @babel/runtime/helpers/typeof.js，把如下代码替换掉原文件代码即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_typeof2</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="string">&quot;@babel/helpers - typeof&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> (_typeof2 =</span><br><span class="line">    <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="string">&quot;symbol&quot;</span> == <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator</span><br><span class="line">      ? <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">typeof</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> o &amp;&amp;</span><br><span class="line">            <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp;</span><br><span class="line">            o.constructor === <span class="built_in">Symbol</span> &amp;&amp;</span><br><span class="line">            o !== <span class="built_in">Symbol</span>.prototype</span><br><span class="line">            ? <span class="string">&quot;symbol&quot;</span></span><br><span class="line">            : <span class="keyword">typeof</span> o;</span><br><span class="line">        &#125;)(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="string">&quot;symbol&quot;</span> === _typeof2(<span class="built_in">Symbol</span>.iterator)</span><br><span class="line">      ? (<span class="built_in">module</span>.exports = _typeof =</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _typeof2(o);</span><br><span class="line">          &#125;)</span><br><span class="line">      : (<span class="built_in">module</span>.exports = _typeof =</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o &amp;&amp;</span><br><span class="line">              <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp;</span><br><span class="line">              o.constructor === <span class="built_in">Symbol</span> &amp;&amp;</span><br><span class="line">              o !== <span class="built_in">Symbol</span>.prototype</span><br><span class="line">              ? <span class="string">&quot;symbol&quot;</span></span><br><span class="line">              : _typeof2(o);</span><br><span class="line">          &#125;),</span><br><span class="line">    _typeof(o)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = _typeof;</span><br></pre></td></tr></table></figure><p>其他一些别的错误，需要看报错信息对应改一下，这里就不再多介绍了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是反编译&quot;&gt;&lt;a href=&quot;#什么是反编译&quot; class=&quot;headerlink&quot; title=&quot;什么是反编译&quot;&gt;&lt;/a&gt;什么是反编译&lt;/h2&gt;&lt;p&gt;微信小程序可以运行在手机微信或者 pc 版微信环境下，它是以一个应用包的形式存在的，这个应用包的后缀通常是 .wxapkg。如果想知道某个微信小程序的功能模块是如何实现的，就需要把这个包给解开，这个过程就叫反编译。&lt;/p&gt;
&lt;h2 id=&quot;获取小程序包&quot;&gt;&lt;a href=&quot;#获取小程序包&quot; class=&quot;headerlink&quot; title=&quot;获取小程序包&quot;&gt;&lt;/a&gt;获取小程序包&lt;/h2&gt;&lt;p&gt;要反编译微信小程序，那首先就需要获取微信小程序的应用包。&lt;/p&gt;
&lt;p&gt;可以在 pc 版本微信上获取包，那么就需要在 pc 版微信上先运行某个小程序；运行完成后，就会在电脑某个目录下生成这个小程序的包，我们需要找到这个目录，那么就找到了这个包了。&lt;/p&gt;
&lt;p&gt;windows 和 mac 环境不同，包的位置也会不一样。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;windows 系统&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;打开微信设置-文件管理-就能看到微信的目录了，继续往下找到 /applet 这个目录，就能看到小程序的包了。示例：D:\软件\WeChat Files\WeChat Files\Applet\小程序 AppID__APP__.wxapkg&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mac 系统&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;包通常是被放在：/System/Volumes/Data/Users/你的用户名/Library/Containers/com.tencent.xinWeChat/Data/.wxapplet/packages/小程序 AppID/随机数/&lt;strong&gt;APP&lt;/strong&gt;.wxapkg&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="https://bubuzou.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="https://bubuzou.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="反编译" scheme="https://bubuzou.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>mac 终端命令大全</title>
    <link href="https://bubuzou.com/2024/06/06/mac-terminal-command/"/>
    <id>https://bubuzou.com/2024/06/06/mac-terminal-command/</id>
    <published>2024-06-06T09:37:58.000Z</published>
    <updated>2024-06-14T13:05:27.648Z</updated>
    
    <content type="html"><![CDATA[<p>“终端” App 可让高级用户和开发者通过命令行界面 (CLI) 与 Mac 操作系统进行通信。你可以输入命令和脚本（称为 shell 脚本）在 Mac 上执行任务。</p><p><a href="https://support.apple.com/zh-cn/guide/terminal/trmlshtcts/2.14/mac/14.0">Mac 终端键盘快键键</a></p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><table><thead><tr><th>命令</th><th>功能描述</th><th>举例</th></tr></thead><tbody><tr><td>mkdir</td><td>创建一个目录</td><td>mkdir dirname</td></tr><tr><td>rmdir</td><td>删除一个目录</td><td>rmdir dirname</td></tr><tr><td>mvdir</td><td>移动或重命名一个目录</td><td>mvdir dir1 dir2</td></tr><tr><td>cd</td><td>改变当前目录</td><td>cd dirname</td></tr><tr><td>pwd</td><td>显示当前目录的路径名</td><td>pwd</td></tr><tr><td>ls</td><td>显示当前目录的内容</td><td>ls -la</td></tr><tr><td>dircmp</td><td>比较两个目录的内容</td><td>dircmp dir1 dir2</td></tr></tbody></table><a id="more"></a><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>cat</td><td>显示或连接文件</td><td>cat filename</td></tr><tr><td>pg</td><td>分页格式化显示文件内容</td><td>pg filename</td></tr><tr><td>more</td><td>分屏显示文件内容</td><td>more filename</td></tr><tr><td>cp</td><td>复制文件或目录</td><td>cp file1 file2</td></tr><tr><td>rm</td><td>删除文件或目录</td><td>rm filename</td></tr><tr><td>mv</td><td>改变文件名或所在目录</td><td>mv file1 file2</td></tr><tr><td>ln</td><td>联接文件</td><td>ln -s file1 file2</td></tr><tr><td>find</td><td>使用匹配表达式查找文件</td><td>find . -name “*.c” -print</td></tr><tr><td>file</td><td>显示文件类型</td><td>file filename</td></tr><tr><td>open</td><td>使用默认的程序打开文件</td><td>open filename</td></tr></tbody></table><h2 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h2><table><thead><tr><th>命令</th><th>功能描述</th><th>举例</th></tr></thead><tbody><tr><td>head</td><td>显示文件的最初几行</td><td>head -20 filename</td></tr><tr><td>tail</td><td>显示文件的最后几行</td><td>tail -15 filename</td></tr><tr><td>cut</td><td>显示文件每行中的某些域</td><td>cut -f1,7 -d: /etc/passwd</td></tr><tr><td>colrm</td><td>从标准输入中删除若干列</td><td>colrm 8 20 file2</td></tr><tr><td>paste</td><td>横向连接文件</td><td>paste file1 file2</td></tr><tr><td>diff</td><td>比较并显示两个文件的差异</td><td>diff file1 file2</td></tr><tr><td>sed</td><td>非交互方式流编辑器</td><td>sed “s/red/green/g” filename</td></tr><tr><td>grep</td><td>在文件中按模式查找</td><td>grep “a” filename</td></tr><tr><td>awk</td><td>在文件中查找并处理模式</td><td>awk ‘{print $1 $1}’ filename</td></tr><tr><td>sort</td><td>排序或归并文件</td><td>sort -d -f -u file1</td></tr><tr><td>uniq</td><td>去掉文件中的重复行</td><td>uniq file1 file2</td></tr><tr><td>comm</td><td></td><td>comm file1 file2</td></tr><tr><td>wc</td><td>统计文件的字符数、词数和行数</td><td>wc filename</td></tr><tr><td>nl</td><td>给文件加上行号</td><td>nl file1 &gt;file2</td></tr></tbody></table><h2 id="安全操作"><a href="#安全操作" class="headerlink" title="安全操作"></a>安全操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>passwd</td><td>修改用户密码</td><td>passwd</td></tr><tr><td>chmod</td><td>改变文件或目录的权限</td><td>chmod ug+x filename</td></tr><tr><td>umask</td><td>定义创建文件的权限掩码</td><td>umask 027</td></tr><tr><td>chown</td><td>改变文件或目录的属主</td><td>chown newowner filename</td></tr><tr><td>chgrp</td><td>改变文件或目录的所属组</td><td>chgrp staff filename</td></tr><tr><td>xlock</td><td>给终端上锁</td><td>xlock -remote</td></tr></tbody></table><h2 id="编程操作"><a href="#编程操作" class="headerlink" title="编程操作"></a>编程操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>make</td><td>维护可执行程序的最新版本</td><td>make</td></tr><tr><td>touch</td><td>更新文件的访问和修改时间</td><td>touch -m 05202400 filename</td></tr><tr><td>dbx</td><td>命令行界面调试工具</td><td>dbx a.out</td></tr><tr><td>xde</td><td>图形用户界面调试工具</td><td>xde a.out</td></tr></tbody></table><h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>ps</td><td>显示进程当前状态</td><td>ps u</td></tr><tr><td>kill</td><td>终止进程</td><td>kill -9 30142</td></tr><tr><td>nice</td><td>改变待执行命令的优先级</td><td>nice cc -c *.c</td></tr><tr><td>renice</td><td>改变已运行进程的优先级</td><td>renice +20 32768</td></tr></tbody></table><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>date</td><td>显示系统的当前日期和时间</td><td>date</td></tr><tr><td>cal</td><td>显示日历</td><td>cal 8 1996</td></tr><tr><td>time</td><td>统计程序的执行时间</td><td>time a.out</td></tr></tbody></table><h2 id="网络与通信操作"><a href="#网络与通信操作" class="headerlink" title="网络与通信操作"></a>网络与通信操作</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>telnet</td><td>远程登录</td><td>telnet hpc.sp.net.edu.cn</td></tr><tr><td>rlogin</td><td>远程登录</td><td>rlogin hostname -l username</td></tr><tr><td>rsh</td><td>在远程主机执行指定命令</td><td>rsh f01n03 date</td></tr><tr><td>ftp</td><td>在本地主机与远程主机之间传输文件</td><td>ftp ftp.sp.net.edu.cn</td></tr><tr><td>rcp</td><td>在本地主机与远程主机 之间复制文</td><td>rcp file1 host1:file2</td></tr><tr><td>ping</td><td>给一个网络主机发送 回应请求</td><td>ping hpc.sp.net.edu.cn</td></tr><tr><td>mail</td><td>阅读和发送电子邮件</td><td>mail</td></tr><tr><td>write</td><td>给另一用户发送报文</td><td>write username pts/1</td></tr><tr><td>mesg</td><td>允许或拒绝接收报文</td><td>mesg n</td></tr></tbody></table><h2 id="Korn-Shell-命令"><a href="#Korn-Shell-命令" class="headerlink" title="Korn Shell 命令"></a>Korn Shell 命令</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>history</td><td>列出最近执行过的 几条命令及编号</td><td>history</td></tr><tr><td>r</td><td>重复执行最近执行过的 某条命令</td><td>r -2</td></tr><tr><td>alias</td><td>给某个命令定义别名</td><td>alias del=rm -i</td></tr><tr><td>unalias</td><td>取消对某个别名的定义</td><td>unalias del</td></tr></tbody></table><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>uname</td><td>显示操作系统的有关信息</td><td>uname -a</td></tr><tr><td>clear</td><td>清除屏幕或窗口内容</td><td>clear</td></tr><tr><td>env</td><td>显示当前所有设置过的环境变量</td><td>env</td></tr><tr><td>who</td><td>列出当前登录的所有用户</td><td>who</td></tr><tr><td>whoami</td><td>显示当前正进行操作的用户名</td><td>whoami</td></tr><tr><td>tty</td><td>显示终端或伪终端的名称</td><td>tty</td></tr><tr><td>stty</td><td>显示或重置控制键定义</td><td>stty</td></tr><tr><td>du</td><td>查询磁盘使用情况</td><td>du -k subdir</td></tr><tr><td>df</td><td>显示文件系统的总空间和可用空间</td><td>df /tmp</td></tr><tr><td>w</td><td>显示当前系统活动的总信息</td><td>w</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“终端” App 可让高级用户和开发者通过命令行界面 (CLI) 与 Mac 操作系统进行通信。你可以输入命令和脚本（称为 shell 脚本）在 Mac 上执行任务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.apple.com/zh-cn/guide/terminal/trmlshtcts/2.14/mac/14.0&quot;&gt;Mac 终端键盘快键键&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录操作&quot;&gt;&lt;a href=&quot;#目录操作&quot; class=&quot;headerlink&quot; title=&quot;目录操作&quot;&gt;&lt;/a&gt;目录操作&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能描述&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;mkdir&lt;/td&gt;
&lt;td&gt;创建一个目录&lt;/td&gt;
&lt;td&gt;mkdir dirname&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rmdir&lt;/td&gt;
&lt;td&gt;删除一个目录&lt;/td&gt;
&lt;td&gt;rmdir dirname&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mvdir&lt;/td&gt;
&lt;td&gt;移动或重命名一个目录&lt;/td&gt;
&lt;td&gt;mvdir dir1 dir2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cd&lt;/td&gt;
&lt;td&gt;改变当前目录&lt;/td&gt;
&lt;td&gt;cd dirname&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pwd&lt;/td&gt;
&lt;td&gt;显示当前目录的路径名&lt;/td&gt;
&lt;td&gt;pwd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ls&lt;/td&gt;
&lt;td&gt;显示当前目录的内容&lt;/td&gt;
&lt;td&gt;ls -la&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dircmp&lt;/td&gt;
&lt;td&gt;比较两个目录的内容&lt;/td&gt;
&lt;td&gt;dircmp dir1 dir2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="web综合" scheme="https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="mac" scheme="https://bubuzou.com/tags/mac/"/>
    
      <category term="命令" scheme="https://bubuzou.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>深入学习 TypeScript 类型体操</title>
    <link href="https://bubuzou.com/2024/02/18/typescript-deep/"/>
    <id>https://bubuzou.com/2024/02/18/typescript-deep/</id>
    <published>2024-02-18T06:19:26.000Z</published>
    <updated>2024-06-14T12:58:46.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式匹配做提取"><a href="#模式匹配做提取" class="headerlink" title="模式匹配做提取"></a>模式匹配做提取</h2><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p><strong>提取数组第一个元素的类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetFirst&lt;Arr <span class="keyword">extends</span> unknown[]&gt; = Arr <span class="keyword">extends</span> [infer First, ...unknown[]]</span><br><span class="line">  ? First</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p><strong>提取数组最后一个元素的类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetLast&lt;Arr <span class="keyword">extends</span> unknown[]&gt; = Arr <span class="keyword">extends</span> [...unknown[], infer Last]</span><br><span class="line">  ? Last</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p><strong>取去掉最后一个元素的数组</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PopArr&lt;Arr <span class="keyword">extends</span> unknown[]&gt; = Arr <span class="keyword">extends</span> []</span><br><span class="line">  ? []</span><br><span class="line">  : Arr <span class="keyword">extends</span> [...infer Rest, unknown]</span><br><span class="line">  ? Rest</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><strong>字符串是否以某个特定字符开头</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StartWidth&lt;</span><br><span class="line">  Str <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  Prefix <span class="keyword">extends</span> <span class="built_in">String</span></span><br><span class="line">&gt; = Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Prefix&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><strong>将字符串中某个特定的部分替换成别的字符串</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceStr&lt;</span><br><span class="line">  Str <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  From <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  To <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Prefix&#125;</span><span class="subst">$&#123;From&#125;</span><span class="subst">$&#123;infer Suffix&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;Prefix&#125;</span><span class="subst">$&#123;To&#125;</span><span class="subst">$&#123;Suffix&#125;</span>`</span></span><br><span class="line">  : Str;</span><br></pre></td></tr></table></figure><p><strong>字符串去除右空格</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TrimStrRight&lt;Str <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Rest&#125;</span><span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">  | <span class="string">&quot; &quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">  | <span class="string">&quot;\n&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">  | <span class="string">&quot;\t&quot;</span>&#125;</span>`</span></span><br><span class="line">  ? TrimStrRight&lt;Rest&gt;</span><br><span class="line">  : Str;</span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p><strong>提取函数参数的类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetParameters&lt;Func <span class="keyword">extends</span> <span class="built_in">Function</span>&gt; = Func <span class="keyword">extends</span> (</span><br><span class="line">  ...args: infer Args</span><br><span class="line">) =&gt; unknown</span><br><span class="line">  ? Args</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p><strong>提取函数返回值的类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetReturnType&lt;Func <span class="keyword">extends</span> <span class="built_in">Function</span>&gt; = Func <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer ReturnType</span><br><span class="line">  ? ReturnType</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p><strong>提取构造器参数的类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetInstanceParameters&lt;ConstructorType <span class="keyword">extends</span> <span class="keyword">new</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; =</span><br><span class="line">  ConstructorType <span class="keyword">extends</span> <span class="keyword">new</span> (...args: infer ParametersType) =&gt; <span class="built_in">any</span></span><br><span class="line">    ? ParametersType</span><br><span class="line">    : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p><strong>提取构造器返回值类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetInstanceReturnType&lt;ConstructorType <span class="keyword">extends</span> <span class="keyword">new</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; =</span><br><span class="line">  ConstructorType <span class="keyword">extends</span> <span class="keyword">new</span> (...args: <span class="built_in">any</span>) =&gt; infer InstanceType</span><br><span class="line">    ? InstanceType</span><br><span class="line">    : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p><strong>提取 props 中 ref 值的类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetRefProps&lt;Props&gt; = <span class="string">&quot;ref&quot;</span> <span class="keyword">extends</span> keyof Props</span><br><span class="line">  ? Props <span class="keyword">extends</span> &#123; ref?: infer Value | <span class="literal">undefined</span> &#125;</span><br><span class="line">    ? Value</span><br><span class="line">    : <span class="built_in">never</span></span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h2 id="重新构造做变换"><a href="#重新构造做变换" class="headerlink" title="重新构造做变换"></a>重新构造做变换</h2><p>TypeScript 的 type、infer、类型参数声明的变量都不能修改，想对类型做各种变换产生新的类型就需要重新构造。</p><h3 id="数组类型的构造"><a href="#数组类型的构造" class="headerlink" title="数组类型的构造"></a>数组类型的构造</h3><p><strong>给数组/元组添加新类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Push&lt;Arr <span class="keyword">extends</span> unknown[], Ele&gt; = [...Arr, Ele];</span><br></pre></td></tr></table></figure><p><strong>元组重组</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tuple1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">type</span> tuple2 = [<span class="string">&quot;guang&quot;</span>, <span class="string">&quot;dong&quot;</span>];</span><br><span class="line"><span class="comment">// 重组成如下的元组</span></span><br><span class="line"><span class="keyword">type</span> tuple = [[<span class="number">1</span>, <span class="string">&quot;guang&quot;</span>], [<span class="number">2</span>, <span class="string">&quot;dong&quot;</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码实现</span></span><br><span class="line"><span class="keyword">type</span> Zip&lt;One <span class="keyword">extends</span> unknown[], Other <span class="keyword">extends</span> unknown[]&gt; = One <span class="keyword">extends</span> [</span><br><span class="line">  infer OneFirst,</span><br><span class="line">  ...infer OneRest</span><br><span class="line">]</span><br><span class="line">  ? Other <span class="keyword">extends</span> [infer OtherFirst, ...infer OtherRest]</span><br><span class="line">    ? [[OneFirst, OtherFirst], ...Zip&lt;OneRest, OtherRest&gt;]</span><br><span class="line">    : []</span><br><span class="line">  : [];</span><br></pre></td></tr></table></figure><h3 id="字符串类型的构造"><a href="#字符串类型的构造" class="headerlink" title="字符串类型的构造"></a>字符串类型的构造</h3><p><strong>将字符串首字母大写</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CapitalizeStr&lt;Str <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">  Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;Uppercase&lt;First&gt;&#125;</span><span class="subst">$&#123;Rest&#125;</span>`</span></span><br><span class="line">    : Str;</span><br></pre></td></tr></table></figure><p><strong>将字符串下划线转驼峰</strong></p><dl><dt>```ts<code>type CamelCase&lt;Str extends string&gt; = Str extends</code>${infer Left}_${infer Right}${infer Rest}<code>?</code>${Left}${Uppercase<Right>}${CamelCase<Rest>}`</dt><dd>Str;</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**删除字符串子串**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;ts</span><br><span class="line">type DropSubStr&lt;Str extends string, SubStr extends string&gt; &#x3D;</span><br><span class="line">    Str extends &#96;$&#123;infer Prefix&#125;$&#123;SubStr&#125;$&#123;infer Suffix&#125;&#96;</span><br><span class="line">        ? DropSubStr&lt;&#96;$&#123;Prefix&#125;$&#123;Suffix&#125;&#96;, SubStr&gt;</span><br><span class="line">        : Str;</span><br></pre></td></tr></table></figure><h3 id="函数类型的构造"><a href="#函数类型的构造" class="headerlink" title="函数类型的构造"></a>函数类型的构造</h3><p><strong>给函数添加一个参数</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendArgument&lt;Func <span class="keyword">extends</span> <span class="built_in">Function</span>, Arg&gt; = Func <span class="keyword">extends</span> (</span><br><span class="line">  ...args: infer Args</span><br><span class="line">) =&gt; infer ReturnType</span><br><span class="line">  ? <span class="function">(<span class="params">...args: [...Args, Arg]</span>) =&gt;</span> ReturnType</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="索引类型的构造"><a href="#索引类型的构造" class="headerlink" title="索引类型的构造"></a>索引类型的构造</h3><p>索引类型是聚合多个元素的类型。比如 class 和对象都是索引类型。索引类型的元素的类型只能是 string、number 或者 Symbol 等类型。</p><p>索引类型的每个元素的类型可以添加修饰符：readonly（只读）、?（可选）。</p><p><strong>映射类型语法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mapping&lt;Obj <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Obj]: Obj[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>用 as 做重映射改变索引类型的 Key 转成大写</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UppercaseKey&lt;Obj <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Obj <span class="keyword">as</span> Uppercase&lt;Key &amp; <span class="built_in">string</span>&gt;]: Obj[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>因为这里索引的类型可能是 string、number 或 symbol 类型，但是这里转成大写只能是限定为 string。</p></blockquote><p><strong>TS 内置高级类型 Record</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span> | symbol, T&gt; = &#123; [P <span class="keyword">in</span> K]: T &#125;;</span><br></pre></td></tr></table></figure><p><strong>UppercaseKey 重写版：用 Record 来约束索引类型而不是 object</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UppercaseKey&lt;Obj <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Obj <span class="keyword">as</span> Uppercase&lt;Key &amp; <span class="built_in">string</span>&gt;]: Obj[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>给索引类型添加只读的高级类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToReadonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [Key <span class="keyword">in</span> keyof T]: T[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>给索引类型添加可选的高级类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToPartial&lt;T&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof T]?: T[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>给索引类型去掉只读修饰符</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToMutable&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [Key <span class="keyword">in</span> keyof T]: T[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>给索引类型去掉可选修饰符</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToRequired&lt;T&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof T]-?: T[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>返回特定值的类型的索引类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterByValueType&lt;Obj <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;, ValueType&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Obj <span class="keyword">as</span> Obj[Key] <span class="keyword">extends</span> ValueType ? Key : <span class="built_in">never</span>]: Obj[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归复用做循环"><a href="#递归复用做循环" class="headerlink" title="递归复用做循环"></a>递归复用做循环</h2><h3 id="Promise-的递归复用"><a href="#Promise-的递归复用" class="headerlink" title="Promise 的递归复用"></a>Promise 的递归复用</h3><p><strong>提取 Promise 值的类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepPromiseValueType&lt;P <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;unknown&gt;&gt; = P <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;</span><br><span class="line">  infer ValueType</span><br><span class="line">&gt;</span><br><span class="line">  ? ValueType <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;unknown&gt;</span><br><span class="line">    ? DeepPromiseValueType&lt;ValueType&gt;</span><br><span class="line">    : ValueType</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p><strong>提取 Promise 值的类型简化版</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepPromiseValueType&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;infer ValueType&gt;</span><br><span class="line">  ? DeepPromiseValueType&lt;ValueType&gt;</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="数组类型的递归"><a href="#数组类型的递归" class="headerlink" title="数组类型的递归"></a>数组类型的递归</h3><p><strong>反转元组</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReversrArr&lt;Arr <span class="keyword">extends</span> unknown[]&gt; = Arr <span class="keyword">extends</span> [</span><br><span class="line">  infer First,</span><br><span class="line">  ...infer Rest</span><br><span class="line">]</span><br><span class="line">  ? [...ReversrArr&lt;Rest&gt;, First]</span><br><span class="line">  : Arr;</span><br></pre></td></tr></table></figure><p><strong>查找元素</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Includes&lt;Arr <span class="keyword">extends</span> unknown[], FindItem&gt; = Arr <span class="keyword">extends</span> [</span><br><span class="line">  infer First,</span><br><span class="line">  ...infer Rest</span><br><span class="line">]</span><br><span class="line">  ? IsEqual&lt;First, FindItem&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : Includes&lt;Rest, FindItem&gt;</span><br><span class="line">  : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> IsEqual&lt;A, B&gt; = (A <span class="keyword">extends</span> B ? <span class="literal">true</span> : <span class="literal">false</span>) &amp;</span><br><span class="line">  (B <span class="keyword">extends</span> A ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p><strong>删除元素</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RemoveItem&lt;</span><br><span class="line">  Arr <span class="keyword">extends</span> unknown[],</span><br><span class="line">  Item,</span><br><span class="line">  Result <span class="keyword">extends</span> unknown[] = []</span><br><span class="line">&gt; = Arr <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? IsEqual&lt;First, Item&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? RemoveItem&lt;Rest, Item, Result&gt;</span><br><span class="line">    : RemoveItem&lt;Rest, Item, [...Result, First]&gt;</span><br><span class="line">  : Result;</span><br><span class="line"><span class="keyword">type</span> IsEqual&lt;A, B&gt; = (A <span class="keyword">extends</span> B ? <span class="literal">true</span> : <span class="literal">false</span>) &amp;</span><br><span class="line">  (B <span class="keyword">extends</span> A ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p><strong>构造指定类型的数组</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BuildArray&lt;</span><br><span class="line">  Length <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Ele = unknown,</span><br><span class="line">  Arr <span class="keyword">extends</span> unknown[] = []</span><br><span class="line">&gt; = Arr[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> Length ? Arr : BuildArray&lt;Length, Ele, [...Arr, Ele]&gt;;</span><br></pre></td></tr></table></figure><h3 id="字符串类型的递归"><a href="#字符串类型的递归" class="headerlink" title="字符串类型的递归"></a>字符串类型的递归</h3><p><strong>替换子串</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceAll&lt;</span><br><span class="line">  Str <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  From <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  To <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Left&#125;</span><span class="subst">$&#123;From&#125;</span><span class="subst">$&#123;infer Right&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;Left&#125;</span><span class="subst">$&#123;To&#125;</span><span class="subst">$&#123;ReplaceAll&lt;Right, From, To&gt;&#125;</span>`</span></span><br><span class="line">  : Str;</span><br></pre></td></tr></table></figure><p><strong>提取字符做联合类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToUnion&lt;Str <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">  Str <span class="keyword">extends</span> <span class="string">`&#123;infer First&#125;<span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">    ? First | StringToUnion&lt;Rest&gt;</span><br><span class="line">    : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p><strong>反转字符串</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReverseStr&lt;Str <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;ReverseStr&lt;Rest&gt;&#125;</span><span class="subst">$&#123;First&#125;</span>`</span></span><br><span class="line">  : Str;</span><br></pre></td></tr></table></figure><h3 id="对象类型的递归"><a href="#对象类型的递归" class="headerlink" title="对象类型的递归"></a>对象类型的递归</h3><p><strong>深度递归</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepToReadonly&lt;T <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span></span><br><span class="line">  ? &#123;</span><br><span class="line">      <span class="keyword">readonly</span> [Key <span class="keyword">in</span> keyof T]: T[Key] <span class="keyword">extends</span> <span class="built_in">Object</span></span><br><span class="line">        ? T[Key] <span class="keyword">extends</span> <span class="built_in">Function</span></span><br><span class="line">          ? T[Key]</span><br><span class="line">          : DeepToReadonly&lt;T[Key]&gt;</span><br><span class="line">        : T[Key];</span><br><span class="line">    &#125;</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h2 id="数组长度做计算"><a href="#数组长度做计算" class="headerlink" title="数组长度做计算"></a>数组长度做计算</h2><h3 id="数组长度实现加减乘除"><a href="#数组长度实现加减乘除" class="headerlink" title="数组长度实现加减乘除"></a>数组长度实现加减乘除</h3><p><strong>加法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BuildArray&lt;</span><br><span class="line">  Length <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Ele = unknown,</span><br><span class="line">  Arr <span class="keyword">extends</span> unknown[] = []</span><br><span class="line">&gt; = Arr[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> Length ? Arr : BuildArray&lt;Length, Ele, [...Arr, Ele]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Add&lt;Num1 <span class="keyword">extends</span> <span class="built_in">number</span>, Num2 <span class="keyword">extends</span> <span class="built_in">number</span>&gt; = [</span><br><span class="line">  ...BuildArray&lt;Num1&gt;,</span><br><span class="line">  ...BuildArray&lt;Num2&gt;</span><br><span class="line">][<span class="string">&quot;length&quot;</span>];</span><br></pre></td></tr></table></figure><p><strong>减法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Subtract&lt;</span><br><span class="line">  Num1 <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Num2 <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">&gt; = BuildArray&lt;Num1&gt; <span class="keyword">extends</span> [...BuildArray&lt;Num2&gt;, ...infer Rest]</span><br><span class="line">  ? Rest[<span class="string">&quot;length&quot;</span>]</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p><strong>乘法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Multiple&lt;</span><br><span class="line">  Num1 <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Num2 <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  ResultArr <span class="keyword">extends</span> unknown[] = []</span><br><span class="line">&gt; = Num2 <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">  ? ResultArr[<span class="string">&quot;length&quot;</span>]</span><br><span class="line">  : Multiple&lt;Num1, Subtract&lt;Num2, <span class="number">1</span>&gt;, [...ResultArr, ...BuildArray&lt;Num1&gt;]&gt;;</span><br></pre></td></tr></table></figure><p><strong>除法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Divide&lt;</span><br><span class="line">  Num1 <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Num2 <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  ResultArr <span class="keyword">extends</span> unknown[] = []</span><br><span class="line">&gt; = Num1 <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">  ? ResultArr[<span class="string">&quot;length&quot;</span>]</span><br><span class="line">  : Divide&lt;Subtract&lt;Num1, Num2&gt;, Num2, [...ResultArr, unknown]&gt;;</span><br></pre></td></tr></table></figure><h3 id="数组长度实现计数"><a href="#数组长度实现计数" class="headerlink" title="数组长度实现计数"></a>数组长度实现计数</h3><p><strong>计算字符串长度</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StrLen&lt;</span><br><span class="line">  Str <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  CountArr <span class="keyword">extends</span> unknown[] = []</span><br><span class="line">&gt; = Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? StrLen&lt;Rest, [...CountArr, unknown]&gt;</span><br><span class="line">  : CountArr[<span class="string">&quot;length&quot;</span>];</span><br></pre></td></tr></table></figure><p><strong>比较 2 个数值谁更大</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GreaterThan&lt;</span><br><span class="line">  Num1 <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Num2 <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  CountArr <span class="keyword">extends</span> unknown[] = []</span><br><span class="line">&gt; = Num1 <span class="keyword">extends</span> Num2</span><br><span class="line">  ? <span class="literal">false</span></span><br><span class="line">  : CountArr[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> Num2</span><br><span class="line">  ? <span class="literal">true</span></span><br><span class="line">  : CountArr[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> Num1</span><br><span class="line">  ? <span class="literal">false</span></span><br><span class="line">  : GreaterThan&lt;Num1, Num2, [...CountArr, unknown]&gt;;</span><br></pre></td></tr></table></figure><p><strong>实现斐波那契数列</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FibonacciLoop&lt;</span><br><span class="line">  PrevArr <span class="keyword">extends</span> unknown[],</span><br><span class="line">  CurrentArr <span class="keyword">extends</span> unknown[],</span><br><span class="line">  IndexArr <span class="keyword">extends</span> unknown[] = [],</span><br><span class="line">  Num <span class="keyword">extends</span> <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line">&gt; = IndexArr[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> Num</span><br><span class="line">  ? CurrentArr[<span class="string">&quot;length&quot;</span>]</span><br><span class="line">  : FibonacciLoop&lt;</span><br><span class="line">      CurrentArr,</span><br><span class="line">      [...PrevArr, ...CurrentArr],</span><br><span class="line">      [...IndexArr, unknown],</span><br><span class="line">      Num</span><br><span class="line">    &gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fibonacci&lt;Num <span class="keyword">extends</span> <span class="built_in">number</span>&gt; = FibonacciLoop&lt;[<span class="number">1</span>], [], [], Num&gt;;</span><br></pre></td></tr></table></figure><h2 id="聚合分散可简化"><a href="#聚合分散可简化" class="headerlink" title="聚合分散可简化"></a>聚合分散可简化</h2><h3 id="分布式条件类型"><a href="#分布式条件类型" class="headerlink" title="分布式条件类型"></a>分布式条件类型</h3><p>当类型参数为联合类型，并且在条件类型左边直接引用该类型参数的时候，TypeScript 会把每一个元素单独传入来做类型运算，最后再合并成联合类型，这种语法叫做分布式条件类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Union = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> UppercaseA&lt;Item <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Item <span class="keyword">extends</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">  ? Uppercase&lt;Item&gt;</span><br><span class="line">  : Item;</span><br></pre></td></tr></table></figure><p>这和联合类型遇到字符串时的处理一样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Union = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> str = <span class="string">`<span class="subst">$&#123;Union&#125;</span>~`</span>;</span><br><span class="line"><span class="comment">// type str = &#x27;a~&#x27; | &#x27;b~&#x27;;</span></span><br></pre></td></tr></table></figure><h3 id="数组转联合类型"><a href="#数组转联合类型" class="headerlink" title="数组转联合类型"></a>数组转联合类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">type</span> UnionArr = Arr[<span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// type UnionArr = &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;;</span></span><br></pre></td></tr></table></figure><h3 id="判断是否是联合类型"><a href="#判断是否是联合类型" class="headerlink" title="判断是否是联合类型"></a>判断是否是联合类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> isUnion&lt;A, B = A&gt; = A <span class="keyword">extends</span> A ? ([B] <span class="keyword">extends</span> [A] ? <span class="literal">false</span> : <span class="literal">true</span>) : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>当 A 是联合类型时：</p><ul><li>A extends A 这种写法是为了触发分布式条件类型，让每个类型单独传入处理的，没别的意义。</li><li>A extends A 和 [A] extends [A] 是不同的处理，前者是单个类型和整个类型做判断，后者两边都是整个联合类型，因为只有 extends 左边直接是类型参数才会触发分布式条件类型。</li></ul><h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BEM&lt;</span><br><span class="line">  Block <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  Element <span class="keyword">extends</span> <span class="built_in">string</span>[],</span><br><span class="line">  Modifiers <span class="keyword">extends</span> <span class="built_in">string</span>[]</span><br><span class="line">&gt; = <span class="string">`<span class="subst">$&#123;Block&#125;</span>__<span class="subst">$&#123;Element[<span class="built_in">number</span>]&#125;</span>--<span class="subst">$&#123;Modifiers[<span class="built_in">number</span>]&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><h3 id="全组合"><a href="#全组合" class="headerlink" title="全组合"></a>全组合</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 和 B 的全组合</span></span><br><span class="line"><span class="keyword">type</span> Combination&lt;A <span class="keyword">extends</span> <span class="built_in">string</span>, B <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">    A | B | <span class="string">`<span class="subst">$&#123;A&#125;</span><span class="subst">$&#123;B&#125;</span>`</span> | <span class="string">`<span class="subst">$&#123;B&#125;</span><span class="subst">$&#123;A&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全组合</span></span><br><span class="line"><span class="keyword">type</span> AllCombinations&lt;A <span class="keyword">extends</span> <span class="built_in">string</span>, B <span class="keyword">extends</span> <span class="built_in">string</span> = A&gt; =</span><br><span class="line">    A extens A</span><br><span class="line">        ? Combination&lt;A, AllCombinations&lt;Exclude&lt;B, A&gt;&gt;&gt;</span><br><span class="line">        : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h2 id="特殊特性要记清"><a href="#特殊特性要记清" class="headerlink" title="特殊特性要记清"></a>特殊特性要记清</h2><h3 id="IsAny"><a href="#IsAny" class="headerlink" title="IsAny"></a>IsAny</h3><p>any 类型与任何类型的交叉都是 any，也就是 1 &amp; any 结果是 any。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsAny&lt;T&gt; = <span class="string">&quot;a&quot;</span> <span class="keyword">extends</span> <span class="number">1</span> &amp; T ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="IsEqual"><a href="#IsEqual" class="headerlink" title="IsEqual"></a>IsEqual</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下这种写法不能判断 isAny，isEqual&lt;&#x27;a&#x27;, any&gt; 会返回 true</span></span><br><span class="line"><span class="keyword">type</span> IsEqual&lt;A, B&gt; = (A <span class="keyword">extends</span> B ? <span class="literal">true</span> : <span class="literal">false</span>) &amp;</span><br><span class="line">  (B <span class="keyword">extends</span> A ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这个可以判断 IsEqual2&lt;&#x27;a&#x27;, any&gt; 会返回 false</span></span><br><span class="line"><span class="keyword">type</span> IsEqual2&lt;A, B&gt; = (&lt;T&gt;<span class="function">() =&gt;</span> T <span class="keyword">extends</span> A ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span> &lt;</span><br><span class="line">  T</span><br><span class="line">&gt;<span class="function">() =&gt;</span> T <span class="keyword">extends</span> B ? <span class="number">1</span> : <span class="number">2</span></span><br><span class="line">  ? <span class="literal">true</span></span><br><span class="line">  : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="IsUnion"><a href="#IsUnion" class="headerlink" title="IsUnion"></a>IsUnion</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsUnion&lt;A, B&gt; = A <span class="keyword">extends</span> A ? ([B] <span class="keyword">extends</span> [A] ? <span class="literal">false</span> : <span class="literal">true</span>) : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="IsNever"><a href="#IsNever" class="headerlink" title="IsNever"></a>IsNever</h3><p>never 在条件类型中也比较特殊，如果条件类型左边是类型参数，并且传入的是 never，那么直接返回 never。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TestNever&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 如下会返回 never</span></span><br><span class="line"><span class="keyword">type</span> result = TestNever&lt;<span class="built_in">never</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 IsNever</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">never</span>] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>除此之外，any 在条件类型中也比较特殊，如果类型参数为 any，会直接返回 trueType 和 falseType 的合并。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TestAny&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 如下会返回 1 | 2</span></span><br><span class="line"><span class="keyword">type</span> result = TestAny&lt;<span class="built_in">any</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="IsTuple"><a href="#IsTuple" class="headerlink" title="IsTuple"></a>IsTuple</h3><p>元组类型的 length 是数字字面量，而数组的 length 是 number。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsTuple&lt;T&gt; = T <span class="keyword">extends</span> [...infer Eles]</span><br><span class="line">  ? NotEqual&lt;Ele[<span class="string">&quot;length&quot;</span>], <span class="built_in">number</span>&gt;</span><br><span class="line">  : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NotEqual&lt;A, B&gt; = (&lt;T&gt;<span class="function">() =&gt;</span> T <span class="keyword">extends</span> A ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span> &lt;</span><br><span class="line">  T</span><br><span class="line">&gt;<span class="function">() =&gt;</span> T <span class="keyword">extends</span> B ? <span class="number">1</span> : <span class="number">2</span></span><br><span class="line">  ? <span class="literal">false</span></span><br><span class="line">  : <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="UnionToIntersection"><a href="#UnionToIntersection" class="headerlink" title="UnionToIntersection"></a>UnionToIntersection</h3><p>联合类型转交叉类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersecion&lt;U&gt; = (U <span class="keyword">extends</span> U ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> unknown : <span class="built_in">never</span>) <span class="keyword">extends</span> (</span><br><span class="line">  x: infer R</span><br><span class="line">) =&gt; unknown</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="GetOptional"><a href="#GetOptional" class="headerlink" title="GetOptional"></a>GetOptional</h3><p>提取索引类型中的可选索引。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetOptional&lt;Obj <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Obj <span class="keyword">as</span> &#123;&#125; <span class="keyword">extends</span> Pick&lt;Obj, Key&gt; ? Key : <span class="built_in">never</span>]: Obj[Key];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick 是 TS 内置高级类型</span></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123; [P <span class="keyword">in</span> K]: T[P] &#125;;</span><br></pre></td></tr></table></figure><h3 id="GetRequired"><a href="#GetRequired" class="headerlink" title="GetRequired"></a>GetRequired</h3><p>提取索引类型中的非可选索引构造成新的索引类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetRequired&lt;Obj <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Obj <span class="keyword">as</span> &#123;&#125; <span class="keyword">extends</span> Pick&lt;Obj, Key&gt; ? <span class="built_in">never</span> : Key]: Obj[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="RemoveIndexSignature"><a href="#RemoveIndexSignature" class="headerlink" title="RemoveIndexSignature"></a>RemoveIndexSignature</h3><p>过滤掉索引类型中的可索引签名，构造成一个新的索引类型。<br>索引签名的特性：索引签名不能构造成字符串字面量类型，因为它没有名字，而其他索引可以</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RemoveIndexSignature&lt;Obj <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Obj <span class="keyword">as</span> Key <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Str&#125;</span>`</span> ? Str : <span class="built_in">never</span>]: Obj[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ClassPublicProps"><a href="#ClassPublicProps" class="headerlink" title="ClassPublicProps"></a>ClassPublicProps</h3><p>过滤 class 的 public 属性。<br>根据特性：keyof 只能拿到 class 的 public 索引，private 和 protected 的索引会被忽略。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ClassPublicProps&lt;Obj <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Obj]: Obj[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="as-const"><a href="#as-const" class="headerlink" title="as const"></a>as const</h3><p>TypeScript 默认推导出来的类型并不是字面量类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> objType = <span class="keyword">typeof</span> obj;</span><br><span class="line"><span class="comment">// type objType = &#123;</span></span><br><span class="line"><span class="comment">//     a: number;</span></span><br><span class="line"><span class="comment">//     b: number</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>如果想要推到出字面量，就需要用 as const：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">type</span> arrType = <span class="keyword">typeof</span> arr;</span><br><span class="line"><span class="comment">// type arrType = number[];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> arrType2 = <span class="keyword">typeof</span> arr2;</span><br><span class="line"><span class="comment">// type arrType2 = readonly [1, 2, 3];</span></span><br></pre></td></tr></table></figure><p>反转 3 个元素的元组类型，需要加上 readonly 才能匹配成功。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReverseArr&lt;Arr&gt; = Arr <span class="keyword">extends</span> <span class="keyword">readonly</span> [infer A, infer B, infer C]</span><br><span class="line">  ? [C, B, A]</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h2 id="练一练"><a href="#练一练" class="headerlink" title="练一练"></a>练一练</h2><h3 id="实现-ParseQueryString"><a href="#实现-ParseQueryString" class="headerlink" title="实现 ParseQueryString"></a>实现 ParseQueryString</h3><p>将 ‘a=1&amp;b=2&amp;c=3’ 转成 {a: 1, b: 2, c: 3}</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParseQueryString&lt;Str <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">  Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Param&#125;</span>&amp;<span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">    ? MergeParams&lt;ParseParams&lt;Param&gt;, ParseQueryString&lt;Rest&gt;&gt;</span><br><span class="line">    : ParseParam&lt;Str&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ParseParams&lt;Param <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">  Param <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Key&#125;</span>=<span class="subst">$&#123;infer Value&#125;</span>`</span></span><br><span class="line">    ? &#123;</span><br><span class="line">        [K <span class="keyword">in</span> Key]: Value;</span><br><span class="line">      &#125;</span><br><span class="line">    : Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MergeParams&lt;</span><br><span class="line">  OneParam <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;,</span><br><span class="line">  OtherParam <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span><br><span class="line">&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof OneParam | keyof OtherParam]: Key <span class="keyword">extends</span> keyof OneParam</span><br><span class="line">    ? Key <span class="keyword">extends</span> keyof OtherParam</span><br><span class="line">      ? MergeValue&lt;OneParam[Key], OtherParam[Key]&gt;</span><br><span class="line">      : OneParam[Key]</span><br><span class="line">    : Key <span class="keyword">extends</span> keyof OtherParam</span><br><span class="line">    ? OtherParam[Key]</span><br><span class="line">    : <span class="built_in">never</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MergeValue&lt;One, Other&gt; = One <span class="keyword">extends</span> Other</span><br><span class="line">  ? One</span><br><span class="line">  : Other <span class="keyword">extends</span> unknown[]</span><br><span class="line">  ? [One, ...Other]</span><br><span class="line">  : [One, Other];</span><br></pre></td></tr></table></figure><h2 id="TS-内置的高级类型"><a href="#TS-内置的高级类型" class="headerlink" title="TS 内置的高级类型"></a>TS 内置的高级类型</h2><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>提取函数类型的参数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Parameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: infer P</span><br><span class="line">) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? P</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><p>提取函数类型的返回值类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span></span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters</h3><p>提取构造函数的参数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConstructorParameters&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...ars: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (</span><br><span class="line">  ...args: infer P</span><br><span class="line">) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? P</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h3><p>提取构造器返回值类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InstanceType&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...ars: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (</span><br><span class="line">  ...ars: <span class="built_in">any</span></span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><h3 id="ThisParameterType"><a href="#ThisParameterType" class="headerlink" title="ThisParameterType"></a>ThisParameterType</h3><p>提取函数参数中 this 的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ThisParameterType&lt;T&gt; = T <span class="keyword">extends</span> (<span class="built_in">this</span>: infer U, ...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? U</span><br><span class="line">  : unknown;</span><br></pre></td></tr></table></figure><h3 id="OmitThisParameter"><a href="#OmitThisParameter" class="headerlink" title="OmitThisParameter"></a>OmitThisParameter</h3><p>去除函数参数中的 this 类型，并且返回一个新的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OmitThisParameter&lt;T&gt; =</span><br><span class="line">    unknown <span class="keyword">extends</span> ThisParameterType&lt;T&gt;</span><br><span class="line">        ? T</span><br><span class="line">        : T <span class="keyword">extends</span> (...args: infer A) =&gt; infer R</span><br><span class="line">            ? （...args: A） =&gt; infer R</span><br><span class="line">            : T;</span><br></pre></td></tr></table></figure><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p>把索引类型的所有索引变成可选类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p>把索引类型里可选索引改成必选索引</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p>索引类型的索引添加只读</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p>过滤出指定的索引类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p>创建索引类型</p><blockquote><p>keyof any 会返回 string | number | symbol</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 Record 里的第一个参数是 string | number | symbol，那么创建的就是索引签名索引类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RecordRes = Record&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="comment">// RecordRes = &#123;</span></span><br><span class="line"><span class="comment">//     [x: string]: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h3><p>去掉联合类型中的某些类型，即取差集</p><p>联合类型当作为类型参数出现在条件类型左边时，会被分散成单个类型传入，这叫做分布式条件类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure><h3 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h3><p>提取联合类型中的某些类型，即取交集</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h3><p>去掉某部分索引类型的索引构成新索引类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">in</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, EXclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure><h3 id="Awaited"><a href="#Awaited" class="headerlink" title="Awaited"></a>Awaited</h3><p>提取 Promise 的返回值类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Awaited&lt;T&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line">        ? T</span><br><span class="line">        : T <span class="keyword">extends</span> <span class="built_in">object</span> &amp; &#123; then(onfulfilled: infer F): <span class="built_in">any</span>&#125;</span><br><span class="line">            ? F <span class="keyword">extends</span> (<span class="function">(<span class="params">value, infer V, ...ars: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span>)</span><br><span class="line">                ? Awaited&lt;V&gt;</span><br><span class="line">                : <span class="built_in">never</span></span><br><span class="line">            : T;</span><br></pre></td></tr></table></figure><h3 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h3><p>判断是否是空类型，即不是 null 或 undefined</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NonNullable&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | unfefined ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure><h3 id="Uppercase、Lowercase、Capitalize、Uncapitalize"><a href="#Uppercase、Lowercase、Capitalize、Uncapitalize" class="headerlink" title="Uppercase、Lowercase、Capitalize、Uncapitalize"></a>Uppercase、Lowercase、Capitalize、Uncapitalize</h3><p>这几个类型分别是实现大写、小写、首字母大写、去掉首字母大写的。<br>他们的实现是直接用 js 实现的。</p><h2 id="综合实战"><a href="#综合实战" class="headerlink" title="综合实战"></a>综合实战</h2><h3 id="KebabCaseToCamelCase"><a href="#KebabCaseToCamelCase" class="headerlink" title="KebabCaseToCamelCase"></a>KebabCaseToCamelCase</h3><p>‘aa-bb-cc’ 这种是 KebabCase，而 ‘aaBbCc’ 这种是 CamelCase</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KebabCaseToCamelCase&lt;Str <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">  Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Item&#125;</span>-<span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;Item&#125;</span><span class="subst">$&#123;KebabCaseToCamelCase&lt;Capitalize&lt;Rest&gt;&gt;&#125;</span>`</span></span><br><span class="line">    : Str;</span><br></pre></td></tr></table></figure><h3 id="CamelCaseToKebabCase"><a href="#CamelCaseToKebabCase" class="headerlink" title="CamelCaseToKebabCase"></a>CamelCaseToKebabCase</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CamelCaseToKebabCase&lt;Str <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">  Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">    ? First <span class="keyword">extends</span> Lowercase&lt;First&gt;</span><br><span class="line">      ? <span class="string">`<span class="subst">$&#123;First&#125;</span><span class="subst">$&#123;CamelCaseToKebabCase&lt;Rest&gt;&#125;</span>`</span></span><br><span class="line">      : <span class="string">`-<span class="subst">$&#123;Lowercase&lt;First&gt;&#125;</span><span class="subst">$&#123;CamelCaseToKebabCase&lt;Rest&gt;&#125;</span>`</span></span><br><span class="line">    : Str;</span><br></pre></td></tr></table></figure><h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p>对数组做分组，比如 1、2、3、4、5 的数组，每两个为 1 组，那就可以分为 1、2 和 3、4 以及 5 这三个 Chunk。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chunk&lt;</span><br><span class="line">  Arr <span class="keyword">extends</span> unknown[],</span><br><span class="line">  ItemLen <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  CurItem <span class="keyword">extends</span> unknown[] = [],</span><br><span class="line">  Res <span class="keyword">extends</span> unknown[] = []</span><br><span class="line">&gt; = Arr <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? CurItem[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> ItemLen</span><br><span class="line">    ? Chunk&lt;Rest, ItemLen, [First], [...Res, CurItem]&gt;</span><br><span class="line">    : Chunk&lt;Rest, ItemLen, [...CurItem, First], Res&gt;</span><br><span class="line">  : [...Res, CurItem];</span><br></pre></td></tr></table></figure><h3 id="TupleToNestedObject"><a href="#TupleToNestedObject" class="headerlink" title="TupleToNestedObject"></a>TupleToNestedObject</h3><p>根据数组类型，比如 [‘a’, ‘b’, ‘c’] 的元组类型，再加上值的类型 ‘xxx’，构造出这样的索引类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToNestedObject&lt;Tuple <span class="keyword">extends</span> unknown[], ValueType&gt; = Tuple <span class="keyword">extends</span> [</span><br><span class="line">  infer First,</span><br><span class="line">  ...infer Rest</span><br><span class="line">]</span><br><span class="line">  ? &#123;</span><br><span class="line">      [Key <span class="keyword">in</span> First <span class="keyword">as</span> Key <span class="keyword">extends</span> keyof <span class="built_in">any</span></span><br><span class="line">        ? Key</span><br><span class="line">        : <span class="built_in">never</span>]: Rest <span class="keyword">extends</span> unknown[]</span><br><span class="line">        ? TupleToNestedObject&lt;Rest, ValueType&gt;</span><br><span class="line">        : ValueType;</span><br><span class="line">    &#125;</span><br><span class="line">  : ValueType;</span><br></pre></td></tr></table></figure><h3 id="PartialObjectPropByKeys"><a href="#PartialObjectPropByKeys" class="headerlink" title="PartialObjectPropByKeys"></a>PartialObjectPropByKeys</h3><p>把一个索引类型的某些 Key 转为 可选的，其余的 Key 不变。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialObjectPropByKeys&lt;</span><br><span class="line">  Obj <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;,</span><br><span class="line">  Key <span class="keyword">extends</span> keyof <span class="built_in">any</span></span><br><span class="line">&gt; = Partial&lt;Pick&lt;Obj, Extract&lt;keyof Obj, Key&gt;&gt;&gt; &amp; Omit&lt;Obj, Key&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PartialObjectPropByKeys2&lt;</span><br><span class="line">  Obj <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;,</span><br><span class="line">  KeyType <span class="keyword">extends</span> keyof <span class="built_in">any</span></span><br><span class="line">&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Obj <span class="keyword">as</span> Key <span class="keyword">extends</span> KeyType ? Key? : Key]: Obj[Key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="函数重载的三种写法"><a href="#函数重载的三种写法" class="headerlink" title="函数重载的三种写法"></a>函数重载的三种写法</h3><p><strong>第一种</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Func &#123;</span><br><span class="line">  (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  (a: <span class="built_in">string</span>, b: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> add: Func = <span class="function">(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure><p><strong>第三种</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Func = (<span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>) &amp; ((a: <span class="built_in">string</span>, b: <span class="built_in">string</span>): <span class="built_in">string</span>)</span><br><span class="line"><span class="keyword">const</span> add: Func = <span class="function">(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure><h3 id="UnionToTuple"><a href="#UnionToTuple" class="headerlink" title="UnionToTuple"></a>UnionToTuple</h3><p>将联合类型转成元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToTuple&lt;T&gt; = UnionToIntersection&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="function">() =&gt;</span> T : <span class="built_in">never</span></span><br><span class="line">&gt; <span class="keyword">extends</span> () =&gt; infer ReturnType</span><br><span class="line">  ? [...UnionToTuple&lt;Exclude&lt;T, ReturnType&gt;&gt;, ReturnType]</span><br><span class="line">  : [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合转交叉</span></span><br><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = (</span><br><span class="line">  U <span class="keyword">extends</span> U ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> unknown : <span class="built_in">never</span></span><br><span class="line">) <span class="keyword">extends</span> (x: infer R) =&gt; unknown</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>实现一个类似的效果，将：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = join(<span class="string">&quot;-&quot;</span>)(<span class="string">&quot;guang&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;dong&quot;</span>);</span><br><span class="line"><span class="comment">// 转成 res = &#x27;guang-and-dong&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>join 代码实现</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">Delimiter</span> <span class="title">extends</span> <span class="title">string</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  delimiter: Delimiter</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): &lt;<span class="title">Items</span> <span class="title">extends</span> <span class="title">string</span>[]&gt;(<span class="params">...parts: Items</span>) =&gt; <span class="title">JoinType</span>&lt;<span class="title">Items</span>, <span class="title">Delimiter</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> JoinType&lt;</span><br><span class="line">  Items <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  Delimiter <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  Result <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">&gt; = Items <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? JoinType&lt;Rest, Delimiter, <span class="string">`<span class="subst">$&#123;Result&#125;</span><span class="subst">$&#123;First &amp; <span class="built_in">string</span>&#125;</span>-`</span>&gt;</span><br><span class="line">  : RemoveLastDelimiter&lt;Result&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RemoveLastDelimiter&lt;Str <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Rest&#125;</span>-`</span></span><br><span class="line">  ? Rest</span><br><span class="line">  : Str;</span><br></pre></td></tr></table></figure><h3 id="AllKeyPath"><a href="#AllKeyPath" class="headerlink" title="AllKeyPath"></a>AllKeyPath</h3><p>拿到一个索引类型的所有 key 的路径。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AllKeyPath&lt;Obj <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;&gt; = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Obj]: Key <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">    ? Obj[Key] <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span><br><span class="line">      ? Key | <span class="string">`<span class="subst">$&#123;Key&#125;</span>.<span class="subst">$&#123;AllKeyPath&lt;Obj[Key]&gt;&#125;</span>`</span></span><br><span class="line">      : Key</span><br><span class="line">    : <span class="built_in">never</span>;</span><br><span class="line">&#125;[keyof Obj];</span><br></pre></td></tr></table></figure><h3 id="Defaultize"><a href="#Defaultize" class="headerlink" title="Defaultize"></a>Defaultize</h3><p>实现这样一个高级类型，对 A、B 两个索引类型做合并，如果是只有 A 中有的不变，如果是 A、B 都有的就变为可选，只有 B 中有的也变为可选。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Defaultize&lt;A, B&gt; = Pick&lt;A, Exclude&lt;keyof A, keyof B&gt;&gt; &amp;</span><br><span class="line">  Partial&lt;Pick&lt;A, Extract&lt;keyof A, keyof B&gt;&gt;&gt; &amp;</span><br><span class="line">  Partial&lt;Pick&lt;B, Exclude&lt;keyof B, keyof A&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure><h2 id="infer-extends"><a href="#infer-extends" class="headerlink" title="infer extends"></a>infer extends</h2><h3 id="枚举值转联合类型"><a href="#枚举值转联合类型" class="headerlink" title="枚举值转联合类型"></a>枚举值转联合类型</h3><p>以下会把枚举的数值类型转成字符串类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Code &#123;</span><br><span class="line">  a = <span class="number">111</span>,</span><br><span class="line">  b = <span class="number">222</span>,</span><br><span class="line">  c = <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> res = <span class="string">`<span class="subst">$&#123;Code&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// res = &#x27;111&#x27; | &#x27;222&#x27; | &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="StrToNum"><a href="#StrToNum" class="headerlink" title="StrToNum"></a>StrToNum</h3><p>使用 infer extends 后就就可以正常使用了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Code &#123;</span><br><span class="line">  a = <span class="number">111</span>,</span><br><span class="line">  b = <span class="number">222</span>,</span><br><span class="line">  c = <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> StrToNum&lt;Str&gt; = Str <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Num <span class="keyword">extends</span> <span class="built_in">number</span>&#125;</span>`</span> ? Num : Str;</span><br><span class="line"><span class="keyword">type</span> res = StrToNum&lt;<span class="string">`<span class="subst">$&#123;Code&#125;</span>`</span>&gt;;</span><br><span class="line"><span class="comment">// res = &#x27;abc&#x27; | 111 | 222</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模式匹配做提取&quot;&gt;&lt;a href=&quot;#模式匹配做提取&quot; class=&quot;headerlink&quot; title=&quot;模式匹配做提取&quot;&gt;&lt;/a&gt;模式匹配做提取&lt;/h2&gt;&lt;h3 id=&quot;数组类型&quot;&gt;&lt;a href=&quot;#数组类型&quot; class=&quot;headerlink&quot; title=&quot;数组类型&quot;&gt;&lt;/a&gt;数组类型&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;提取数组第一个元素的类型&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; GetFirst&amp;lt;Arr &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; unknown[]&amp;gt; = Arr &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; [infer First, ...unknown[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ? First&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  : &lt;span class=&quot;built_in&quot;&gt;never&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提取数组最后一个元素的类型&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; GetLast&amp;lt;Arr &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; unknown[]&amp;gt; = Arr &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; [...unknown[], infer Last]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ? Last&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  : &lt;span class=&quot;built_in&quot;&gt;never&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;取去掉最后一个元素的数组&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; PopArr&amp;lt;Arr &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; unknown[]&amp;gt; = Arr &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ? []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  : Arr &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; [...infer Rest, unknown]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ? Rest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  : &lt;span class=&quot;built_in&quot;&gt;never&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="TypeScript" scheme="https://bubuzou.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://bubuzou.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>微前端的几种架构介绍</title>
    <link href="https://bubuzou.com/2024/02/02/micro-desc/"/>
    <id>https://bubuzou.com/2024/02/02/micro-desc/</id>
    <published>2024-02-02T02:19:26.000Z</published>
    <updated>2024-06-14T12:56:30.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是微前端"><a href="#什么是微前端" class="headerlink" title="什么是微前端"></a>什么是微前端</h2><p>而提到微前端就离不开微服务，大家对微服务都比较熟悉了，微服务允许后端体系结构通过松散耦合的代码库进行扩展，每个代码库负责自己的业务逻辑，并公开一个 API，每个 API 均可独立部署，并且各自由不同的团队拥有和维护。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202207/16568565844214.jpg" alt="-w610"></p><p>前端架构经历了从单体，到前后端分离，再到微服务，最终发展到现在的微前端的过程如下图所示：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202207/16568581684949.jpg" alt="-w697"></p><p>微前端的思路是把微服务的架构引入到前端，其核心都是要能够以业务为单元构建端到端的垂直架构，使得单个的团队能够独立自主的进行相关的开发，同时又具备相当的灵活性，按需求来组成交付应用。</p><p>“微前端”一词最早于 2016 年底在 ThoughtWorks 技术雷达中提出的。它将微服务的概念扩展到了前端世界。微前端的核心思路其实是远程应用程序，包含组件／模块／包的运行时加载。</p><a id="more"></a><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202207/16568585249329.jpg" alt="-w478"></p><p>如上图，对于用户而言，访问的是一个微前端的容器（container），容器加载运行在远程服务上的应用，把这些远程应用作为组件／模块／包在本地浏览器中加载。</p><ul><li>组件是底层 UI 库的构建单元；</li><li>模块是相应运行时的构建单元；</li><li>包是依赖性解析器的构建单元；</li><li>微前端是所提出的应用程序的构建块。</li></ul><p>上面说了很多，总结一下就是：微前端（Micro-Frontends）是一种类似于微服务的架构，他将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以<strong>独立开发</strong>、<strong>独立部署</strong>、<strong>独立运行</strong>。微前端不是单纯的前端框架或者工具，而是一套架构体系。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202207/16568208609680.jpg" alt="-w665"></p><h2 id="为什么需要微前端"><a href="#为什么需要微前端" class="headerlink" title="为什么需要微前端"></a>为什么需要微前端</h2><p>在前面我们看到的微前端之前的架构，所有的前端还是一个单体，前端团队会依赖所有的服务或者后台的 API，前端开发会成为整个系统的瓶颈。使用微前端，就是要让前端业务从水平分层变为垂直应用的一部分，进入业务团队，剥离耦合。</p><p>那么微前端有什么好处，为什么要采用微前端架构呢？</p><ul><li>各个团队独立开发，相互不影响，独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新；</li><li>增量升级，在面对各种复杂场景时，通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略。因为是运行时加载，可以在没有重建的情况下添加，删除或替换前端的各个部分；</li><li>不受技术影响，每个团队都应该能够选择和升级其技术栈，而无需与其他团队进行协调。也就是说 A 应用可以用 React，而 B 应用使用 Vue，大家可以通过同一个基座应用来加载；</li><li>独立运行时，每个微应用之间状态隔离，运行时状态不共享。隔离团队代码，即使所有团队都使用相同的框架，也不要共享运行时。构建自包含的独立应用程序。不要依赖共享状态或全局变量；</li><li>建立团队命名空间，对于 CSS，事件，本地存储和 Cookies，可以避免冲突并阐明所有权。</li></ul><p>因此，微前端和微服务的本质都是关于去耦合。而只有当应用程序达到一定规模时，这才开始变得更有意义。</p><h2 id="如何实现微前端架构"><a href="#如何实现微前端架构" class="headerlink" title="如何实现微前端架构"></a>如何实现微前端架构</h2><p>微前端不是一个库，是一种前端架构的设计思路，要实现微前端，本质上就是在运行时远程加载应用。如下列了一些实现方案，但不仅仅只是这样：</p><ul><li>纯 nginx 路由转发；</li><li>使用 iframe 创建容器；</li><li>组合式应用路由分发；</li><li>使用 Web Components 技术构建；</li><li>Module Federation；</li></ul><h3 id="纯-nginx-路由转发"><a href="#纯-nginx-路由转发" class="headerlink" title="纯 nginx 路由转发"></a>纯 nginx 路由转发</h3><p>即通过路由将不同的业务分发到不同的、独立前端应用上。其通常可以通过 HTTP 服务器的反向代理来实现。这种方案，不涉及前端的改造，完全是依靠运维层面的配置。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202207/16568205299916.jpg" alt="-w498"></p><p>当在浏览器里访问 <a href="http://www.nrp.com/app1">www.nrp.com/app1</a> 的时候，其实访问的是 app1 这个应用；当访问 <a href="http://www.nrp.com/app2">www.nrp.com/app2</a> 的时候，其实访问的是 app2 这个应用。要实现这个功能，就可以用 nginx 的反向代理来实现路由分发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.nrp.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">      root   &#x2F;www&#x2F;wwwroot&#x2F;www.nrp.com&#x2F;;</span><br><span class="line">      index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F;app1 &#123;</span><br><span class="line">      proxy_pass http:&#x2F;&#x2F;www.app1.com&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F;app2 &#123;</span><br><span class="line">      proxy_pass http:&#x2F;&#x2F;www.app2.com&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 http 服务分发不同的路由到不同的独立应用上，虽然实现上很简单，但是缺点也相当明显：</p><ul><li>每一次切换应用的时候都会重新请求资源，没办法做到局部更新当前页面，就相当于是刷新了浏览器，完全丢失了单页应用的体验；</li><li>需要配置一个通用可扩展的路由规则，否则当引入新的应用的时候，还需要修改 nginx 的路由配置；</li></ul><h3 id="使用-iframe-创建容器"><a href="#使用-iframe-创建容器" class="headerlink" title="使用 iframe 创建容器"></a>使用 iframe 创建容器</h3><p>HTML 内联框架元素 <code>&lt;iframe&gt;</code> 表示嵌套的正在浏览的上下文，能有效地将另一个 HTML 页面嵌入到当前页面中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>iframe 可以创建一个全新的独立的宿主环境，这意味着我们的前端应用之间可以相互独立运行。通过给 iframe 的 src 指定不同的地址，来实现加载不同的子应用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;app in appList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-show</span>=<span class="string">&quot;currAppCode == app.code&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;app.code&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:src</span>=<span class="string">&quot;app.src&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 iframe 来加载不同的微应用，接入非常简单，且由于 iframe 天然的沙箱环境使得 js 和样式隔离都非常完美。但他存在以下一些问题：</p><ul><li>页面加载问题：iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载，阻塞 onload 事件。相比于 SPA 加载会更慢；</li><li>布局问题：iframe 必须给一个指定的高度，否则会塌陷。另外有些时候会出现多个滚动条，用户体验不佳；</li><li>弹窗及遮罩层问题：弹窗只能在 iframe 区域进行展示，没办法在浏览器视口里显示，导致的问题是，弹窗遮罩无法覆盖浏览器视口且弹窗位置可能没有垂直水平居中；</li><li>浏览器记录和前进后退问题：iframe 和主页面共用浏览器记录，导致前进后退的时候不能切换不同的应用；刷新页面无法保存当前状态，比如访问一个微应用的列表页，当从列表页点击进入详情，此时刷新浏览器，会加载列表页</li></ul><h3 id="组合式应用路由分发"><a href="#组合式应用路由分发" class="headerlink" title="组合式应用路由分发"></a>组合式应用路由分发</h3><p>这个方案和第一种方案很像，都是需要通过 nginx 来将路由分发到不同的应用上，可以认为是它的升级版，区别是这种方式的系统在运行时将由主应用来进行路由管理，子应用的加载、启动、卸载以及通信都需要依靠主应用来完成。</p><p>这种方式的代表开源框架就是 <a href="https://github.com/umijs/qiankun">qiankun</a>。</p><p>作为微前端的基座应用，是整个应用的入口，负责承载当前微应用的展示和对其他路由微应用的转发，对于当前微应用的展示，一般是由以下几步构成：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202207/16568630083671.jpg" alt="-w767"></p><ul><li>作为一个 SPA 的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用 iframe 之外，要能先拉取到微应用的页面内容，这就需要远程拉取机制。</li><li>远程拉取实施的前提是需要知道拉取的地址是什么？所以就需要先在主应用里集成一套微应用的管理机制，比如说当浏览器地址匹配 /app1 的时候就去加载 app1 应用的内容，而 app1 的地址其实是动态配置到本地的映射，最终将指向一个可以独立访问的域名。</li><li>有了拉取地址之后，通常会采用 fetch API 来首先获取到微应用的 HTML 内容。然后通过解析将微应用的 JavaScript 和 CSS 进行抽离，采用 eval 方法来运行 JavaScript，并将 CSS 和 HTML 内容 append 到基座应用中留给微应用的展示区域，当微应用切换走时，可以在主应用里同步卸载这些内容，这就构成的当前应用的展示流程。</li></ul><p>对于路由分发而言，以采用 vue-router 开发的基座 SPA 应用来举例，主要是下面这个流程：</p><p>当浏览器的路径变化后，vue-router 会监听 hashchange 或者 popstate 事件，从而获取到路由切换的时机。<br>最先接收到这个变化的是基座的 router，通过查询注册信息可以获取到转发到那个微应用，经过一些逻辑处理后，采用修改 hash 方法或者 pushState 方法来路由信息推送给微应用的路由，微应用可以是手动监听 hashchange 或者 popstate 事件接收，或者采用 React-router，vue-router 接管路由，后面的逻辑就由微应用自己控制。</p><h3 id="使用-Web-Components-技术构建"><a href="#使用-Web-Components-技术构建" class="headerlink" title="使用 Web Components 技术构建"></a>使用 Web Components 技术构建</h3><p>Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 Web 应用中使用它们。</p><p>它主要有三项技术组件：</p><ul><li>Custom elements（自定义元素）：一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。</li><li>Shadow DOM（影子 DOM）：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。</li><li>HTML templates（HTML 模板）： <code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</li></ul><p>这里有一个<a href="https://jsbin.com/yobopor/1/edit?html,js,output">在线的 Web Components 示例</a></p><p>随后，在各自的 HTML 文件里，创建相应的组件元素，编写相应的组件逻辑。一个典型的 Web Components 应用架构如下图所示：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202207/16568230270366.jpg" alt="-w810"></p><p>可以看到这边方式与我们上面使用 iframe 的方式很相似，组件拥有自己独立的 Scripts 和 Styles，以及对应的用于单独部署组件的域名。然而它并没有想象中的那么美好，要直接使用纯 Web Components 来构建前端应用的难度有：</p><ul><li>重写现有的前端应用。是的，现在我们需要完成使用 Web Components 来完成整个系统的功能。</li><li>上下游生态系统不完善。缺乏相应的一些第三方控件支持，这也是为什么 jQuery 相当流行的原因。</li><li>系统架构复杂。当应用被拆分为一个又一个的组件时，组件间的通讯就成了一个特别大的麻烦。</li><li>Web Components 中的 ShadowDOM 更像是新一代的前端 DOM 容器。而遗憾的是并不是所有的浏览器，都可以完全支持 Web Components。</li></ul><p><a href="https://github.com/micro-zoe/micro-app">MicroApp</a> 借鉴了 Web Component 的思想，通过 CustomElement 结合自定义的 ShadowDom，将微前端封装成一个类 Web Component 组件，从而实现微前端的组件化渲染。</p><h3 id="Module-Federation"><a href="#Module-Federation" class="headerlink" title="Module Federation"></a>Module Federation</h3><p>Module Federation 是 webpack 5 中的一个新特性，能轻易实现在两个使用 webpack 构建的项目之间共享代码，通俗点讲，Module Federation 提供了能在当前应用加载其他应用的能力。这就为实现微前端提供了另一种可能。</p><p><a href="https://github.com/efoxTeam/emp">EMP</a> 就是基于这个特性研发出来的微前端解决方案。</p><p>对于 Module Federation，它有几个概念：</p><ul><li>local module（本地模块）：就是普通模块，对于某个项目而言，每次构建就都是产生本地模块的过程；</li><li>remote module（远程模块）：远程模块不属于当前构建，并在运行时从所谓的容器加载；加载远程模块被认为是异步操作，通常可以通过调用 import() 实现；</li><li>container（容器）：每个构建都充当一个容器，也可将其他构建作为容器。通过这种方式，每个构建都能够通过从对应容器中加载模块来访问其他容器暴露出来的模块。</li><li>shared module（共享模块）：共享模块是指既可重写的又可作为向嵌套容器提供重写的模块。它们通常指向每个构建中的相同模块，例如相同的库。</li></ul><p>所以，当前模块想要加载其他模块，就要有一个引入动作，同样，如果想让其他模块使用，就需要有一个导出动作。通过以下 2 个 webpack 插件配置参数可以实现模块的导入和导出。</p><ul><li>expose：导出应用，被其他应用导入；</li><li>remote：引入其他应用；</li></ul><p>这与基座模式完全不同，像 iframe 和 qiankun 都是需要一个基座（中心容器）去加载其他子应用。而 Module Federation 任意一个模块都可以引用其他应用，同时也可以导出被其他应用使用，这就没有了容器中心的概念。</p><p>想要使用 Module Federation 功能需要引入 webpack 5 中内置的插件 ModuleFederationPlugin，通过配置该插件来完成。比如 base 应用需要引入 expose 应用里导出的 HelloWorld 模块，可以这样配置：</p><p>expose 的 vue.config.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.container.ModuleFederationPlugin(&#123;</span><br><span class="line">    name: <span class="string">&quot;app_expose&quot;</span>,</span><br><span class="line">    filename: <span class="string">&quot;remoteEntry.js&quot;</span></span><br><span class="line">    exposes: &#123;</span><br><span class="line">      <span class="string">&quot;./HelloWorld.vue&quot;</span>: <span class="string">&quot;./src/components/HelloWorld.vue&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      vue: &#123;</span><br><span class="line">        singleton: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>base 应用的 vue.config.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.container.ModuleFederationPlugin(&#123;</span><br><span class="line">    name: <span class="string">&quot;app_base&quot;</span>,</span><br><span class="line">    filename: <span class="string">&quot;remoteEntry.js&quot;</span>,</span><br><span class="line">    remotes: &#123;</span><br><span class="line">      app_expose: <span class="string">&quot;app_expose@http://localhost:8082/remoteEntry.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      vue: &#123;</span><br><span class="line">        singleton: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>使用 expose 应用的 HelloWorld 模块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;Vue logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../assets/logo.png&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">msg</span>=<span class="string">&quot;Welcome to Your Vue.js&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;js&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123;  defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&quot;app_expose/HelloWorld.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;HomeView&#x27;</span>,</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      HelloWorld</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>webpack 5 与之前版本的模块管理对比图：<br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202207/16568539763219.jpg" alt="-w859"></p><h2 id="微前端的问题和缺点"><a href="#微前端的问题和缺点" class="headerlink" title="微前端的问题和缺点"></a>微前端的问题和缺点</h2><p>讲了这么多的优点和实现，那么微前端是不是解决前端开发问题的银弹呢？当然不是。所有的架构都是取舍和权衡，这个世界上并不存在银弹，微前端架构和微服务一样也存在他的弊端，单体架构未必就差。</p><ul><li>微前端的构建通常比较复杂，从工具，打包，到部署，微前端都是更为复杂的存在，天下没有免费的午餐，对于小型项目，它的成本太高；</li><li>每个团队可以使用不同的框架，这个听上去很美，但是实际操作起来，除了要支持历史遗留的应用，它的意义不大。同时也为带来体验上的问题。可以远程加载不同的框架代码是一回事，把它们都用好是另一回事；</li><li>性能上来看，如果优化得不好微前端的性能可能会存在问题，至少微前端框架是额外的一层加载。如果不同的微前端使用了不同的框架，那么每一个框架都需要额外的加载；</li></ul><p>微前端架构还在不断发展之中，本文提到的 nginx / iframe／ qiankun／Web Components / Module Federation 只是诸多解决方案中的一小部分，前端的发展变化和生态系统实在是丰富，相信未来会有更多以及更好用的微前端架构的出现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是微前端&quot;&gt;&lt;a href=&quot;#什么是微前端&quot; class=&quot;headerlink&quot; title=&quot;什么是微前端&quot;&gt;&lt;/a&gt;什么是微前端&lt;/h2&gt;&lt;p&gt;而提到微前端就离不开微服务，大家对微服务都比较熟悉了，微服务允许后端体系结构通过松散耦合的代码库进行扩展，每个代码库负责自己的业务逻辑，并公开一个 API，每个 API 均可独立部署，并且各自由不同的团队拥有和维护。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202207/16568565844214.jpg&quot; alt=&quot;-w610&quot;&gt;&lt;/p&gt;
&lt;p&gt;前端架构经历了从单体，到前后端分离，再到微服务，最终发展到现在的微前端的过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202207/16568581684949.jpg&quot; alt=&quot;-w697&quot;&gt;&lt;/p&gt;
&lt;p&gt;微前端的思路是把微服务的架构引入到前端，其核心都是要能够以业务为单元构建端到端的垂直架构，使得单个的团队能够独立自主的进行相关的开发，同时又具备相当的灵活性，按需求来组成交付应用。&lt;/p&gt;
&lt;p&gt;“微前端”一词最早于 2016 年底在 ThoughtWorks 技术雷达中提出的。它将微服务的概念扩展到了前端世界。微前端的核心思路其实是远程应用程序，包含组件／模块／包的运行时加载。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/categories/JavaScript/"/>
    
    
      <category term="微前端" scheme="https://bubuzou.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>git clone 的时候如何通过 SSH 链接来下载远程项目</title>
    <link href="https://bubuzou.com/2023/10/11/git-clone-over-ssh/"/>
    <id>https://bubuzou.com/2023/10/11/git-clone-over-ssh/</id>
    <published>2023-10-11T02:19:26.000Z</published>
    <updated>2024-06-14T13:05:58.378Z</updated>
    
    <content type="html"><![CDATA[<p>当我们需要从 github 下载项目的时候，它提供了 2 种下载链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/ant-design/ant-design.git</span><br><span class="line">git@github.com:ant-design/ant-design.git</span><br></pre></td></tr></table></figure><p>上面 2 种下载链接分别使用了 HTTPS 和 SSH 协议。那么这两种协议有什么区别呢？</p><ul><li><strong>访问控制</strong>：SSH 协议使用公钥和私钥来进行身份验证，因此你需要在远程主机上安装你的公钥。只有拥有私钥的用户才能进行身份验证和访问。相反，HTTPS 协议使用用户名和密码进行身份验证。git clone 或 git fetch 的时候，如果使用 HTTPS 链接则不需要进行身份验证，而 SSH 链接需要。</li><li><strong>传输速度</strong>：SSH 协议在传输数据时进行压缩，因此它可以在传输大量数据时比 HTTPS 更快。此外，SSH 协议通常可以在传输数据时使用更少的带宽，这对于连接速度较慢的网络非常有用。</li><li><strong>防火墙限制</strong>： 某些公司或组织可能会在防火墙中阻止对 SSH 端口的访问，这可能会使 SSH 协议无法使用。另一方面，HTTPS 协议通常可以通过防火墙，因为它使用标准的 Web 端口 80 和 443。</li></ul><p>想要通过 SSH 链接来下载项目，需要在客户端和服务器之间配置 SSH key，那么如何做呢？下面以 github 为例来说明具体步骤。</p><h2 id="1-在本地生成-SSH-key"><a href="#1-在本地生成-SSH-key" class="headerlink" title="1. 在本地生成 SSH key"></a>1. 在本地生成 SSH key</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;user@example.com&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这里我把 <a href="mailto:&#117;&#x73;&#101;&#x72;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;">&#117;&#x73;&#101;&#x72;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;</a> 替换成了我的 github.com 的邮箱。执行完后可能会有如下提示，不用管直接按回车即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private ed25519 key pair.</span><br><span class="line">Enter file in which to save the key (/home/johndoe/.ssh/id_ed25519):</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure><p>最后你会发现会打印这么一串信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SHA256:ToTEp33dDV8Sokslnx568DC5ABPQTmvlBjGx+r/W0k8 user@example.com</span><br><span class="line"> The key&#x27;s randomart image is:</span><br><span class="line"> +--[ED25519 256]--+</span><br><span class="line"> |o.+o ..          |</span><br><span class="line"> |. +o....+        |</span><br><span class="line"> | +.=  .o.        |</span><br><span class="line"> |o.+ o . .  .      |</span><br><span class="line"> |o+ . . .So .     |</span><br><span class="line"> |*.    oo+ o .    |</span><br><span class="line"> |o*.  o =E= o     |</span><br><span class="line"> |ooo.o =..o o      |</span><br><span class="line"> |.o+o++ ..        |</span><br><span class="line"> +----[SHA256]-----+</span><br></pre></td></tr></table></figure><p>然后你就会发现在 .ssh 目录下多了 2 个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls ~/.ssh</span></span><br><span class="line">id_ed25519  id_ed25519.pub</span><br></pre></td></tr></table></figure><h2 id="2-为你的-github-账户添加一个公共的-key"><a href="#2-为你的-github-账户添加一个公共的-key" class="headerlink" title="2. 为你的 github 账户添加一个公共的 key"></a>2. 为你的 github 账户添加一个公共的 key</h2><p>上面已经在本地生成好了 SSH key，现在就要把这个 key 的内容贴到 github 账户里。</p><p>执行如下命令后，会在终端打印 key 的内容，可以选中它们然后复制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_ed25519.pub</span><br></pre></td></tr></table></figure><p>然后按照如下顺序把 key 的内容贴到 github 的账户里。</p><ul><li><ol><li>Log in to your GitHub account.</li></ol></li><li><ol start="2"><li>Navigate to “Settings”.</li></ol></li><li><ol start="3"><li>Click on “SSH and GPG keys” in the left menu.</li></ol></li><li><ol start="4"><li>Click on the “New SSH key” button.</li></ol></li></ul><h2 id="3-测试是否可用"><a href="#3-测试是否可用" class="headerlink" title="3. 测试是否可用"></a>3. 测试是否可用</h2><p>接下来就可以找个 github 仓库，复制 SSH 的地址进行 clone 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:ant-design/ant-design.git --depth=1</span><br></pre></td></tr></table></figure><h2 id="4-为-SSH-代理指定-SSH-key"><a href="#4-为-SSH-代理指定-SSH-key" class="headerlink" title="4. 为 SSH 代理指定 SSH key"></a>4. 为 SSH 代理指定 SSH key</h2><p>如果您不想每次 git 使用 SSH 键时输入密码，则可以将键添加到 SSH 代理管理的键列表中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure><p><em>但是每次电脑重启后，如上设置就会失效，需要重新设置。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们需要从 github 下载项目的时候，它提供了 2 种下载链接：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://github.com/ant-design/ant-design.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git@github.com:ant-design/ant-design.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上面 2 种下载链接分别使用了 HTTPS 和 SSH 协议。那么这两种协议有什么区别呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;访问控制&lt;/strong&gt;：SSH 协议使用公钥和私钥来进行身份验证，因此你需要在远程主机上安装你的公钥。只有拥有私钥的用户才能进行身份验证和访问。相反，HTTPS 协议使用用户名和密码进行身份验证。git clone 或 git fetch 的时候，如果使用 HTTPS 链接则不需要进行身份验证，而 SSH 链接需要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输速度&lt;/strong&gt;：SSH 协议在传输数据时进行压缩，因此它可以在传输大量数据时比 HTTPS 更快。此外，SSH 协议通常可以在传输数据时使用更少的带宽，这对于连接速度较慢的网络非常有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;防火墙限制&lt;/strong&gt;： 某些公司或组织可能会在防火墙中阻止对 SSH 端口的访问，这可能会使 SSH 协议无法使用。另一方面，HTTPS 协议通常可以通过防火墙，因为它使用标准的 Web 端口 80 和 443。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想要通过 SSH 链接来下载项目，需要在客户端和服务器之间配置 SSH key，那么如何做呢？下面以 github 为例来说明具体步骤。&lt;/p&gt;
&lt;h2 id=&quot;1-在本地生成-SSH-key&quot;&gt;&lt;a href=&quot;#1-在本地生成-SSH-key&quot; class=&quot;headerlink&quot; title=&quot;1. 在本地生成 SSH key&quot;&gt;&lt;/a&gt;1. 在本地生成 SSH key&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t ed25519 -C &amp;quot;user@example.com&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="web综合" scheme="https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="git" scheme="https://bubuzou.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>从 ESLint 开始，说透我如何在团队项目中基于 Vue 做代码校验</title>
    <link href="https://bubuzou.com/2021/06/16/eslint/"/>
    <id>https://bubuzou.com/2021/06/16/eslint/</id>
    <published>2021-06-16T02:23:14.000Z</published>
    <updated>2024-06-12T09:26:57.287Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202106/eslint.png"></p><p>最近遇到了一个老项目，比较有意思的是这个项目集前后端的代码于一起，而后端也会去修改前端代码，所以就出现了后端用 IntelliJ IDEA 来开发前端项目，而前端用 VSCode 来开发前端项目的情况。<br>于是乎，出现了代码规范的问题，所以就有了这篇文章，整理了一下前端代码校验以及在 Vue 项目中的实践。</p><p>阅读完这篇文章，你可以收获：</p><ul><li>能够自己亲手写出一套 ESLint 配置；</li><li>会知道业界都有哪些著名的 JS 代码规范，熟读它们可以让你写出更规范的代码；</li><li>vue-cli 在初始化一个包含代码校验的项目时都做了什么；</li><li>Prettier 是什么？为什么要使用它？如何与 ESLint 配合使用？</li><li>EditorConfig 又是什么？如何使用？</li><li>如何在 VSCode 中通过插件来协助代码校验工作；</li><li>如何保证 push 到远程仓库的代码是符合规范的；</li></ul><a id="more"></a><p>下面开始阅读吧，如果你对 ESLint 比较熟悉，可以直接跳过这个部分。</p><h2 id="ESLint-是什么"><a href="#ESLint-是什么" class="headerlink" title="ESLint 是什么"></a>ESLint 是什么</h2><p>ESLint 是一个集代码审查和修复的工具，它的核心功能是通过配置一个个规则来限制代码的合法性和风格。</p><h3 id="配置解析器和解析参数"><a href="#配置解析器和解析参数" class="headerlink" title="配置解析器和解析参数"></a>配置解析器和解析参数</h3><p>ESLint 的解析器，早期的时候用的是 <a href="http://esprima.org/" title="Esprima">Esprima</a>，后面基于 Esprima v1.2.2 版本开发了一个新的解析器 <a href="https://github.com/eslint/espree" title="Espree">Espree</a>，并且把它当做默认解析器。</p><p>除了使用 ESLint 自带的解析器外，还可以指定其他解析器：</p><ul><li><a href="https://github.com/babel/babel/tree/main/eslint/babel-eslint-parser" title="@babel/eslint-parser">@babel/eslint-parser</a>：使 Babel 和 ESLint 兼容，对一些 Babel 语法提供支持；</li><li><a href="https://github.com/typescript-eslint/typescript-eslint" title="@typescript-eslint/parser">@typescript-eslint/parser</a>：TSLint 被弃用后，TypeScript 提供了此解析器用于将其与 ESTree 兼容，使 ESLint 对 TypeScript 进行支持；</li></ul><p>为项目指定某个选择器的原则是什么？</p><ul><li>如果你的项目用到了比较新的 ES 语法，比如 ES2021 的 Promise.any()，那就可以指定 @babel/eslint-parser 为解析器；</li><li>如果项目是基于 TS 开发的，那就使用 @typescript-eslint/parser；</li></ul><blockquote><p>如果你对 ES 最新标准还不熟悉，可以看看这篇文章：<a href="https://juejin.cn/post/6896986598999588872">送你一份精心总结的 3 万字 ES6 实用指南（下）</a></p></blockquote><p>除了指定解析器 parser 外，还可以额外配置解析器参数 parserOption：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ESLint 默认解析器，也可以指定成别的</span></span><br><span class="line">    parser: <span class="string">&quot;espree&quot;</span>,</span><br><span class="line">    parserOption: &#123;</span><br><span class="line">        <span class="comment">// 指定要使用的 ECMAScript 版本，默认值 5</span></span><br><span class="line">        ecmaVersion: <span class="number">5</span>,</span><br><span class="line">        <span class="comment">// 设置为 script (默认) 或 module（如果你的代码是 ECMAScript 模块)</span></span><br><span class="line">        sourceType: <span class="string">&quot;script&quot;</span>,</span><br><span class="line">        <span class="comment">// 这是个对象，表示你想使用的额外的语言特性,所有选项默认都是 false</span></span><br><span class="line">        ecmafeatures: &#123;</span><br><span class="line">            <span class="comment">// 是否允许在全局作用域下使用 return 语句</span></span><br><span class="line">            globalReturn: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// 是否启用全局 strict 模式（严格模式）</span></span><br><span class="line">            impliedStrict: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// 是否启用JSX</span></span><br><span class="line">            jsx: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// 是否启用对实验性的objectRest/spreadProperties的支持</span></span><br><span class="line">            experimentalObjectRestSpread: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定环境-env"><a href="#指定环境-env" class="headerlink" title="指定环境 env"></a>指定环境 env</h3><p>指定不同的环境可以给对应环境下提供预设的全局变量。比如说在 browser 环境下，可以使用 window 全局变量；在 node 环境下，可以使用 process 全局变量等；</p><p>ESLint 中可配置的环境比较多，<a href="https://eslint.org/docs/user-guide/configuring/language-options#specifying-environments" title="Specifying Environments">这里有份完整的环境列表</a>，下面列出几个比较常见的：</p><ul><li>browser：浏览器全局变量；</li><li>node：Node.js 全局变量和作用域；</li><li>es6：es6 中除了模块之外的其他特性，同时将自动设置 parserOptions.ecmaVersion 参数为 6；以此类推 ES2017 是 7，而 ES2021 是 12；</li><li>es2017：parserOptions.ecmaVersion 为 8；</li><li>es2020：parserOptions.ecmaVersion 为 11；</li><li>es2021：parserOptions.ecmaVersion 为 12；</li></ul><p>配置方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    env: &#123;</span><br><span class="line">        browser: <span class="literal">true</span>,</span><br><span class="line">        node: <span class="literal">true</span>,</span><br><span class="line">        es6: <span class="literal">true</span>,</span><br><span class="line">        commonjs: <span class="literal">true</span>,</span><br><span class="line">        mocha: <span class="literal">true</span>,</span><br><span class="line">        jquery: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以指定多个环境并不意味着配置的环境越多越好，实际配置的时候还是得依据当前项目的环境来选择。</p><h3 id="配置全局变量-globals"><a href="#配置全局变量-globals" class="headerlink" title="配置全局变量 globals"></a>配置全局变量 globals</h3><p>ESLint 的一些核心规则依赖于对代码在运行时可用的全局变量的了解。 由于这些在不同环境之间可能会有很大差异，并且在运行时会进行修改，因此 ESLint 不会假设你的执行环境中存在哪些全局变量。</p><p>如果你想使用这些全局变量，那就可以通过 globals 来指定。比如在 <a href="https://github.com/facebook/react/blob/master/.eslintrc.js" title="react .eslintrc.js">react .eslintrc.js</a> 里就把 spyOnDev、 spyOnProd 等变量挂在了 global 下作为全局变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    globals: &#123;</span><br><span class="line">        spyOnDev: <span class="literal">true</span>,</span><br><span class="line">        spyOnProd: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于它的值需要特别说明下：</p><ul><li>false、readable、readonly 这 3 个是等价的，表示变量只可读不可写；</li><li>true、writeable、writable 这 3 个是等价的，表示变量可读可写；</li></ul><h3 id="配置扩展-extends"><a href="#配置扩展-extends" class="headerlink" title="配置扩展 extends"></a>配置扩展 extends</h3><p>实际项目中配置规则的时候，不可能团队一条一条的去商议配置，太费精力了。通常的做法是使用业内大家普通使用的、遵循的编码规范；然后通过 extends 去引入这些规范。extends 配置的时候接受字符串或者数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;plugin:vue/essential&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;eslint-config-standard&#x27;</span>, <span class="comment">// 可以缩写成 &#x27;standard&#x27;</span></span><br><span class="line">        <span class="string">&#x27;@vue/prettier&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;./node_modules/coding-standard/.eslintrc-es6&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从上面的配置，可以知道 extends 支持的配置类型可以是以下几种</strong></p><ul><li>eslint 开头的：是 ESLint 官方的扩展；</li><li>plugin 开头的：是插件类型扩展，比如 plugin:vue/essential；</li><li>eslint-config 开头的：来自 npm 包，使用时可以省略前缀 eslint-config-，比如上面的可以直接写成 standard；</li><li>@开头的：扩展和 eslint-config 一样，只是在 npm 包上面加了一层作用域 scope；</li><li>一个执行配置文件的相对路径或绝对路径；</li></ul><p><strong>那有哪些常用的、比较著名扩展可以被 extends 引入呢</strong></p><ul><li><a href="https://eslint.org/docs/rules/">eslint:recommended</a>：ESLint 内置的推荐规则，即 ESLint Rules 列表中打了钩的那些规则；</li><li><a href="https://eslint.org/docs/rules/">eslint:all</a>：ESLint 内置的所有规则；</li><li><a href="https://github.com/standard/eslint-config-standard" title="eslint-config-standard">eslint-config-standard</a>：standard 的 JS 规范；</li><li><a href="https://github.com/prettier/eslint-config-prettier" title="eslint-config-prettier">eslint-config-prettier</a>：关闭和 ESLint 中以及其他扩展中有冲突的规则；</li><li><a href="https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb-base">eslint-config-airbnb-base</a>：airbab 的 JS 规范；</li><li><a href="https://github.com/AlloyTeam/eslint-config-alloy" title="eslint-config-alloy">eslint-config-alloy</a>：腾讯 AlloyTeam 前端团队出品，可以很好的针对你项目的技术栈进行配置选择，比如可以选 React、Vue（现已支持 Vue 3.0）、TypeScript 等；</li></ul><h3 id="使用插件-plugins"><a href="#使用插件-plugins" class="headerlink" title="使用插件 plugins"></a>使用插件 plugins</h3><p><strong>ESLint 提供插件是干嘛用的</strong></p><p>ESLint 虽然可以定义很多的 rules，以及通过 extends 来引入更多的规则，但是说到底只是检查 JS 语法。如果需要检查 Vue 中的 template 或者 React 中的 jsx，就束手无策了。<br>所以引入插件的目的就是为了增强 ESLint 的检查能力和范围。</p><p><strong>如何配置插件</strong></p><p>ESLint 相关的插件的命名形式有 2 种：不带命名空间的和带命名空间的，比如：</p><ul><li>eslint-plugin- 开头的可以省略这部分前缀；</li><li>@<scope>/ 开头的；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">&#x27;jquery&#x27;</span>, <span class="comment">// 是指 eslint-plugin-jquery</span></span><br><span class="line">    <span class="string">&#x27;@jquery/jquery&#x27;</span>, <span class="comment">// 是指 @jquery/eslint-plugin-jquery</span></span><br><span class="line">    <span class="string">&#x27;@foobar&#x27;</span>, <span class="comment">// 是指 @foobar/eslint-plugin</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要基于插件进行 extends 和 rules 的配置的时候，需要加上插件的引用，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="string">&#x27;jquery&#x27;</span>,   <span class="comment">// eslint-plugin-jquery</span></span><br><span class="line">        <span class="string">&#x27;@foo/foo&#x27;</span>, <span class="comment">// @foo/eslint-plugin-foo</span></span><br><span class="line">        <span class="string">&#x27;@bar,      // @bar/eslint-plugin</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    extends: [</span></span><br><span class="line"><span class="string">        &#x27;</span>plugin:jquery/recommended<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;</span>plugin:@foo/foo/recommended<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;</span>plugin:@bar/recommended<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    rules: &#123;</span></span><br><span class="line"><span class="string">        &#x27;</span>jquery/a-rule<span class="string">&#x27;: &#x27;</span>error<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;</span>@foo/foo/some-rule<span class="string">&#x27;: &#x27;</span>error<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;</span>@bar/another-rule<span class="string">&#x27;: &#x27;</span>error<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>以上配置来自 <a href="https://eslint.org/docs/user-guide/configuring/plugins#configuring-plugins" title="ESLint plugins">ESLint plugins</a></p><h3 id="配置规则-rules"><a href="#配置规则-rules" class="headerlink" title="配置规则 rules"></a>配置规则 rules</h3><p>ESLint 提供了大量内置的规则，这里是它的规则列表 <a href="https://eslint.org/docs/rules/">ESLint Rules</a>，除此之外你还可以通过插件来添加更多的规则。</p><p><strong>规则的校验说明，有 3 个报错等级</strong></p><ul><li>off 或 0：关闭对该规则的校验；</li><li>warn 或 1：启用规则，不满足时抛出警告，且不会退出编译进程；</li><li>error 或 2：启用规则，不满足时抛出错误，且会退出编译进程；</li></ul><p>通常规则只需要配置开启还是关闭即可；但是也有些规则可以传入属性，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">&#x27;quotes&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;single&#x27;</span>],  <span class="comment">// 如果不是单引号，则报错</span></span><br><span class="line">        <span class="string">&#x27;one-var&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;var&#x27;</span>: <span class="string">&#x27;always&#x27;</span>,  <span class="comment">// 每个函数作用域中，只允许 1 个 var 声明</span></span><br><span class="line">            <span class="string">&#x27;let&#x27;</span>: <span class="string">&#x27;never&#x27;</span>,   <span class="comment">// 每个块作用域中，允许多个 let 声明</span></span><br><span class="line">            <span class="string">&#x27;const&#x27;</span>: <span class="string">&#x27;never&#x27;</span>, <span class="comment">// 每个块作用域中，允许多个 const 声明</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何知道某个扩展有哪些规则可以配置，以及每个规则具体限制？<br>这里直接给出业内著名且使用比较多的规则列表的快速链接：</p><ul><li><a href="https://eslint.org/docs/rules/">ESLint rules</a>，这整个列表对应 eslint:all，而打钩 ✔️ 的是 eslint:recommenmed；</li><li><a href="https://github.com/prettier/eslint-config-prettier/blob/main/index.js">Prettier rules</a></li><li><a href="https://github.com/standard/standard/blob/master/RULES.md">standard rules</a></li><li><a href="https://github.com/airbnb/javascript">airbnb rules</a></li><li><a href="https://github.com/AlloyTeam/eslint-config-alloy/blob/master/config/rules/vue.json">AlloyTeam vue rules</a></li></ul><p><strong>规则的优先级</strong></p><ul><li>如果 extends 配置的是一个数组，那么最终会将所有规则项进行合并，出现冲突的时候，后面的会覆盖前面的；</li><li>通过 rules 单独配置的规则优先级比 extends 高；</li></ul><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p><strong>配置当前目录为 root</strong></p><p>ESLint 检测配置文件步骤：</p><ul><li><ol><li>在要检测的文件同一目录里寻找 .eslintrc.* 和 package.json；</li></ol></li><li><ol start="2"><li>紧接着在父级目录里寻找，一直到文件系统的根目录；</li></ol></li><li><ol start="3"><li>如果在前两步发现有 root：true 的配置，停止在父级目录中寻找 .eslintrc；</li></ol></li><li><ol start="4"><li>如果以上步骤都没有找到，则回退到用户主目录 ~/.eslintrc 中自定义的默认配置；</li></ol></li></ul><p>通常我们都习惯把 ESLint 配置文件放到项目根目录，因此可以为了避免 ESLint 校验的时候往父级目录查找配置文件，所以需要在配置文件中加上 root: true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加共享数据</strong></p><p>ESLint 支持在配置文件添加共享设置，你可以添加 settings 对象到配置文件，它将提供给每一个将被执行的规则。如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    settings: &#123;</span><br><span class="line">        sharedData: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://gist.github.com/rswanderer/29dc65efc421b3b5b0442f1bd3dcd046" title="ESLint配置文件.eslintrc参数说明">ESLint 配置文件.eslintrc 参数说明</a></p><p><strong>针对个别文件设置新的检查规则</strong></p><p>比如 webpack 的中包含了某些运行时的 JS 文件，而这些文件是只跑在浏览器端的，所以需要针对这部分文件进行差异化配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">overrides: [</span><br><span class="line">  &#123;</span><br><span class="line">    files: [<span class="string">&#x27;lib/**/*.runtime.js&#x27;</span>, <span class="string">&#x27;hot/*.js&#x27;</span>],</span><br><span class="line">    env: &#123;</span><br><span class="line">      es6: <span class="literal">false</span>,</span><br><span class="line">      browser: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    globals: &#123;</span><br><span class="line">      <span class="built_in">Promise</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">      ecmaVersion: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>以上配置来自 <a href="https://github.com/webpack/webpack/blob/master/.eslintrc.js" title="webpack .eslintrc.js">webpack .eslintrc.js</a></p><h2 id="如何校验"><a href="#如何校验" class="headerlink" title="如何校验"></a>如何校验</h2><p>上面细说了 ESLint 的各种配置项，以及针对 Vue 项目如何进行差异配置的说明。</p><p>现在我们知道了如何配置，但是你知道这些配置都是配置到哪里的吗？</p><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>ESLint 支持 3 种配置方式：</p><ul><li>命令行：不推荐，不做介绍；</li><li>单文件内注释：不推荐，不做介绍；</li><li>配置文件：配置文件的类型可以是好几种，比如：.js、.yml、json 等。推荐使用 .eslintrc.js；</li></ul><p>下面通过命令来生成一个配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 eslint</span></span><br><span class="line">npm i eslint -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个配置文件</span></span><br><span class="line">npx eslint --init</span><br></pre></td></tr></table></figure><p>最后会在当前目录生成一个 .eslintrc.js 文件。这里就不把代码贴出来了，没参考意义。</p><p>上面我们知道了可以将配置统一写到一个配置文件里，但是你知道该如何去触发这个配置文件的校验规则嘛？</p><h3 id="校验单个文件"><a href="#校验单个文件" class="headerlink" title="校验单个文件"></a>校验单个文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验 a.js 和 b.js</span></span><br><span class="line">npx eslint a.js b.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验 src 和 scripts 目录</span></span><br><span class="line">npx eslint src scripts</span><br></pre></td></tr></table></figure><h3 id="校验别的类型的文件"><a href="#校验别的类型的文件" class="headerlink" title="校验别的类型的文件"></a>校验别的类型的文件</h3><p>通常 ESLint 只能校验 JS 文件。比如需要校验 .vue 文件，光配置 vue 插件和 vue-eslint-parser 解析器是不够的，还需要让 ESLint 在查找文件的时候找到 .vue 文件。</p><p>可以通过 –ext 来指定具体需要校验的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx eslint --ext .js,.jsx,.vue src</span><br></pre></td></tr></table></figure><h3 id="自动修复部分校验错误的代码"><a href="#自动修复部分校验错误的代码" class="headerlink" title="自动修复部分校验错误的代码"></a>自动修复部分校验错误的代码</h3><p>rules 列表项中标识了一个扳手 🔧 图案的规则就标识该规则是可以通过 ESLint 工具自动修复代码的。<br>如何自动修复呢？通过 –fix 即可。比如对于 ESLint Rules 里的这个 <a href="https://eslint.org/docs/rules/semi">semi</a> 规则，它就是带扳手图案的。</p><p>对于如下的 a.js 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">12</span></span><br></pre></td></tr></table></figure><p>当在配置文件配置了 ‘semi’: [2, ‘always’] 后，运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx eslint --fix a.js</span><br></pre></td></tr></table></figure><p>校验直接就通过了，且会自动修复代码，在代码末尾自动加上分号。</p><h3 id="把校验命令加到-package-json"><a href="#把校验命令加到-package-json" class="headerlink" title="把校验命令加到 package.json"></a>把校验命令加到 package.json</h3><p>检验命令比较长，也难记，习惯上会把这些命名直接写到 package.json 里：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;npx eslint --ext .js,.jsx,.vue src&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint:fix&quot;</span>: <span class="string">&quot;npx eslint --fix --ext .js,.jsx,.vue src&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤一些不需要校验的文件"><a href="#过滤一些不需要校验的文件" class="headerlink" title="过滤一些不需要校验的文件"></a>过滤一些不需要校验的文件</h3><p>对于一些公共的 JS、测试脚本或者是特定目录下的文件习惯上是不需要校验的，因此可以在项目根目录通过创建一个 .eslintignore 文件来配置，告诉 ESLint 校验的时候忽略它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public&#x2F;</span><br><span class="line">src&#x2F;main.js</span><br></pre></td></tr></table></figure><p>除了 .eslintignore 中指定的文件或目录，ESLint 总是忽略 /node_modules/ 和 /bower_components/ 中的文件；因此对于一些目前解决不了的规则报错，但是如果又急于打包上线，在不影响运行的情况下，我们就可以利用 .eslintignore 文件将其暂时忽略。</p><h2 id="在-Vue-项目中的实践"><a href="#在-Vue-项目中的实践" class="headerlink" title="在 Vue 项目中的实践"></a>在 Vue 项目中的实践</h2><p>上面把 ESLint 的几乎所有的配置参数和校验方式都详细的介绍了一遍，但是如果想在项目中落地，仅仅靠上面的知识还是不够的。下面将细说如何在 Vue 中落地代码校验。</p><p>关于如何在 Vue 中落地代码校验，一般是有 2 种情况：</p><ul><li>通过 vue-cli 初始化项目的时候已经选择了对应的校验配置</li><li>对于一个空的 Vue 项目，想接入代码校验</li></ul><p>其实这 2 种情况最终的校验的核心配置都是一样的，只是刚开始的时候安装的包有所区别。下面通过分析 vue-cli 配置的代码校验，来看看它到底做了哪些事情，通过它安装的包以及包的作用，我们就会知道如何在空项目中配置代码校验了。</p><h3 id="通过-vue-cli-初始化的项目"><a href="#通过-vue-cli-初始化的项目" class="headerlink" title="通过 vue-cli 初始化的项目"></a>通过 vue-cli 初始化的项目</h3><p>如果你的项目最初是通过 vue-cli 新建的，那么在新建的时候会让你选</p><ul><li>是否支持 eslint；</li><li>是否开启保存校验；</li><li>是否开启提交前校验；</li></ul><p>如果都开启了话，会安装如下几个包：</p><ul><li>eslint：前面 2 大章节介绍的就是这玩意，ESLint 出品，是代码校验的基础包，且提供了很多内置的 Rules，比如 eslint:recommended 经常被作为项目的 JS 检查规范被引入；</li><li>babel-eslint：一个对 Babel 解析器的包装，使其能够与 ESLint 兼容；</li><li>lint-staged：请看后面 pre-commit 部分；</li><li>@vue/cli-plugin-eslint</li><li>eslint-plugin-vue</li></ul><p>下面重点介绍 @vue/cli-plugin-eslint 和 eslint-plugin-vue，说下这 2 个包是干嘛的。</p><h4 id="vue-cli-plugin-eslint"><a href="#vue-cli-plugin-eslint" class="headerlink" title="@vue/cli-plugin-eslint"></a>@vue/cli-plugin-eslint</h4><p>这个包它主要干了 2 件事情：</p><p><strong>第一件事</strong></p><p>往 package.json 里注册了一个命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;vue-cli-service lint&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这个命令之后，它会去检查和修复部分可以修复的问题。默认查找的文件是 src 和 tests 目录下所有的 .js,.jsx,.vue 文件，以及项目根目录下所有的 js 文件（比如，也会检查 .eslintrc.js）。</p><p>当然你也可以自定义的传入参数和校验文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue-cli-service lint [options] [...files]</span><br></pre></td></tr></table></figure><p>支持的参数如下：</p><ul><li>–no-fix: 不会修复 errors 和 warnings；</li><li>–max-errors [limit]：指定导致出现 npm ERR 错误的最大 errors 数量；</li></ul><p><strong>第二件事</strong></p><p>增加了代码保存触发校验的功能 lintOnSave，这个功能默认是开启的。如果想要关闭这个功能，可以在 vue.config.js 里配置，习惯上只开启 development 环境下的代码保存校验功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lintOnSave 参数说明：</p><ul><li>true 或者 warning：开启保存校验，会将 errors 级别的错误在终端中以 WARNING 的形式显示。默认的，WARNING 将不会导致编译失败；</li><li>false：不开启保存校验；</li><li>error：开启保存校验，会将 errors 级别的错误在终端中以 ERROR 的形式出现，会导致编译失败，同时浏览器页面变黑，显示 Failed to compile。</li></ul><h4 id="eslint-plugin-vue"><a href="#eslint-plugin-vue" class="headerlink" title="eslint-plugin-vue"></a>eslint-plugin-vue</h4><p>eslint-plugin-vue 是对 .vue 文件进行代码校验的插件。</p><p><strong>针对这个插件，它提供了这几个扩展</strong></p><ul><li>plugin:vue/base：基础</li><li>plugin:vue/essential：预防错误的（用于 Vue 2.x）</li><li>plugin:vue/recommended：推荐的，最小化任意选择和认知开销（用于 Vue 2.x）；</li><li>plugin:vue/strongly-recommended：强烈推荐，提高可读性（用于 Vue 2.x）；</li><li>plugin:vue/vue3-essential：（用于 Vue 3.x）</li><li>plugin:vue/vue3-strongly-recommended：（用于 Vue 3.x）</li><li>plugin:vue/vue3-recommended：（用于 Vue 3.x）</li></ul><p>各扩展规则列表：<a href="https://eslint.vuejs.org/rules/">vue rules</a></p><p><strong>看到这么一堆的扩展，是不是都不知道选哪个了</strong></p><p>代码规范的东西，原则还是得由各自的团队去磨合商议出一套适合大家的规则。不过，如果你用的是 Vue2，我这里可以推荐 2 套 extends 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Vue 官方示例上的配置</span></span><br><span class="line">   <span class="keyword">extends</span>: [<span class="string">&#x27;eslint:recommended&#x27;</span>, <span class="string">&#x27;plugin:vue/recommended&#x27;</span>],</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 或者使用 AlloyTeam 团队那套</span></span><br><span class="line">   <span class="keyword">extends</span>: [<span class="string">&#x27;alloy&#x27;</span>, <span class="string">&#x27;alloy/vue&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置和插件对应的解析器</strong></p><p>如果是 Vue 2.x 项目，配置了 eslint-plugin-vue 插件和 extends 后，template 校验还是会失效，因为不管是 ESLint 默认的解析器 Espree 还是 babel-eslint 都只能解析 JS，无法解析 template 的内容。</p><p>而 vue-eslint-parser 只能解析 template 的内容，但是不会解析 JS，因此还需要对解析器做如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    parser: <span class="string">&#x27;vue-eslint-parser&#x27;</span>,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        parser: <span class="string">&#x27;babel-eslint&#x27;</span>,</span><br><span class="line">        ecmaVersion: <span class="number">12</span>,</span><br><span class="line">        sourceType: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;plugin:vue/recommended&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    plugins: [<span class="string">&#x27;vue&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://eslint.vuejs.org/user-guide/#faq" title="eslint-plugin-vue">eslint-plugin-vue faq</a></p><h3 id="让-Prettier-管控代码风格"><a href="#让-Prettier-管控代码风格" class="headerlink" title="让 Prettier 管控代码风格"></a>让 Prettier 管控代码风格</h3><p>针对 Prettier 不得不提出以下疑问？</p><ul><li>Prettier 是什么？</li><li>为什么有了 ESLint，还需要引入 Prettier 呢？它两之间有什么区别？</li><li>如何配置 Prettier？</li><li>Prettier 如何和 ESLint 结合使用？</li></ul><h4 id="Prettier-是什么"><a href="#Prettier-是什么" class="headerlink" title="Prettier 是什么"></a>Prettier 是什么</h4><p>用它自己的话来说：我是一个自以为是的<strong>代码格式化</strong>工具，而且我支持的文件类型很多，比如：</p><ul><li>JavaScript（包括实验中的特性）</li><li>JSX</li><li>Vue</li><li>TypeScript</li><li>CSS、Less、SCSS</li><li>HTML</li><li>JSON</li><li>Markdown</li></ul><p>以及还有一些其他类型的文件。</p><h4 id="Prettier-对比-ESLint"><a href="#Prettier-对比-ESLint" class="headerlink" title="Prettier 对比 ESLint"></a>Prettier 对比 ESLint</h4><p>我们知道 ESLint 负责了对代码的校验功能，并且主要提供了 2 类规则：</p><ul><li>检查格式化的规则</li><li>检查代码质量的规则</li></ul><p>说到底 ESLint 就是通过一条条的规则去限制代码的规范，但是这些规则毕竟是有限的，而且更重要的是这些规则的重点并不在代码风格上，所以单凭 ESLint 并不能完全的统一代码风格。</p><p>这个时候就需要引入 Prettier 了，因为它干的事就是只管代码格式化，不管代码质量。</p><blockquote><p>Prettier：在代码风格这一块，我一直拿捏的死死的。</p></blockquote><h4 id="如何配置-Prettier"><a href="#如何配置-Prettier" class="headerlink" title="如何配置 Prettier"></a>如何配置 Prettier</h4><p>初始化操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">npm i prettier -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建 .prettierrc.js</span></span><br><span class="line"><span class="built_in">echo</span> module.exports = &#123;&#125; &gt; .prettierrc.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建 .prettierignore</span></span><br><span class="line"><span class="built_in">echo</span> &gt; .prettierignore</span><br></pre></td></tr></table></figure><p>Prettier 支持可以配置参数不多，总共才 21 个，这里是所有参数的说明 <a href="https://prettier.io/docs/en/options.html#print-width" title="prettier options">prettier options</a></p><p>所有参数都有默认值，也就是说即使你没有配置 .prettierrc.js，当你用 Prettier 去格式化代码的时候全部都会走默认配置。针对个别参数，你不想用默认设置的话，就可以在 .prettierrc.js 配置具体想要的值。</p><p>如下，把项目中会用到的参数进行一个说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  printWidth: <span class="number">80</span>, <span class="comment">//（默认值）单行代码超出 80 个字符自动换行</span></span><br><span class="line">  tabWidth: <span class="number">2</span>, <span class="comment">//（默认值）一个 tab 键缩进相当于 2 个空格</span></span><br><span class="line">  useTabs: <span class="literal">true</span>, <span class="comment">// 行缩进使用 tab 键代替空格</span></span><br><span class="line">  semi: <span class="literal">false</span>, <span class="comment">//（默认值）语句的末尾加上分号</span></span><br><span class="line">  singleQuote: <span class="literal">true</span>, <span class="comment">// 使用单引号</span></span><br><span class="line">  quoteProps: <span class="string">&#x27;as-needed&#x27;</span>, <span class="comment">//（默认值）仅仅当必须的时候才会加上双引号</span></span><br><span class="line">  jsxSingleQuote: <span class="literal">true</span>, <span class="comment">// 在 JSX 中使用单引号</span></span><br><span class="line">  trailingComma: <span class="string">&#x27;all&#x27;</span>, <span class="comment">// 不用在多行的逗号分隔的句法结构的最后一行的末尾加上逗号</span></span><br><span class="line">  bracketSpacing: <span class="literal">true</span>, <span class="comment">//（默认值）在括号和对象的文字之间加上一个空格</span></span><br><span class="line">  jsxBracketSameLine: <span class="literal">true</span>, <span class="comment">// 把 &gt; 符号放在多行的 JSX 元素的最后一行</span></span><br><span class="line">  arrowParens: <span class="string">&#x27;avoid&#x27;</span>, <span class="comment">// 当箭头函数中只有一个参数的时候可以忽略括弧</span></span><br><span class="line">  htmlWhitespaceSensitivity: <span class="string">&#x27;ignore&#x27;</span>, <span class="comment">// vue template 中的结束标签结尾尖括号掉到了下一行</span></span><br><span class="line">  vueIndentScriptAndStyle: <span class="literal">false</span>, <span class="comment">//（默认值）对于 .vue 文件，不缩进 &lt;script&gt; 和 &lt;style&gt; 里的内容</span></span><br><span class="line">  embeddedLanguageFormatting: <span class="string">&#x27;auto&#x27;</span>, <span class="comment">//（默认值）允许自动格式化内嵌的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩展阅读：关于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas#trailing_commas_in_functions" title="Trailing commas">Trailing commas</a> 你或许想了解更多。</p></blockquote><p>然后可以通过命令来格式化代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将格式化当前目录及子目录下所有文件</span></span><br><span class="line">npx prettier --write .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查某个文件是否已经格式化</span></span><br><span class="line">npx prettier --check src/main.js</span><br></pre></td></tr></table></figure><p>如果有些文件不想被 Prettier 格式化，可以将其写入到 .prettierignore 里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;</span><br><span class="line">package.json</span><br><span class="line">public&#x2F;</span><br><span class="line">test&#x2F;*.*</span><br></pre></td></tr></table></figure><h4 id="Prettier-和-ESLint-一起干活更配哦"><a href="#Prettier-和-ESLint-一起干活更配哦" class="headerlink" title="Prettier 和 ESLint 一起干活更配哦"></a>Prettier 和 ESLint 一起干活更配哦</h4><p>上面介绍了 Prettier 的具体配置，这里主要介绍和 ESLint 结合使用的配置和注意事项。</p><p>和 ESLint 配合使用需要用到 eslint-plugin-prettier 这个插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint-plugin-prettier -D</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    plugins: [<span class="string">&#x27;prettier&#x27;</span>],</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个插件的工作原理是先调用 Prettier 对你的代码进行格式化，然后会把格式化前后不一致的地方进行标记，通过配置 ‘prettier/prettier’: ‘error’ 此条规则会将标记地方进行 error 级别的报错提示，然后可以通过 ESLint 的 –fix 自动修复功能将其修复。</p><p><strong>冲突了怎么办</strong></p><p>通过前面的介绍，我们知道 ESLint 也是会对代码风格做一些限制的，而 Prettier 主要就是规范代码风格，所以在把它们结合一起使用的时候是存会在一些问题的。对于个别规则，会使得双方在校验后出现代码格式不一致的问题。</p><p>那么当 Prettier 和 ESLint 出现冲突之后，该怎么办呢？</p><p>用 Prettier 的话来说很简单，只要使用 eslint-config-prettier 就可以了。解决冲突的思路就是通过将这个包提供的扩展放到 extends 最后面引入，依据 rules 生效的优先级，所以它会覆盖前面起冲突的规则，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;prettier&#x27;</span>,  <span class="comment">// 必须放最后</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了能覆盖和 ESLint 中起冲突的规则之外，eslint-config-prettier 还能覆盖来自以下插件的规则（只列了部分）：</p><ul><li>eslint-plugin-standard</li><li>eslint-plugin-vue</li></ul><p>那 eslint-config-prettier 到底提供了哪些覆盖规则呢？直接看这个列表：<a href="https://github.com/prettier/eslint-config-prettier/blob/main/index.js">eslint-config-prettier rules</a></p><p>如果想覆盖某些插件的规则，需要引入对应插件的扩展，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;plugin:vue/recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;prettier/standard&#x27;</span>,      <span class="comment">// 覆盖 eslint-config-stanard</span></span><br><span class="line">        <span class="string">&#x27;prettier/vue&#x27;</span>,           <span class="comment">// 覆盖 eslint-plugin-vue</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示：在 eslint-config-prettier 8.0.0 版本后，extends 不再需要为单独的插件引入对应扩展来覆盖冲突了，统一引入 ‘prettier’ 即可。</p></blockquote><p>如果同时使用了 eslint-plugin-prettier 和 eslint-config-prettier 可以这么配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [<span class="string">&#x27;plugin:prettier/recommended&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实和下面这些配置是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [<span class="string">&#x27;prettier&#x27;</span>],  <span class="comment">// eslint-config-prettier 提供的，用于覆盖起冲突的规则</span></span><br><span class="line">    plugins: [<span class="string">&#x27;prettier&#x27;</span>],  <span class="comment">// 注册 eslint-plugin-prettier 插件</span></span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;arrow-body-style&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;prefer-arrow-callback&#x27;</span>: <span class="string">&#x27;off&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果是在 Vue 2 项目中配置 ESLint 和 Prettier 会这么配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    parser: <span class="string">&#x27;vue-eslint-parser&#x27;</span>,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        parser: <span class="string">&#x27;babel-eslint&#x27;</span>,</span><br><span class="line">        ecmaVersion: <span class="number">12</span>,</span><br><span class="line">        sourceType: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;plugin:vue/recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>,  <span class="comment">// 在前面 Vue 配置的基础上加上这行</span></span><br><span class="line">    ],</span><br><span class="line">    plugins: [<span class="string">&#x27;vue&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果你的项目是用 vue-cli 初始化的，且选择了 eslint + prettier 方案的话，生成的项目中，.eslintrc.js 配置文件中 extends 的配置是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;plugin:vue/essential&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;@vue/prettier&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的最后一项扩展是 @vue/prettier，这个对应的是 @vue/eslint-config-prettier 这个包，让我们看看这个包下面的 index.js 内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    plugins: [<span class="string">&#x27;prettier&#x27;</span>],</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">        <span class="built_in">require</span>.resolve(<span class="string">&#x27;eslint-config-prettier&#x27;</span>),</span><br><span class="line">        <span class="built_in">require</span>.resolve(<span class="string">&#x27;eslint-config-prettier/vue&#x27;</span>)</span><br><span class="line">    ],</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和我们上面配置的内容是相差无几的，而引入 eslint-config-prettier/vue 是因为这个 @vue/eslint-config-prettier 包依赖的 eslint-config-prettier 版本是 ^6.0.0 版本的，所以在处理冲突的时候需要特别指定和对应类型插件匹配的扩展。</p><h3 id="让-EditorConfig-助力多编辑器开发吧"><a href="#让-EditorConfig-助力多编辑器开发吧" class="headerlink" title="让 EditorConfig 助力多编辑器开发吧"></a>让 EditorConfig 助力多编辑器开发吧</h3><p><a href="https://editorconfig.org/" title="EditorConfig">EditorConfig</a> 是个啥玩意？<br>它可以对多种类型的单文件进行简单的格式化，它提供的配置参数很少：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告诉 EditorConfig 插件，这是根文件，不用继续往上查找</span></span><br><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配全部文件</span></span><br><span class="line">[*]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置字符集</span></span><br><span class="line">charset = utf-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进风格，可选 space、tab</span></span><br><span class="line">indent_style = tab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进的空格数，当 indent_style = tab 将使用 tab_width</span></span><br><span class="line"><span class="comment"># 否则使用 indent_size</span></span><br><span class="line">indent_size = 2</span><br><span class="line">tab_width = 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结尾换行符，可选 lf、cr、crlf</span></span><br><span class="line">end_of_line = lf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件结尾插入新行</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一行中的前后空格</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配md结尾的文件</span></span><br><span class="line">[*.md]</span><br><span class="line">insert_final_newline = <span class="literal">false</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>虽然它提供的格式化的配置参数很少，就 3 个，缩进风格、是否在文件末尾插入新行和是否删除一行中前后空格。但是它还是非常有必要存在的，理由有 3 个：</p><ul><li>能够在不同的编辑器和 IDE 中保持一致的代码风格；</li><li>配合插件打开文件即自动格式化，非常方便</li><li>支持格式化的文件类型很多；</li></ul><p>如果需要让以上的配置生效，还得在 VSCode 里安装 EditorConfig for VS Code 这个插件配合使用。</p><p><strong>重点来了</strong></p><p>可以看到 EditorConfig 和 Prettier 会存在一些重复的配置，比如都提供了对缩进的配置参数，所以在实际使用的时候需要避免它们，或者把他们的参数设置为一致。</p><h3 id="在-VSCode-中支持-ESLint"><a href="#在-VSCode-中支持-ESLint" class="headerlink" title="在 VSCode 中支持 ESLint"></a>在 VSCode 中支持 ESLint</h3><p>前面做的配置，都需要执行命令才能进行检查和修复代码，还是挺不方便的，如果我希望编辑完或者保存的时候去检查代码该如何做呢？可以直接在 IDE 里安装 ESLint 插件，因为我使用的是 VSCode，所以这里只介绍在 VSCode 中的配置。</p><p>在使用前，需要把 ESLint 扩展安装到 VSCode 里，这里我就不细说安装步骤了。<br>安装完成后，需要在设置里写入配置：</p><ul><li>在 VSCode 左下角找到一个齿轮 ⚙ 图标，点击后选择设置选项，这个时候打开了设置面板；</li><li>然后在 VSCode 右上角找到打开设置（json）的图标，点击后，会打开 settings.json 文件；</li><li>然后把以下配置贴进去即可；</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;eslint.alwaysShowStatus&quot;</span>: <span class="literal">true</span>, <span class="comment">// 总是在 VSCode 显示 ESLint 的状态</span></span><br><span class="line">  <span class="attr">&quot;eslint.quiet&quot;</span>: <span class="literal">true</span>, <span class="comment">// 忽略 warning 的错误</span></span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 保存时使用 ESLint 修复可修复错误</span></span><br><span class="line">    <span class="attr">&quot;source.fixAll&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置说明，在 ESLint 2.0.4 版本开始：</p><ul><li>不需要通过 eslint.validate 来指定校验的文件类型了，已经自动支持了 .vue 文件；</li><li>editor.codeActionsOnSave 开启保存自动修复功能；</li></ul><p>当这样配置之后呢，每次编辑代码 ESLint 都会实时校验代码，且当保存的时候会自动 fix，是不是很方便呢。不过对于有些无法自动 fix 的代码就需要你手动去修改了，如果不想修改的话就可以配置 rules 把该条规则给关闭掉。</p><p>其实在团队开发的时候，最好把针对 VSCode 的配置，写一个文件跟随着项目，一起提交到远程仓库，这样的话就保证了项目成员都是用的这套配置。比如可以在项目根目录新建 .vscode/settings.json，然后写入上面的那串配置内容。</p><h3 id="在提交前做校验-pre-commit"><a href="#在提交前做校验-pre-commit" class="headerlink" title="在提交前做校验 pre-commit"></a>在提交前做校验 pre-commit</h3><p>以上只是通过 ESLint 自动修复能够修复的错误以及通过 Prettier 进行代码的格式化，但是在实际开发的时候难免会遇到无法 fix 的错误，可能开发人员也忘记修改，如果这个时候把代码提交到远程仓库，那就把糟糕的代码给提交上去了。</p><p>那么如何杜绝把糟糕的代码提交上去呢？可以通过配置 git hooks 的 pre-commit 钩子来实现这个目的。主要是利用了 <a href="https://typicode.github.io/husky/#/?id=install" title="husky">husky</a> 和 <a href="https://github.com/okonet/lint-staged" title="lint-staged">lint-staged</a> 这 2 个包。husky 就是用来配置 git hooks 的，而 lint-staged 则是对拿到的 staged 文件进行处理，比如执行 npx eslint –fix 进行代码校验。</p><p>具体操作步骤如下：</p><p>1、执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx mrm lint-staged</span><br></pre></td></tr></table></figure><p>会自动安装 lint-staged 和 husky 并且在 package.json 里写入 lint-staged。</p><blockquote><p>注意：mrm 是一个自动化工具，它将根据 package.json 依赖项中的代码质量工具来安装和配置 husky 和 lint-staged，因此请确保在此之前安装并配置所有代码质量工具，如 Prettier 和 ESlint。</p></blockquote><p>如果上面顺利会在 package.json 里写入 lint-staged，可以自行修改让它支持 .vue 文件的校验：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;*.&#123;js,vue&#125;&quot;</span>: <span class="string">&quot;eslint --cache --fix&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、启动 git hooks</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky install</span><br></pre></td></tr></table></figure><p>经过上面的命令后，v6 版本的 husky 会在项目根目录新建一个 .husky 目录。如果是 v4 版本的则会写入到 package.json 里。</p><p>3、创建 pre-commit 钩子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit <span class="string">&quot;npx lint-staged&quot;</span></span><br></pre></td></tr></table></figure><p>到这里后，git commit 前自动执行代码校验和修复的功能就算完成了。然后你可以试试修改文件，然后提交试试。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202106/16231352077403.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章比较长，前前后后讲了很多代码校验的东西，现在我们来梳理下。</p><p>首先用 ESLint 来做代码校验，它自带的 ruels 能提供 2 种类型的校验，分别是代码错误校验和代码格式校验，而 ESLint 本身的核心工作其实就是校验和修复错误的代码，而对格式化的规则提供的不多。</p><p>所以如果想要对代码格式化进行一个更加精细的配置则需要借助 Prettier，因为它是只负责风格的管控，所以用它再适合不过了。但是如果把 ESLint 和 Prettier 结合起来一起使用的话，就可能会出现规则的冲突了，毕竟它们两者都会对风格进行处理，所以这个时候就可以通过 eslint-config-prettier 这个扩展来把冲突的规则进行关闭，这个扩展不仅可以关闭和 ESLint 内置规则的冲突，还可以关闭实际项目中引用到的扩展规则的冲突，比如和 Vue、React、TypeScript、Flow 的冲突。</p><p>在把 ESLint 和 Prettier 结合的时候，我们希望让 ESLint 来检查代码错误，而 Prettier 校验代码风格，那么这个时候其实是有 2 个任务的，需要用 2 条命令来处理的。但是有了 eslint-plugin-prettier 这个插件后就可以很方便的把它们结合起来，当需要校验代码错误的时候 ESLint 自动会给你校验，当然前提是 VSCode 里必须按照 ESLint 插件，而当需要校验代码风格的时候 ESLint 就会调用 Prettier 的能力进行代码风格的检查。</p><p>文章的后面分别又细说了 EditorConfig 和提交代码前校验的处理，这里就不多讲了。</p><p>看到这里希望你对代码校验和规范有一个新的认识，不过我最希望的是你能够自己动手为你的项目配置一套校验规则，如果不能成功，一定是我的文章写的有问题，欢迎评论区留言指出不足之处，我是大海我来了，下篇文章见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202106/eslint.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近遇到了一个老项目，比较有意思的是这个项目集前后端的代码于一起，而后端也会去修改前端代码，所以就出现了后端用 IntelliJ IDEA 来开发前端项目，而前端用 VSCode 来开发前端项目的情况。&lt;br&gt;于是乎，出现了代码规范的问题，所以就有了这篇文章，整理了一下前端代码校验以及在 Vue 项目中的实践。&lt;/p&gt;
&lt;p&gt;阅读完这篇文章，你可以收获：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够自己亲手写出一套 ESLint 配置；&lt;/li&gt;
&lt;li&gt;会知道业界都有哪些著名的 JS 代码规范，熟读它们可以让你写出更规范的代码；&lt;/li&gt;
&lt;li&gt;vue-cli 在初始化一个包含代码校验的项目时都做了什么；&lt;/li&gt;
&lt;li&gt;Prettier 是什么？为什么要使用它？如何与 ESLint 配合使用？&lt;/li&gt;
&lt;li&gt;EditorConfig 又是什么？如何使用？&lt;/li&gt;
&lt;li&gt;如何在 VSCode 中通过插件来协助代码校验工作；&lt;/li&gt;
&lt;li&gt;如何保证 push 到远程仓库的代码是符合规范的；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://bubuzou.com/categories/vue/"/>
    
    
      <category term="eslint" scheme="https://bubuzou.com/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>死磕 36 个 JS 手写题（搞懂后，提升真的大）</title>
    <link href="https://bubuzou.com/2021/04/02/write-js-hand-by-hand/"/>
    <id>https://bubuzou.com/2021/04/02/write-js-hand-by-hand/</id>
    <published>2021-04-02T09:30:05.000Z</published>
    <updated>2021-04-30T01:47:48.107Z</updated>
    
    <content type="html"><![CDATA[<p><strong>为什么要写这类文章</strong></p><p>作为一个程序员，代码能力毋庸置疑是非常非常重要的，就像现在为什么大厂面试基本都问什么 API 怎么实现可见其重要性。我想说的是居然手写这么重要，那我们就必须掌握它，所以文章标题用了死磕，一点也不过分，也希望不被认为是标题党。</p><p>作为一个普通前端，我是真的写不出 Promise A+ 规范，但是没关系，我们可以站在巨人的肩膀上，要相信我们现在要走的路，前人都走过，所以可以找找现在社区已经存在的那些优秀的文章，比如工业聚大佬写的 <a href="https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g">100 行代码实现 Promises/A+ 规范</a>，找到这些文章后不是收藏夹吃灰，得找个时间踏踏实实的学，一行一行的磨，直到搞懂为止。我现在就是这么干的。</p><p><strong>能收获什么</strong></p><p>这篇文章总体上分为 2 类手写题，前半部分可以归纳为是常见需求，后半部分则是对现有技术的实现；</p><ul><li>对常用的需求进行手写实现，比如数据类型判断函数、深拷贝等可以直接用于往后的项目中，提高了项目开发效率；</li><li>对现有关键字和 API 的实现，可能需要用到别的知识或 API，比如在写 forEach 的时候用到了无符号位右移的操作，平时都不怎么能够接触到这玩意，现在遇到了就可以顺手把它掌握了。所以手写这些实现能够潜移默化的扩展并巩固自己的 JS 基础；</li><li>通过写各种测试用例，你会知道各种 API 的边界情况，比如 Promise.all， 你得考虑到传入参数的各种情况，从而加深了对它们的理解及使用；</li></ul><p><strong>阅读的时候需要做什么</strong></p><p>阅读的时候，你需要把每行代码都看懂，知道它在干什么，为什么要这么写，能写得更好嘛？比如在写图片懒加载的时候，一般我们都是根据当前元素的位置和视口进行判断是否要加载这张图片，普通程序员写到这就差不多完成了。而大佬程序员则是会多考虑一些细节的东西，比如性能如何更优？代码如何更精简？比如 yeyan1996 写的图片懒加载就多考虑了 2 点：比如图片全部加载完成的时候得把事件监听给移除；比如加载完一张图片的时候，得把当前 img 从 imgList 里移除，起到优化内存的作用。</p><p>除了读通代码之外，还可以打开 Chrome 的 Script snippet 去写测试用例跑跑代码，做到更好的理解以及使用。</p><p>在看了几篇以及写了很多测试用例的前提下，尝试自己手写实现，看看自己到底掌握了多少。条条大路通罗马，你还能有别的方式实现嘛？或者你能写得比别人更好嘛？</p><p>好了，还楞着干啥，开始干活。</p><a id="more"></a><h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><p>typeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeOf</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line">typeOf([])        <span class="comment">// &#x27;array&#x27;</span></span><br><span class="line">typeOf(&#123;&#125;)        <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line">typeOf(<span class="keyword">new</span> <span class="built_in">Date</span>)  <span class="comment">// &#x27;date&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.colors</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Dog.prototype =  <span class="keyword">new</span> Animal()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog1 = <span class="keyword">new</span> Dog()</span><br><span class="line">dog1.colors.push(<span class="string">&#x27;brown&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> dog2 = <span class="keyword">new</span> Dog()</span><br><span class="line"><span class="built_in">console</span>.log(dog2.colors)  <span class="comment">// [&#x27;black&#x27;, &#x27;white&#x27;, &#x27;brown&#x27;]</span></span><br></pre></td></tr></table></figure><p>原型链继承存在的问题：</p><ul><li>问题1：原型中包含的引用类型属性将被所有实例共享；</li><li>问题2：子类在实例化的时候不能给父类构造函数传参；</li></ul><h3 id="借用构造函数实现继承"><a href="#借用构造函数实现继承" class="headerlink" title="借用构造函数实现继承"></a>借用构造函数实现继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="built_in">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype =  <span class="keyword">new</span> Animal()</span><br></pre></td></tr></table></figure><p>借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="built_in">this</span>, name)</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype =  <span class="keyword">new</span> Animal()</span><br><span class="line">Dog.prototype.constructor = Dog</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">&#x27;奶昔&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">dog1.colors.push(<span class="string">&#x27;brown&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">&#x27;哈赤&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(dog2) </span><br><span class="line"><span class="comment">// &#123; name: &quot;哈赤&quot;, colors: [&quot;black&quot;, &quot;white&quot;], age: 1 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承已经相对完善了，但还是存在问题，它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。</p><p>所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。</p><p>寄生式组合继承写法上和组合继承基本类似，区别是如下这里：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Dog.prototype =  new Animal()</span></span><br><span class="line"><span class="deletion">- Dog.prototype.constructor = Dog</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ function F() &#123;&#125;</span></span><br><span class="line"><span class="addition">+ F.prototype = Animal.prototype</span></span><br><span class="line"><span class="addition">+ let f = new F()</span></span><br><span class="line"><span class="addition">+ f.constructor = Dog</span></span><br><span class="line"><span class="addition">+ Dog.prototype = f</span></span><br></pre></td></tr></table></figure><p>稍微封装下上面添加的代码后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = object(parent.prototype)</span><br><span class="line">    prototype.constructor = child</span><br><span class="line">    child.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Dog, Animal)</span><br></pre></td></tr></table></figure><p>如果你嫌弃上面的代码太多了，还可以基于组合继承的代码改成最简单的寄生式组合继承：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Dog.prototype =  new Animal()</span></span><br><span class="line"><span class="deletion">- Dog.prototype.constructor = Dog</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ Dog.prototype =  Object.create(Animal.prototype)</span></span><br><span class="line"><span class="addition">+ Dog.prototype.constructor = Dog</span></span><br></pre></td></tr></table></figure><h3 id="class-实现继承"><a href="#class-实现继承" class="headerlink" title="class 实现继承"></a>class 实现继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125; </span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>ES5 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.indexOf(item) === index</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span> [...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="number">2</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>现在就是要实现 flat 这种效果。</p><p>ES5 实现：递归。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>浅拷贝：只考虑对象类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单版深拷贝：只考虑普通对象属性，不考虑内置对象和函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? deepClone(obj[key]) : obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂版深克隆：基于简单版的基础上，还考虑了内置对象比如 Date、RegExp 等对象和函数以及解决了循环引用的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> target === <span class="string">&quot;function&quot;</span>) &amp;&amp; target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target, map = new WeakMap()</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前值的构造函数：获取它的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">constructor</span> = target.<span class="keyword">constructor</span>;</span><br><span class="line">    // 检测当前对象target是否与正则、日期格式对象匹配</span><br><span class="line">    if (/^(RegExp|Date)$/i.test(<span class="keyword">constructor</span>.name)) &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的特殊对象(正则类/日期类)的实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">constructor</span>(target);  </span><br><span class="line">    &#125;</span><br><span class="line">    if (isObject(target)) &#123;</span><br><span class="line">        map.set(target, <span class="literal">true</span>);  <span class="comment">// 为循环引用的对象做标记</span></span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">                cloneTarget[prop] = deepClone(target[prop], map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件总线（发布订阅模式）"><a href="#事件总线（发布订阅模式）" class="headerlink" title="事件总线（发布订阅模式）"></a>事件总线（发布订阅模式）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.cache = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    on(name, fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cache[name]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.cache[name].push(fn)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cache[name] = [fn]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    off(name, fn) &#123;</span><br><span class="line">        <span class="keyword">let</span> tasks = <span class="built_in">this</span>.cache[name]</span><br><span class="line">        <span class="keyword">if</span> (tasks) &#123;</span><br><span class="line">            <span class="keyword">const</span> index = tasks.findIndex(<span class="function"><span class="params">f</span> =&gt;</span> f === fn || f.callback === fn)</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                tasks.splice(index, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    emit(name, once = <span class="literal">false</span>, ...args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cache[name]) &#123;</span><br><span class="line">            <span class="comment">// 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span></span><br><span class="line">            <span class="keyword">let</span> tasks = <span class="built_in">this</span>.cache[name].slice()</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> tasks) &#123;</span><br><span class="line">                fn(...args)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (once) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="built_in">this</span>.cache[name]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> eventBus = <span class="keyword">new</span> EventEmitter()</span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello, <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">eventBus.on(<span class="string">&#x27;aaa&#x27;</span>, fn1)</span><br><span class="line">eventBus.on(<span class="string">&#x27;aaa&#x27;</span>, fn2)</span><br><span class="line">eventBus.emit(<span class="string">&#x27;aaa&#x27;</span>, <span class="literal">false</span>, <span class="string">&#x27;布兰&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="comment">// &#x27;布兰 12&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;hello, 布兰 12&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="解析-URL-参数为对象"><a href="#解析-URL-参数为对象" class="headerlink" title="解析 URL 参数为对象"></a>解析 URL 参数为对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.exec(url)[<span class="number">1</span>]; <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">    <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">    <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">    paramsArr.forEach(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/=/</span>.test(param)) &#123; <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">            <span class="keyword">let</span> [key, val] = param.split(<span class="string">&#x27;=&#x27;</span>); <span class="comment">// 分割 key 和 value</span></span><br><span class="line">            val = <span class="built_in">decodeURIComponent</span>(val); <span class="comment">// 解码</span></span><br><span class="line">            val = <span class="regexp">/^\d+$/</span>.test(val) ? <span class="built_in">parseFloat</span>(val) : val; <span class="comment">// 判断是否转为数字</span></span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123; <span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">                paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">                paramsObj[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">            paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>; <span class="comment">// 模板字符串正则</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(template)) &#123; <span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">        <span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>]; <span class="comment">// 查找当前模板里第一个模板字符串的字段</span></span><br><span class="line">        template = template.replace(reg, data[name]); <span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">        <span class="keyword">return</span> render(template, data); <span class="comment">// 递归的渲染并返回渲染后的结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> template; <span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">&#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">render(template, person); <span class="comment">// 我是布兰，年龄12，性别undefined</span></span><br></pre></td></tr></table></figure><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>与普通的图片懒加载不同，如下这个多做了 2 个精心处理：</p><ul><li>图片全部加载完成后移除事件监听；</li><li>加载完的图片，从 imgList 移除；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imgList = [...document.querySelectorAll(<span class="string">&#x27;img&#x27;</span>)]</span><br><span class="line"><span class="keyword">let</span> length = imgList.length</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> imgLazyLoad = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> deleteIndexList = []</span><br><span class="line">        imgList.forEach(<span class="function">(<span class="params">img, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> rect = img.getBoundingClientRect()</span><br><span class="line">            <span class="keyword">if</span> (rect.top &lt; <span class="built_in">window</span>.innerHeight) &#123;</span><br><span class="line">                img.src = img.dataset.src</span><br><span class="line">                deleteIndexList.push(index)</span><br><span class="line">                count++</span><br><span class="line">                <span class="keyword">if</span> (count === length) &#123;</span><br><span class="line">                    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;scroll&#x27;</span>, imgLazyLoad)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        imgList = imgList.filter(<span class="function">(<span class="params">img, index</span>) =&gt;</span> !deleteIndexList.includes(index))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里最好加上防抖处理</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, imgLazyLoad)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.cn/post/6844903856489365518#heading-19" title="图片懒加载">图片懒加载</a></p><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。</p><p>简单版：函数内部支持使用 this 和 event 对象；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;layout&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, e)  <span class="comment">// 分别打印：node 这个节点 和 MouseEvent</span></span><br><span class="line">    node.innerHTML = count++;</span><br><span class="line">&#125;;</span><br><span class="line">node.onmousemove = debounce(getUserAction, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>最终版：除了支持 this 和 event 外，还支持以下功能：</p><ul><li>支持立即执行；</li><li>函数可能有返回值；</li><li>支持取消功能；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setUseAction = debounce(getUserAction, <span class="number">10000</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 使用防抖</span></span><br><span class="line">node.onmousemove = setUseAction</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消防抖</span></span><br><span class="line">setUseAction.cancel()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/22">JavaScript专题之跟着underscore学防抖</a></p><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>触发高频事件，且 N 秒内只执行一次。</p><p>简单版：使用时间戳来实现，立即执行一次，然后每 N 秒执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        context = <span class="built_in">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终版：支持取消节流；另外通过传入第三个参数，options.leading 来表示是否可以立即执行一次，opitons.trailing 表示结束调用的时候是否还要执行一次，默认都是 true。<br>注意设置的时候不能同时将 leading 或 trailing 设置为 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="built_in">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        previous = <span class="number">0</span>;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节流的使用就不拿代码举例了，参考防抖的写就行。</p><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/26">JavaScript专题之跟着 underscore 学节流</a></p><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。还不懂？来举个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> addCurry = curry(add)</span><br><span class="line">addCurry(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>现在就是要实现 curry 这个函数，使函数从一次调用传入多个参数变成多次调用每次传一个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> judge = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == fn.length) <span class="keyword">return</span> fn(...args)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> judge(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> partialAdd = partial(add, <span class="number">1</span>)</span><br><span class="line">partialAdd(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>发现没有，其实偏函数和函数柯里化有点像，所以根据函数柯里化的实现，能够能很快写出偏函数的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上这个功能比较简单，现在我们希望偏函数能和柯里化一样能实现占位功能，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clg</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> partialClg = partial(clg, <span class="string">&#x27;_&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">partialClg(<span class="number">1</span>, <span class="number">3</span>)  <span class="comment">// 依次打印：1, 2, 3</span></span><br></pre></td></tr></table></figure><p><code>_</code> 占的位其实就是 1 的位置。相当于：partial(clg, 1, 2)，然后 partialClg(3)。明白了原理，我们就来写实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        args[index] = </span><br><span class="line">        <span class="keyword">return</span> fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 核心原理：script 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> generateUrl = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dataSrc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params.hasOwnProperty(key)) &#123;</span><br><span class="line">                dataSrc += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dataSrc += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataSrc&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">        scriptEle.src = generateUrl()</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(scriptEle)</span><br><span class="line">        <span class="built_in">window</span>[callbackName] = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            <span class="built_in">document</span>.removeChild(scriptEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Mscrosoft.XMLHttp&#x27;</span>);</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">false</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                resolve(xhr.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.responseText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现数组原型方法"><a href="#实现数组原型方法" class="headerlink" title="实现数组原型方法"></a>实现数组原型方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach2 = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)  <span class="comment">// this 就是当前的数组</span></span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">// 后面有解释</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            callback.call(thisArg, O[k], k, O);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#polyfill" title="forEach#polyfill">forEach#polyfill</a></p><p>O.length &gt;&gt;&gt; 0 是什么操作？就是无符号右移 0 位，那有什么意义嘛？就是为了保证转换后的值为正整数。其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。感兴趣可以阅读 <a href="https://zhuanlan.zhihu.com/p/100790268" title="something &gt;&gt;&gt; 0是什么意思">something &gt;&gt;&gt; 0是什么意思?</a>。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>基于 forEach 的实现能够很容易写出 map 的实现：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span></span><br><span class="line"><span class="addition">+ Array.prototype.map2 = function(callback, thisArg) &#123;</span></span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&#x27;this is null or not defined&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &#x27; is not a function&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line"><span class="deletion">-   let k = 0</span></span><br><span class="line"><span class="addition">+   let k = 0, res = []</span></span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line"><span class="deletion">-           callback.call(thisArg, O[k], k, O);</span></span><br><span class="line"><span class="addition">+           res[k] = callback.call(thisArg, O[k], k, O);</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+   return res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>同样，基于 forEach 的实现能够很容易写出 filter 的实现：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span></span><br><span class="line"><span class="addition">+ Array.prototype.filter2 = function(callback, thisArg) &#123;</span></span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&#x27;this is null or not defined&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &#x27; is not a function&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line"><span class="deletion">-   let k = 0</span></span><br><span class="line"><span class="addition">+   let k = 0, res = []</span></span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line"><span class="deletion">-           callback.call(thisArg, O[k], k, O);</span></span><br><span class="line"><span class="addition">+           if (callback.call(thisArg, O[k], k, O)) &#123;</span></span><br><span class="line"><span class="addition">+               res.push(O[k])                </span></span><br><span class="line"><span class="addition">+           &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+   return res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>同样，基于 forEach 的实现能够很容易写出 some 的实现：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span></span><br><span class="line"><span class="addition">+ Array.prototype.some2 = function(callback, thisArg) &#123;</span></span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&#x27;this is null or not defined&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &#x27; is not a function&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">    let k = 0</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line"><span class="deletion">-           callback.call(thisArg, O[k], k, O);</span></span><br><span class="line"><span class="addition">+           if (callback.call(thisArg, O[k], k, O)) &#123;</span></span><br><span class="line"><span class="addition">+               return true</span></span><br><span class="line"><span class="addition">+           &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+   return false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce2 = <span class="function"><span class="keyword">function</span>(<span class="params">callback, initialValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>, acc</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        acc = initialValue</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没传入初始值的时候，取数组中第一个非 empty 的值为初始值</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; len &amp;&amp; !(k <span class="keyword">in</span> O)) &#123;</span><br><span class="line">            k++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; len) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>( <span class="string">&#x27;Reduce of empty array with no initial value&#x27;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        acc = O[k++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            acc = callback(acc, O[k], k, O)</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现函数原型方法"><a href="#实现函数原型方法" class="headerlink" title="实现函数原型方法"></a>实现函数原型方法</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>使用一个指定的 this 值和一个或多个参数来调用一个函数。</p><p>实现要点：</p><ul><li>this 可能传入 null；</li><li>传入不固定个数的参数；</li><li>函数可能有返回值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply 和 call 一样，唯一的区别就是 call 是传入不固定个数的参数，而 apply 是传入一个数组。</p><p>实现要点：</p><ul><li>this 可能传入 null；</li><li>传入一个数组；</li><li>函数可能有返回值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="string">&#x27;arr[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind 方法会创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><p>实现要点：</p><ul><li>bind() 除了 this 外，还可传入多个参数；</li><li>bing 创建的新函数可能传入多个参数；</li><li>新函数可能被当做构造函数调用；</li><li>函数可能有返回值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-new-关键字"><a href="#实现-new-关键字" class="headerlink" title="实现 new 关键字"></a>实现 new 关键字</h2><p>new 运算符用来创建用户自定义的对象类型的实例或者具有构造函数的内置对象的实例。</p><p>实现要点：</p><ul><li>new 会产生一个新对象；</li><li>新对象需要能够访问到构造函数的属性，所以需要重新指定它的原型；</li><li>构造函数可能会显示返回；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ret || obj 这里这么写考虑了构造函数显示返回 null 的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> ? ret || obj : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = objectFactory(person, <span class="string">&#x27;布兰&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="实现-instanceof-关键字"><a href="#实现-instanceof-关键字" class="headerlink" title="实现 instanceof 关键字"></a>实现 instanceof 关键字</h2><p>instanceof 就是判断构造函数的 prototype 属性是否出现在实例的原型链上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = left.__proto__</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (proto === right.prototype) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        proto = proto.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 left.<strong>proto</strong> 这种写法可以换成 Object.getPrototypeOf(left)。</p><h2 id="实现-Object-create"><a href="#实现-Object-create" class="headerlink" title="实现 Object.create"></a>实现 Object.create</h2><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create2 = <span class="function"><span class="keyword">function</span>(<span class="params">proto, propertyObject = undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Object prototype may only be an Object or null.&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (propertyObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = proto</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="keyword">new</span> F()</span><br><span class="line">    <span class="keyword">if</span> (propertyObject != <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(obj, propertyObject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个没有原型对象的对象，Object.create(null)</span></span><br><span class="line">        obj.__proto__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-Object-assign"><a href="#实现-Object-assign" class="headerlink" title="实现 Object.assign"></a>实现 Object.assign</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign2 = <span class="function"><span class="keyword">function</span>(<span class="params">target, ...source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="built_in">Object</span>(target) </span><br><span class="line">    source.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                    ret[key] = obj[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-JSON-stringify"><a href="#实现-JSON-stringify" class="headerlink" title="实现 JSON.stringify"></a>实现 JSON.stringify</h2><p>JSON.stringify([, replacer [, space]) 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 replacer 和第三个参数 space，如果对这两个参数的作用还不了解，建议阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" title="stringify">MDN</a> 文档。</p><ol><li>基本数据类型：<ul><li>undefined 转换之后仍是 undefined(类型也是 undefined)</li><li>boolean 值转换之后是字符串 “false”/“true”</li><li>number 类型(除了 NaN 和 Infinity)转换之后是字符串类型的数值</li><li>symbol 转换之后是 undefined</li><li>null 转换之后是字符串 “null”</li><li>string 转换之后仍是string</li><li>NaN 和 Infinity 转换之后是字符串 “null”</li></ul></li><li>函数类型：转换之后是 undefined</li><li>如果是对象类型(非函数)<ul><li>如果是一个数组：如果属性值中出现了 undefined、任意的函数以及 symbol，转换成字符串 “null” ；</li><li>如果是 RegExp 对象：返回 {} (类型是 string)；</li><li>如果是 Date 对象，返回 Date 的 toJSON 字符串值；</li><li>如果是普通对象；<ul><li>如果有 toJSON() 方法，那么序列化 toJSON() 的返回值。</li><li>如果属性值中出现了 undefined、任意的函数以及 symbol 值，忽略。</li><li>所有以 symbol 为属性键的属性都会被完全忽略掉。</li></ul></li></ul></li><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataType = <span class="keyword">typeof</span> data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dataType !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = data;</span><br><span class="line">        <span class="comment">//data 可能是 string/number/null/undefined/boolean</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(data) || data === <span class="literal">Infinity</span>) &#123;</span><br><span class="line">            <span class="comment">//NaN 和 Infinity 序列化返回 &quot;null&quot;</span></span><br><span class="line">            result = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&#x27;function&#x27;</span> || dataType === <span class="string">&#x27;undefined&#x27;</span> || dataType === <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//function 、undefined 、symbol 序列化返回 undefined</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            result = <span class="string">&#x27;&quot;&#x27;</span> + data + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//boolean 返回 String()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.toJSON &amp;&amp; <span class="keyword">typeof</span> data.toJSON === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> jsonStringify(data.toJSON());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> result = [];</span><br><span class="line">            <span class="comment">//如果是数组</span></span><br><span class="line">            <span class="comment">//toJSON 方法可以存在于原型链中</span></span><br><span class="line">            data.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&#x27;undefined&#x27;</span> || <span class="keyword">typeof</span> item === <span class="string">&#x27;function&#x27;</span> || <span class="keyword">typeof</span> item === <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">                    result[index] = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result[index] = jsonStringify(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            result = <span class="string">&quot;[&quot;</span> + result + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> result.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//普通对象</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 循环引用抛错(暂未检测，循环引用时，堆栈溢出)</span></span><br><span class="line"><span class="comment">             * symbol key 忽略</span></span><br><span class="line"><span class="comment">             * undefined、函数、symbol 为属性值，被忽略</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">let</span> result = [];</span><br><span class="line">            <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">//key 如果是symbol对象，忽略</span></span><br><span class="line">                    <span class="keyword">if</span> (data[item] !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> data[item] !== <span class="string">&#x27;function&#x27;</span></span><br><span class="line">                        &amp;&amp; <span class="keyword">typeof</span> data[item] !== <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">//键值如果是 undefined、函数、symbol 为属性值，忽略</span></span><br><span class="line">                        result.push(<span class="string">&#x27;&quot;&#x27;</span> + item + <span class="string">&#x27;&quot;&#x27;</span> + <span class="string">&quot;:&quot;</span> + jsonStringify(data[item]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;&#123;&quot;</span> + result + <span class="string">&quot;&#125;&quot;</span>).replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/YvetteLau/Step-By-Step/issues/39#issuecomment-508327280" title="实现 JSON.stringify">实现 JSON.stringify</a></p><h2 id="实现-JSON-parse"><a href="#实现-JSON-parse" class="headerlink" title="实现 JSON.parse"></a>实现 JSON.parse</h2><p>介绍 2 种方法实现：</p><ul><li>eval 实现；</li><li>new Function 实现；</li></ul><h3 id="eval-实现"><a href="#eval-实现" class="headerlink" title="eval 实现"></a>eval 实现</h3><p>第一种方式最简单，也最直观，就是直接调用 eval，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + json + <span class="string">&quot;)&quot;</span>);  <span class="comment">// obj 就是 json 反序列化之后得到的对象</span></span><br></pre></td></tr></table></figure><p>但是直接调用 eval 会存在安全问题，如果数据中可能不是 json 数据，而是可执行的 JavaScript 代码，那很可能会造成 XSS 攻击。因此，在调用 eval 之前，需要对数据进行校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    rx_one.test(</span><br><span class="line">        json.replace(rx_two, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            .replace(rx_three, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">            .replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> +json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/youngwind/blog/issues/115#issue-300869613" title="JSON.parse 三种实现方式">JSON.parse 三种实现方式</a></p><h3 id="new-Function-实现"><a href="#new-Function-实现" class="headerlink" title="new Function 实现"></a>new Function 实现</h3><p>Function 与 eval 有相同的字符串参数特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = (<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + json))();</span><br></pre></td></tr></table></figure><h2 id="实现-Promise"><a href="#实现-Promise" class="headerlink" title="实现 Promise"></a>实现 Promise</h2><p>实现 Promise 需要完全读懂 <a href="https://promisesaplus.com/" title="Promise A+ 规范">Promise A+ 规范</a>，不过从总体的实现上看，有如下几个点需要考虑到：</p><ul><li>then 需要支持链式调用，所以得返回一个新的 Promise；</li><li>处理异步问题，所以得先用 onResolvedCallbacks 和 onRejectedCallbacks 分别把成功和失败的回调存起来；</li><li>为了让链式调用正常进行下去，需要判断 onFulfilled 和 onRejected 的类型；</li><li>onFulfilled 和 onRejected 需要被异步调用，这里用 setTimeout 模拟异步；</li><li>处理 Promise 的 resolve；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> resolve = (value) = &gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.value = value;</span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.forEach((fn) = &gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> reject = (reason) = &gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.reason = reason;</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach((fn) = &gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 解决 onFufilled，onRejected 没有传值的问题</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : (v) = &gt; v;</span><br><span class="line">        <span class="comment">// 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获</span></span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span> ? onRejected : (err) = &gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 每次调用 then 都返回一个新的 promise</span></span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) = &gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">                <span class="comment">//Promise/A+ 2.2.4 --- setTimeout</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        <span class="comment">// x可能是一个proimise</span></span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">                <span class="comment">//Promise/A+ 2.2.3</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.push(() = &gt; &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            </span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(() = &gt; &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> resolvePromise = (promise2, x, resolve, reject) = &gt; &#123;</span><br><span class="line">    <span class="comment">// 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Promise/A+ 2.3.3.3.3 只能调用一次</span></span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line">    <span class="comment">// 后续的条件要严格判断 保证代码能和别的库一起使用</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> &amp;&amp; x != <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3</span></span><br><span class="line">                then.call(</span><br><span class="line">                    x, (y) = &gt; &#123;</span><br><span class="line">                        <span class="comment">// 根据 promise 的状态决定是成功还是失败</span></span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1</span></span><br><span class="line">                        resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                    &#125;, (r) = &gt; &#123;</span><br><span class="line">                        <span class="comment">// 只要失败就失败 Promise/A+ 2.3.3.3.2</span></span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        reject(r);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4</span></span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// Promise/A+ 2.3.3.2</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4</span></span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Promise 写完之后可以通过 promises-aplus-tests 这个包对我们写的代码进行测试，看是否符合 A+ 规范。不过测试前还得加一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="comment">// 这里是上面写的 Promise 全部代码</span></span><br><span class="line"><span class="built_in">Promise</span>.defer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全局安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i promises-aplus-tests -g</span><br></pre></td></tr></table></figure><p>终端下执行验证命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests promise.js</span><br></pre></td></tr></table></figure><p>上面写的代码可以顺利通过全部 872 个测试用例。</p><p>参考：</p><ul><li><a href="https://juejin.cn/post/6844903625769091079" title="BAT前端经典面试问题：史上最最最详细的手写Promise教程">BAT前端经典面试问题：史上最最最详细的手写Promise教程</a></li><li><a href="https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g" title="100 行代码实现 Promises/A+ 规范">100 行代码实现 Promises/A+ 规范</a></li></ul><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是 Promsie，则直接输出它</span></span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://bubuzou.com/2020/10/22/promise/" title="深入理解 Promise">深入理解 Promise</a></p><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 的规则是这样的：</p><ul><li>传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；</li><li>只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；</li><li>只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>, result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                index++</span><br><span class="line">                result[i] = val</span><br><span class="line">                <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                rejecte(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>Promise.allSettled 的规则是这样：</p><ul><li>所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise，且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象；</li><li>如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    status: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                    value: val</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">if</span> (result.length === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    status: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                    reason: err</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">if</span> (result.length === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>Promise.any 的规则是这样：</p><ul><li>空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；</li><li>只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；</li><li>其他情况都会返回一个 pending 的新实例；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (promiseArr.length === <span class="number">0</span>) <span class="keyword">return</span> </span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">                </span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                index++</span><br><span class="line">                <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                  reject(<span class="keyword">new</span> AggregateError(<span class="string">&#x27;All promises were rejected&#x27;</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>能看到这里的对代码都是真爱了，毕竟代码这玩意看起来是真的很枯燥，但是如果看懂了后，就会像打游戏赢了一样开心，而且这玩意会上瘾，当你通关了越多的关卡后，你的能力就会拔高一个层次。用标题的话来说就是：搞懂后，提升真的大。加油吧💪，干饭人</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202104/16172447086022.jpg" alt="-w117"></p><p>噢不，代码人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;为什么要写这类文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个程序员，代码能力毋庸置疑是非常非常重要的，就像现在为什么大厂面试基本都问什么 API 怎么实现可见其重要性。我想说的是居然手写这么重要，那我们就必须掌握它，所以文章标题用了死磕，一点也不过分，也希望不被认为是标题党。&lt;/p&gt;
&lt;p&gt;作为一个普通前端，我是真的写不出 Promise A+ 规范，但是没关系，我们可以站在巨人的肩膀上，要相信我们现在要走的路，前人都走过，所以可以找找现在社区已经存在的那些优秀的文章，比如工业聚大佬写的 &lt;a href=&quot;https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g&quot;&gt;100 行代码实现 Promises/A+ 规范&lt;/a&gt;，找到这些文章后不是收藏夹吃灰，得找个时间踏踏实实的学，一行一行的磨，直到搞懂为止。我现在就是这么干的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;能收获什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇文章总体上分为 2 类手写题，前半部分可以归纳为是常见需求，后半部分则是对现有技术的实现；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对常用的需求进行手写实现，比如数据类型判断函数、深拷贝等可以直接用于往后的项目中，提高了项目开发效率；&lt;/li&gt;
&lt;li&gt;对现有关键字和 API 的实现，可能需要用到别的知识或 API，比如在写 forEach 的时候用到了无符号位右移的操作，平时都不怎么能够接触到这玩意，现在遇到了就可以顺手把它掌握了。所以手写这些实现能够潜移默化的扩展并巩固自己的 JS 基础；&lt;/li&gt;
&lt;li&gt;通过写各种测试用例，你会知道各种 API 的边界情况，比如 Promise.all， 你得考虑到传入参数的各种情况，从而加深了对它们的理解及使用；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;阅读的时候需要做什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;阅读的时候，你需要把每行代码都看懂，知道它在干什么，为什么要这么写，能写得更好嘛？比如在写图片懒加载的时候，一般我们都是根据当前元素的位置和视口进行判断是否要加载这张图片，普通程序员写到这就差不多完成了。而大佬程序员则是会多考虑一些细节的东西，比如性能如何更优？代码如何更精简？比如 yeyan1996 写的图片懒加载就多考虑了 2 点：比如图片全部加载完成的时候得把事件监听给移除；比如加载完一张图片的时候，得把当前 img 从 imgList 里移除，起到优化内存的作用。&lt;/p&gt;
&lt;p&gt;除了读通代码之外，还可以打开 Chrome 的 Script snippet 去写测试用例跑跑代码，做到更好的理解以及使用。&lt;/p&gt;
&lt;p&gt;在看了几篇以及写了很多测试用例的前提下，尝试自己手写实现，看看自己到底掌握了多少。条条大路通罗马，你还能有别的方式实现嘛？或者你能写得比别人更好嘛？&lt;/p&gt;
&lt;p&gt;好了，还楞着干啥，开始干活。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>1.5 万字 CSS 基础拾遗（核心知识、常用需求）</title>
    <link href="https://bubuzou.com/2021/03/22/css_base/"/>
    <id>https://bubuzou.com/2021/03/22/css_base/</id>
    <published>2021-03-22T01:20:26.000Z</published>
    <updated>2021-09-06T09:56:22.607Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章围绕了 CSS 的核心知识点和项目中常见的需求来展开。虽然行文偏长，但偏基础，适合初级中级前端阅读，阅读的时候请适当跳过已经掌握的部分。</p><p>这篇文章断断续续写了比较久，也参考了许多优秀的文章，但或许文章里还是存在不好或不对的地方，请多多指教，可以评论里直接提出来哈。</p><p>小 tip：后续内容更精彩哦。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/cssxm.png"></p><a id="more"></a><h2 id="核心概念和知识点"><a href="#核心概念和知识点" class="headerlink" title="核心概念和知识点"></a>核心概念和知识点</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>CSS 的核心功能是将 CSS 属性设定为特定的值。一个属性与值的键值对被称为<strong>声明</strong>（declaration）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br></pre></td></tr></table></figure><p>而如果将一个或者多个声明用 <code>&#123;&#125;</code> 包裹起来后，那就组成了一个<strong>声明块</strong>（declaration block）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明块如果需要作用到对应的 HTML 元素，那还需要加上<strong>选择器</strong>。选择器和声明块组成了<strong>CSS 规则集</strong>（CSS ruleset），常简称为 CSS 规则。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css001.png"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>规则集中最后一条声明可以省略分号，但是并不建议这么做，因为容易出错。</p></blockquote><p>CSS 中的<strong>注释</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 单行注释 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多行</span></span><br><span class="line"><span class="comment">    注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 CSS 文件中，除了注释、CSS 规则集以及 @规则 外，定义的一些别的东西都将被浏览器忽略。</p><h3 id="规则"><a href="#规则" class="headerlink" title="@规则"></a>@规则</h3><p>CSS 规则是样式表的主体，通常样式表会包括大量的规则列表。但有时候也需要在样式表中包括其他的一些信息，比如字符集，导入其它的外部样式表，字体等，这些需要专门的语句表示。</p><p>而 @规则 就是这样的语句。CSS 里包含了以下 @规则：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@namespace">@namespace</a> 告诉 CSS 引擎必须考虑 XML 命名空间。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">@media</a>, 如果满足媒体查询的条件则条件规则组里的规则生效。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@page">@page</a>, 描述打印文档时布局的变化.</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">@font-face</a>, 描述将下载的外部的字体。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes">@keyframes</a>, 描述 CSS 动画的关键帧。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@document">@document</a>, 如果文档样式表满足给定条件则条件规则组里的规则生效。 (推延至 CSS Level 4 规范)</li></ul><p>除了以上这几个之外，下面还将对几个比较生涩的 @规则 进行介绍。</p><h4 id="charset"><a href="#charset" class="headerlink" title="@charset"></a>@charset</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset" title="@charset">@charset</a> 用于定义样式表使用的字符集。它必须是样式表中的第一个元素。如果有多个 <code>@charset</code> 被声明，只有第一个会被使用，而且不能在 HTML 元素或 HTML 页面的 <code>&lt;style&gt;</code> 元素内使用。</p><p>注意：值必须是双引号包裹，且和</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br></pre></td></tr></table></figure><p>平时写样式文件都没写 @charset 规则，那这个 CSS 文件到底是用的什么字符编码的呢？</p><p>某个样式表文件到底用的是什么字符编码，浏览器有一套识别顺序（优先级由高到低）：</p><ul><li><p>文件开头的 <a href="https://en.wikipedia.org/wiki/Byte_order_mark" title="Byte order mark">Byte order mark</a> 字符值，不过一般编辑器并不能看到文件头里的 BOM 值；</p></li><li><p>HTTP 响应头里的 <code>content-type</code> 字段包含的 <code>charset</code> 所指定的值，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text&#x2F;css; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure></li><li><p>CSS 文件头里定义的 @charset 规则里指定的字符编码；</p></li><li><p><code>&lt;link&gt;</code> 标签里的 charset 属性，该条已在 HTML5 中废除；</p></li><li><p>默认是 <code>UTF-8</code>。</p></li></ul><h4 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import" title="@import">@import</a> 用于告诉 CSS 引擎引入一个外部样式表。</p><p>link 和 @import 都能导入一个样式文件，它们有什么区别嘛？</p><ul><li>link 是 HTML 标签，除了能导入 CSS 外，还能导入别的资源，比如图片、脚本和字体等；而 @import 是 CSS 的语法，只能用来导入 CSS；</li><li>link 导入的样式会在页面加载时同时加载，@import 导入的样式需等页面加载完成后再加载；</li><li>link 没有兼容性问题，@import 不兼容 ie5 以下；</li><li>link 可以通过 JS 操作 DOM 动态引入样式表改变样式，而@import 不可以。</li></ul><h4 id="supports"><a href="#supports" class="headerlink" title="@supports"></a>@supports</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports" title="@supports">@supports</a> 用于查询特定的 CSS 是否生效，可以结合 not、and 和 or 操作符进行后续的操作。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果支持自定义属性，则把 body 颜色设置为变量 varName 指定的颜色 */</span></span><br><span class="line"><span class="keyword">@supports</span> (<span class="attribute">--foo:</span> green) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--varName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>层叠样式表，这里的层叠怎么理解呢？其实它是 CSS 中的核心特性之一，用于合并来自多个源的属性值的算法。比如说针对某个 HTML 标签，有许多的 CSS 声明都能作用到的时候，那最后谁应该起作用呢？层叠性说的大概就是这个。</p><p>针对不同源的样式，将按照如下的顺序进行层叠，越往下优先级越高：</p><ul><li>用户代理样式表中的声明(例如，浏览器的默认样式，在没有设置其他样式时使用)。</li><li><del>用户样式表中的常规声明(由用户设置的自定义样式。由于 Chrome 在很早的时候就放弃了用户样式表的功能，所以这里将不再考虑它的排序。)</del>。</li><li>作者样式表中的常规声明(这些是我们 Web 开发人员设置的样式)。</li><li>作者样式表中的 !important 声明。</li><li><del>用户样式表中的 !important 声明 S</del>。</li></ul><p>理解层叠性的时候需要结合 CSS 选择器的优先级以及继承性来理解。比如针对同一个选择器，定义在后面的声明会覆盖前面的；作者定义的样式会比默认继承的样式优先级更高。</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>CSS 选择器无疑是其核心之一，对于基础选择器以及一些常用伪类必须掌握。下面列出了常用的选择器。<br>想要获取更多选择器的用法可以看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors" title="MDN CSS Selectors">MDN CSS Selectors</a>。</p><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><ul><li>标签选择器：<code>h1</code></li><li>类选择器：<code>.checked</code></li><li>ID 选择器：<code>#picker</code></li><li>通配选择器：<code>*</code></li></ul><p><strong>属性选择器</strong></p><ul><li><code>[attr]</code>：指定属性的元素；</li><li><code>[attr=val]</code>：属性等于指定值的元素；</li><li><code>[attr*=val]</code>：属性包含指定值的元素；</li><li><code>[attr^=val]</code> ：属性以指定值开头的元素；</li><li><code>[attr$=val]</code>：属性以指定值结尾的元素；</li><li><code>[attr~=val]</code>：属性包含指定值(完整单词)的元素(不推荐使用)；</li><li><code>[attr|=val]</code>：属性以指定值(完整单词)开头的元素(不推荐使用)；</li></ul><h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4><ul><li>相邻兄弟选择器：<code>A + B</code></li><li>普通兄弟选择器：<code>A ~ B</code></li><li>子选择器：<code>A &gt; B</code></li><li>后代选择器：<code>A B</code></li></ul><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><p><strong>条件伪类</strong></p><ul><li><code>:lang()</code>：基于元素语言来匹配页面元素；</li><li><code>:dir()</code>：匹配特定文字书写方向的元素；</li><li><code>:has()</code>：匹配包含指定元素的元素；</li><li><code>:is()</code>：匹配指定选择器列表里的元素；</li><li><code>:not()</code>：用来匹配不符合一组选择器的元素；</li></ul><p><strong>行为伪类</strong></p><ul><li><code>:active</code>：鼠标激活的元素；</li><li><code>:hover</code>： 鼠标悬浮的元素；</li><li><code>::selection</code>：鼠标选中的元素；</li></ul><p><strong>状态伪类</strong></p><ul><li><code>:target</code>：当前锚点的元素；</li><li><code>:link</code>：未访问的链接元素；</li><li><code>:visited</code>：已访问的链接元素；</li><li><code>:focus</code>：输入聚焦的表单元素；</li><li><code>:required</code>：输入必填的表单元素；</li><li><code>:valid</code>：输入合法的表单元素；</li><li><code>:invalid</code>：输入非法的表单元素；</li><li><code>:in-range</code>：输入范围以内的表单元素；</li><li><code>:out-of-range</code>：输入范围以外的表单元素；</li><li><code>:checked</code>：选项选中的表单元素；</li><li><code>:optional</code>：选项可选的表单元素；</li><li><code>:enabled</code>：事件启用的表单元素；</li><li><code>:disabled</code>：事件禁用的表单元素；</li><li><code>:read-only</code>：只读的表单元素；</li><li><code>:read-write</code>：可读可写的表单元素；</li><li><code>:blank</code>：输入为空的表单元素；</li><li><code>:current()</code>：浏览中的元素；</li><li><code>:past()</code>：已浏览的元素；</li><li><code>:future()</code>：未浏览的元素；</li></ul><p><strong>结构伪类</strong></p><ul><li><code>:root</code>：文档的根元素；</li><li><code>:empty</code>：无子元素的元素；</li><li><code>:first-letter</code>：元素的首字母；</li><li><code>:first-line</code>：元素的首行；</li><li><code>:nth-child(n)</code>：元素中指定顺序索引的元素；</li><li><code>:nth-last-child(n)</code>：元素中指定逆序索引的元素；；</li><li><code>:first-child </code>：元素中为首的元素；</li><li><code>:last-child</code> ：元素中为尾的元素；</li><li><code>:only-child</code>：父元素仅有该元素的元素；</li><li><code>:nth-of-type(n) </code>：标签中指定顺序索引的标签；</li><li><code>:nth-last-of-type(n)</code>：标签中指定逆序索引的标签；</li><li><code>:first-of-type</code> ：标签中为首的标签；</li><li><code>:last-of-type</code>：标签中为尾标签；</li><li><code>:only-of-type</code>：父元素仅有该标签的标签；</li></ul><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><ul><li><code>::before</code>：在元素前插入内容；</li><li><code>::after</code>：在元素后插入内容；</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css022.png"></p><p>优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。为了记忆，可以把权重分成如下几个等级，数值越大的权重越高：</p><ul><li>10000：!important；</li><li>01000：内联样式；</li><li>00100：ID 选择器；</li><li>00010：类选择器、伪类选择器、属性选择器；</li><li>00001：元素选择器、伪元素选择器；</li><li>00000：通配选择器、后代选择器、兄弟选择器；</li></ul><p>可以看到内联样式（通过元素中 style 属性定义的样式）的优先级大于任何选择器；而给属性值加上 <code>!important</code> 又可以把优先级提至最高，就是因为它的优先级最高，所以需要谨慎使用它，以下有些使用注意事项：</p><ul><li>一定要优先考虑使用样式规则的优先级来解决问题而不是 !important；</li><li>只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important；</li><li>永远不要在你的插件中使用 !important；</li><li>永远不要在全站范围的 CSS 代码中使用 !important；</li></ul><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css023.jpg"></p><p>在 CSS 中有一个很重要的特性就是子元素会继承父元素对应属性计算后的值。比如页面根元素 html 的文本颜色默认是黑色的，页面中的所有其他元素都将继承这个颜色，当申明了如下样式后，H1 文本将变成橙色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设想一下，如果 CSS 中不存在继承性，那么我们就需要为不同文本的标签都设置一下 color，这样一来的后果就是 CSS 的文件大小就会无限增大。</p><p>CSS 属性很多，但并不是所有的属性默认都是能继承父元素对应属性的，那哪些属性存在默认继承的行为呢？一定是那些不会影响到页面布局的属性，可以分为如下几类：</p><ul><li>字体相关：<code>font-family</code>、<code>font-style</code>、<code>font-size</code>、<code>font-weight</code> 等；</li><li>文本相关：<code>text-align</code>、<code>text-indent</code>、<code>text-decoration</code>、<code>text-shadow</code>、<code>letter-spacing</code>、<code>word-spacing</code>、<code>white-space</code>、<code>line-height</code>、<code>color</code> 等；</li><li>列表相关：<code>list-style</code>、<code>list-style-image</code>、<code>list-style-type</code>、<code>list-style-position</code> 等；</li><li>其他属性：<code>visibility</code>、<code>cursor</code> 等；</li></ul><p>对于其他默认不继承的属性也可以通过以下几个属性值来控制继承行为：</p><ul><li><code>inherit</code>：继承父元素对应属性的计算值；</li><li><code>initial</code>：应用该属性的默认值，比如 color 的默认值是 <code>#000</code>；</li><li><code>unset</code>：如果属性是默认可以继承的，则取 <code>inherit</code> 的效果，否则同 <code>initial</code>；</li><li><code>revert</code>：效果等同于 <code>unset</code>，兼容性差。</li></ul><h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p>在 CSS 的世界中，会把内容按照从左到右、从上到下的顺序进行排列显示。正常情况下会把页面分割成一行一行的显示，而每行又可能由多列组成，所以从视觉上看起来就是从上到下从左到右，而这就是 CSS 中的流式布局，又叫文档流。文档流就像水一样，能够自适应所在的容器，一般它有如下几个特性：</p><ul><li>块级元素默认会占满整行，所以多个块级盒子之间是从上到下排列的；</li><li>内联元素默认会在一行里一列一列的排布，当一行放不下的时候，会自动切换到下一行继续按照列排布；</li></ul><p><strong>如何脱离文档流呢？</strong></p><p>脱流文档流指节点脱流正常文档流后，在正常文档流中的其他节点将忽略该节点并填补其原先空间。文档一旦脱流，计算其父节点高度时不会将其高度纳入，脱流节点不占据空间。有两种方式可以让元素脱离文档流：浮动和定位。</p><ul><li>使用浮动（float）会将元素脱离文档流，移动到容器左/右侧边界或者是另一个浮动元素旁边，该浮动元素之前占用的空间将被别的元素填补，另外浮动之后所占用的区域不会和别的元素之间发生重叠；</li><li>使用绝对定位（<code>position: absolute;</code>）或者固定定位（<code>position: fixed;</code>）也会使得元素脱离文档流，且空出来的位置将自动被后续节点填补。</li></ul><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>在 CSS 中任何元素都可以看成是一个盒子，而一个盒子是由 4 部分组成的：内容（content）、内边距（padding）、边框（border）和外边距（margin）。</p><p>盒模型有 2 种：标准盒模型和 IE 盒模型，分别是由 W3C 和 IExplore 制定的标准。</p><p>如果给某个元素设置如下样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准盒模型认为：盒子的实际尺寸 = 内容（设置的宽/高） + 内边距 + 边框</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/contentbox.png"></p><p>所以 <code>.box</code> 元素内容的宽度就为 <code>200px</code>，而实际的宽度则是 <code>width</code> + <code>padding-left</code> + <code>padding-right</code> + <code>border-left-width</code> + <code>border-right-width</code> = 200 + 10 + 10 + 1 + 1 = 222。</p><p>IE 盒模型认为：盒子的实际尺寸 = 设置的宽/高 = 内容 + 内边距 + 边框</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/borderbox.png"></p><p><code>.box</code> 元素所占用的实际宽度为 <code>200px</code>，而内容的真实宽度则是 <code>width</code> - <code>padding-left</code> - <code>padding-right</code> - <code>border-left-width</code> - <code>border-right-width</code> = 200 - 10 - 10 - 1 - 1 = 178。</p><p>现在高版本的浏览器基本上默认都是使用标准盒模型，而像 IE6 这种老古董才是默认使用 IE 盒模型的。</p><p>在 CSS3 中新增了一个属性 <code>box-sizing</code>，允许开发者来指定盒子使用什么标准，它有 2 个值：</p><ul><li><code>content-box</code>：标准盒模型；</li><li><code>border-box</code>：IE 盒模型；</li></ul><h3 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h3><p>视觉格式化模型（Visual formatting model）是用来处理和在视觉媒体上显示文档时使用的计算规则。CSS 中一切皆盒子，而视觉格式化模型简单来理解就是规定这些盒子应该怎么样放置到页面中去，这个模型在计算的时候会依赖到很多的因素，比如：盒子尺寸、盒子类型、定位方案（是浮动还是定位）、兄弟元素或者子元素以及一些别的因素。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css016.jpg" alt="Visual formatting model"></p><p>从上图中可以看到视觉格式化模型涉及到的内容很多，有兴趣深入研究的可以结合上图看这个 W3C 的文档 <a href="https://www.w3.org/TR/CSS2/visuren.html" title="Visual formatting model">Visual formatting model</a>。所以这里就简单介绍下盒子类型。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css018.png"></p><p>盒子类型由 display 决定，同时给一个元素设置 display 后，将会决定这个盒子的 2 个显示类型（display type）：</p><ul><li>outer display type（对外显示）：决定了该元素本身是如何布局的，即参与何种格式化上下文；</li><li>inner display type（对内显示）：其实就相当于把该元素当成了容器，规定了其内部子元素是如何布局的，参与何种格式化上下文；</li></ul><h4 id="outer-display-type"><a href="#outer-display-type" class="headerlink" title="outer display type"></a>outer display type</h4><p>对外显示方面，盒子类型可以分成 2 类：block-level box（块级盒子） 和 inline-level box（行内级盒子）。</p><p>依据上图可以列出都有哪些块级和行内级盒子：</p><ul><li>块级盒子：display 为 block、list-item、table、flex、grid、flow-root 等；</li><li>行内级盒子：display 为 inline、inline-block、inline-table 等；</li></ul><p>所有块级盒子都会参与 BFC，呈现垂直排列；而所有行内级盒子都参会 IFC，呈现水平排列。</p><p>除此之外，block、inline 和 inline-block 还有什么更具体的区别嘛？</p><p><strong>block</strong></p><ul><li>占满一行，默认继承父元素的宽度；多个块元素将从上到下进行排列；</li><li>设置 width/height 将会生效；</li><li>设置 padding 和 margin 将会生效；</li></ul><p><strong>inline</strong></p><ul><li>不会占满一行，宽度随着内容而变化；多个 inline 元素将按照从左到右的顺序在一行里排列显示，如果一行显示不下，则自动换行；</li><li>设置 width/height 将不会生效；</li><li>设置竖直方向上的 padding 和 margin 将不会生效；</li></ul><p><strong>inline-block</strong></p><ul><li>是行内块元素，不单独占满一行，可以看成是能够在一行里进行左右排列的块元素；</li><li>设置 width/height 将会生效；</li><li>设置 padding 和 margin 将会生效；</li></ul><h4 id="inner-display-type"><a href="#inner-display-type" class="headerlink" title="inner display type"></a>inner display type</h4><p>对内方面，其实就是把元素当成了容器，里面包裹着文本或者其他子元素。container box 的类型依据 display 的值不同，分为 4 种：</p><ul><li>block container：建立 BFC 或者 IFC；</li><li>flex container：建立 FFC；</li><li>grid container：建立 GFC;</li><li>ruby container：接触不多，不做介绍。</li></ul><p>值得一提的是如果把 img 这种替换元素（replaced element）申明为 block 是不会产生 container box 的，因为替换元素比如 img 设计的初衷就仅仅是通过 src 把内容替换成图片，完全没考虑过会把它当成容器。</p><p>参考：</p><ul><li><a href="https://yachen168.github.io/article/display.html" title="CSS 原理 - 你所不知道的 display">CSS 原理 - 你所不知道的 display</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10223896?sc=pt" title="格式化上下文">格式化上下文</a></li></ul><h3 id="格式化上下文"><a href="#格式化上下文" class="headerlink" title="格式化上下文"></a>格式化上下文</h3><p>格式化上下文（Formatting Context）是 CSS2.1 规范中的一个概念，大概说的是页面中的一块渲染区域，规定了渲染区域内部的子元素是如何排版以及相互作用的。</p><p>不同类型的盒子有不同格式化上下文，大概有这 4 类：</p><ul><li>BFC (Block Formatting Context) 块级格式化上下文；</li><li>IFC (Inline Formatting Context) 行内格式化上下文；</li><li>FFC (Flex Formatting Context) 弹性格式化上下文；</li><li>GFC (Grid Formatting Context) 格栅格式化上下文；</li></ul><p>其中 BFC 和 IFC 在 CSS 中扮演着非常重要的角色，因为它们直接影响了网页布局，所以需要深入理解其原理。</p><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><p>块格式化上下文，它是一个独立的渲染区域，只有块级盒子参与，它规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css019.png" alt="图来源于 yachen168"></p><p><strong>BFC 渲染规则</strong></p><ul><li>内部的盒子会在垂直方向，一个接一个地放置；</li><li>盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；</li><li>每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；</li><li>BFC 的区域不会与 float 盒子重叠；</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算 BFC 的高度时，浮动元素也参与计算。</li></ul><p><strong>如何创建 BFC？</strong></p><ul><li>根元素：html</li><li>非溢出的可见元素：overflow 不为 visible</li><li>设置浮动：float 属性不为 none</li><li>设置定位：position 为 absolute 或 fixed</li><li>定义成块级的非块级元素：display: inline-block/table-cell/table-caption/flex/inline-flex/grid/inline-grid</li></ul><p><strong>BFC 应用场景</strong></p><p>1、 自适应两栏布局</p><p>应用原理：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css013.gif"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span>aside<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    &lt;!-- 触发 BFC --&gt;</span><br><span class="line">    <span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>;<span class="selector-tag">BFCoverflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、清除内部浮动</p><p>浮动造成的问题就是父元素高度坍塌，所以清除浮动需要解决的问题就是让父元素的高度恢复正常。而用 BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css014.png"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、 防止垂直 margin 合并</p><p>BFC 渲染原理之一：同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个 BFC 中即可阻止垂直 margin 合并。那如何让 2 个相邻的兄弟元素不在同一个 BFC 中呢？可以给其中一个元素外面包裹一层，然后触发其包裹层的 BFC，这样一来 2 个元素就不会在同一个 BFC 中了。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css015.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;contain-b&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo3</span> <span class="selector-class">.a</span>,</span><br><span class="line"><span class="selector-class">.demo3</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.contain-b</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上 3 个 示例 ，可以结合这个 <a href="https://codepen.io/bulandent/pen/eYBVpEm">BFC 应用示例</a> 配合观看更佳。</p><p>参考：<a href="https://yachen168.github.io/article/Formatting-context.html" title="CSS 原理 - Formatting Context">CSS 原理 - Formatting Context</a></p><h4 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h4><p>IFC 的形成条件非常简单，块级元素中仅包含内联级别元素，需要注意的是当 IFC 中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css020.png"></p><p><strong>IFC 渲染规则</strong></p><ul><li>子元素在水平方向上一个接一个排列，在垂直方向上将以容器顶部开始向下排列；</li><li>节点无法声明宽高，其中 margin 和 padding 在水平方向有效在垂直方向无效；</li><li>节点在垂直方向上以不同形式对齐；</li><li>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的线盒（line box）。线盒的宽度是由包含块（containing box）和与其中的浮动来决定；</li><li>IFC 中的 line box 一般左右边贴紧其包含块，但 float 元素会优先排列。</li><li>IFC 中的 line box 高度由 line-height 计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同；</li><li>当内联级盒子的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性值来决定；</li><li>当一个内联盒子超过父元素的宽度时，它会被分割成多盒子，这些盒子分布在多个 line box 中。如果子元素未设置强制换行的情况下，inline box 将不可被分割，将会溢出父元素。</li></ul><p>针对如上的 IFC 渲染规则，你是不是可以分析下下面这段代码的 IFC 环境是怎么样的呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>It can get <span class="tag">&lt;<span class="name">strong</span>&gt;</span>very complicated<span class="tag">&lt;/<span class="name">storng</span>&gt;</span> once you start looking into it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css017.gif"></p><p>对应上面这样一串 HTML 分析如下：</p><ul><li>p 标签是一个 block container，对内将产生一个 IFC；</li><li>由于一行没办法显示完全，所以产生了 2 个线盒（line box）；线盒的宽度就继承了 p 的宽度；高度是由里面的内联盒子的 line-height 决定；</li><li>It can get：匿名的内联盒子；</li><li>very complicated：strong 标签产生的内联盒子；</li><li>once you start：匿名的内联盒子；</li><li>looking into it.：匿名的内联盒子。</li></ul><p>参考：<a href="https://www.w3.org/TR/CSS2/visuren.html#inline-formatting" title="Inline formatting contexts">Inline formatting contexts</a></p><p><strong>IFC 应用场景</strong></p><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。</li><li>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中。</li></ul><p>偷个懒，demo 和图我就不做了。</p><h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p>在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴。众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开，而这其实就是层叠上下文所要描述的东西。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csszindex.png" alt="-w566"></p><p>我们对层叠上下文的第一印象可能要来源于 z-index，认为它的值越大，距离屏幕观察者就越近，那么层叠等级就越高，事实确实是这样的，但层叠上下文的内容远非仅仅如此：</p><ul><li>z-index 能够在层叠上下文中对元素的堆叠顺序其作用是必须配合定位才可以；</li><li>除了 z-index 之外，一个元素在 Z 轴上的显示顺序还受层叠等级和层叠顺序影响；</li></ul><p>在看层叠等级和层叠顺序之前，我们先来看下如何产生一个层叠上下文，特定的 HTML 元素或者 CSS 属性产生层叠上下文，MDN 中给出了这么一个列表，符合以下任一条件的元素都会产生层叠上下文：</p><ul><li>html 文档根元素</li><li>声明 position: absolute/relative 且 z-index 值不为 auto 的元素；</li><li>声明 position: fixed/sticky 的元素；</li><li>flex 容器的子元素，且 z-index 值不为 auto；</li><li>grid 容器的子元素，且 z-index 值不为 auto；</li><li>opacity 属性值小于 1 的元素；</li><li>mix-blend-mode 属性值不为 normal 的元素；</li><li>以下任意属性值不为 none 的元素：<ul><li>transform</li><li>filter</li><li>perspective</li><li>clip-path</li><li>mask / mask-image / mask-border</li></ul></li><li>isolation 属性值为 isolate 的元素；</li><li>-webkit-overflow-scrolling 属性值为 touch 的元素；</li><li>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；</li><li>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</li></ul><p><strong>层叠等级</strong></p><p>层叠等级指节点在三维空间 Z 轴上的上下顺序。它分两种情况：</p><ul><li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在 Z 轴上的上下顺序；</li><li>在其他普通元素中，它描述定义的是这些普通元素在 Z 轴上的上下顺序；</li></ul><p>普通节点的层叠等级优先由其所在的层叠上下文决定，层叠等级的比较只有在当前层叠上下文中才有意义，脱离当前层叠上下文的比较就变得无意义了。</p><p><strong>层叠顺序</strong></p><p>在同一个层叠上下文中如果有多个元素，那么他们之间的层叠顺序是怎么样的呢？</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css002.png"></p><p>以下这个列表越往下层叠优先级越高，视觉上的效果就是越容易被用户看到（不会被其他元素覆盖）：</p><ul><li>层叠上下文的 border 和 background</li><li>z-index &lt; 0 的子节点</li><li>标准流内块级非定位的子节点</li><li>浮动非定位的子节点</li><li>标准流内行内非定位的子节点</li><li>z-index: auto/0 的子节点</li><li>z-index &gt; 0 的子节点</li></ul><p><strong>如何比较两个元素的层叠等级？</strong></p><ul><li>在同一个层叠上下文中，比较两个元素就是按照上图的介绍的层叠顺序进行比较。</li><li>如果不在同一个层叠上下文中的时候，那就需要比较两个元素分别所处的层叠上下文的等级。</li><li>如果两个元素都在同一个层叠上下文，且层叠顺序相同，则在 HTML 中定义越后面的层叠等级越高。</li></ul><p>参考：<a href="https://juejin.cn/post/6844903667175260174" title="彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index">彻底搞懂 CSS 层叠上下文、层叠等级、层叠顺序、z-index</a></p><h3 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h3><p>CSS 的声明是由属性和值组成的，而值的类型有许多种：</p><ul><li>数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值；</li><li>百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的 font-size；</li><li>颜色：用于指定 background-color、color 等；</li><li>坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性；</li><li>函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等；</li></ul><p>而还有些值是需要带单位的，比如 width: 100px，这里的 px 就是表示长度的单位，长度单位除了 px 外，比较常用的还有 em、rem、vw/vh 等。那他们有什么区别呢？又应该在什么时候使用它们呢？</p><h4 id="px"><a href="#px" class="headerlink" title="px"></a>px</h4><p>屏幕分辨率是指在屏幕的横纵方向上的像素点数量，比如分辨率 1920×1080 意味着水平方向含有 1920 个像素数，垂直方向含有 1080 个像素数。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css004.png"></p><p>而 px 表示的是 CSS 中的像素，在 CSS 中它是绝对的长度单位，也是最基础的单位，其他长度单位会自动被浏览器换算成 px。但是对于设备而言，它其实又是相对的长度单位，比如宽高都为 2px，在正常的屏幕下，其实就是 4 个像素点，而在设备像素比(devicePixelRatio) 为 2 的 Retina 屏幕下，它就有 16 个像素点。所以屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。</p><p>讲到这里，还有一些相关的概念需要理清下：</p><p><strong>设备像素（Device pixels）</strong></p><p>设备屏幕的物理像素，表示的是屏幕的横纵有多少像素点；和屏幕分辨率是差不多的意思。</p><p><strong>设备像素比（DPR）</strong></p><p>设备像素比表示 1 个 CSS 像素等于几个物理像素。</p><p>计算公式：DPR = 物理像素数 / 逻辑像素数；</p><p>在浏览器中可以通过 window.devicePixelRatio 来获取当前屏幕的 DPR。</p><p><strong>像素密度（DPI/PPI）</strong></p><p>像素密度也叫显示密度或者屏幕密度，缩写为 DPI(Dots Per Inch) 或者 PPI(Pixel Per Inch)。从技术角度说，PPI 只存在于计算机显示领域，而 DPI 只出现于打印或印刷领域。</p><p>计算公式：像素密度 = 屏幕对角线的像素尺寸 / 物理尺寸</p><p>比如，对于分辨率为 750 * 1334 的 iPhone 6 来说，它的像素密度为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">750</span> * <span class="number">750</span> + <span class="number">1334</span> * <span class="number">1334</span>) / <span class="number">4.7</span> = <span class="number">326</span>ppi</span><br></pre></td></tr></table></figure><p><strong>设备独立像素（DIP）</strong></p><p>DIP 是特别针对 Android 设备而衍生出来的，原因是安卓屏幕的尺寸繁多，因此为了显示能尽量和设备无关，而提出的这个概念。它是基于屏幕密度而计算的，认为当屏幕密度是 160 的时候，px = DIP。</p><p>计算公式：dip = px * 160 / dpi</p><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>em 是 CSS 中的相对长度单位中的一个。居然是相对的，那它到底是相对的谁呢？它有 2 层意思：</p><ul><li>在 font-size 中使用是相对于<strong>父元素</strong>的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；</li><li>在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；</li></ul><p>我们都知道每个浏览器都会给 HTML 根元素 html 设置一个默认的 font-size，而这个值通常是 16px。这也就是为什么 1em = 16px 的原因所在了。</p><p>em 在计算的时候是会层层计算的，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于如上一个结构的 HTML，由于根元素 html 的字体大小是 16px，所以 p 标签最终计算出来后的字体大小会是 16 _ 2 _ 2 = 64px</p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem(root em) 和 em 一样，也是一个相对长度单位，不过 rem 相对的是 HTML 的根元素 html。</p><p>rem 由于是基于 html 的 font-size 来计算，所以通常用于自适应网站或者 H5 中。</p><p>比如在做 H5 的时候，前端通常会让 UI 给 750px 宽的设计图，而在开发的时候可以基于 iPhone X 的尺寸 375px * 812px 来写页面，这样一来的话，就可以用下面的 JS 依据当前页面的视口宽度自动计算出根元素 html 的基准 font-size 是多少。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> docEl = doc.documentElement,</span><br><span class="line">    resizeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>,</span><br><span class="line">    psdWidth = <span class="number">750</span>, <span class="comment">// 设计图宽度</span></span><br><span class="line">    recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> clientWidth = docEl.clientWidth</span><br><span class="line">      <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (clientWidth &gt;= <span class="number">640</span>) &#123;</span><br><span class="line">        docEl.style.fontSize = <span class="number">200</span> * (<span class="number">640</span> / psdWidth) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        docEl.style.fontSize = <span class="number">200</span> * (clientWidth / psdWidth) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 绑定事件的时候最好配合防抖函数</span></span><br><span class="line">  win.addEventListener(resizeEvt, debounce(recalc, <span class="number">1000</span>), <span class="literal">false</span>)</span><br><span class="line">  doc.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, recalc, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> context = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p>比如当视口是 375px 的时候，经过计算 html 的 font-size 会是 100px，这样有什么好处呢？好处就是方便写样式，比如从设计图量出来的 header 高度是 50px 的，那我们写样式的时候就可以直接写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css005.png"></p><p>每个从设计图量出来的尺寸只要除于 100 即可得到当前元素的 rem 值，都不用经过计算，非常方便。偷偷告诉你，如果你把上面那串计算 html 标签 font-size 的 JS 代码中的 200 替换成 2，那在计算 rem 的时候就不需要除于 100 了，从设计图量出多大 px，就直接写多少个 rem。</p><h4 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw/vh"></a>vw/vh</h4><p>vw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位：</p><ul><li>1vw = 视口宽度均分成 100 份中 1 份的长度；</li><li>1vh = 视口高度均分成 100 份中 1 份的长度；</li></ul><p>在 JS 中 100vw = window.innerWidth，100vh = window.innerHeight。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css006.jpg"></p><p>vw/vh 的出现使得多了一种写自适应布局的方案，开发者不再局限于 rem 了。</p><p>相对视口的单位，除了 vw/vh 外，还有 vmin 和 vmax：</p><ul><li>vmin：取 vw 和 vh 中值较小的；</li><li>vmax：取 vw 和 vh 中值较大的；</li></ul><h3 id="颜色体系"><a href="#颜色体系" class="headerlink" title="颜色体系"></a>颜色体系</h3><p>CSS 中用于表示颜色的值种类繁多，足够构成一个体系，所以这里就专门拿出一个小节来讲解它。</p><p>根据 <a href="https://drafts.csswg.org/css-color-3/" title="CSS 颜色草案">CSS 颜色草案</a> 中提到的颜色值类型，大概可以把它们分为这几类：</p><ul><li>颜色关键字</li><li>transparent 关键字</li><li>currentColor 关键字</li><li>RGB 颜色</li><li>HSL 颜色</li></ul><h4 id="颜色关键字"><a href="#颜色关键字" class="headerlink" title="颜色关键字"></a>颜色关键字</h4><p>颜色关键字（color keywords）是不区分大小写的标识符，它表示一个具体的颜色，比如 white（白），黑（black）等；</p><p>可接受的关键字列表在 CSS 的演变过程中发生了改变：</p><ul><li>CSS 标准 1 只接受 16 个基本颜色，称为 VGA 颜色，因为它们来源于 VGA 显卡所显示的颜色集合而被称为 VGA colors （视频图形阵列色彩）。</li><li>CSS 标准 2 增加了 orange 关键字。</li><li>从一开始，浏览器接受其它的颜色，由于一些早期浏览器是 X11 应用程序，这些颜色大多数是 X11 命名的颜色列表，虽然有一点不同。SVG 1.0 是首个正式定义这些关键字的标准；CSS 色彩标准 3 也正式定义了这些关键字。它们经常被称作扩展的颜色关键字， X11 颜色或 SVG 颜色 。</li><li>CSS 颜色标准 4 添加可 rebeccapurple 关键字来纪念 web 先锋 Eric Meyer。</li></ul><p>如下这张图是 16 个基础色，又叫 VGA 颜色。截止到目前为止 CSS 颜色关键字总共有 146 个，这里可以查看 <a href="https://codepen.io/bulandent/pen/gOLovwL" title="完整的色彩关键字列表">完整的色彩关键字列表</a>。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css007.png" alt="VGA 颜色"></p><p>需要注意的是如果声明的时候的颜色关键字是错误的，浏览器会忽略它。</p><h4 id="transparent-关键字"><a href="#transparent-关键字" class="headerlink" title="transparent 关键字"></a>transparent 关键字</h4><p>transparent 关键字表示一个完全透明的颜色，即该颜色看上去将是背景色。从技术上说，它是带有 alpha 通道为最小值的黑色，是 rgba(0,0,0,0) 的简写。</p><p>透明关键字有什么应用场景呢？</p><p><strong>实现三角形</strong></p><p>下面这个图是用 4 条边框填充的正方形，看懂了它你大概就知道该如何用 CSS 写三角形了。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css008.png"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border-top-color</span>: <span class="number">#ffc107</span>;</span><br><span class="line">  <span class="attribute">border-right-color</span>: <span class="number">#00bcd4</span>;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>: <span class="number">#e26b6b</span>;</span><br><span class="line">  <span class="attribute">border-left-color</span>: <span class="number">#cc7cda</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 transparent 实现三角形的原理：</p><ul><li>首先宽高必须是 0px，通过边框的粗细来填充内容；</li><li>那条边需要就要加上颜色，而不需要的边则用 transparent；</li><li>想要什么样姿势的三角形，完全由上下左右 4 条边的中有颜色的边和透明的边的位置决定；</li><li>等腰三角形：设置一条边有颜色，然后紧挨着的 2 边是透明，且宽度是有颜色边的一半；直角三角形：设置一条边有颜色，然后紧挨着的任何一边透明即可。</li></ul><p>看下示例：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css009.png"></p><p><strong>增大点击区域</strong></p><p>常常在移动端的时候点击的按钮的区域特别小，但是由于现实效果又不太好把它做大，所以常用的一个手段就是通过透明的边框来增大按钮的点击区域：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="currentColor-关键字"><a href="#currentColor-关键字" class="headerlink" title="currentColor 关键字"></a>currentColor 关键字</h4><p>currentColor 会取当前元素继承父级元素的文本颜色值或声明的文本颜色值，即 computed 后的 color 值。</p><p>比如，对于如下 CSS，该元素的边框颜色会是 red：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid currentColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RGB-A-颜色"><a href="#RGB-A-颜色" class="headerlink" title="RGB[A] 颜色"></a>RGB[A] 颜色</h4><p>RGB[A] 颜色是由 R(red)-G(green)-B(blue)-A(alpha) 组成的色彩空间。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css010.png"></p><p>在 CSS 中，它有两种表示形式：</p><ul><li>十六进制符号；</li><li>函数符；</li></ul><p><strong>十六进制符号</strong></p><p>RGB 中的每种颜色的值范围是 00~ff，值越大表示颜色越深。所以一个颜色正常是 6 个十六进制字符加上 # 组成，比如红色就是 #ff0000。</p><p>如果 RGB 颜色需要加上不透明度，那就需要加上 alpha 通道的值，它的范围也是 00~ff，比如一个带不透明度为 67% 的红色可以这样写 #ff0000aa。</p><p>使用十六进制符号表示颜色的时候，都是用 2 个十六进制表示一个颜色，如果这 2 个字符相同，还可以缩减成只写 1 个，比如，红色 #f00；带 67% 不透明度的红色 #f00a。</p><p><strong>函数符</strong></p><p>当 RGB 用函数表示的时候，每个值的范围是 0<del>255 或者 0%</del>100%，所以红色是 rgb(255, 0, 0)， 或者 rgb(100%, 0, 0)。</p><p>如果需要使用函数来表示带不透明度的颜色值，值的范围是 0<del>1 及其之间的小数或者 0%</del>100%，比如带 67% 不透明度的红色是 rgba(255, 0, 0, 0.67) 或者 rgba(100%, 0%, 0%, 67%)</p><blockquote><p>需要注意的是 RGB 这 3 个颜色值需要保持一致的写法，要嘛用数字要嘛用百分比，而不透明度的值的可以不用和 RGB 保持一致写法。比如 rgb(100%, 0, 0) 这个写法是无效的；而 rgb(100%, 0%, 0%, 0.67) 是有效的。</p></blockquote><p>在第 4 代 CSS 颜色标准中，新增了一种新的函数写法，即可以把 RGB 中值的分隔逗号改成空格，而把 RGB 和 alpha 中的逗号改成 /，比如带 67% 不透明度的红色可以这样写 rgba(255 0 0 / 0.67)。另外还把 rgba 的写法合并到 rgb 函数中了，即 rgb 可以直接写带不透明度的颜色。</p><h4 id="HSL-A-颜色"><a href="#HSL-A-颜色" class="headerlink" title="HSL[A] 颜色"></a>HSL[A] 颜色</h4><p>HSL[A] 颜色是由色相(hue)-饱和度(saturation)-亮度(lightness)-不透明度组成的颜色体系。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css011.png"></p><ul><li>色相（H）是色彩的基本属性，值范围是 0<del>360 或者 0deg</del>360deg， 0 (或 360) 为红色, 120 为绿色, 240 为蓝色；</li><li>饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0~100% 的数值；0% 为灰色， 100% 全色；</li><li>亮度（L），取 0~100%，0% 为暗，100% 为白；</li><li>不透明度（A），取 0<del>100%，或者 0</del>1 及之间的小数；</li></ul><p>写法上可以参考 RGB 的写法，只是参数的值不一样。</p><p>给一个按钮设置不透明度为 67% 的红色的 color 的写法，以下全部写法效果一致：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000aa</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f00a</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.67</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">100%</span> <span class="number">0%</span> <span class="number">0%</span> / <span class="number">67%</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">100%</span>, <span class="number">50%</span>, <span class="number">67%</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">hsl</span>(<span class="number">0deg</span> <span class="number">100%</span> <span class="number">50%</span> / <span class="number">67%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小提示：在 Chrome DevTools 中可以按住 shift + 鼠标左键可以切换颜色的表示方式。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css012.gif"></p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询是指针对不同的设备、特定的设备特征或者参数进行定制化的修改网站的样式。</p><p>你可以通过给 <code>&lt;link&gt;</code> 加上 media 属性来指定该样式文件只能对什么设备生效，不指定的话默认是 all，即对所有设备都生效：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>都支持哪些设备类型？</p><ul><li>all：适用于所有设备；</li><li>print：适用于在打印预览模式下在屏幕上查看的分页材料和文档；</li><li>screen：主要用于屏幕；</li><li>speech：主要用于语音合成器。</li></ul><blockquote><p>需要注意的是：通过 media 指定的 <link> 资源尽管不匹配它的设备类型，但是浏览器依然会加载它。</p></blockquote><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css021.png"></p><p>除了通过 <code>&lt;link&gt;</code> 让指定设备生效外，还可以通过 <code>@media</code> 让 CSS 规则在特定的条件下才能生效。响应式页面就是使用了 @media 才让一个页面能够同时适配 PC、Pad 和手机端。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">1000px</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>媒体查询支持逻辑操作符：</p><ul><li>and：查询条件都满足的时候才生效；</li><li>not：查询条件取反；</li><li>only：整个查询匹配的时候才生效，常用语兼容旧浏览器，使用时候必须指定媒体类型；</li><li>逗号或者 or：查询条件满足一项即可匹配；</li></ul><p>媒体查询还支持<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#%E5%AA%92%E4%BD%93%E7%89%B9%E6%80%A7" title="众多的媒体特性">众多的媒体特性</a>，使得它可以写出很复杂的查询条件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用户设备的最小高度为680px或为纵向模式的屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-height:</span> <span class="number">680px</span>), screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> portrait) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见需求"><a href="#常见需求" class="headerlink" title="常见需求"></a>常见需求</h2><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>之前我们通常是在预处理器里才可以使用变量，而现在 CSS 里也支持了变量的用法。通过自定义属性就可以在想要使用的地方引用它。</p><p>自定义属性也和普通属性一样具有级联性，申明在 :root 下的时候，在全文档范围内可用，而如果是在某个元素下申明自定义属性，则只能在它及它的子元素下才可以使用。</p><p>自定义属性必须通过 <code>--x</code> 的格式申明，比如：–theme-color: red; 使用自定义属性的时候，需要用 var 函数。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span> 定义自定义属性 <span class="selector-tag">--</span> &gt; <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--theme-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!<span class="selector-tag">--</span> 使用变量 <span class="selector-tag">--</span> &gt; <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--theme-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css024.png"></p><p>上图这个是使用 CSS 自定义属性配合 JS 实现的动态调整元素的 box-shadow，具体可以看这个 <a href="https://codepen.io/bulandent/pen/GVjxLJ">codepen demo</a>。</p><h3 id="1px-边框解决方案"><a href="#1px-边框解决方案" class="headerlink" title="1px 边框解决方案"></a>1px 边框解决方案</h3><p>Retina 显示屏比普通的屏幕有着更高的分辨率，所以在移动端的 1px 边框就会看起来比较粗，为了美观通常需要把这个线条细化处理。这里有篇文章列举了 7 种方案可以参考一下：<a href="https://www.jianshu.com/p/7e63f5a32636" title="7种方法解决移动端Retina屏幕1px边框问题">7 种方法解决移动端 Retina 屏幕 1px 边框问题</a></p><p>而这里附上最后一种通过伪类和 transform 实现的相对完美的解决方案：</p><p>只设置单条底部边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale-1px-bottom</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale-1px-bottom</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时设置 4 条边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale-1px</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: left top;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>什么是浮动：浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。</p><p>为什么要清楚浮动，它造成了什么问题？</p><p>因为浮动元素会脱离正常的文档流，并不会占据文档流的位置，所以如果一个父元素下面都是浮动元素，那么这个父元素就无法被浮动元素所撑开，这样一来父元素就丢失了高度，这就是所谓的浮动造成的父元素高度坍塌问题。</p><p>父元素高度一旦坍塌将对后面的元素布局造成影响，为了解决这个问题，所以需要清除浮动，让父元素恢复高度，那该如何做呢？</p><p>这里介绍两种方法：通过 BFC 来清除、通过 clear 来清除。</p><h4 id="BFC-清除浮动"><a href="#BFC-清除浮动" class="headerlink" title="BFC 清除浮动"></a>BFC 清除浮动</h4><p>前面介绍 BFC 的时候提到过，计算 BFC 高度的时候浮动子元素的高度也将计算在内，利用这条规则就可以清楚浮动。</p><p>假设一个父元素 parent 内部只有 2 个子元素 child，且它们都是左浮动的，这个时候 parent 如果没有设置高度的话，因为浮动造成了高度坍塌，所以 parent 的高度会是 0，此时只要给 parent 创造一个 BFC，那它的高度就能恢复了。</p><p>而产生 BFC 的方式很多，我们可以给父元素设置 overflow: auto 来简单的实现 BFC 清除浮动，但是为了兼容 IE 最好用 overflow: hidden。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 overflow: hidden 来清除浮动并不完美，当元素有阴影或存在下拉菜单的时候会被截断，所以该方法使用比较局限。</p><h4 id="通过-clear-清除浮动"><a href="#通过-clear-清除浮动" class="headerlink" title="通过 clear 清除浮动"></a>通过 clear 清除浮动</h4><p>我先把结论贴出来：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的核心原理就是通过 ::after 伪元素为在父元素的最后一个子元素后面生成一个内容为空的块级元素，然后通过 clear 将这个伪元素移动到所有它之前的浮动元素的后面，画个图来理解一下。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css003.png"></p><p>可以结合这个 <a href="https://codepen.io/bulandent/pen/LYbOvOa">codepen demo</a> 一起理解上图的 clear 清楚浮动原理。</p><p>上面这个 demo 或者图里为了展示需要所以给伪元素的内容设置为了 ::after，实际使用的时候需要设置为空字符串，让它的高度为 0，从而父元素的高度都是由实际的子元素撑开。</p><p>该方式基本上是现在人人都在用的清除浮动的方案，非常通用。</p><p>参考：<a href="https://www.jianshu.com/p/09bd5873bed4" title="CSS中的浮动和清除浮动，梳理一下">CSS 中的浮动和清除浮动，梳理一下</a></p><h3 id="消除浏览器默认样式"><a href="#消除浏览器默认样式" class="headerlink" title="消除浏览器默认样式"></a>消除浏览器默认样式</h3><p>针对同一个类型的 HTML 标签，不同的浏览器往往有不同的表现，所以在网站制作的时候，开发者通常都是需要将这些浏览器的默认样式清除，让网页在不同的浏览器上能够保持一致。</p><p>针对清除浏览器默认样式这件事，在很早之前 CSS 大师 Eric A. Meyer 就干过。它就是写一堆通用的样式用来重置浏览器默认样式，这些样式通常会放到一个命名为 reset.css 文件中。比如大师的 <a href="https://meyerweb.com/eric/tools/css/reset/" title="reset.css">reset.css</a> 是这么写的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-tag">span</span>,</span><br><span class="line"><span class="selector-tag">applet</span>,</span><br><span class="line"><span class="selector-tag">object</span>,</span><br><span class="line"><span class="selector-tag">iframe</span>,</span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span>,</span><br><span class="line"><span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-tag">blockquote</span>,</span><br><span class="line"><span class="selector-tag">pre</span>,</span><br><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">abbr</span>,</span><br><span class="line"><span class="selector-tag">acronym</span>,</span><br><span class="line"><span class="selector-tag">address</span>,</span><br><span class="line"><span class="selector-tag">big</span>,</span><br><span class="line"><span class="selector-tag">cite</span>,</span><br><span class="line"><span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">del</span>,</span><br><span class="line"><span class="selector-tag">dfn</span>,</span><br><span class="line"><span class="selector-tag">em</span>,</span><br><span class="line"><span class="selector-tag">img</span>,</span><br><span class="line"><span class="selector-tag">ins</span>,</span><br><span class="line"><span class="selector-tag">kbd</span>,</span><br><span class="line"><span class="selector-tag">q</span>,</span><br><span class="line"><span class="selector-tag">s</span>,</span><br><span class="line"><span class="selector-tag">samp</span>,</span><br><span class="line"><span class="selector-tag">small</span>,</span><br><span class="line"><span class="selector-tag">strike</span>,</span><br><span class="line"><span class="selector-tag">strong</span>,</span><br><span class="line"><span class="selector-tag">sub</span>,</span><br><span class="line"><span class="selector-tag">sup</span>,</span><br><span class="line"><span class="selector-tag">tt</span>,</span><br><span class="line"><span class="selector-tag">var</span>,</span><br><span class="line"><span class="selector-tag">b</span>,</span><br><span class="line"><span class="selector-tag">u</span>,</span><br><span class="line"><span class="selector-tag">i</span>,</span><br><span class="line"><span class="selector-tag">center</span>,</span><br><span class="line"><span class="selector-tag">dl</span>,</span><br><span class="line"><span class="selector-tag">dt</span>,</span><br><span class="line"><span class="selector-tag">dd</span>,</span><br><span class="line"><span class="selector-tag">ol</span>,</span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">li</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span>,</span><br><span class="line"><span class="selector-tag">form</span>,</span><br><span class="line"><span class="selector-tag">label</span>,</span><br><span class="line"><span class="selector-tag">legend</span>,</span><br><span class="line"><span class="selector-tag">table</span>,</span><br><span class="line"><span class="selector-tag">caption</span>,</span><br><span class="line"><span class="selector-tag">tbody</span>,</span><br><span class="line"><span class="selector-tag">tfoot</span>,</span><br><span class="line"><span class="selector-tag">thead</span>,</span><br><span class="line"><span class="selector-tag">tr</span>,</span><br><span class="line"><span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-tag">td</span>,</span><br><span class="line"><span class="selector-tag">article</span>,</span><br><span class="line"><span class="selector-tag">aside</span>,</span><br><span class="line"><span class="selector-tag">canvas</span>,</span><br><span class="line"><span class="selector-tag">details</span>,</span><br><span class="line"><span class="selector-tag">embed</span>,</span><br><span class="line"><span class="selector-tag">figure</span>,</span><br><span class="line"><span class="selector-tag">figcaption</span>,</span><br><span class="line"><span class="selector-tag">footer</span>,</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">hgroup</span>,</span><br><span class="line"><span class="selector-tag">menu</span>,</span><br><span class="line"><span class="selector-tag">nav</span>,</span><br><span class="line"><span class="selector-tag">output</span>,</span><br><span class="line"><span class="selector-tag">ruby</span>,</span><br><span class="line"><span class="selector-tag">section</span>,</span><br><span class="line"><span class="selector-tag">summary</span>,</span><br><span class="line"><span class="selector-tag">time</span>,</span><br><span class="line"><span class="selector-tag">mark</span>,</span><br><span class="line"><span class="selector-tag">audio</span>,</span><br><span class="line"><span class="selector-tag">video</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font</span>: inherit;</span><br><span class="line">  <span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* HTML5 display-role reset for older browsers */</span></span><br><span class="line"><span class="selector-tag">article</span>,</span><br><span class="line"><span class="selector-tag">aside</span>,</span><br><span class="line"><span class="selector-tag">details</span>,</span><br><span class="line"><span class="selector-tag">figcaption</span>,</span><br><span class="line"><span class="selector-tag">figure</span>,</span><br><span class="line"><span class="selector-tag">footer</span>,</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">hgroup</span>,</span><br><span class="line"><span class="selector-tag">menu</span>,</span><br><span class="line"><span class="selector-tag">nav</span>,</span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ol</span>,</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span>,</span><br><span class="line"><span class="selector-tag">q</span> &#123;</span><br><span class="line">  <span class="attribute">quotes</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-pseudo">:after</span>,</span><br><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">content</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">  <span class="attribute">border-spacing</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他的这份 reset.css 据说是被使用最广泛的重设样式的方案了。</p><p>除了 reset.css 外，后来又出现了 <a href="https://github.com/necolas/normalize.css" title="Normalize.css">Normalize.css</a> 。关于 Normalize.css, 其作者 necolas 专门写了一篇文章介绍了它，并谈到了它和 reset.css 的区别。这个是他写那篇文章的翻译版：<a href="https://jerryzou.com/posts/aboutNormalizeCss/" title="让我们谈一谈 Normalize.css">让我们谈一谈 Normalize.css</a>。</p><p>文章介绍到：Normalize.css 只是一个很小的 CSS 文件，但它在默认的 HTML 元素样式上提供了跨浏览器的高度一致性。相比于传统的 CSS reset，Normalize.css 是一种现代的、为 HTML5 准备的优质替代方案，现在已经有很多知名的框架和网站在使用它了。</p><p>Normalize.css 的具体样式可以看这里 <a href="https://necolas.github.io/normalize.css/latest/normalize.css">Normalize.css</a></p><p>区别于 reset.css，Normalize.css 有如下特点：</p><ul><li>reset.css 几乎为所有标签都设置了默认样式，而 Normalize.css 则是有选择性的保护了部分有价值的默认值；</li><li>修复了很多浏览器的 bug，而这是 reset.css 没做到的；</li><li>不会让你的调试工具变的杂乱，相反 reset.css 由于设置了很多默认值，所以在浏览器调试工具中往往会看到一大堆的继承样式，显得很杂乱；</li><li>Normalize.css 是模块化的，所以可以选择性的去掉永远不会用到的部分，比如表单的一般化；</li><li>Normalize.css 有详细的说明文档；</li></ul><h3 id="长文本处理"><a href="#长文本处理" class="headerlink" title="长文本处理"></a>长文本处理</h3><p><strong>默认：字符太长溢出了容器</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext01.png"></p><p><strong>字符超出部分换行</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext02.png"></p><p><strong>字符超出位置使用连字符</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext03.png"></p><p><strong>单行文本超出省略</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext04.png"></p><p><strong>多行文本超出省略</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext05.png"></p><p>查看以上这些方案的示例： <a href="https://codepen.io/bulandent/pen/abBrNby">codepen demo</a></p><p>有意思的是刚好前两天看到 chokcoco 针对文本溢出也写了一篇文章，主要突出的是对整块的文本溢出处理。啥叫整块文本？比如，下面这种技术标签就是属于整块文本：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csslongtext06.png"></p><p>另外他还对 iOS/Safari 做了兼容处理，感兴趣的可以去阅读下：<a href="https://juejin.cn/post/6938583040469762055" title="CSS 整块文本溢出省略特性探究">CSS 整块文本溢出省略特性探究</a>。</p><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>让元素在父元素中呈现出水平垂直居中的形态，无非就 3 种情况：</p><ul><li>单行的文本、inline 或者 inline-block 元素；</li><li>固定宽高的块级盒子；</li><li>不固定宽高的块级盒子；</li></ul><p>以下列到的所有水平垂直居中方案这里写了个 <a href="https://codepen.io/bulandent/pen/ymaKoM">codepen demo</a>，配合示例阅读效果更佳。</p><h4 id="单行的文本、inline-或-inline-block-元素"><a href="#单行的文本、inline-或-inline-block-元素" class="headerlink" title="单行的文本、inline 或 inline-block 元素"></a>单行的文本、inline 或 inline-block 元素</h4><p><strong>水平居中</strong></p><p>此类元素需要水平居中，则父级元素必须是块级元素(<code>block level</code>)，且父级元素上需要这样设置样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>垂直居中</strong></p><p>方法一：通过设置上下内间距一致达到垂直居中的效果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.single-line</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：通过设置 <code>height</code> 和 <code>line-height</code> 一致达到垂直居中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.single-line</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="固定宽高的块级盒子"><a href="#固定宽高的块级盒子" class="headerlink" title="固定宽高的块级盒子"></a>固定宽高的块级盒子</h4><p><strong>方法一：absolute + 负 margin</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter01.png"></p><p><strong>方法二：absolute + margin auto</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter02.png"></p><p><strong>方法三：absolute + calc</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter03.png"></p><h4 id="不固定宽高的块级盒子"><a href="#不固定宽高的块级盒子" class="headerlink" title="不固定宽高的块级盒子"></a>不固定宽高的块级盒子</h4><p>这里列了 6 种方法，参考了<a href="https://segmentfault.com/a/1190000016389031">颜海镜</a> 写的文章 ，其中的两种 line-height 和 writing-mode 方案看后让我惊呼：还有这种操作？学到了学到了。</p><p><strong>方法一：absolute + transform</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter04.png"></p><p><strong>方法二：line-height + vertical-align</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter05.png"></p><p><strong>方法三：writing-mode</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter06.png"></p><p><strong>方法四：table-cell</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter07.png"></p><p><strong>方法五：flex</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter08.png"></p><p><strong>方法六：grid</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csscenter09.png"></p><h3 id="常用布局"><a href="#常用布局" class="headerlink" title="常用布局"></a>常用布局</h3><h4 id="两栏布局（边栏定宽主栏自适应）"><a href="#两栏布局（边栏定宽主栏自适应）" class="headerlink" title="两栏布局（边栏定宽主栏自适应）"></a>两栏布局（边栏定宽主栏自适应）</h4><p>针对以下这些方案写了几个示例： <a href="https://codepen.io/bulandent/pen/JjbqxbM">codepen demo</a></p><p><strong>方法一：float + overflow（BFC 原理）</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css2layout01.png"></p><p><strong>方法二：float + margin</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css2layout02.png"></p><p><strong>方法三：flex</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css2layout03.png"></p><p><strong>方法四：grid</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css2layout04.png"></p><h4 id="三栏布局（两侧栏定宽主栏自适应）"><a href="#三栏布局（两侧栏定宽主栏自适应）" class="headerlink" title="三栏布局（两侧栏定宽主栏自适应）"></a>三栏布局（两侧栏定宽主栏自适应）</h4><p>针对以下这些方案写了几个示例： <a href="https://codepen.io/bulandent/pen/abBrXrj">codepen demo</a></p><p><strong>方法一：圣杯布局</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3layout01.png"></p><p><strong>方法二：双飞翼布局</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3layout02.png"></p><p><strong>方法三：float + overflow（BFC 原理）</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3layout03.png"></p><p><strong>方法四：flex</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3layout04.png"></p><p><strong>方法五：grid</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3layout05.png"></p><h4 id="多列等高布局"><a href="#多列等高布局" class="headerlink" title="多列等高布局"></a>多列等高布局</h4><p>结合示例阅读更佳：<a href="https://codepen.io/bulandent/pen/jOVogdj">codepen demo</a></p><p><strong>方法一：padding + 负 margin</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csssameheight01.png"></p><p><strong>方法二：设置父级背景图片</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/csssameheight02.png"></p><h4 id="三行布局（头尾定高主栏自适应）"><a href="#三行布局（头尾定高主栏自适应）" class="headerlink" title="三行布局（头尾定高主栏自适应）"></a>三行布局（头尾定高主栏自适应）</h4><p>列了 4 种方法，都是基于如下的 HTML 和 CSS 的，结合示例阅读效果更佳：<a href="https://codepen.io/bulandent/pen/yLVdpvr">codepen demo</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-class">.layout</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法一：calc</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3row01.png"></p><p><strong>方法二：absolute</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3row02.png"></p><p><strong>方法三：flex</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3row03.png"></p><p><strong>方法四：grid</strong></p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/css3row04.png"></p><h2 id="结了个尾"><a href="#结了个尾" class="headerlink" title="结了个尾"></a>结了个尾</h2><p>这是我断断续续写了 2 周完成的文章，算是自己对 CSS 的一个总结，虽然写得很长，但不足以覆盖所有 CSS 的知识，比如动画和一些 CSS3 的新特性就完全没涉及，因为这要写下来估计得有大几万字（其实就是懒 😝 ）。</p><p>码字作图不易，如果喜欢或者对你有丝毫帮助的话，帮忙点个 👍 哈，点赞就是我的动力。同时也希望自己能坚持认真的写下去，因为在总结提升自己的同时如果也能帮助更多的前端 er，那将会让我感觉很开心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章围绕了 CSS 的核心知识点和项目中常见的需求来展开。虽然行文偏长，但偏基础，适合初级中级前端阅读，阅读的时候请适当跳过已经掌握的部分。&lt;/p&gt;
&lt;p&gt;这篇文章断断续续写了比较久，也参考了许多优秀的文章，但或许文章里还是存在不好或不对的地方，请多多指教，可以评论里直接提出来哈。&lt;/p&gt;
&lt;p&gt;小 tip：后续内容更精彩哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202103/cssxm.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://bubuzou.com/categories/css/"/>
    
    
      <category term="css" scheme="https://bubuzou.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>为你的网站加上 WebP 格式的图片吧</title>
    <link href="https://bubuzou.com/2021/01/23/webp/"/>
    <id>https://bubuzou.com/2021/01/23/webp/</id>
    <published>2021-01-23T01:49:25.000Z</published>
    <updated>2021-09-06T09:58:29.176Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一篇文章：<a href="https://github.com/Bulandent/blog/issues/17">jpg、gif、png 和 svg 用于 web 上，我们该如何选择最合适的图像格式</a>，介绍了这几种图片格式的特点，以及如何为网站选择合适的图片，然后评论区有位大佬让我补充下 WebP 格式，于是乎它来了。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp006.png"></p><h2 id="什么是-WebP-格式"><a href="#什么是-WebP-格式" class="headerlink" title="什么是 WebP 格式"></a>什么是 WebP 格式</h2><p>WebP 是一种现代图像格式，可为 Web 上的图像提供出色的无损和有损压缩。 使用 WebP，网站管理员和 Web 开发人员可以创建更小，更丰富的图像，从而使 Web 更快。</p><p>与 PNG 相比，WebP 无损图像的尺寸要小 26％。 在同等的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。</p><p>无损 WebP 支持透明性（也称为 Alpha 通道），而仅增加了 22％ 的字节数。 对于可以接受有损 RGB 压缩的情况，有损 WebP 还支持透明性，与 PNG 相比，文件大小通常小 3 倍。</p><blockquote><p>上面这 3 段话来源于 <a href="https://developers.google.com/speed/webp">https://developers.google.com/speed/webp</a></p></blockquote><a id="more"></a><h2 id="为什么你需要这个格式"><a href="#为什么你需要这个格式" class="headerlink" title="为什么你需要这个格式"></a>为什么你需要这个格式</h2><p>因为 WebP 图像比 JPEG 和 PNG 图像小-通常文件大小减少 25-35％。这样可以减小页面大小并提高性能。举 2 个例子：</p><ul><li>YouTube 发现，切换到 WebP 缩略图可将页面加载速度提高 10％。</li><li>当他们切换到使用 WebP 时，Facebook 节省了 25-35％ 的 JPEG 文件大小，节省了 80％ 的 PNG 文件大小。</li></ul><p>WebP 是 JPEG，PNG 和 GIF 图像的理想替代品。 另外，WebP 提供无损压缩和有损压缩。 在无损压缩中，不会丢失任何数据。 有损压缩会减小文件大小，但会以降低图像质量为代价。</p><h2 id="如何将图片转成-WebP-格式"><a href="#如何将图片转成-WebP-格式" class="headerlink" title="如何将图片转成 WebP 格式"></a>如何将图片转成 WebP 格式</h2><p>通常，开发者会用如下两种方式来将图片转成 WebP 格式：</p><ul><li><a href="https://developers.google.com/speed/webp/docs/using">cwebp</a> 命令行工具</li><li><a href="https://github.com/imagemin/imagemin-webp">Imagemin WebP</a> 插件（npm 包）</li></ul><p>如果你的项目比较简单或者你仅需要将图片转化一次，那么 <code>cwebp</code> 命令行工具是一个很好的选择；而如果你使用构建工具比如 <code>Webpack</code> 或 <code>Gulp</code> 等去构建你的项目的时候，那么将图片转 <code>WebP</code> 使用 <code>Imagemin WebP</code> 插件就是你最好的选择了。</p><p>当你需要把图片转成 <code>WebP</code> 格式的时候，你可以设置很多的参数，但是你最需要关心的就仅仅只是压缩质量，你可以指定一个压缩的质量等级，它的范围是从 0 ~ 100，0 表示质量最差，100 是最好。那么该把它设置成多少才最合适呢？这就需要你好好的花费一翻功夫去实践到底哪个质量等级是既兼顾了呈现质量又不会使得文件太大呢？</p><h3 id="使用-cwebp-转换图片"><a href="#使用-cwebp-转换图片" class="headerlink" title="使用 cwebp 转换图片"></a>使用 cwebp 转换图片</h3><p>使用这个命令前需要先安装它的工具包 webp，按照如下几个步骤操作即可：</p><ul><li><p>可以<a href="https://storage.googleapis.com/downloads.webmproject.org/releases/webp/index.html">去这下载 webp 工具包</a> ，这个网站提供了很多版本的包，选择一个和电脑匹配的包，比如我是 Mac 系统，我下载的是 <code>libwebp-1.1.0-rc2-mac-10.15</code> 版本的包，下载完成后解压，然后把解压后的文件夹放到你想要存放的目录，我是把他放到了 <code>/Applications/Utilities/</code> 下；</p></li><li><p>设置环境变量，使得命令可以在终端下使用。而我是直接修改当前用户下的 <code>.bash_profile</code> 文件，该文件目录：<code>/Users/ccp/.bash_profile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;$PATH:&#x2F;Applications&#x2F;Utilities&#x2F;libwebp-1.1.0-rc2-mac-10.15&#x2F;bin</span><br></pre></td></tr></table></figure><p>修改完成后，需要让命令立即生效的话，需要在终端下运行：<code>source .bash_profile</code></p></li><li><p>然后就可以在终端下输入 <code>cwebp</code>，如果它能提示你如何使用该命令，说明这个包安装好了，可以正常使用 cwebp 命令了。</p></li><li><p>阅读 libwebp 包的下的 READMD，可以发现，该包除了有 cwebp 命令外，还提供了很多额外的命令，具体用法可以自行查阅相关文档。</p></li></ul><p>除了以上这种操作稍微麻烦的安装方式外，还可以使用 OS X 的包管理工具进行安装（你怎么不早说 😭）：</p><ul><li><a href="https://formulae.brew.sh/formula/webp">Homebrew WebP package</a></li><li><a href="https://www.macports.org/ports.php?by=library&substr=webp">Macports WebP package</a></li></ul><p>安装成功后，就可以愉快的使用 cwebp 命令了。来看看以下操作：</p><p>使用 cwebp 的默认压缩设置转换单张图片（默认是有损压缩，且默认的压缩的质量参数是 75）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cwebp images&#x2F;flower.jpg -o images&#x2F;flower.webp</span><br></pre></td></tr></table></figure><p>使用 50 质量等级去转换单张图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cwebp -q 50 images&#x2F;flower.jpg -o images&#x2F;flower.webp</span><br></pre></td></tr></table></figure><p>转换指定目录下的所有文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for file in images&#x2F;*; do cwebp &quot;$file&quot; -o &quot;$&#123;file%.*&#125;.webp&quot;; done</span><br></pre></td></tr></table></figure><h3 id="使用-Imagemin-转换图片"><a href="#使用-Imagemin-转换图片" class="headerlink" title="使用 Imagemin 转换图片"></a>使用 Imagemin 转换图片</h3><p>Imagemin Webp 插件可以在 Node 环境中独立使用，也可以结合 Webpack 等构建工具使用。通常只需要 10 行左右代码即可配置完成。</p><p>Node 环境下配置，以下代码会把 images 目录下的图片转成 WebP 图片后存到 compressed_images 目录下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imagemin = <span class="built_in">require</span>(<span class="string">&#x27;imagemin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> imageminWebp = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-webp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">imagemin([<span class="string">&#x27;images/*&#x27;</span>], &#123;</span><br><span class="line">  destination: <span class="string">&#x27;compressed_images&#x27;</span>,</span><br><span class="line">  plugins: [imageminWebp(&#123; <span class="attr">quality</span>: <span class="number">50</span> &#125;)],</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Done!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在构建工具 Webpack 下使用，这里还配合了 <code>copy-webpack-plugin</code> 插件实现图片的复制。以下代码来源于 <a href="https://glitch.com/edit/#!/webp-webpack">webp-webpack</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2018 Google LLC.</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ImageminWebP = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-webp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ImageminPlugin = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-webpack-plugin&#x27;</span>).default</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">from</span>: <span class="string">&#x27;./images/**/**&#x27;</span>,</span><br><span class="line">        to: <span class="string">&#x27;./images/[name].webp&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]),</span><br><span class="line">    <span class="keyword">new</span> ImageminPlugin(&#123;</span><br><span class="line">      <span class="comment">// imagemin-webp docs: https://github.com/imagemin/imagemin-webp</span></span><br><span class="line">      plugins: [ImageminWebP(&#123; <span class="attr">quality</span>: <span class="number">50</span> &#125;)],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以尝试使用 <a href="https://www.npmjs.com/package/imagemin-webp-webpack-plugin">imagemin-webp-webpack-plugin</a> 这个插件，因为我看它最近 4 个月内有过更新，下载量也快 10K 了，应该可以满足需求。</p><h2 id="对比-WebP-和-其他图片格式"><a href="#对比-WebP-和-其他图片格式" class="headerlink" title="对比 WebP 和 其他图片格式"></a>对比 WebP 和 其他图片格式</h2><p>下面我用 PS 做了一张图片：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp001.png"></p><p>然后用它导出了 4 张图片，它们的信息如下：</p><ul><li><code>jpg_60.jpg</code>：质量为 60 的 JPG 格式图片，48KB；</li><li><code>jpg_100.jpg</code>：质量为 100 的 JPG 格式图片，142KB；</li><li><code>png_8.png</code>：8 位的 PNG 格式图片，60KB；</li><li><code>png_24.png</code>：24 位的 PNG 格式图片，200KB；</li></ul><p>然后我用如下命令，批量将他们转成了 WebP 格式的图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for file in Downloads&#x2F;img&#x2F;*; do cwebp &quot;$file&quot; -o &quot;$&#123;file%.*&#125;.webp&quot;; done</span><br></pre></td></tr></table></figure><p>然后可以看到 <code>Downloads/img/</code> 文件夹下所有文件的信息如下：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp002.png"></p><p>发现这 4 张图片被转成 WebP 格式的图片后文件大小居然都差不多大，大概都是 22KB，比原来真的小了太多了，尤其是 PNG 24 和 JPG 质量 100 的图片体积缩减更加明显。<strong>而最差的 JPG 质量 60 的图片再被转成 WebP 格式后，体积竟然还缩减了 54% 左右</strong>。</p><p>接下来我们再把这 4 张图片通过在线工具 <a href="https://tinypng.com/">TinyPNG</a> 压缩一下，以下是文件压缩后的信息（左右两列绿色数字分别表示：文件压缩前大小和压缩后大小）：</p><p><img src="../webp_003.png"></p><p>发现 TinyPNG 对 PNG 24 和 JPG 质量 100 的图片压缩效果比较明显。**另外将这压缩过的 4 张图片和 WebP 格式的图片（22KB）相比，发现 WebP 图片的文件大小还是明显小很多，小了超过 50%**，所以这就是为什么建议在 Web 应用上使用 WebP 图片的原因，真的优化太大了。</p><h2 id="让-WebP-图片在-Mac-下正常预览"><a href="#让-WebP-图片在-Mac-下正常预览" class="headerlink" title="让 WebP 图片在 Mac 下正常预览"></a>让 WebP 图片在 Mac 下正常预览</h2><p>从这往上翻的第二张图，可以发现 WebP 格式的图片在 Mac 下是无法正常预览的，所以需要给 Mac 加上这种能力。另外需要说一句 WebP 图片在 Chrome 下可以很好的支持了，直接将图片拖到浏览器中即可显示。</p><p>说到预览，看一下 WebP 在各浏览器下的兼容程度：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp005.png"></p><p>由上图可以看出，基本上现代浏览器已经能很好的支持 WebP 图片了，所以在生产环境上使用它是一点问题都没有。</p><p>Mac 需要正常预览 WebP 图片，可以在这里 <a href="https://github.com/Nyx0uf/qlImageSize">qlImageSize</a> 下载了 2 个插件来支持它：</p><ul><li><code>qlImageSize</code>：<code>QuickLook</code> 插件，用来预览 WebP 图片，且能在标题栏里显示尺寸、文件大小等信息，另外还可以让 WebP 图片在访达中以缩略图的形式显示出来。</li><li><code>mdImageSize</code>：<code>Spotlight</code> 插件，用来在显示简介的时候能够支持 WebP 图片的信息；</li></ul><p>下载完这 2 个插件包后，解压，然后把插件复制到对应的目录下保存：</p><ul><li><code>qlImageSize</code> 复制到 <code>/Library/QuickLook</code> 目录下；</li><li><code>mdImageSize</code> 复制到 <code>/Library/Spotlight</code> 目录下；</li></ul><p>这个时候 WebP 图片应该就能快速预览了，还不行的话就重启下访达进程（按住 option，同时鼠标右键点击访达，选择重新开启）。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp004.png"></p><h2 id="兼容不同浏览器"><a href="#兼容不同浏览器" class="headerlink" title="兼容不同浏览器"></a>兼容不同浏览器</h2><p>如果你的网站对于不兼容 WebP 格式的图片的浏览器（比如 IE11）也有需求的话，那这里有一套方案可以让图片不会因为浏览器兼容性而显示出错：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;flower.webp&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/jpeg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;flower.jpg&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;flower.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于上面这段代码，浏览器会首先检测是否支持 <code>&lt;source&gt;</code> 标签列表里的资源，如果兼容的话，默认会加载 <code>flower.webp</code> 图片，如果都不支持 <code>&lt;source&gt;</code> 列表里的资源的话，则会去加载 <code>&lt;img&gt;</code> 里指定的图片。</p><h2 id="接下来该干什么"><a href="#接下来该干什么" class="headerlink" title="接下来该干什么"></a>接下来该干什么</h2><p>之前我做的项目里的图片基本都是 JPG\PNG 格式的，我找了一张我们网站首页的 Banner 图，就是那种 1920px 宽度的图片，它在被压缩工具压缩后文件大小还有 275 KB ，而当我用 cwebp 工具用 -q 75 的质量参数去转换成 WebP 图片后，你们知道它的文件大小变成多少了吗？它变成 50KB 😱</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp007.png"></p><p>真的的不试不知道，一试吓一跳，原来 WebP 格式的图片能够带来这么大的优化效果，最关键的是 2 张图片用肉眼看起来显示效果差不多。</p><p>真的很棒 👍，WebP 凭借一己之力将网站的性能优化提高了一个档次。所以接下来 KPI 就有了：可以很愉快的把项目里所有的图片都转成 WebP 图片了。这么干完之后，你就可以和领导提涨薪了，领导领导我把我们网站优化了一下，性能提升了 10% ~ 20% 左右。不过接下来发生什么，可不要来找我哈。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://web.dev/serve-images-webp/">https://web.dev/serve-images-webp/</a></li><li><a href="https://developers.google.com/speed/webp">https://developers.google.com/speed/webp</a></li><li><a href="https://github.com/Nyx0uf/qlImageSize">https://github.com/Nyx0uf/qlImageSize</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了一篇文章：&lt;a href=&quot;https://github.com/Bulandent/blog/issues/17&quot;&gt;jpg、gif、png 和 svg 用于 web 上，我们该如何选择最合适的图像格式&lt;/a&gt;，介绍了这几种图片格式的特点，以及如何为网站选择合适的图片，然后评论区有位大佬让我补充下 WebP 格式，于是乎它来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/webp006.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-WebP-格式&quot;&gt;&lt;a href=&quot;#什么是-WebP-格式&quot; class=&quot;headerlink&quot; title=&quot;什么是 WebP 格式&quot;&gt;&lt;/a&gt;什么是 WebP 格式&lt;/h2&gt;&lt;p&gt;WebP 是一种现代图像格式，可为 Web 上的图像提供出色的无损和有损压缩。 使用 WebP，网站管理员和 Web 开发人员可以创建更小，更丰富的图像，从而使 Web 更快。&lt;/p&gt;
&lt;p&gt;与 PNG 相比，WebP 无损图像的尺寸要小 26％。 在同等的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。&lt;/p&gt;
&lt;p&gt;无损 WebP 支持透明性（也称为 Alpha 通道），而仅增加了 22％ 的字节数。 对于可以接受有损 RGB 压缩的情况，有损 WebP 还支持透明性，与 PNG 相比，文件大小通常小 3 倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面这 3 段话来源于 &lt;a href=&quot;https://developers.google.com/speed/webp&quot;&gt;https://developers.google.com/speed/webp&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web综合" scheme="https://bubuzou.com/categories/web%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="图像" scheme="https://bubuzou.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
      <category term="性能优化" scheme="https://bubuzou.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>让人爱不释手的 JS 扩展操作符 13 用</title>
    <link href="https://bubuzou.com/2021/01/13/spread-operator/"/>
    <id>https://bubuzou.com/2021/01/13/spread-operator/</id>
    <published>2021-01-13T01:49:25.000Z</published>
    <updated>2021-01-26T00:43:28.808Z</updated>
    
    <content type="html"><![CDATA[<p>我相信你一定或多或少的接触或使用过 <code>JS</code> 中的扩展操作符（Spread Operator），在基本形式中，扩展操作符看起来像三个点，比如如下这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...arr]</span><br></pre></td></tr></table></figure><p>而实际上，它也就是这么用的，但是如果事情有这么简单，就不用我在这里写了。扩展操作符给我最大的印象就是，这玩意还挺方便的，然而最近写代码的时候经常性的遇到需要使用扩展操作符的场景，所以我干脆在网上找了些资料，把平时常见的应用场景给罗列了下，发现这个操作符是真的强大，有多强大？来看看下面这些用法吧。</p><h2 id="1-字符串转数组"><a href="#1-字符串转数组" class="headerlink" title="1. 字符串转数组"></a>1. 字符串转数组</h2><p>字符串转数组最普遍的做法是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure><p>而使用了扩展操作符后可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> arr = [...str]</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-将类数组转换为数组"><a href="#2-将类数组转换为数组" class="headerlink" title="2. 将类数组转换为数组"></a>2. 将类数组转换为数组</h2><p>在 <code>JS</code> 中有一种数据结构叫做 <code>NodeList</code>，它和数组很相似，也被叫做“类数组”，类数组是什么？在 MDN 中是这么定义它的：</p><blockquote><p>类数组：拥有一个 length 属性和若干索引属性的任意对象。</p></blockquote><p>类数组有哪些呢？以下这些可以看成是类数组：</p><ul><li><code>NodeList</code>：<code>document.querySelectorAll()</code> 返回的对象；</li><li><code>HTMLCollection</code>：<code>document.getElementsByTagName()</code> 返回的对象；</li><li><code>Arguments</code>：函数里的参数对象；</li></ul><p>类数组没有数组的一些方法比如 <code>push</code>、<code>map</code> 等，所以经常需要将它们转成数组，而通常我们是这么转化的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(nodeList <span class="keyword">instanceof</span> NodeList)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, nodeList)</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [].slice.call(nodeList)</span><br><span class="line"><span class="built_in">console</span>.log(arr2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 又或者</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="built_in">Array</span>.from(nodeList)</span><br><span class="line"><span class="built_in">console</span>.log(arr3 <span class="keyword">instanceof</span> <span class="built_in">Array</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>而有了扩展操作符可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> arr = [...nodeList]</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="3-向数组中添加项"><a href="#3-向数组中添加项" class="headerlink" title="3. 向数组中添加项"></a>3. 向数组中添加项</h2><p>往数组中添加几项通常这样操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头部添加</span></span><br><span class="line">arr.unshift(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1, 2, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从尾部添加</span></span><br><span class="line">arr.push(<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1，2, 5, 6, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从任意位置添加</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1，2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><p>使用扩展操作符后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, ...arr, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="4-拷贝数组和对象"><a href="#4-拷贝数组和对象" class="headerlink" title="4. 拷贝数组和对象"></a>4. 拷贝数组和对象</h2><p>通常拷贝一个数组，可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arr.slice()</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)   <span class="comment">// [2, 3, 5, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// [1, 3, 5, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr3)  <span class="comment">// [1, 3, 5, 7]</span></span><br></pre></td></tr></table></figure><p>但是有了扩展操作符，拷贝数组就能写得很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// [1, 3, 5, 7]</span></span><br></pre></td></tr></table></figure><p>同样的，扩展操作符还能拷贝对象。<br>拷贝对象的通常做法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Object</span>.assign(&#123;&#125;, person)</span><br><span class="line">person.age = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 20 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2)      <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>有了扩展操作符，拷贝一个对象就相当方便了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p2 = &#123;...person&#125;</span><br><span class="line">person.age = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 20 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2)      <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至还可以这么写</span></span><br><span class="line"><span class="keyword">let</span> &#123;...p3&#125; = person</span><br></pre></td></tr></table></figure><blockquote><p>注意：扩展操作符只能深拷贝结构为一层的对象，如果对象是两层的结构，那么使用扩展操作符拷贝会是浅拷贝。</p></blockquote><h2 id="5-合并数组或对象"><a href="#5-合并数组或对象" class="headerlink" title="5. 合并数组或对象"></a>5. 合并数组或对象</h2><p>数组合并通常是这么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr3 = arr1.concat( arr2 )</span><br><span class="line"><span class="built_in">console</span>.log(arr3)  <span class="comment">// [1, 3, 5, 2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>使用扩展操作符后，可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr3 = [...arr1, ...arr2]</span><br><span class="line"><span class="built_in">console</span>.log(arr3)  <span class="comment">// [1, 3, 5, 2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>对了，它除了能合并数组外还能合并对象呢。合并对象，通常的做法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p2 = &#123; <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Object</span>.assign(&#123;&#125;, p1, p2)</span><br><span class="line"><span class="built_in">console</span>.log(p3)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12&#125;</span></span><br></pre></td></tr></table></figure><p>用扩展操作符合并对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p2 = &#123; <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p3 = &#123; ...p1, ...p2 &#125;</span><br><span class="line"><span class="built_in">console</span>.log(p3)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12&#125;</span></span><br></pre></td></tr></table></figure><h2 id="6-解构对象"><a href="#6-解构对象" class="headerlink" title="6. 解构对象"></a>6. 解构对象</h2><p>经常我们给对象设置参数的时候会这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">    sex: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name = person.name</span><br><span class="line"><span class="keyword">let</span> age = person.age</span><br><span class="line"><span class="keyword">let</span> sex = person.sex</span><br></pre></td></tr></table></figure><p>而有了扩展操作符，我们就可以这么写，不过其实如下这种写法并不是扩展操作符的写法🤣，而是剩余操作符的写法，虽然写出来后看起来差不多，但就在操作对象这一点上，基本上可以认为它和扩展操作符是相反的操作，扩展操作符是用来展开对象的属性到多个变量上，而剩余操作符是用来把多个参数凝聚到一个变量上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">    sex: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name, ...reset &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(name)   <span class="comment">// &#x27;布兰&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(reset)  <span class="comment">// &#123; age: 12, sex: &#x27;male&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="7-给对象添加属性"><a href="#7-给对象添加属性" class="headerlink" title="7. 给对象添加属性"></a>7. 给对象添加属性</h2><p>给对象加属性通常这样加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line">person.age = <span class="number">12</span></span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>使用扩展操作符给对象添加属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line">person = &#123;...person, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>关于使用扩展操作符给对象添加属性，这里有 2 个小技巧：</p><ul><li><ol><li>给新对象设置默认值：</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认 person 对象的 age 属性值 为 12</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">age</span>: <span class="number">12</span>, ...&#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; age: 12, name: &#x27;布兰&#x27; &#125; </span></span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>重写对象属性</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 对象的 age 属性被重写为 20</span></span><br><span class="line">person = &#123;...person, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(person)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 20 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="8-设置对象-Getter"><a href="#8-设置对象-Getter" class="headerlink" title="8. 设置对象 Getter"></a>8. 设置对象 Getter</h2><p>设置对象 <code>Getter</code> 通常做法是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    get() &#123; <span class="keyword">return</span> <span class="number">12</span> &#125;,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.age)  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>而有了扩展操作符后可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line">person = &#123;</span><br><span class="line">    ...person, </span><br><span class="line">    <span class="keyword">get</span> <span class="title">age</span>() &#123; <span class="keyword">return</span> <span class="number">12</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.age)  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h2 id="9-将数组作为函数参数展开"><a href="#9-将数组作为函数参数展开" class="headerlink" title="9. 将数组作为函数参数展开"></a>9. 将数组作为函数参数展开</h2><p>如果我们有一个形参是多个参数的函数，但是当调用的时候发现入参却是一个数组，常规做法是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>) </span>&#123; &#125; </span><br><span class="line">fn.apply(<span class="literal">null</span>, arr)</span><br></pre></td></tr></table></figure><p>使用扩展操作符后，就简单多了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>) </span>&#123; &#125; </span><br><span class="line">fn(...arr)</span><br></pre></td></tr></table></figure><h2 id="10-无限参数的函数"><a href="#10-无限参数的函数" class="headerlink" title="10. 无限参数的函数"></a>10. 无限参数的函数</h2><p>如果有这么一个累加函数，他会把所有传递进来的参数都加起来，普通做法是把参数都整合到数组里，然后这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( doSum([<span class="number">1</span>, <span class="number">3</span>]) )     <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log( doSum([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]) )  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>如果参数不是数组，而是需要一个个传递，相当于函数必须支持无限参数，那可能会这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++)&#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="comment">// let args = [].slice.call(arguments) </span></span><br><span class="line">    <span class="comment">// return args.reduce((acc, cur) =&gt; acc + cur)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>) )        <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>) )     <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) )  <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>而有了扩展操作符，就简单多了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSum</span>(<span class="params">...arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>) )        <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>) )     <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log( doSum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) )  <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><h2 id="11-扩展函数的剩余参数"><a href="#11-扩展函数的剩余参数" class="headerlink" title="11. 扩展函数的剩余参数"></a>11. 扩展函数的剩余参数</h2><p>有的时候一个函数需要传递很多的参数，比如小程序页面（<code>WePY</code>）的 <code>onLoad</code> 生命周期函数里就可能有很多别的页面传递过来的参数，然后还需要在函数里进行一些数据初始化工作，这样一来就会显得很臃肿不美观，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">a, b, x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 进行一系列初始化数据工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用了扩展操作符后，我们就可以按照业务把参数进行解构，把本该在一个函数里进行初始化的工作拆分成多个，可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">other</span>(<span class="params"> x, y </span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">a, b, ...restConfig</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 a 和 b 参数进行操作</span></span><br><span class="line">    <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">    <span class="keyword">return</span> other( ...restConfig )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-结合-Math-函数使用"><a href="#12-结合-Math-函数使用" class="headerlink" title="12. 结合 Math 函数使用"></a>12. 结合 Math 函数使用</h2><p>比如当需要对一个数组求最大值的时候，通常会这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].concat(arr).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max(arr)[<span class="number">0</span>])  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> <span class="built_in">Math</span>.max(acc, cur))  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 又或者</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>但是使用扩展操作符后，能够把给数组求最大值写得更加简洁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...arr)</span><br><span class="line"><span class="built_in">console</span>.log(max)  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h2 id="13-在-new-表达式中使用"><a href="#13-在-new-表达式中使用" class="headerlink" title="13. 在 new 表达式中使用"></a>13. 在 new 表达式中使用</h2><p>假设有一个数组格式的日期，想要通过 Date 构造函数创建一个日期实例的话，可能会这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2021</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>([].toString.call(arr))</span><br><span class="line"><span class="built_in">console</span>.log(date)  <span class="comment">// &#x27;Mon Feb 01 2021 00:00:00 GMT+0800 (中国标准时间)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> (<span class="built_in">Function</span>.prototype.bind.apply(</span><br><span class="line">    <span class="built_in">Date</span>, </span><br><span class="line">    [<span class="literal">null</span>].concat(arr)</span><br><span class="line">))</span><br><span class="line"><span class="built_in">console</span>.log(date2)  <span class="comment">// &#x27;Mon Feb 01 2021 00:00:00 GMT+0800 (中国标准时间)&#x27; </span></span><br></pre></td></tr></table></figure><p>而有了扩展操作符就简单多了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2021</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(...arr)</span><br><span class="line"><span class="built_in">console</span>.log(date)  <span class="comment">// &#x27;Mon Feb 01 2021 00:00:00 GMT+0800 (中国标准时间)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个操作符真可谓使用简单无脑，但是功能效率上不得不说很强大，所以我们要做的就是只要记住在什么时候使用它就好了，于是乎为了让大家能更好的记住这 13 种使用场景，我特意做了一个图，方便大家记忆，是不是很贴？是的话请不要吝啬你的爱心，给个小星星👍吧，感谢感谢。以上这些只列了 13 种写法，我觉得作为一个这么强大的操作符，肯定有更多使用的场景，欢迎把你们知道的写到评论区吧。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202101/js_spread_operator.png"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/post/6896986598999588872#heading-46">「建议收藏」送你一份精心总结的3万字ES6实用指南（下）</a></li><li><a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md">https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md</a></li><li><a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Rest.md">https://github.com/tc39/proposal-object-rest-spread/blob/master/Rest.md</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我相信你一定或多或少的接触或使用过 &lt;code&gt;JS&lt;/code&gt; 中的扩展操作符（Spread Operator），在基本形式中，扩展操作符看起来像三个点，比如如下这样：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[...arr]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;而实际上，它也就是这么用的，但是如果事情有这么简单，就不用我在这里写了。扩展操作符给我最大的印象就是，这玩意还挺方便的，然而最近写代码的时候经常性的遇到需要使用扩展操作符的场景，所以我干脆在网上找了些资料，把平时常见的应用场景给罗列了下，发现这个操作符是真的强大，有多强大？来看看下面这些用法吧。&lt;/p&gt;
&lt;h2 id=&quot;1-字符串转数组&quot;&gt;&lt;a href=&quot;#1-字符串转数组&quot; class=&quot;headerlink&quot; title=&quot;1. 字符串转数组&quot;&gt;&lt;/a&gt;1. 字符串转数组&lt;/h2&gt;&lt;p&gt;字符串转数组最普遍的做法是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr = str.split(&lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr)  &lt;span class=&quot;comment&quot;&gt;// [&amp;#x27;h&amp;#x27;, &amp;#x27;e&amp;#x27;, &amp;#x27;l&amp;#x27;, &amp;#x27;l&amp;#x27;, &amp;#x27;o&amp;#x27;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;而使用了扩展操作符后可以这样：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr = [...str]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr)  &lt;span class=&quot;comment&quot;&gt;// [&amp;#x27;h&amp;#x27;, &amp;#x27;e&amp;#x27;, &amp;#x27;l&amp;#x27;, &amp;#x27;l&amp;#x27;, &amp;#x27;o&amp;#x27;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>6 分钟了解 HTTP 发展史</title>
    <link href="https://bubuzou.com/2021/01/05/http/"/>
    <id>https://bubuzou.com/2021/01/05/http/</id>
    <published>2021-01-05T01:49:25.000Z</published>
    <updated>2021-09-06T09:57:14.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。</p><h3 id="完整请求流程"><a href="#完整请求流程" class="headerlink" title="完整请求流程"></a>完整请求流程</h3><ul><li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li><li>建立好连接之后，会发送一个 GET 请求行的信息，如 GET /index.html 用来获取 index.html。</li><li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li><li>HTML 文档传输完成后，断开连接。</li></ul><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_031.png" alt="HTTP/0.9 请求过程"></p><a id="more"></a><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li><li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li><li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li></ul><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>HTTP/0.9 存在许多的问题，比如如下的这些：</p><ul><li>只支持 HTML 类型文件，无法传输 JS、CSS、字体、图片和视频等类型的文件；</li><li>文件传输格式局限于 ASCII，无法输出其他类型编码的文件；</li><li>只有请求行，传输给服务器的信息太少；</li><li>只响应请求数据，不能传输额外的数据给浏览器。</li></ul><p>所以它已经不能满足当时的需求了，于是乎 HTTP/1.0 来了，它带来了这些：</p><ul><li><p>新增了请求头和请求体，能传输更多的信息给服务器，比如如下请求头字段：Accept 文件类型，Accept-Encoding 压缩格式，Accept-Charset 字符编码格式，Accept-Language 国际化语音：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Accept: text&#x2F;html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Charset: ISO-8859-1,utf-8</span><br><span class="line">Accept-Language: zh-CN,zh</span><br></pre></td></tr></table></figure></li><li><p>请求头新增 User-Agent 字段，用于服务器统计客户端信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br></pre></td></tr></table></figure></li><li><p>新增了响应头，能够告诉浏览器更多的信息，比如 Content-Encoding 表示服务器返回文件的压缩类型，Content-Type 告诉浏览器服务器返回的是什么类型的文件以及使用了什么编码格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure></li><li><p>新增响应行状态码，用于告知浏览器当前请求的状态，比如 200 表示请求成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure></li><li><p>新增缓存机制，用来缓存已经下载过的资源，减轻了服务端压力。</p></li></ul><p>在构建请求流程上来看，HTTP/1.0 区别于 HTTP/0.9 最大的区别就是在请求和响应的时候新增了不少字段用于在浏览器和服务器之间通信。</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>HTTP/1.0 虽说已经能够传输不同类型的文件了，但是它还是有缺点的，比如每发出一次 HTTP 请求都需要经历如下阶段：</p><ul><li>建立 TCP 连接；</li><li>HTTP 请求；</li><li>HTTP 响应；</li><li>断开 TCP 连接。</li></ul><p>HTTP/1.0 发送多个同域名请求：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_032.png" alt="HTTP/1.0 的短链接"></p><p>可以发现每次请求都需要重新建立 TCP 连接和断开连接的操作，这无疑增加了网络开销，同时也延迟了页面显示。</p><p><strong>HTTP/1.1 在请求头中增加了 Connection 字段</strong>：用于提供 TCP 的持久连接**：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>它默认是开启持久连接的，即对于同一个域名，浏览器默认支持 6 个 TCP 持久连接。<br>当启用持久连接后，多个同域名下的请求发送会是如下情况：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_033.png" alt="HTTP/1.1 的持久连接"></p><p><strong>HTTP/1.1 中新增 Host 字段，用于支持虚拟主机</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: bubuzou.com</span><br></pre></td></tr></table></figure><blockquote><p>虚拟主机：一台物理机器上绑定多个虚拟主机，每个虚拟主机有单独的域名，这些域名都公用一个 IP 地址。</p></blockquote><p><strong>HTTP/1.1 通过引入 Chunk transfer 机制来支持动态内容</strong>：服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。</p><p><strong>HTTP/1.1 还引入了客户端 Cookie 机制和安全机制</strong></p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>我们知道 HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：</p><ul><li>增加了持久连接；</li><li>浏览器为每个域名最多同时维护 6 个 TCP 持久连接；</li><li>使用 CDN 的实现域名分片机制。</li></ul><h3 id="HTTP-1-1-中依然存在的问题"><a href="#HTTP-1-1-中依然存在的问题" class="headerlink" title="HTTP/1.1 中依然存在的问题"></a>HTTP/1.1 中依然存在的问题</h3><p>虽然 HTTP/1.1 采取了很多优化资源加载速度的策略，也取得了一定的效果，但是 HTTP/1.1 对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题。</p><p>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</p><p>之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。</p><p>之所以会出现这个问题，主要是 3 个问题导致的：</p><p><strong>第一个原因，TCP 的慢启动</strong></p><p>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。这个过程可以想象是一辆车的启动过程，开始的时候慢，当速度起来后加速就更快了。</p><p>而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p><p><strong>第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽</strong></p><p>你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。</p><p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p><p><strong>第三个原因，HTTP/1.1 队头阻塞的问题</strong></p><p>我们知道在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p><p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。</p><h3 id="HTTP-2-的多路复用"><a href="#HTTP-2-的多路复用" class="headerlink" title="HTTP/2 的多路复用"></a>HTTP/2 的多路复用</h3><p>为了解决 HTTP/1.1 中存在的问题，在 HTTP/2 中采用最具颠覆性的方案：多路复用机制。<br><img src="https://static001.geekbang.org/resource/image/0a/00/0a990f86ad9c19fd7d7620b2ef7ee900.jpg"></p><p><strong>HTTP/2 多路复用是什么</strong></p><p>HTTP/2 的多路复用机制用简单的话来说就是浏览器针对同一域名的资源，只建立一个 TCP 连接通道，所有的针对这个域名的请求全部都在这个通道中完成；</p><p>除此之外，数据的传输不再使用文本格式，而是会将它们分割为更小的流和帧，并对他们采用二进制格式的编码。在一个 TCP 连接通道中，支持任意数量的双向数据流，这些数据流是并行、乱序的且它们之间互不干扰。而数据流中传输的数据是二进制帧，它是 HTTP/2 中数据传输的最小单位，一个流中的帧是按照顺序传输的，且是并行的，所以无需按顺序等待。</p><p><strong>解决了什么问题</strong></p><p>因为只使用一个 TCP 连接，所以减少了由于 TCP 慢启动而消耗的时间，另外也由于只有单条 TCP 连接，所以不存在不同的 TCP 争夺网络带宽的问题。</p><p>客户端发送的请求经过二进制分帧层后，不再是一个个完整的 HTTP 请求报文，而是一堆乱序的帧（即不同流的帧是乱的，但是同一条流的帧数顺序传输的），所以就不会按顺序传输，也就不存在等待，从而解决了 HTTP 对头阻塞问题。</p><p><strong>是如何实现的</strong></p><ul><li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li><li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。请求头的信息存在 header 帧中，而请求体数据存在 data 帧中。</li><li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li><li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li><li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li><li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。</li></ul><h3 id="HTTP-2-其他特性"><a href="#HTTP-2-其他特性" class="headerlink" title="HTTP/2 其他特性"></a>HTTP/2 其他特性</h3><p><strong>1. 可以设置请求的优先级</strong></p><p>在浏览器中，某些数据是非常重要的，比如关键 CSS 或者 JS，这些重要的数据如果比较晚才推送到浏览器，那么对用户来说肯定是一个不好的体验。</p><p>所以 HTTP/2 中可以支持设置请求的优先级，这样服务器收到高优先级的请求后，会优先处理。</p><p><strong>2. 服务器推送</strong></p><p>在 HTTP/2 中服务器解析到一个 HTML 页面后，服务器知道浏览器需要这个页面上引用到的资源，比如 CSS 和 JS，那么服务器就会主动的把这些资源一并推送给浏览器，减少客户端的等待时间。</p><p><strong>3. 头部压缩</strong></p><p>HTTP/2 使用 HPACK 压缩算法对请求头和响应头进行压缩，虽然单个请求压缩之后效果不是很明显，但是如果一个页面有 100 个请求，那每个请求压缩 20% 之后，那提速效果就很明显了。</p><p>而 HPACK 的压缩原理其实就是 2 点：</p><ul><li>它要求客户端和服务器两者都维护和更新先前看到的报头字段的索引列表（即，建立共享的压缩上下文），然后将该列表用作有效编码先前传输的值的参考。在实际传输的时候用索引代替每一侧的静态或动态表中已经存在的字段，从而减小每个请求的大小。</li><li>它允许通过静态霍夫曼码对发送的标头字段进行编码，从而减小了它们各自的传输大小。</li></ul><h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h2><p>HTTP/2 依然是基于 TCP 的，所以还存在以下一些问题。</p><h3 id="TCP-的队头阻塞"><a href="#TCP-的队头阻塞" class="headerlink" title="TCP 的队头阻塞"></a>TCP 的队头阻塞</h3><p>HTTP/2 中多个请求是跑在一个 TCP 连接中的，如果某个数据流中出现了丢包的情况，就会阻塞该 TCP 连接中的所有请求。这个和 HTTP/1.1 中的不同，在 HTTP/1.1 中，由于浏览器为每个域名建立了 6 个 TCP 连接，如果其中一个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</p><h3 id="TCP-建立连接的延时"><a href="#TCP-建立连接的延时" class="headerlink" title="TCP 建立连接的延时"></a>TCP 建立连接的延时</h3><p>在传输数据之前，需要进行 TCP 的 3 次握手，需要花费 1.5 个 RTT；如果是 HTTPS，那还需要进行 TLS 连接，又需要 1 ~ 2 个 RTT。</p><blockquote><p>网络延迟又叫 RTT(Round Trip Time)，是从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间。</p></blockquote><p>总之，在传输数据之前需要花掉 3 ~ 4 个 RTT。如果客户端和服务器距离近的话，那 1 个 RTT 大概是 10ms，但如果远的话，可能是 100ms，所以传输数据之前需要花掉 300ms 左右，这个时候就能感觉到慢了。</p><h3 id="TCP-协议僵化"><a href="#TCP-协议僵化" class="headerlink" title="TCP 协议僵化"></a>TCP 协议僵化</h3><p>我们知道 TCP 协议存在队头阻塞和建立连接延迟的问题，但是又没办法改进 TCP 协议，理由有如下 2 个：</p><ul><li>中间设备僵化。中间设备比如路由器、交换机、防火墙和 NAT 等，这些设备依赖的软件使用了大量的 TCP 特性，一旦功能被设置后就很少进行更新了。如果在客户端进行升级 TCP 协议，那么当新协议的数据包经过这些设备的时候，可能会不理解包的内容，造成数据丢失。</li><li>操作系统也是导致 TCP 协议僵化的另外一个原因。</li></ul><h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p><img src="https://static001.geekbang.org/resource/image/0b/c6/0bae470bb49747b9a59f9f4bb496a9c6.png"></p><p>HTTP/3 是基于 UDP 实现的，实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。</p><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li><li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li><li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li><li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li></ul><h3 id="HTTP-3-的挑战"><a href="#HTTP-3-的挑战" class="headerlink" title="HTTP/3 的挑战"></a>HTTP/3 的挑战</h3><ul><li>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</li><li>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li><li>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～ 7% 的丢包率。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP-0-9&quot;&gt;&lt;a href=&quot;#HTTP-0-9&quot; class=&quot;headerlink&quot; title=&quot;HTTP/0.9&quot;&gt;&lt;/a&gt;HTTP/0.9&lt;/h2&gt;&lt;p&gt;HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。&lt;/p&gt;
&lt;h3 id=&quot;完整请求流程&quot;&gt;&lt;a href=&quot;#完整请求流程&quot; class=&quot;headerlink&quot; title=&quot;完整请求流程&quot;&gt;&lt;/a&gt;完整请求流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。&lt;/li&gt;
&lt;li&gt;建立好连接之后，会发送一个 GET 请求行的信息，如 GET /index.html 用来获取 index.html。&lt;/li&gt;
&lt;li&gt;服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。&lt;/li&gt;
&lt;li&gt;HTML 文档传输完成后，断开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_031.png&quot; alt=&quot;HTTP/0.9 请求过程&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="http" scheme="https://bubuzou.com/categories/http/"/>
    
    
      <category term="http" scheme="https://bubuzou.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Resourse Hints 知多少</title>
    <link href="https://bubuzou.com/2020/12/28/resource-hints/"/>
    <id>https://bubuzou.com/2020/12/28/resource-hints/</id>
    <published>2020-12-28T01:49:25.000Z</published>
    <updated>2021-01-14T02:21:56.536Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇文章 <a href="https://juejin.cn/post/6914479519394955271">探究网页资源究竟是如何阻塞浏览器加载的</a> 中介绍到 JS 会阻塞 DOM 的加载，样式会阻塞页面的渲染，外链样式里的自定义字体还会对文字造成闪动给用户带来不好的体验，诸如此类问题还有挺多，那到底该如何解决它们呢？</p><p>今天我们就来学习通过在 <code>link</code> 标签里加上特定的属性，比如 <code>preload</code>、<code>prefetch</code> 等来解决此类问题，那么你对这些属性又了解多少呢？把它们用在了你们的项目优化中了嘛？</p><a id="more"></a><h2 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h2><p><code>preload</code> 提升了资源加载的优先级，使得它提前开始加载（预加载），在需要用的时候能够更快的使用上。另外 <code>onload</code> 事件必须等页面所有资源都加载完成才触发，而当给某个资源加上 <code>preload</code> 后，该资源将不会阻塞 <code>onload</code>。</p><h3 id="preload-怎么用"><a href="#preload-怎么用" class="headerlink" title="preload 怎么用"></a>preload 怎么用</h3><p>当某个页面加载了 2 个脚本 <code>jquery.min.js</code> 和 <code>main.js</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时该页面的资源加载 <code>Waterfall</code> 长这样：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_019.png"></p><p>当在 <code>&lt;head&gt;</code> 里通过 <code>&lt;link&gt;</code> 标签给 <code>main.js</code> 配置 <code>preload</code> 预加载后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时的 <code>main.js</code> 加载顺序出现在了 <code>jquery.min.js</code> 的前面，这就是 <code>preload</code> 提升资源加载优先级的效果。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_020.png" alt="preload main.js"></p><blockquote><p>当一直刷新浏览器的时候，偶然出现 Waterfall 并不能准确的显示资源加载的顺序，所以这个时候就需要比较每个资源被加入到下载队列的时间，比如如下的 main.js 由于用了 preload 预加载，所以 queue time 比较早。</p></blockquote><p> <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_021.png" alt="preload main.js"><br> <img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_022.png" alt="preload main.js"></p><p>通过 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 只是预加载了资源，但是资源加载完成后并不会执行，所以需要在想要执行的地方通过 <code>&lt;script&gt;</code> 来引入它：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是也有一个例外，因为 <code>CSS</code> 的加载也是通过 <code>&lt;link&gt;</code> 标签引入的，所以我们可以巧妙的利用这点，当 <code>onload</code> 事件触发的时候修改 <code>rel</code> 属性的值，使得它由原来的预加载样式变成引入样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;this.rel=&#x27;stylesheet&#x27;&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果通过 <code>preload</code> 加载了资源，但是又没有使用它，则浏览器会报一个警告：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_023.png" alt="preload main.js"></p><p><code>preload</code> 除了能够预加载脚本之外，还可以通过 <code>as</code> 指定别的资源类型，比如：</p><ul><li><code>style</code> 样式表；</li><li><code>font</code>：字体文件；</li><li><code>image</code>：图片文件；</li><li><code>audio</code>：音频文件；</li><li><code>video</code>：视频文件；</li><li><code>document</code>：文档。</li></ul><h3 id="preload-应用案例"><a href="#preload-应用案例" class="headerlink" title="preload 应用案例"></a>preload 应用案例</h3><p><code>preload</code> 主要用于提升当前页面某些阻塞资源的下载优先级，使得页面能够尽快渲染显示出来。</p><p><strong>案例一：预加载定义在 CSS 中资源的下载，比如自定义字体</strong></p><p>当页面中使用了自定义字体的时候，就必须在 <code>CSS</code> 中引入该字体，而由于字体必须要等到浏览器下载完且解析该 <code>CSS</code> 文件的时候才开始下载，所以对应页面上该字体处可能会出现闪动的现象，为了避免这种现象的出现，就可以使用 <code>preload</code> 来提前加载字体，<code>type</code> 可以用来指定具体的字体类型，<strong>加载字体必须指定 <code>crossorigin</code> 属性，否则会导致字体被加载两次</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">crossorigin</span> <span class="attr">type</span>=<span class="string">&quot;font/woff2&quot;</span> <span class="attr">href</span>=<span class="string">&quot;myfont.woff2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上这种写法和指定 <code>crossorigin=&quot;anonymous&quot;</code> 是等同的效果。</p><p><strong>案例二：预加载 CSS 文件</strong></p><p>在首屏加载优化中一直存在一种技术，叫做抽取关键 <code>CSS</code>，意思就是把页面中在视口中出现的样式抽出一个独立的 <code>CSS</code> 文件出来 <code>critical.css</code>，然后剩余的样式在放到另外一个文件上 <code>non-critical.css</code>：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_030.png"></p><p>由于 <code>CSS</code> 会阻塞页面的渲染，当同时去加载这 2 部分样式的时候，只要 <code>non-critical.css</code> 还没加载完成，那么页面就显示不了，而实际上只需要显示出视口下的界面即可，所以期待的结果是：当加载完成 <code>critical.css</code> 的时候马上显示出视口下的界面，不让 <code>non-critical.css</code> 阻塞渲染，则需要给 <code>non-critical.css</code> 加上预加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://bubuzou.com/non-critical.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://bubuzou.com/critical.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://bubuzou.com/non-critical.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>案例三：创建动态的预加载资源</strong></p><p>当需要预先加载的时候调用 <code>downloadScript</code>，而希望执行的时候则调用 <code>runScript</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">&quot;link&quot;</span>)</span><br><span class="line">    el.as = <span class="string">&quot;script&quot;</span></span><br><span class="line">    el.rel = <span class="string">&quot;preload&quot;</span></span><br><span class="line">    el.href = src</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(el)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>)</span><br><span class="line">    el.src = src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例四：结合媒体查询预加载响应式图片</strong></p><p><code>preload</code> 甚至还可以结合媒体查询加载对应尺寸下的资源，对于以下代码当可视区域尺寸小于 <code>600px</code> 的时候会提前加载这张图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;image&quot;</span> <span class="attr">href</span>=<span class="string">&quot;someimage.jpg&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 600px)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>案例五：结合 <code>Webpack</code> 预加载 <code>JS</code> 模块</strong></p><p><code>Webpack</code> 从 <code>4.6.0</code> 版本开始支持在魔术注释中配置预加载模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(_<span class="comment">/* webpackPreload: true */</span>_ <span class="string">&quot;CriticalChunk&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果是版本比较老的，则可以使用 <code>preload-webpack-plugin</code> 进行处理。</p><h2 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h2><p><code>preload</code> 用于提前加载用于当前页面的资源，而 <code>prefetch</code> 则是用于加载未来（比如下一个页面）会用到的资源，并且告诉浏览器在空闲的时候去下载，它会将下载资源的优先级降到最低。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_018.png"></p><p>比如在首页配置如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们会在页面中看到该脚本的下载优先级已经被降低为 <code>Lowest</code>：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_016.png"></p><p>当资源被下载完成后，会被存到浏览器缓存中，当从首页跳转到页面 A 的时候，假如页面 A 中引入了该脚本，那么浏览器会直接从 <code>prefetch cache</code> 中读取该资源，从而实现资源加载优化。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_017.png"></p><h2 id="preconnect"><a href="#preconnect" class="headerlink" title="preconnect"></a>preconnect</h2><p>当浏览器向服务器请求一个资源的时候，需要建立连接，而建立一个安全的连接需要经历以下 3 个步骤：</p><ul><li>查询域名并将其解析成 IP 地址（DNS Lookup）；</li><li>建立和服务器的连接（Initial connection）；</li><li>加密连接以确保安全（SSL）；</li></ul><p>以上 3 个步骤浏览器都需要和服务器进行通信，而这一来一往的请求和响应势必会耗费不少时间。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_029.png"></p><p>而就基于这点上，可以使用 <code>preconnect</code> 或者 <code>dns-prefetch</code> 进行优化，而它两又是什么呢？怎么使用呢？</p><h3 id="preconnect-是什么，怎么用"><a href="#preconnect-是什么，怎么用" class="headerlink" title="preconnect 是什么，怎么用"></a>preconnect 是什么，怎么用</h3><p>当我们的站点需要对别的域下的资源进行请求的时候，就需要和那个域建立连接，然后才能开始下载资源，如果我都已经知道了是和哪个域进行通信，那不就可以先建立连接，然后等需要进行资源请求的时候就可以直接进行下载了。</p><p>假设当前站点是 <code>https://a.com</code>，这个站点的主页需要请求 <code>https://b.com/b.js</code> 这个资源。对比正常请求和配置了 <code>preconnect</code> 时候的请求，它们在请求时间轴上看到的表现是不一样的：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_024.png"></p><p>通过如下配置可以提前建立和 <code>https://b.com</code> 这个域的连接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://b.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 <code>preconnect</code> 提早建立和第三方源的连接，可以将资源的加载时间缩短 100ms ~ 500ms，这个时间虽然看起来微不足道，但是它是实实在在的优化了页面的性能，提升了用户的体验。</p><blockquote><p>通过 preconnect 和别的域建立连接后，应该尽快的使用它，因为浏览器会关闭所有在 10 秒内未使用的连接。不必要的预连接会延迟其他重要资源，因此要限制 preconnect 连接域的数量。</p></blockquote><h3 id="preconnect-应用场景"><a href="#preconnect-应用场景" class="headerlink" title="preconnect 应用场景"></a>preconnect 应用场景</h3><p><strong>场景一：</strong></p><p>当知道资源是来源于哪个源下，但是对于加载哪个资源不是很明确的时候，比如对于如下这些资源：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_025.png"><br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_026.png"></p><p>它们要嘛是动态的，要嘛是根据不同环境携带不同参数，所以它们很适合用 <code>preconnect</code> 进行加载。</p><p><strong>场景二：</strong></p><p>如果页面上有流媒体，但是没那么快播放，又希望当按下播放按钮的时候可以越快开始越好，此时就可以使用 <code>preconnect</code> 预建立连接，节省一段时间。</p><p>如果用 <code>preconnect</code> 预建立连接的资源是一个字体文件，那么也是需要加上 <code>crossorigin</code> 属性。</p><h2 id="dns-prefetch"><a href="#dns-prefetch" class="headerlink" title="dns-prefetch"></a>dns-prefetch</h2><p>通常我们记住一个网站都是通过它的域名，但是对于服务器来说，它是通过 IP 来记住它们的。浏览器使用 <code>DNS</code> 来将站点转成 IP 地址，这个是建立连接的第一步，而这一步骤通常需要花费的时间大概是 20ms ~ 120ms。因此，可以通过 <code>dns-prefetch</code> 来节省这一步骤的时间。</p><p>居然能通过 <code>preconnect</code> 来减少整个建立连接的时间，那为什么还需要 <code>dns-prefetch</code> 来减少建立连接中第一步 DNS 查找解析的时间呢？</p><p>假如页面引入了许多第三方域下的资源，而如果它们都通过 <code>preconnect</code> 来预建立连接，其实这样的优化效果反而不好，甚至可能变差，所以这个时候就有另外一个方案，那就是对于最关键的连接使用 <code>preconnect</code>，而其他的则可以用 <code>dns-prefetch</code>。</p><p>可以按照如下方式配置 <code>dns-prefetch</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外由于 <code>preconnect</code> 的浏览器兼容稍微比 <code>dns-prefetch</code> 低，看下图：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_027.png" alt="preconnect"><br><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_028.png" alt="dns-prefetch"></p><p>因此 <code>dns-prefetch</code> 可以作为不支持预连接的浏览器的后备选择，同时配置它们两即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/fi3ework/blog/issues/16">前端性能优化之关键路径渲染优化</a></li><li><a href="https://web.dev/link-prefetch/">https://web.dev/link-prefetch/</a></li><li><a href="https://www.w3.org/TR/resource-hints/">https://www.w3.org/TR/resource-hints/</a></li><li><a href="https://juejin.cn/post/6844903473163534343">译文Preload，Prefetch 和它们在 Chrome 之中的优先级</a></li><li><a href="https://shubo.io/preload-prefetch-preconnect">preload-prefetch-preconnect</a></li><li><a href="https://web.dev/extract-critical-css/">https://web.dev/extract-critical-css/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上篇文章 &lt;a href=&quot;https://juejin.cn/post/6914479519394955271&quot;&gt;探究网页资源究竟是如何阻塞浏览器加载的&lt;/a&gt; 中介绍到 JS 会阻塞 DOM 的加载，样式会阻塞页面的渲染，外链样式里的自定义字体还会对文字造成闪动给用户带来不好的体验，诸如此类问题还有挺多，那到底该如何解决它们呢？&lt;/p&gt;
&lt;p&gt;今天我们就来学习通过在 &lt;code&gt;link&lt;/code&gt; 标签里加上特定的属性，比如 &lt;code&gt;preload&lt;/code&gt;、&lt;code&gt;prefetch&lt;/code&gt; 等来解决此类问题，那么你对这些属性又了解多少呢？把它们用在了你们的项目优化中了嘛？&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>探究网页资源究竟是如何阻塞浏览器加载的</title>
    <link href="https://bubuzou.com/2020/12/26/browser-block/"/>
    <id>https://bubuzou.com/2020/12/26/browser-block/</id>
    <published>2020-12-26T01:49:25.000Z</published>
    <updated>2021-01-14T02:09:49.712Z</updated>
    
    <content type="html"><![CDATA[<p>一个页面允许加载的外部资源有很多，常见的有脚本、样式、字体、图片和视频等，对于这些外部资源究竟是如何影响整个页面的加载和渲染的呢？今天我们来一探究竟。</p><p>阅读完这篇文章你将解开如下谜团：</p><ul><li>如何用 Chrome 定制网络加载速度？</li><li>图片/视频/字体会阻塞页面加载嘛？</li><li>CSS 是如何阻塞页面加载的？</li><li>JS 又是如何阻塞页面加载的？</li><li>JS 一定会阻塞 DOM 加载嘛？</li><li>defer 和 async 是什么？又有何特点？</li><li>动态脚本会造成阻塞嘛？</li><li>阻塞是怎么和 DOMContentLoaded 与 onload 扯上关系的？</li></ul><a id="more"></a><h2 id="测试前环境准备"><a href="#测试前环境准备" class="headerlink" title="测试前环境准备"></a>测试前环境准备</h2><p>测试之前我们需要对浏览器下载资源的速度进行控制，将它重新设置为 50kb/s，操作方式：</p><ol><li>打开 <code>Chrome</code> 开发者工具；</li><li>在 <code>Network</code> 面板下找到 <code>Disable cache</code> 右侧的下拉列表，然后选择 Add 添加自定义节流配置；</li><li>添加一个下载速度为 50kb/s 的配置；</li><li>最后在第二步骤中的下拉列表选择刚刚配置的选项即可；</li><li>注意：如果当前选择的自定义选项被修改了，则需要切换到别的选项再切回来才可生效。</li></ol><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_005.png"></p><p>为什么是这个速度？因为如下的一些资源，比如图片、样式或者脚本体积都是 50kb 的好几倍，方便测试。</p><h2 id="图片会造成阻塞嘛"><a href="#图片会造成阻塞嘛" class="headerlink" title="图片会造成阻塞嘛"></a>图片会造成阻塞嘛</h2><p>直接写个示例来看下结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;DOMContentLoaded&#x27;</span>)</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;onload&#x27;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://xxx.oss-cn-shenzhen.aliyuncs.com/images/flow.png&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是 h2 标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这张图片的大小大概是 200kb，当把网络下载速度限制成 50kb/s，打开该页面，可以看到如下结果：当 <code>h1</code> 和 <code>h2</code> 标签渲染出来且打印了 <code>DOMContentLoaded</code> 的时候，此时图片还在加载中，这就说明了图片并不会阻塞 <code>DOM</code> 的加载，更加不会阻塞页面渲染；当图片加载完成的时候，会打印 <code>onload</code>，说明图片延迟了 <code>onload</code> 事件的触发。</p><p>视频、字体和图片其实是一样的，也不会阻塞 <code>DOM</code> 的加载和渲染。</p><h2 id="CSS-加载阻塞"><a href="#CSS-加载阻塞" class="headerlink" title="CSS 加载阻塞"></a>CSS 加载阻塞</h2><p>同样的，我们还是直接用代码来测试 <code>CSS</code> 加载对页面阻塞的情况，因为下面代码加载的 <code>bootstrap.css</code> 是 192kb 的，所以理论上下载它应该需要花费 3 到 4 秒左右。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试过程如下：</p><ol><li>在 <code>Elements</code> 面板下，选中 <code>h1</code> 这个标签，然后按 <code>delete</code> 键将它从 <code>DOM</code> 中删掉，从而模拟首次加载；</li><li>刷新浏览器，马上 <code>Elements</code> 面板下就加载出 <code>h1</code> 标签，继续加载 3 到 4 秒后（此时正在加载 <code>bootstrap.css</code>），页面出现 <code>我是 h1 标签</code> 字样，此时页面已经渲染完成。</li></ol><p>从而得出结论：</p><ul><li><code>bootstrap.css</code> 还没加载完成，而 <code>DOM</code> 中就已经出现 <code>h1</code> 标签，<strong>说明 <code>CSS</code> 不会阻塞 <code>DOM</code> 的解析</strong>；</li><li>页面直到 <code>bootstrap.css</code> 加载完成才出现 <code>h1</code> 里的文案，<strong>说明 <code>CSS</code> 会阻塞 <code>DOM</code> 的渲染</strong>。</li></ul><p>为什么是这个结论呢？试想一下页面渲染的流程就知道了。浏览器首先解析 <code>HTML</code> 生成 <code>DOM</code> 树，解析 <code>CSS</code> 生成 <code>CSSOM</code> 树，然后 <code>DOM</code> 树和 <code>CSSOM</code> 树进行合成生成渲染树，通过渲染树进行布局并且计算每个节点信息，绘制页面。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_006.png"></p><p>可以说解析 <code>DOM</code> 和 解析 <code>CSS</code> 其实是并列进行的，既然是并列进行的，那 <code>CSS</code> 和 <code>DOM</code> 就不会互相影响了，这和结论一相符；另外渲染页面一定是在得到 <code>CSSOM</code> 树之后进行的，这和结论二相符。</p><p><code>CSS</code> 一定会阻塞 <code>DOM</code> 的渲染嘛？答案是否定的，当把外链样式放到 <code>&lt;body&gt;</code> 最尾部去加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时刷新浏览器，页面上会马上显示出 <code>我是 h1 标签</code> 字样，当 3 到 4 秒过后样式加载完成的时会造成二次渲染，页面重新渲染出该字样，这就**说明 <code>CSS</code> 阻塞 <code>DOM</code> 的渲染只阻塞定义在 <code>CSS</code> 后面的 <code>DOM</code>**。二次渲染会对用户造成不好的体验且加重了浏览器的负担，所以这也就是为什么需要把外链样式提前到 <code>&lt;head&gt;</code> 里加载的原因。</p><h2 id="CSS-会阻塞后面-JS-的执行嘛"><a href="#CSS-会阻塞后面-JS-的执行嘛" class="headerlink" title="CSS 会阻塞后面 JS 的执行嘛"></a>CSS 会阻塞后面 JS 的执行嘛</h2><p><code>CSS</code> 阻塞了后面 <code>DOM</code> 的渲染，那它会阻塞 <code>JS</code> 的执行嘛？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;888&#x27;</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>刷新浏览器的时候可以看到，浏览器 <code>Console</code> 面板下没有打印内容，而当样式加载完成的时候打印了 888，这就<strong>说明 <code>CSS</code> 会阻塞定义在其之后 <code>JS</code> 的执行</strong>。</p><p>为什么会这样呢？试想一下，如果 <code>JS</code> 里执行的操作需要获取当前 <code>h1</code> 标签的样式，而由于样式没加载完成，所以就无法得到想要的结果，从而证明了 <code>CSS</code> 需要阻塞定义在其之后 <code>JS</code> 的执行。</p><h2 id="JS-加载阻塞"><a href="#JS-加载阻塞" class="headerlink" title="JS 加载阻塞"></a>JS 加载阻塞</h2><p><code>CSS</code> 会阻塞 <code>DOM</code> 的渲染和阻塞定义在其之后的 <code>JS</code> 的执行，那 <code>JS</code> 加载会对渲染过程造成什么影响呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先删除页面中已经存在的 <code>h1</code> 标签（如果存在的话），仔细观察 <code>Elements</code> 面板，当刷新浏览器的时候，一直未加载出 <code>h1</code> 标签（期间页面一直白屏），直到 <code>JS</code> 加载完成后，<code>DOM</code> 中才出现，这足以<strong>说明了 <code>JS</code> 会阻塞定义在其之后的 <code>DOM</code> 的加载</strong>，所以应该将外部 <code>JS</code> 放到 <code>&lt;body&gt;</code> 的最尾部去加载，减少页面加载白屏时间。</p><h2 id="defer-和-async"><a href="#defer-和-async" class="headerlink" title="defer 和 async"></a>defer 和 async</h2><p><code>JS</code> 一定会阻塞定义在其之后的 <code>DOM</code> 的加载嘛？来测试一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段代码的测试结果是当页面中显示出 h1 标签的时候，脚本还没有加载完成，这就说明了 <code>async</code> 脚本不会阻塞 <code>DOM</code> 的加载；同理我们可以用同样的方式测试 <code>defer</code>，也会得到这个结论。</p><p>现在我们知道了通过 <code>defer</code> 或者 <code>async</code> 方式加载 <code>JS</code> 的时候，它是不会阻塞 <code>DOM</code> 加载的。那么你知道 <code>defer</code> 和 <code>async</code> 是什么嘛？它们两者有什么区别呢？</p><p>回答这些疑问之前，我们先来看下当浏览器解析 <code>HTML</code> 遇到 <code>script</code> 标签的时候会发生什么？</p><ul><li>暂停解析 <code>DOM</code>；</li><li>执行 <code>script</code> 里的脚本，如果该 <code>script</code> 是外链，则会先下载它，下载完成后立刻执行；</li><li>执行完成后继续解析剩余 <code>DOM</code>。</li></ul><p>上面这是解析时遇到一个正常的外链的情况，正常外链的下载和执行都会阻塞页面解析；而如果外链是通过 <code>defer</code> 或者 <code>async</code> 加载的时候又会是如何呢？</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_009.png"></p><p><strong><code>defer</code> 特点</strong></p><ul><li>对于 <code>defer</code> 的 <code>script</code>，浏览器会继续解析 <code>html</code>，且同时并行下载脚本，等 <code>DOM</code> 构建完成后，才会开始执行脚本，所以它不会造成阻塞；</li><li><code>defer</code> 脚本下载完成后，执行时间一定是 <code>DOMContentLoaded</code> 事件触发之前执行；</li><li>多个 <code>defer</code> 的脚本执行顺序严格按照定义顺序进行，而不是先下载好的先执行；</li></ul><p><strong><code>async</code> 特点</strong></p><ul><li>对于 <code>async</code> 的 <code>script</code>，浏览器会继续解析 <code>html</code>，且同时并行下载脚本，一旦脚本下载完成会立刻执行；和 <code>defer</code> 一样，它在下载的时候也不会造成阻塞，但是如果它下载完成后 <code>DOM</code> 还没解析完成，则执行脚本的时候是会阻塞解析的；</li><li><code>async</code> 脚本的执行 和 <code>DOMContentLoaded</code> 的触发顺序无法明确谁先谁后，因为脚本可能在 <code>DOM</code> 构建完成时还没下载完，也可能早就下载好了；</li><li>多个 <code>async</code>，按照谁先下载完成谁先执行的原则进行，所以当它们之间有顺序依赖的时候特别容易出错。</li></ul><blockquote><p>defer 和 async 都只能用于外部脚本，如果 script 没有 src 属性，则会忽略它们。</p></blockquote><h2 id="动态脚本会造成阻塞嘛"><a href="#动态脚本会造成阻塞嘛" class="headerlink" title="动态脚本会造成阻塞嘛"></a>动态脚本会造成阻塞嘛</h2><p>对于如下这段代码，当刷新浏览器的时候会发现页面上马上显示出 <code>我是 h1 标签</code>，而过几秒后才加载完动态插入的脚本，所以可以得出结论：<strong>动态插入的脚本不会阻塞页面解析</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略了部分内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span></span><br><span class="line">        script.src = src</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.append(script)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    loadScript(<span class="string">&#x27;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>动态插入的脚本在加载完成后会立即执行，这和 <code>async</code> 一致，所以如果需要保证多个插入的动态脚本的执行顺序，则可以设置 <code>script.async = false</code>，此时动态脚本的执行顺序将按照插入顺序执行和 <code>defer</code> 一样。</p><h2 id="DOMContentLoaded-和-onload"><a href="#DOMContentLoaded-和-onload" class="headerlink" title="DOMContentLoaded 和 onload"></a>DOMContentLoaded 和 onload</h2><p>在浏览器中加载资源涉及到 2 个事件，分别是 <code>DOMContentLoaded</code> 和 <code>onload</code>，那么它们之间有什么区别呢？</p><ul><li><code>onload</code>：当页面所有资源（包括 <code>CSS</code>、<code>JS</code>、图片、字体、视频等）都加载完成才触发，而且它是绑定到 <code>window</code> 对象上；</li><li><code>DOMContentLoaded</code>：当 HTML 已经完成解析，并且构建出了 <code>DOM</code>，但此时外部资源比如样式和脚本可能还没加载完成，并且该事件需要绑定到 <code>document</code> 对象上；</li></ul><p>细心的你一定看到了上面的可能二字，为什么当 <code>DOMContentLoaded</code> 触发的时候样式和脚本是可能还没加载完成呢？</p><h3 id="DOMContentLoaded-遇到脚本"><a href="#DOMContentLoaded-遇到脚本" class="headerlink" title="DOMContentLoaded 遇到脚本"></a>DOMContentLoaded 遇到脚本</h3><p>当浏览器处理一个 <code>HTML</code> 文档，并在文档中遇到 <code>&lt;script&gt;</code> 标签时，就会在继续构建 <code>DOM</code> 之前运行它。这是一种防范措施，因为脚本可能想要修改 <code>DOM</code>，甚至对其执行 <code>document.write</code> 操作，所以 <strong><code>DOMContentLoaded</code> 必须等待脚本执行结束后才触发</strong>。以下这段代码验证了这个结论：当脚本加载完成的时候，<code>Console</code> 面板下才会打印出 <code>DOMContentLoaded</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;DOMContentLoaded&#x27;</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么一定是脚本执行完成后才会触发 <code>DOMContentLoaded</code> 嘛？答案也是否定的，有两个例外，对于 <code>async</code> 脚本和动态脚本是不会阻塞 <code>DOMContentLoaded</code> 触发的。</p><h3 id="DOMContentLoaded-遇到样式"><a href="#DOMContentLoaded-遇到样式" class="headerlink" title="DOMContentLoaded 遇到样式"></a>DOMContentLoaded 遇到样式</h3><p>前面我们已经介绍到 <code>CSS</code> 是不会阻塞 <code>DOM</code> 的解析的，所以理论上 <code>DOMContentLoaded</code> 应该不会等到外部样式的加载完成后才触发，这么分析是对的，让我们用下面代码进行测试一翻就知道了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;DOMContentLoaded&#x27;</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是 h1 标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果：当样式还没加载完成的时候，就已经打印出 <code>DOMContentLoaded</code>，这和我们分析的结果是一致的。但是一定是这样嘛？显然不一定，这里有个小坑，（基于上面代码）在样式后面再加上 <code>&lt;script&gt;</code> 标签的时候，会发现只有等样式加载完成了才会打印出 <code>DOMContentLoaded</code>，为什么会这样呢？正是因为 <code>&lt;script&gt;</code> 会阻塞 <code>DOMContentLoaded</code> 的触发，所以<strong>当外部样式后面有脚本（<code>async</code> 脚本和动态脚本除外）的时候，外部样式就会阻塞 <code>DOMContentLoaded</code> 的触发</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只显示了部分内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://zh.javascript.info/onload-ondomcontentloaded">DOMContentLoaded</a></li><li><a href="https://html.spec.whatwg.org/multipage/scripting.html">https://html.spec.whatwg.org/multipage/scripting.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个页面允许加载的外部资源有很多，常见的有脚本、样式、字体、图片和视频等，对于这些外部资源究竟是如何影响整个页面的加载和渲染的呢？今天我们来一探究竟。&lt;/p&gt;
&lt;p&gt;阅读完这篇文章你将解开如下谜团：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何用 Chrome 定制网络加载速度？&lt;/li&gt;
&lt;li&gt;图片/视频/字体会阻塞页面加载嘛？&lt;/li&gt;
&lt;li&gt;CSS 是如何阻塞页面加载的？&lt;/li&gt;
&lt;li&gt;JS 又是如何阻塞页面加载的？&lt;/li&gt;
&lt;li&gt;JS 一定会阻塞 DOM 加载嘛？&lt;/li&gt;
&lt;li&gt;defer 和 async 是什么？又有何特点？&lt;/li&gt;
&lt;li&gt;动态脚本会造成阻塞嘛？&lt;/li&gt;
&lt;li&gt;阻塞是怎么和 DOMContentLoaded 与 onload 扯上关系的？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>很多人知道 Web Storage，但是你清楚 Cookie 嘛</title>
    <link href="https://bubuzou.com/2020/12/24/browser-store/"/>
    <id>https://bubuzou.com/2020/12/24/browser-store/</id>
    <published>2020-12-24T01:49:25.000Z</published>
    <updated>2021-07-07T07:26:28.837Z</updated>
    
    <content type="html"><![CDATA[<p>可以在浏览器的 <code>Application</code> 面板下看到浏览器的本地存储包含了：<code>Cookie</code>、<code>sessionStorage</code>、<code>localStorage</code> 和 <code>IndexedDB</code>。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_008.png"></p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie-是什么"><a href="#Cookie-是什么" class="headerlink" title="Cookie 是什么"></a>Cookie 是什么</h3><p><code>Cookie</code> 又叫 <code>HTTP Cookie</code> 或者叫浏览器 <code>Cookie</code>。<code>Cookie</code> 的作用是维护服务端和客户端的会话状态，简而言之就是告诉服务器当前客户端用户的一些信息，比如是否登录啥的。</p><a id="more"></a><h3 id="Cookie-是如何工作的"><a href="#Cookie-是如何工作的" class="headerlink" title="Cookie 是如何工作的"></a>Cookie 是如何工作的</h3><p><code>Cookie</code> 通常是由服务端生成，然后通过响应头的 <code>Set-Cookie</code> 发送给客户端浏览器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK</span><br><span class="line">Content-type: text&#x2F;html</span><br><span class="line">Set-Cookie: my_cookie&#x3D;bulandent</span><br></pre></td></tr></table></figure><!-- more  --><p>浏览器会将 <code>Cookie</code> 保存在本地，并且会在下次请求头部的 <code>Cookie</code> 中附上这个值：</p><pre><code>GET /home.html HTTP/1.1Host: www.example.orgCookie: my_cookie=bulandent</code></pre><h3 id="Cookie-分类"><a href="#Cookie-分类" class="headerlink" title="Cookie 分类"></a>Cookie 分类</h3><p>按照 <code>Cookie</code> 的生命周期可以将它分为两类：</p><ul><li>会话 <code>Cookie</code>：没有指定过期时间 （<code>Expires</code>）或有效期（<code>Max-Age</code>）的 <code>Cookie</code>，当浏览器关闭后会被自动删除，但是现在很多浏览器都实现了会话恢复功能，即使浏览器关闭，会话 <code>Cookie</code> 也会被保留下来；这种类型的 <code>Cookie</code> 会保存在浏览器的内存中；</li><li>持久性 <code>Cookie</code>：通过指定过期时间 （<code>Expires</code>）或有效期（<code>Max-Age</code>）的一种 <code>Cookie</code>，存储于客户端硬盘中。设定的日期和时间是指和客户端系统时间进行比较的。</li></ul><h3 id="Cookie-限制"><a href="#Cookie-限制" class="headerlink" title="Cookie 限制"></a>Cookie 限制</h3><p><code>Cookie</code> 会绑定特定的域名（<code>Domain</code>），除此之外，它还有如下一些限制：</p><p>通常，只要遵守以下大致的限制，就不会在任何浏览器中碰到问题：</p><ul><li>不超过 300 个 <code>Cookie</code>；</li><li>每个 <code>Cookie</code> 不超过 4KB；</li><li>每个域名下不超过 20 个 <code>Cookie</code>。</li></ul><p>每个域能设置的 <code>Cookie</code> 总数也是受限的，但不同浏览器的限制不同。例如：</p><ul><li>最新版 IE 和 Edge 限制每个域不超过 50 个 <code>Cookie</code>；</li><li>最新版 Firefox 限制每个域不超过 150 个 <code>Cookie</code>；</li><li>最新版 Opera 限制每个域不超过 180 个 <code>Cookie</code>；</li><li>Safari 和 Chrome 对每个域的 <code>Cookie</code> 数没有硬性限制。</li></ul><p>如果 <code>Cookie</code> 总数超过了单域名的上限，浏览器就会删除之前设置的 <code>Cookie</code>，而删除的逻辑不同浏览器也不大相同。</p><h3 id="Cookie-构成"><a href="#Cookie-构成" class="headerlink" title="Cookie 构成"></a>Cookie 构成</h3><p><code>Cookie</code> 构成除了以上提到的 <code>Name</code>、<code>Value</code>、<code>Domain</code>、<code>Expires/Max-Age</code> 外，还有几个比较重要的需要说下：</p><ul><li><p><code>Path</code>：请求 <code>URL</code> 中包含这个路径才会把 <code>Cookie</code> 发送到服务器；</p></li><li><p><code>Secure</code>：只有 <code>HTTPS</code> 请求才会发送标记为 <code>Secure</code> 的 <code>Cookie</code>；</p></li><li><p><code>HttpOnly</code>：将限制在客户端通过 <code>document.cookie</code> 读取设置为 <code>HttpOnly</code> 的 <code>Cookie</code>；</p></li><li><p><code>SameSite</code>：控制 <code>Cookie</code> 在跨站请求的时候是否会被发送，有 3 个值：</p><ul><li><code>None</code> 允许跨站请求发送；</li><li><code>Lax</code>：允许跨站 <code>GET</code> 请求发送；</li><li><code>Strict</code>：不允许跨站请求发送；</li></ul></li></ul><blockquote><p>除了服务器能够设置 Cookie 外，客户端也可以通过 document.cookie 设置。</p></blockquote><h3 id="Cookie-缺陷"><a href="#Cookie-缺陷" class="headerlink" title="Cookie 缺陷"></a>Cookie 缺陷</h3><ul><li><code>Cookie</code> 会被附加在每个 <code>HTTP</code> 请求中，所以无形中增加了流量；</li><li>由于在 <code>HTTP</code> 请求中的 <code>Cookie</code> 是明文传递的，所以安全性成问题，除非用超文本传输安全协定；</li><li><code>Cookie</code> 的大小限制在 <code>4KB</code> 左右，对于复杂的存储需求来说是不够用的。</li></ul><h3 id="Cookie-安全"><a href="#Cookie-安全" class="headerlink" title="Cookie 安全"></a>Cookie 安全</h3><p>黑客常常会利用 <code>Cookie</code> 进行攻击，比如 <code>XSS</code> 和 <code>CSRF</code> 等；所以为了网站安全，通常需要针对 <code>Cookie</code> 做一些安全措施：</p><ul><li>对特殊的 <code>Cookie</code> 设置 <code>HttpOnly</code>，防止被客户端脚本读取，比如维护登录状态的 <code>Cookie</code> 就可以这么做；</li><li>用于敏感信息（例如指示身份验证）的 <code>Cookie</code> 的生存期应较短，并且 <code>SameSite</code> 属性设置为<code>Strict</code> 或 <code>Lax</code>。</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p><code>Web Storage</code> 存在的目的就是为了解决每次向服务器请求的时候都需要携带 <code>Cookie</code> 信息的问题。<code>Web Storage</code> 包含了 2 个对象：<code>sessionStorage</code> 和 <code>localStorage</code>。通过这 2 个对象实现了：</p><ul><li>提供在 <code>Cookie</code> 之外的存储会话数据的途径；</li><li>提供跨会话持久化存储大量数据的机制。</li></ul><h3 id="Web-Storage-的限制"><a href="#Web-Storage-的限制" class="headerlink" title="Web Storage 的限制"></a>Web Storage 的限制</h3><p>和其他客户端数据存储方案一样，<code>Web Storage</code> 也有限制。</p><ul><li>存储大小：不同浏览器给 <code>sessionStorage</code> 和 <code>localStorage</code> 设置了不同的空间限制，但大多数会限制为每个源 5MB；</li><li>存储类型：只能存储字符串，所以如果数据是对象结构的，需要通过 <code>JSON.stringify</code> 先转成字符串；</li><li>存储限制于同一个源（<code>origin</code>），这也是同源策略的限制之一。即 <code>http://a.com</code> 和 <code>https://a.com</code> 存储的 ``Web Storage` 数据是不相同的。</li></ul><p><code>Web Storage</code> 提供了一套详细的 <code>API</code> 使得我们可以很好的进行数据存储：</p><p><strong>属性</strong></p><ul><li><code>Storage.length</code>：返回一个整数，表示存储在 Storage 对象中的数据项数量。</li></ul><p><strong>方法</strong></p><ul><li><code>Storage.key(n)</code>：该方法接受一个数值 n 作为参数，并返回存储中的第 n 个键名；</li><li><code>Storage.getItem()</code>：该方法接受一个键名作为参数，返回键名对应的值；</li><li><code>Storage.setItem()</code>：该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值；</li><li><code>Storage.removeItem()</code>：该方法接受一个键名作为参数，并把该键名从存储中删除；</li><li><code>Storage.clear()</code>：调用该方法会清空存储中的所有键名。</li></ul><p><code>sessionStorage</code> 和 <code>localStorage</code> 都是 <code>Storage</code> 的实例，所以自然而然的它们都拥有上面的属性和方法。</p><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p><code>sessionStorage</code> 对象只会存储会话数据，这意味着当浏览器 tab 页被关闭的时候，对应的 <code>sessionStorage</code> 数据将被清除。除此之外，它还有如下表现：</p><ul><li>不受页面刷新（包括强制刷新）影响，并且可以在浏览器崩溃并重启后恢复；</li><li>在当前页面通过新标签页或窗口打开一个新页面的时候，新页面会复制父级页面的 <code>sessionStorage</code> 数据；</li><li>使用同一个 <code>URL</code> 打开多个标签页，它们各自的 <code>sessionStorage</code> 数据不同；</li></ul><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>区别于 <code>sessionStorage</code>，<code>localStorage</code> 的存储不受会话限制而且能够长期存储于客户端浏览器中，直到手动删除或者清除浏览器缓存。</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>虽然 <code>Web Storage</code> 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心，这个时候就需要用到 <code>IndexedDB</code>，它类似于 <code>MySQL</code>，但是和传统数据库最大的区别在于，它是适用对象存储而不是表格保存数据。<code>IndexedDB</code> 也受到源的限制。</p><h3 id="和-Web-Storage-的区别"><a href="#和-Web-Storage-的区别" class="headerlink" title="和 Web Storage 的区别"></a>和 Web Storage 的区别</h3><ul><li>存储大小：<code>Web Storage</code> 限制每个源大约 5MB。<code>IndexedDB</code> 的存储空间有 2 个限制：全局限制即为浏览器的最大存储空间一般是可用磁盘空间的 50%；组限制为全局限制的 20%，且它至少有 10MB，最大为 2GB 存储空间；</li><li>存储类型：<code>Web Storage</code> 只能存储字符串，<code>IndexedDB</code> 可以存储字符串、<code>Blob</code> 和 <code>ArrayBuffer</code>；</li><li><code>Web Storage</code> 的存储操作是同步进行的；<code>IndexedDB</code> 由于数据量大，所以多数操作都是异步执行的；</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP Cookies</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria">Browser_storage_limits_and_eviction_criteria</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以在浏览器的 &lt;code&gt;Application&lt;/code&gt; 面板下看到浏览器的本地存储包含了：&lt;code&gt;Cookie&lt;/code&gt;、&lt;code&gt;sessionStorage&lt;/code&gt;、&lt;code&gt;localStorage&lt;/code&gt; 和 &lt;code&gt;IndexedDB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_008.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;h3 id=&quot;Cookie-是什么&quot;&gt;&lt;a href=&quot;#Cookie-是什么&quot; class=&quot;headerlink&quot; title=&quot;Cookie 是什么&quot;&gt;&lt;/a&gt;Cookie 是什么&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Cookie&lt;/code&gt; 又叫 &lt;code&gt;HTTP Cookie&lt;/code&gt; 或者叫浏览器 &lt;code&gt;Cookie&lt;/code&gt;。&lt;code&gt;Cookie&lt;/code&gt; 的作用是维护服务端和客户端的会话状态，简而言之就是告诉服务器当前客户端用户的一些信息，比如是否登录啥的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器专题之缓存篇</title>
    <link href="https://bubuzou.com/2020/12/20/browser-cache/"/>
    <id>https://bubuzou.com/2020/12/20/browser-cache/</id>
    <published>2020-12-20T01:49:25.000Z</published>
    <updated>2021-01-14T02:04:36.932Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器缓存一直是个老生常谈的话题，也是面试官常常用来鉴别面试者的利器，作为前端来讲这块知识是属于必须掌握的，再者利用好缓存也是做性能优化的有效方法。本文将从缓存原因、缓存读写顺序，缓存位置以及缓存策略这几个角度介绍浏览器缓存，并且最后给出实践的应用举例。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_015.png"></p><h2 id="为什么要缓存"><a href="#为什么要缓存" class="headerlink" title="为什么要缓存"></a>为什么要缓存</h2><p>很多同学知道缓存的位置和字段，知道怎么用，但是你有没有想过为什么我们的页面需要浏览器缓存呢？</p><ul><li>缓存可以减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定是比从服务器请求更快的；</li><li>减少网络带宽消耗：对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。试想一下如果可以使用缓存，只会产生极小的网络流量，这将有效的降低运营成本。</li><li>降低服务器压力：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。</li></ul><a id="more"></a><h2 id="缓存读写顺序"><a href="#缓存读写顺序" class="headerlink" title="缓存读写顺序"></a>缓存读写顺序</h2><p>当浏览器对一个资源（比如一个外链的 <code>a.js</code>）进行请求的时候会发生什么？请从缓存的角度大概说下：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_012.png"></p><ol><li>调用 <code>Service Worker</code> 的 <code>fetch</code> 事件获取资源；</li><li>查看 <code>memory cache</code>；</li><li>查看 <code>disk cache</code>；这里又细分：<ul><li>如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200；</li><li>如果有强制缓存但已失效，使用协商缓存，比较后确定 304 还是 200；</li></ul></li><li>发送网络请求，等待网络响应；</li><li>把响应内容存入 <code>disk cache</code> (如果请求头信息配置可以存的话)；</li><li>把响应内容的引用存入 <code>memory cache</code> (无视请求头信息的配置，除了 <code>no-store</code> 之外)；</li><li>把响应内容存入 <code>Service Worker</code> 的 <code>Cache Storage</code> (如果 <code>Service Worker</code> 的脚本调用了 <code>cache.put()</code>)；</li></ol><p>上面这一系列过程其实是浏览器查找缓存和把资源存入缓存的执行流程。这其中出现了很多专业词汇，让人看了一脸懵逼，下面将从缓存位置和缓存策略两个角度简要介绍浏览器的缓存。</p><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_013.png"></p><p>从浏览器开发者工具的 <code>Network</code> 面板下某个请求的 <code>Size</code> 中可以看到当前请求资源的大小以及来源，从这些来源我们就知道该资源到底是从 <code>memory cache</code> 中读取的呢，还是从 <code>disk cache</code> 中读取的，亦或者是服务器返回的。而这些就是缓存位置：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_011.png"></p><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p> 是一个注册在指定源和路径下的事件驱动 <code>worker</code>；特点是：</p><ul><li>运行在 <code>worker</code> 上下文，因此它不能访问 <code>DOM</code>；</li><li>独立于主线程之外，不会造成阻塞；</li><li>设计完全异步，所以同步 <code>API</code>（如 <code>XHR</code> 和 <code>localStorage</code> ）不能在 <code>Service Worker</code> 中使用；</li><li>最后处于安全考虑，必须在 <code>HTTPS</code> 环境下才可以使用；</li></ul><p>说了这么多特点，那它和缓存有啥关系？其实它有一个功能就是离线缓存：<code>Service Worker Cache</code>；区别于浏览器内部的 <code>memory cache</code> 和 <code>disk cache</code>，它允许我们自己去操控缓存，具体操作过程可以参看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers">Using_Service_Workers</a>；通过 <code>Service Worker</code> 设置的缓存会出现在浏览器开发者工具 <code>Application</code> 面板下的 <code>Cache Storage</code> 中。</p><h3 id="memory-cache"><a href="#memory-cache" class="headerlink" title="memory cache"></a>memory cache</h3><p>是浏览器内存中的缓存，相比于 <code>disk cache</code> 它的特点是读取速度快，但容量小，且时效性短，一旦浏览器 <code>tab</code> 页关闭，<code>memory cache</code> 就将被清空。<code>memory cache</code> 会自动缓存所有资源嘛？答案肯定是否定的，当 <code>HTTP</code> 头设置了 <code>Cache-Control: no-store</code> 的时候或者浏览器设置了 <code>Disabled cache</code> 就无法把资源存入内存了，其实也无法存入硬盘。当从 <code>memory cache</code> 中查找缓存的时候，不仅仅会去匹配资源的 <code>URL</code>，还会看其 <code>Content-type</code> 是否相同。</p><h3 id="disk-cache"><a href="#disk-cache" class="headerlink" title="disk cache"></a>disk cache</h3><p>也叫 <code>HTTP cache</code> 是存在硬盘中的缓存，根据 <code>HTTP</code> 头部的各类字段进行判定资源的缓存规则，比如是否可以缓存，什么时候过期，过期之后需要重新发起请求吗？相比于 <code>memory cache</code> 的 <code>disk cache</code> 拥有存储空间时间长等优点，网站中的绝大多数资源都是存在 <code>disk cache</code> 中的。</p><blockquote><p>浏览器如何判断一个资源是存入内存还是硬盘呢？关于这个问题，网上说法不一，不过比较靠谱的观点是：对于大文件大概率会存入硬盘中；当前系统内存使用率高的话，文件优先存入硬盘。</p></blockquote><p>缓存按照缓存位置划分，其实还有一个 <code>HTTP/2</code> 的内容 <code>push cache</code>，由于目前国内对 <code>HTTP/2</code> 应用还不广泛，且网上对 <code>push cache</code> 的知识还不齐全，所以本篇不打算介绍这块，感兴趣的可以阅读这篇文章：<a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">HTTP/2 push is tougher than I thought</a></p><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_014.png"></p><p>根据 <code>HTTP header</code> 的字段又可以将缓存分成强缓存和协商缓存。强缓存可以直接从缓存中读取资源返回给浏览器而不需要向服务器发送请求，而协商缓存是当强缓存失效后（过了过期时间），浏览器需要携带缓存标识向服务器发送请求，服务器根据缓存标识决定是否使用缓存的过程。强缓存的字段有：<code>Expires</code> 和 <code>Cache-Control</code>。协商缓存的字段有：<code>Last-Modified</code> 和 <code>ETag</code>。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code> 是 <code>HTTP/1.0</code> 的字段，表示缓存过期时间，它是一个 <code>GMT</code> 格式的时间字符串。<code>Expires</code> 需要在服务端配置（具体配置也根据服务器而定），浏览器会根据该过期日期与客户端时间对比，如果过期时间还没到，则会去缓存中读取该资源，如果已经到期了，则浏览器判断为该资源已经不新鲜要重新从服务端获取。由于 <code>Expires</code> 是一个绝对的时间，所以会局限于客户端时间的准确性，从而可能会出现浏览器判断缓存失效的问题。如下是一个 <code>Expires</code> 示例，是一个日期/时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 21 Oct 2020 07:28:00 GMT</span><br></pre></td></tr></table></figure><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>它是 <code>HTTP/1.1</code> 的字段，其中的包含的值很多：</p><ul><li><code>max-age</code> 最大缓存时间，值的单位是秒，在该时间内，浏览器不需要向浏览器请求。这个设置解决了 <code>Expires</code> 中由于客户端系统时间不准确而导致缓存失效的问题；</li><li><code>must-revalidate</code>：如果超过了 <code>max-age</code> 的时间，浏览器必须向服务器发送请求，验证资源是否还有效；</li><li><code>public</code> 响应可以被任何对象（客户端、代理服务器等）缓存；</li><li><code>private</code> 响应只能被客户端缓存；</li><li><code>no-cache</code> 跳过强缓存，直接进入协商缓存阶段；</li><li><code>no-store</code> 不缓存任何内容，设置了这个后资源也不会被缓存到内存和硬盘；</li></ul><p><code>Cache-Control</code> 的值是可以混合使用的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private, max-age&#x3D;0, no-cache</span><br></pre></td></tr></table></figure><p>当混合使用的时候它们的优先级如下图所示：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_003.png"></p><p><strong>当 <code>Expires</code> 和 <code>Cache-Control</code> 都被设置的时候，浏览器会优先考虑后者</strong>。当强缓存失效的时候，则会进入到协商缓存阶段。具体细节是这样：浏览器从本地查找强缓存，发现失效了，然后会拿着缓存标识请求服务器，服务器拿着这个缓存标识和对应的字段进行校验资源是否被修改，如果没有被修改则此时响应状态会是 304，且不会返回请求资源，而是直接从浏览器缓存中读取。</p><p>而浏览器缓存标识可以是：<code>Last-Modified</code> 和 <code>ETag</code>：</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>资源的最后修改时间；第一次请求的时候，响应头会返回该字段告知浏览器资源的最后一次修改时间；浏览器会将值和资源存在缓存中；再次请求该资源的时候，如果强缓存过期，则浏览器会设置请求头的 <code>If-Modifined-Since</code> 字段值为存储在缓存中的上次响应头 <code>Last-Modified</code> 的值，并且发送请求；服务器拿着 <code>If-Modifined-Since</code> 的值和 <code>Last-Modified</code> 进行对比。如果相等，表示资源未修改，响应 304；如果不相等，表示资源被修改，响应 200，且返回请求资源。如果资源更新的速度是小于 1 秒的，那么该字段将失效，因为 <code>Last-Modified</code> 时间是精确到秒的。所以有了 <code>ETag</code>。</p><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>根据资源内容生成的唯一标识，资源是否被修改的判断过程和上面的一致，只是对应的字段替换了。<code>Last-Modified</code> 替换成 <code>ETag</code>，<code>If-Modifined-Since</code> 替换成 <code>If-None-Match</code>。</p><p>当 <code>Last-Modified</code> 和 <code>ETag</code> 都被设置的时候，浏览器会优先考虑后者。</p><h2 id="浏览器的行为"><a href="#浏览器的行为" class="headerlink" title="浏览器的行为"></a>浏览器的行为</h2><ul><li>浏览器地址栏输入 <code>URL</code> 后回车： 查找 <code>disk cache</code> 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (⌘ + R)：因为 <code>TAB</code> 页并没有关闭，因此 <code>memory cache</code> 是可用的，会被优先使用(如果匹配的话)，其次才是 <code>disk cache</code>。</li><li>强制刷新 (⇧ + ⌘ + R)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了 <code>Pragma: no-cache</code>)。服务器直接返回 200 和最新内容。</li><li>当在开发者工具 <code>Network</code> 面板下设置了 <code>Disabled cache</code> 禁用缓存后，浏览器将不会从 <code>memory cache</code> 或者 <code>disk cache</code> 中读取缓存，而是直接发起网络请求。</li></ul><h2 id="缓存应用"><a href="#缓存应用" class="headerlink" title="缓存应用"></a>缓存应用</h2><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>比如页面引入了一个 <code>JQuery</code>，对于页面来说这个脚本就是一个工具库，基本上是不会发生变化的，对于这种资源可以将它的缓存时间设置得长一点，比如如下这个地址的脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>你会看到它的响应头里设置了，<code>max-age=2592000</code> 直接缓存 30 天：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: public, max-age&#x3D;2592000</span><br></pre></td></tr></table></figure><h3 id="频繁变化的资源"><a href="#频繁变化的资源" class="headerlink" title="频繁变化的资源"></a>频繁变化的资源</h3><p>对于频繁变化的资源，比如某个页面经常需要调整，那么这个页面就需要在每次请求的时候都进行验证，可以在响应头这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: no-cache</span><br></pre></td></tr></table></figure><h3 id="不进行缓存"><a href="#不进行缓存" class="headerlink" title="不进行缓存"></a>不进行缓存</h3><p>当然并不是所有请求都能被缓存，无法被浏览器缓存的请求如下：</p><ol><li><code>HTTP</code> 信息头中包含 <code>Cache-Control: no-cache</code> ，<code>pragma: no-cache（HTTP1.0）</code>，或 <code>Cache-Control: max-age=0</code> 等告诉浏览器不用缓存的请求；</li><li>需要根据 <code>Cookie</code>、认证信息等决定输入内容的动态请求是不能被缓存的；</li><li>经过 <code>HTTPS</code> 安全加密的请求；</li><li><code>POST</code> 请求无法被缓存；</li><li><code>HTTP</code> 响应头中不包含 <code>Last-Modified/Etag</code>，也不包含 <code>Cache-Control/Expires</code> 的请求无法被缓存；</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/ljianshu/Blog/issues/23">深入理解浏览器的缓存机制</a></li><li><a href="https://juejin.cn/post/6844903747357769742">一文读懂前端缓存</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service_Worker_API</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器缓存一直是个老生常谈的话题，也是面试官常常用来鉴别面试者的利器，作为前端来讲这块知识是属于必须掌握的，再者利用好缓存也是做性能优化的有效方法。本文将从缓存原因、缓存读写顺序，缓存位置以及缓存策略这几个角度介绍浏览器缓存，并且最后给出实践的应用举例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_015.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么要缓存&quot;&gt;&lt;a href=&quot;#为什么要缓存&quot; class=&quot;headerlink&quot; title=&quot;为什么要缓存&quot;&gt;&lt;/a&gt;为什么要缓存&lt;/h2&gt;&lt;p&gt;很多同学知道缓存的位置和字段，知道怎么用，但是你有没有想过为什么我们的页面需要浏览器缓存呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存可以减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定是比从服务器请求更快的；&lt;/li&gt;
&lt;li&gt;减少网络带宽消耗：对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。试想一下如果可以使用缓存，只会产生极小的网络流量，这将有效的降低运营成本。&lt;/li&gt;
&lt;li&gt;降低服务器压力：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从输入 URL 到页面显示发生了什么</title>
    <link href="https://bubuzou.com/2020/12/16/browser-url/"/>
    <id>https://bubuzou.com/2020/12/16/browser-url/</id>
    <published>2020-12-16T01:49:25.000Z</published>
    <updated>2021-01-14T02:01:49.390Z</updated>
    
    <content type="html"><![CDATA[<p>读了李兵老师的 <a href="https://time.geekbang.org/column/article/117637">浏览器的工作原理与实践</a>，让我对浏览器的工作原理有了更加深刻的理解，尤其是从用户输入 URL 到页面显示这一过程发生的事情，以往看的文章都是点到为止，而他却说得面面俱到非常详细，遂我把内容总结了一下分享给大家，值得你花个 5 分钟阅读一下。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_002.png"></p><a id="more"></a><h2 id="用户输入阶段"><a href="#用户输入阶段" class="headerlink" title="用户输入阶段"></a>用户输入阶段</h2><ol><li>合成 <code>URL</code>：用户输入 <code>URL</code>，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容 + 默认搜索引擎合成新的 <code>URL</code>；如果用户输入的内容符合 <code>URL</code> 规则，浏览器就会根据 <code>URL</code> 协议，在这段内容上加上协议合成合法的 <code>URL</code>；</li><li>加载：用户输入完内容，按下回车键，浏览器导航栏显示 <code>loading</code> 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得；</li></ol><h2 id="发起URL请求阶段"><a href="#发起URL请求阶段" class="headerlink" title="发起URL请求阶段"></a>发起URL请求阶段</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_001.png"></p><ol><li>构建请求：浏览器进程首先会构建请求行信息，然后通过进程间通信（<code>IPC</code>）将 <code>URL</code> 请求发送给网络进程；</li><li>查找缓存：网络进程获取到 <code>URL</code>，先去本地缓存中查找是否有缓存资源，如果有则拦截请求，直接将缓存资源返回给浏览器进程；否则，进入网络请求阶段；</li><li><code>DNS</code> 解析：网络进程请求首先会从 <code>DNS</code> 数据缓存服务中查找是否缓存过当前域名信息，有则直接返回；否则，会进行 <code>DNS</code> 解析返回域名对应的 <code>IP</code> 和端口号，如果没有指定端口号，<code>http</code> 默认 80 端口，<code>https</code> 默认 443。如果是 <code>https</code> 请求，还需要建立 <code>TLS</code> 连接；</li><li>等待 <code>TCP</code> 队列：<code>Chrome</code> 有个机制，同一个域名同时最多只能建立 6 个 <code>TCP</code> 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立 <code>TCP</code> 连接；</li><li>建立 <code>TCP</code> 连接：<code>TCP</code> 三次握手与服务器建立连接，然后进行数据的传输，最后；</li><li>发送 <code>HTTP</code> 请求：浏览器首先会向服务器发送请求行，它包含了请求方法、请求 <code>URI</code> 和 <code>HTTP</code> 协议的版本；另外还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核，请求域名、<code>Cookie</code> 等；如果需要传递参数，则还需要发送请求体；</li><li>服务器处理请求：服务器首先返回响应行，包括协议版本和状态码，比如状态码 200 表示继续处理该请求；（如果是 301，则表示重定向，将会在响应头的 <code>Locaiton</code> 字段中加上重定向的地址信息，接下来浏览器获取这个地址，将会重新导航。）服务器也会向浏览器发送响应头，包含了一些信息，比如服务器生成返回数据的时间、返回的数据类型（<code>JSON</code>、<code>HTML</code>、流媒体等类型），以及服务器要在客户端保存的 <code>Cookie</code> 等；继续发送响应体的数据；</li><li>断开 <code>TCP</code> 连接：数据传输完成，正常情况下 <code>TCP</code> 将四次挥手断开连接。但是如果浏览器或者服务器在HTTP头部加上 <code>Connection: keep-alive</code>，<code>TCP</code> 就会一直保持连接。保持 <code>TCP</code> 连接可以省下下次需要建立连接的时间，提示资源加载速度；</li></ol><h2 id="准备渲染进程阶段"><a href="#准备渲染进程阶段" class="headerlink" title="准备渲染进程阶段"></a>准备渲染进程阶段</h2><ol><li>网络进程将获取到的数据包进行解析，根据响应头中的 <code>Content-type</code> 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 <code>text/html</code> 类型，就通知浏览器进程获取到的是 <code>HTML</code>，应该准备渲染进程了；</li><li>正常情况下每个浏览器的 tab 会对应一个渲染进程，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程，否则就会创建一个新的渲染进程；</li></ol><h2 id="提交文档阶段"><a href="#提交文档阶段" class="headerlink" title="提交文档阶段"></a>提交文档阶段</h2><ol><li>渲染进程准备好后，浏览器会发出 “提交文档” 的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的 “管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程；</li><li>浏览器收到 “确认提交” 的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 <code>URL</code>、前进后退的历史状态，并更新 <code>web</code> 页面，此时的 <code>web</code> 页面是空白页；</li></ol><h2 id="页面渲染阶段"><a href="#页面渲染阶段" class="headerlink" title="页面渲染阶段"></a>页面渲染阶段</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_010.png"></p><ol><li><p>文档一旦提交，渲染进程将开始页面解析和子资源加载；渲染阶段比较复杂，所以将分为多个子阶段，按照渲染的时间顺序可以分为：构建 <code>DOM</code> 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成；</p></li><li><p>构建 <code>DOM</code> 树：<code>HTML</code> 经过解析后输出一个以 <code>document</code> 为顶层节点的树状结构的 <code>DOM</code>；</p></li><li><p>样式计算：这里有 3 个步骤：</p><ul><li>将 3 个来源（<code>&lt;link&gt;</code> 标签引入的外部样式、<code>&lt;style&gt;</code> 标签里定义的样式、以及元素的 <code>style</code> 属性上的样式）的 <code>CSS</code> 转化成浏览器能够理解的结构 <code>styleSheets</code>；</li><li>转换样式表中的属性值，使其标准化；比如 <code>font-weight: bold;</code> 会转成 <code>font-weight: 700;</code>、<code>color: blue;</code> 会转成 <code>color: rgb(0, 0, 255);</code> 等；</li><li>依据 <code>CSS</code> 的继承和层叠规则计算出 <code>DOM</code> 树中每个节点的具体样式；</li></ul></li><li><p>布局阶段：<code>DOM</code> 树中依然存在许多不可见的元素（比如 <code>head</code>），这些元素对于布局是丝毫没用的，所以又会生成一棵只包含可见元素的布局树；然后再根据布局树的每个节点计算出其具体位置和尺寸大小；</p></li><li><p>分层：页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 <code>z-index</code> 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树；关于层叠上下文的知识，具体可以参考这里<a href="https://juejin.cn/post/6844903667175260174">彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index</a>；</p></li><li><p>绘制：为每个图层生成绘制列表，并将其提交到合成线程；</p></li><li><p>光栅化：通常一个页面很大，而视口很局限，所以合成线程会按照视口附近的图块来优先生成位图，并在光栅化线程池中将图块转换成位图；</p></li><li><p>合成：一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 <code>DrawQuad</code>，然后将该命令提交给浏览器进程；之后浏览器将开始生成显示页面。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读了李兵老师的 &lt;a href=&quot;https://time.geekbang.org/column/article/117637&quot;&gt;浏览器的工作原理与实践&lt;/a&gt;，让我对浏览器的工作原理有了更加深刻的理解，尤其是从用户输入 URL 到页面显示这一过程发生的事情，以往看的文章都是点到为止，而他却说得面面俱到非常详细，遂我把内容总结了一下分享给大家，值得你花个 5 分钟阅读一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_002.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器专题之事件机制</title>
    <link href="https://bubuzou.com/2020/12/11/browser-event/"/>
    <id>https://bubuzou.com/2020/12/11/browser-event/</id>
    <published>2020-12-11T01:49:25.000Z</published>
    <updated>2021-01-14T02:01:38.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>在早期 <code>IE</code> 和 <code>Netscape</code> 团队在开发第四代浏览器的时候，遇到一个问题：当点击一个按钮的时候，是应该先处理父级的事件呢？还是应该先处理按钮的事件呢？<code>IE</code> 和 <code>Netscape</code> 给出了 2 种完全相反的答案，<code>IE</code> 提出事件冒泡的概念，而 <code>Netscape</code> 则支持事件捕获。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡认为事件应该由最具体的元素开始触发，然后层层往父级传播：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/eventFlow1.png"></p><a id="more"></a><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>而事件捕获则相反，认为最外层的元素应该最先收到事件，然后层层往下级传递：</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/eventFlow2.png"></p><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>为了在浏览器中兼容这 2 种事件流，在 <code>DOM2 Events</code> 规范中将事件流分为 3 个阶段：事件捕获阶段、到底目标阶段、事件冒泡阶段。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/eventFlow3.png"></p><p>可以通过指定 <code>addEventListener</code> 的第三个参数为 <code>true</code> 来设置事件是在捕获阶段调用事件处理程序，默认是 <code>false</code> 指在冒泡阶段调用事件处理程序。</p><blockquote><p>所有现代浏览器都支持 <code>DOM</code> 事件流，只有 IE8 及更早版本不支持。</p></blockquote><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><h3 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h3><p>就是将事件处理程序直接绑定到 <code>HTML</code> 的属性中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;hello world&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">方式二</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;print(event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">e</span>) </span>&#123; &#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>HTML</code> 事件处理程序修改事件相对麻烦，可能需要同时修改 <code>HTML</code> 和 <code>JS</code>，所以大家都不爱使用这种方式绑定事件。</p><h3 id="DOM0-事件处理程序"><a href="#DOM0-事件处理程序" class="headerlink" title="DOM0 事件处理程序"></a>DOM0 事件处理程序</h3><p>将一个函数赋值给 <code>DOM</code> 元素的一个事件处理程序属性，比如 <code>onclick</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line">btn.onclick = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="DOM2-事件处理程序"><a href="#DOM2-事件处理程序" class="headerlink" title="DOM2 事件处理程序"></a>DOM2 事件处理程序</h3><p>通过 <code>addEventListener</code> 可以添加 <code>DOM2</code> 级别的事件处理程序，它接收 3 个参数：事件名、事件处理程序和 <code>useCapture</code> （它是一个可选参数，是个布尔值，默认为 <code>false</code> 表示在冒泡阶段调用事件处理程序）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>和 <code>DOM0</code> 事件处理程序的区别：</p><ul><li><code>addEventListener</code> 可以改变事件流，即可以在捕获阶段触发事件，而 <code>DOM0</code> 是不行的；</li><li><code>addEventListener</code> 可以为同一个元素多次添加同一类型的事件处理程序，先添加的事件处理程序会先触发，而 <code>DOM0</code> 如果给同一个元素绑定多个相同类型的事件处理程序的话，则后面添加的会覆盖前面定义的；</li></ul><p>它有几个注意事项：</p><ul><li>如果不需要在捕获阶段进行拦截操作，则 <code>useCapture</code> 即第三个参可以不传；</li><li>通过 <code>addEventListener</code> 添加的事件处理程序只能通过 <code>removeEventListener</code> 移除，而且绑定的事件处理程序必须是同一个。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler)</span><br><span class="line">btn.removeEventListener(<span class="string">&quot;click&quot;</span>, handler)</span><br></pre></td></tr></table></figure><h3 id="IE-事件处理函数"><a href="#IE-事件处理函数" class="headerlink" title="IE 事件处理函数"></a>IE 事件处理函数</h3><p>由于 <code>addEventListener</code> 无法兼容 IE8 及更早版本，所以此时就可以使用 <code>attachEvent</code> 添加事件处理程序和用 <code>detachEvent</code> 移除事件处理程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;)</span><br></pre></td></tr></table></figure><p>它有这么几个注意事项：</p><ul><li>注册的事件名和 <code>DOM0</code> 一样，需要带上 <code>on</code>，比如 <code>onclick</code>；</li><li>在通过 <code>attachEvent</code> 添加的事件处理程序内部 <code>this</code> 会指向 <code>window</code>，而 <code>DOM0</code> 和 <code>DOM2</code> 的 <code>this</code> 会指向元素本身；</li><li>和 <code>addEventListener</code> 一样， <code>attachEvent</code> 也可以针对同一元素多次添加同一个事件类型的处理程序，但是触发顺序是后定义的先触发；</li><li>通过 <code>detachEvent</code> 移除事件处理程序的时候，处理函数必须是和注册的同一个，这点和 <code>addEventListener</code> 保持一致；</li></ul><p><code>attachEvent</code> 和 <code>detachEvent</code> 是 <code>IE</code> 专属的 <code>API</code>，所以如果有兼容性要求，我们可以写出跨浏览器的事件处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">            element.attachEvent(<span class="string">&quot;on&quot;</span> + type, handler)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">            element.detachEvent(<span class="string">&quot;on&quot;</span> + type, handler)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>通过不同的事件处理程序添加的事件，<code>event</code> 对象的属性略有不同，我们不需要记住他们的差异，只需要在平时写代码的时候养成一个写兼容代码的习惯即可，如下是一个兼容各种 <code>event</code> 对象的事件处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 事件对象</span></span><br><span class="line">    <span class="keyword">let</span> event = event || <span class="built_in">window</span>.event</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标元素</span></span><br><span class="line">    <span class="keyword">let</span> target = event.target || event.srcElement</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阻止默认事件触发</span></span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">        event.preventDefault()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event.returnValue = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阻止事件冒泡</span></span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">        event.stopPropagation()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event.cancelBubble = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p><code>DOM3 Events</code> 定义了如下事件类型：</p><ul><li>用户界面事件(<code>UIEvent</code>)：涉及与 <code>BOM</code> 交互的通用浏览器事件，比如 <code>onload</code>、<code>resize</code>、<code>scroll</code>、<code>input</code>、<code>select</code> 等；</li><li>焦点事件(<code>FocusEvent</code>)：在元素获得和失去焦点时触发，比如 <code>focus</code>、<code>blur</code>；</li><li>鼠标事件(<code>MouseEvent</code>)：使用鼠标在页面上执行某些操作时触发，比如 <code>click</code>、<code>mousedown</code>、<code>mouseover</code> 等；</li><li>滚轮事件(<code>WheelEvent</code>)：使用鼠标滚轮(或类似设备)时触发，比如 <code>mousewheel</code>；</li><li>输入事件(<code>InputEvent</code>)：向文档中输入文本时触发，比如 <code>textInput</code>；</li><li>键盘事件(<code>KeyboardEvent</code>)：使用键盘在页面上执行某些操作时触发，比如 <code>keydown</code>、<code>keypress</code>；</li><li>合成事件(<code>CompositionEvent</code>)：在使用某种 <code>IME</code>(<code>Input Method Editor</code>，输入法编辑器)输入字符时触发，比如 <code>compositionstart</code>。</li></ul><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托是指将多个元素上绑定的事件通过利用事件冒泡的原理从而转移到他们共同的父级上去绑定，从而在一定程度上起到优化的作用，有的人也喜欢叫它事件代理。比如在 <code>Vue</code> 中经常会将事件绑定到每个列表项中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick(item)&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">其实更好的做法是利用事件委托，将事件绑定到 `ul` 上：</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:data-item</span>=<span class="string">&quot;item&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleClick(event) &#123;</span><br><span class="line">    <span class="keyword">let</span> target = event.target</span><br><span class="line">    <span class="keyword">if</span> (target === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = target.dataset.item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h2&gt;&lt;p&gt;在早期 &lt;code&gt;IE&lt;/code&gt; 和 &lt;code&gt;Netscape&lt;/code&gt; 团队在开发第四代浏览器的时候，遇到一个问题：当点击一个按钮的时候，是应该先处理父级的事件呢？还是应该先处理按钮的事件呢？&lt;code&gt;IE&lt;/code&gt; 和 &lt;code&gt;Netscape&lt;/code&gt; 给出了 2 种完全相反的答案，&lt;code&gt;IE&lt;/code&gt; 提出事件冒泡的概念，而 &lt;code&gt;Netscape&lt;/code&gt; 则支持事件捕获。&lt;/p&gt;
&lt;h3 id=&quot;事件冒泡&quot;&gt;&lt;a href=&quot;#事件冒泡&quot; class=&quot;headerlink&quot; title=&quot;事件冒泡&quot;&gt;&lt;/a&gt;事件冒泡&lt;/h3&gt;&lt;p&gt;事件冒泡认为事件应该由最具体的元素开始触发，然后层层往父级传播：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/eventFlow1.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器专题之安全篇</title>
    <link href="https://bubuzou.com/2020/12/04/web-security/"/>
    <id>https://bubuzou.com/2020/12/04/web-security/</id>
    <published>2020-12-04T01:49:25.000Z</published>
    <updated>2021-03-10T15:27:17.919Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_safe.png"></p><h2 id="同源策略（Same-Origin-Policy）"><a href="#同源策略（Same-Origin-Policy）" class="headerlink" title="同源策略（Same Origin Policy）"></a>同源策略（Same Origin Policy）</h2><p>如果两个 <code>URL</code> 的协议、域名和端口都相同，我们就称这两个 <code>URL</code> 同源。</p><p>比如，这个 <code>http://store.company.com/dir/page.html</code> 和下面这些 <code>URL</code> 相比源的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;store.company.com&#x2F;dir2&#x2F;other.html         &#x2F;&#x2F; 同源，只有路径不同</span><br><span class="line">http:&#x2F;&#x2F;store.company.com&#x2F;dir&#x2F;inner&#x2F;another.html  &#x2F;&#x2F; 同源，只有路径不同</span><br><span class="line">https:&#x2F;&#x2F;store.company.com&#x2F;secure.html            &#x2F;&#x2F; 失败，协议不同</span><br><span class="line">http:&#x2F;&#x2F;news.company.com&#x2F;dir&#x2F;other.html           &#x2F;&#x2F; 失败，域名不同</span><br><span class="line">http:&#x2F;&#x2F;store.company.com:81&#x2F;dir&#x2F;etc.html         &#x2F;&#x2F; 失败，端口不同 ( http:&#x2F;&#x2F; 默认端口是80)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="同源策略的限制"><a href="#同源策略的限制" class="headerlink" title="同源策略的限制"></a>同源策略的限制</h3><ul><li>限制了来自不同源的 <code>JavaScript</code> 脚本对当前 <code>DOM</code> 对象读和写的操作；</li><li>限制了不同源的站点读取当前站点的 <code>Cookie</code>、<code>IndexDB</code>、<code>LocalStorage</code> 等数据；</li><li>限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li></ul><p>由于浏览器同源策略的限制使得 Web 项目难以开发和使用，所以为了既保证安全性又能够灵活开发 Web 应用，<strong>从而出现了一些新技术</strong></p><ul><li>页面中可以引用第三方资源，不过这也暴露了很多诸如 <code>XSS</code> 的安全问题，因此又在这种开放的基础之上引入了内容安全策略 <code>CSP</code> 来限制其自由程度；</li><li>使用 <code>XMLHttpRequest</code> 和 <code>Fetch</code> 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略 <code>CORS</code>，让其可以安全地进行跨域操作；</li><li>两个不同源的 <code>DOM</code>是不能相互操纵的，因此浏览器中又实现了跨文档消息机制，让其可以比较安全地通信，可以通过 <code>window.postMessage</code> 的 <code>JavaScript</code> 接口来和不同源的 <code>DOM</code> 进行通信。</li></ul><h2 id="内容安全策略（CSP）"><a href="#内容安全策略（CSP）" class="headerlink" title="内容安全策略（CSP）"></a>内容安全策略（CSP）</h2><p>内容安全策略（<code>Content Security Policy</code>）简称 <code>CSP</code>，通过它可以明确的告诉客户端浏览器当前页面的哪些外部资源可以被加载执行，而哪些又是不可以的。</p><h3 id="2-种方式启用-CSP"><a href="#2-种方式启用-CSP" class="headerlink" title="2 种方式启用 CSP"></a>2 种方式启用 CSP</h3><ul><li>通过 <code>HTTP</code> 头配置 <code>Content-Security-Policy</code>，以下配置说明该页面只允许当前源和 <code>https://apis.google.com</code> 这 2 个源的脚本加载和执行：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src &#39;self&#39; https:&#x2F;&#x2F;apis.google.com</span><br></pre></td></tr></table></figure><ul><li>通过页面 <code>&lt;meta&gt;</code> 标签配置：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;script-src &#x27;self&#x27; https://apis.google.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSP-的限制"><a href="#CSP-的限制" class="headerlink" title="CSP 的限制"></a>CSP 的限制</h3><p><code>CSP</code> 提供了丰富的限制，<strong>除了能限制脚本的加载和执行，对其他资源也有限制</strong>，比如：</p><ul><li><code>font-src</code>：字体来源；</li><li><code>img-src</code>：图片来源；</li><li><code>style-src</code>：样式来源；</li></ul><p>以上只是列举了一些常见的外部资源的限制，想要查看更多资源限制<a href="https://developers.google.com/web/fundamentals/security/csp">可以看这里</a>。</p><p>默认情况下，这些指令的适用范围很广。如果您不为某条指令（例如，<code>font-src</code>）设置具体的策略，则默认情况下，该指令在运行时假定您指定 <code>*</code> 作为有效来源（例如，您可以从任意位置加载字体，没有任何限制。</p><p>另外你可以通过 <code>default-src</code> 设置资源限制的默认行为，但它只适用于 <code>-src</code> 结尾的所有指令，比如设置了如下的 <code>CSP</code> 规则，则只允许从 <code>https://cdn.example.net</code> 加载脚本、字体、图片、样式等资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src https:&#x2F;&#x2F;cdn.example.net</span><br></pre></td></tr></table></figure><h3 id="CSP-配置事项"><a href="#CSP-配置事项" class="headerlink" title="CSP 配置事项"></a>CSP 配置事项</h3><p>如果要配置多个同一类型的资源限制，需要将它们进行合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src https:&#x2F;&#x2F;host1.com https:&#x2F;&#x2F;host2.com</span><br></pre></td></tr></table></figure><p>不同的资源类型之间需要用分号分隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src https:&#x2F;&#x2F;host1.com; img-src https:&#x2F;&#x2F;host2.com</span><br></pre></td></tr></table></figure><p>可以通过以下值来灵活配置来源列表：</p><ul><li>协议：<code>https:</code>、<code>data:</code>；</li><li>主机名：<code>example.com</code>、<code>example.com:443</code>；</li><li>路径名：<code>example.com/js</code>；</li><li>通配符：<code>*://*.example.com:*</code>。</li></ul><p>还可以给来源列表指定关键字，包含如下 4 个关键字，使用关键字需要加上单引号：</p><ul><li><code>&#39;none&#39;</code>：不执行任何匹配；</li><li><code>&#39;self&#39;</code>：与当前来源（而不是其子域）匹配；</li><li><code>&#39;unsafe-inline&#39;</code>：允许使用内联 <code>JavaScript</code> 和 <code>CSS</code>；</li><li><code>&#39;unsafe-eval&#39;</code>：允许使用类似 <code>eval</code> 的 <code>text-to-JavaScript</code> 机制。</li></ul><h3 id="CSP-应用举例"><a href="#CSP-应用举例" class="headerlink" title="CSP 应用举例"></a>CSP 应用举例</h3><p>让我们假设一下，您在运行一个银行网站，并希望确保只能加载您自己写入的资源。 在此情形下，首先设置一个阻止所有内容的默认政策 (<code>default-src &#39;none&#39;</code>)，然后在此基础上逐步构建。</p><p>假设此银行网站在 <code>https://cdn.mybank.net</code> 上加载所有来自 <code>CDN</code> 的图像、样式和脚本，并通过 <code>XHR</code> 连接到 <code>https://api.mybank.com/</code> 以抽取各种数据。可使用帧，但仅用于网站的本地页面（无第三方来源）。 网站上没有 <code>Flash</code>，也没有字体和 <code>Extra</code>。 我们能够发送的最严格的 <code>CSP</code> 标头为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#39;none&#39;; script-src https:&#x2F;&#x2F;cdn.mybank.net; style-src https:&#x2F;&#x2F;cdn.mybank.net; img-src https:&#x2F;&#x2F;cdn.mybank.net; connect-src https:&#x2F;&#x2F;api.mybank.com; child-src &#39;self&#39;</span><br></pre></td></tr></table></figure><h2 id="安全沙箱（Sandbox）"><a href="#安全沙箱（Sandbox）" class="headerlink" title="安全沙箱（Sandbox）"></a>安全沙箱（Sandbox）</h2><p>我们知道早期的浏览器是单进程架构的，这样当某个标签页挂了之后，将影响到整个浏览器。所以出现了多进程架构，它通过给每个标签页分配一个渲染进程解决了这个问题。</p><p>而渲染进程的工作是进行 <code>HTML</code>、<code>CSS</code> 的解析，<code>JavaScript</code> 的执行等，而这部分内容是直接暴露给用户的，所以也是最容易被黑客利用攻击的地方，如果黑客攻击了这里就有可能获取到渲染进程的权限，进而威胁到操作系统。所以需要一道墙用来把不可信任的代码运行在一定的环境中，限制不可信代码访问隔离区之外的资源，而这道墙就是浏览器的安全沙箱。</p><p>多进程的浏览器架构将主要分为两块：浏览器内核和渲染内核。而安全沙箱能限制了渲染进程对操作系统资源的访问和修改，同时渲染进程内部也没有读写操作系统的能力，而这些都是在浏览器内核中一一实现了，包括持久存储、网络访问和用户交互等一系列直接与操作系统交互的功能。浏览器内核和渲染内核各自职责分明，当他们需要进行数据传输的时候会通过 <code>IPC</code> 进行。</p><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_0042.png" alt="浏览器内核和渲染进程各自职责"></p><blockquote><p>安全沙箱的存在是为了保护客户端操作系统免受黑客攻击，但是阻止不了 XSS 和 CSRF。</p></blockquote><h2 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h2><p>跨站脚本攻击（<code>Cross Site Scripting</code>）本来缩写是 <code>CSS</code>，但是为了和层叠样式表（<code>Cascading Style Sheet</code>）的简写区分开来，所以在安全领域被称为 <code>XSS</code>。它是指黑客往 <code>HTML</code> 文件中或者 <code>DOM</code> 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p><p><strong>可以通过 3 种方式注入恶意脚本</strong></p><h3 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h3><ul><li>首先黑客利用站点漏洞将一段恶意 <code>JavaScript</code> 代码提交到网站的数据库中，比如在表单输入框中输入这样一段内容：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://tod.cn/ReFgeasE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>然后用户向网站请求包含了恶意 <code>JavaScript</code> 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本可以通过 <code>document.cookie</code> 获取到页面 <code>Cookie</code> 信息，然后通过 <code>XMLHttpRequest</code> 将这些信息发送给恶意服务器，恶意服务器拿到用户的 <code>Cookie</code> 信息之后，就可以在其他电脑上模拟用户的登录，然后进行操作。</li></ul><h3 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h3><p>恶意 <code>JavaScript</code> 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 <code>JavaScript</code> 脚本返回给用户。当恶意 <code>JavaScript</code> 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</p><h3 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h3><p>通常是由于是前端代码不够严谨，把不可信的内容插入到了页面。在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等 <code>API</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等代替。比如对于如下代码：当输入 <code>&quot; onclick=alert(&#39;xss&#39;) </code> 且点击生成的链接的时候，就会提示 <code>xss</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;test()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> text = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;text&#x27;</span>).value</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>).innerHTML = <span class="string">`&lt;a href=&quot;<span class="subst">$&#123;text&#125;</span>&quot;&gt;链接&lt;/a&gt;`</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="阻止-XSS-攻击的措施"><a href="#阻止-XSS-攻击的措施" class="headerlink" title="阻止 XSS 攻击的措施"></a>阻止 XSS 攻击的措施</h3><ul><li>服务器对输入脚本进行过滤或转码，比如：<code>&lt;script&gt;</code> 转成 <code>&amp;lt;script&amp;gt;</code> 后脚本就无法执行了；</li><li>使用 <code>HttpOnly</code> 属性，服务器通过响应头来将某些重要的 <code>Cookie</code> 设置为 <code>HttpOnly</code> 值，限制了客户端浏览器可以通过 <code>document.cookie</code> 获取这些重要的 <code>Cookie</code> 信息；</li><li>充分利用 <code>CSP</code>，可以通过 <code>&lt;meta&gt;</code> 来配置 <code>CSP</code>，这也是前端用于防止 <code>XSS</code> 的最合适手段。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h2><p>跨站请求伪造（<code>Cross-site request forgery</code>）简称是 <code>CSRF</code>：是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。</p><h3 id="CSRF-是怎么攻击的"><a href="#CSRF-是怎么攻击的" class="headerlink" title="CSRF 是怎么攻击的"></a>CSRF 是怎么攻击的</h3><p>一个典型的 <code>CSRF</code> 攻击过程应该是这样子的：</p><ul><li>用户登录 A 网站，并且保留了登录信息（<code>Cookie</code>）；</li><li>被黑客诱导访问了 B 网站，从 A 跳转到 B；</li><li>B 网站对 A 网站发出请求（这个就是下面将介绍的几种伪造请求的方式），浏览器请求头中会默认携带 A 网站的 <code>Cookie</code>；</li><li>A 网站服务器收到请求后，经过验证发现用户是登录了的，所以会处理请求。</li></ul><p>下面将举一个例子来模拟几种伪造请求的方式。假设：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;platforma.com&#x2F;withdraw?account&#x3D;账户名&amp;money&#x3D;转账金额&#96;</span><br></pre></td></tr></table></figure><p>这是某个资金平台 A 的转账接口，黑客知道这个接口后就可以通过以下方式进行攻击：</p><p><strong>1. 自动发起 <code>GET</code> 请求</strong></p><p>黑客在他自己网站的页面上加载了一张图片，而链接地址是指向那个转账接口。所以需要做的就是，只要某个用户在资金平台 A 上刚登录过，且此时被诱导点击了黑客的页面，一进入这个页面就会自动发起 <code>GET</code> 请求去加载图片，实而是去请求去执行转账接口。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://platforma.com/withdraw?account=hacker名&amp;money=1000&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 自动发起 <code>POST</code> 请求</strong></p><p>这类其实就是表单的自动提交。以下是黑客网站上的代码，一旦跳转到黑客指定的页面就会自动提交表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://platforma.com/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3. 点击链接来触发请求</strong></p><p>这种伪造请求的方式和第一种很像，不过是将请求的接口放到了 <code>&lt;a&gt;</code> 链接上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;美女图片的链接&quot;</span> /&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;https://platforma.com/withdraw?account=hacker名&amp;money=1000&quot;</span>&gt;</span><br><span class="line">    点击查看更多美女图片</span><br><span class="line">&lt;a/&gt;</span><br></pre></td></tr></table></figure><h3 id="如何预防-CSRF-攻击"><a href="#如何预防-CSRF-攻击" class="headerlink" title="如何预防 CSRF 攻击"></a>如何预防 CSRF 攻击</h3><p><strong>1. 给 Cookie 设置合适的 SameSite</strong></p><p>当从 A 网站登录后，会从响应头中返回服务器设置的 <code>Cookie</code> 信息，而如果 <code>Cookie</code> 携带了 <code>SameSite=strict</code> 则表示完全禁用第三方站点请求头携带 <code>Cookie</code>，比如当从 B 网站请求 A 网站接口的时候，浏览器的请求头将不会携带该 <code>Cookie</code>。<code>SameSite</code> 还有另外 2 个属性值：</p><ul><li><code>Lax</code> 是默认值，允许第三方站点的 <code>GET</code> 请求携带；</li><li><code>None</code> 任何情况下都会携带；</li></ul><p>以下是一个响应头的 <code>Set-Cookie</code> 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: flavor&#x3D;choco; SameSite&#x3D;strict</span><br></pre></td></tr></table></figure><p><strong>2. 同源检测</strong></p><p>在服务端，通过请求头中携带的 <code>Origin</code> 或者 <code>Referer</code> 属性值进行判断请求是否来源同一站点，同时服务器应该优先检测 <code>Origin</code>。为了安全考虑，相比于 <code>Referer</code>，<code>Origin</code> 只包含了域名而不带路径。</p><p><strong>3. CSRF Token</strong></p><p>大概过程是可以分成 2 步骤：</p><ul><li>在浏览器向服务器发起请求时，服务器生成一个 <code>CSRF Token</code>。<code>CSRF Token</code> 其实就是服务器生成的随机字符串，然后将该字符串植入到返回的页面中，通常是放到表单的隐藏输入框中，这样能够很好的保护 <code>CSRF Token</code> 不被泄漏；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://platforma.com/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf-token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;nc98P987b&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>当浏览器再次发送请求的时候（比如转账），就需要携带这个 <code>CSRF Token</code> 值一并提交；</li><li>服务器验证 <code>CSRF Token</code> 是否一致；从第三方网站发出的请求是无法获取用户页面中的 <code>CSRF Token</code> 值的。</li></ul><h2 id="点击劫持（ClickJacking）"><a href="#点击劫持（ClickJacking）" class="headerlink" title="点击劫持（ClickJacking）"></a>点击劫持（ClickJacking）</h2><p>点击劫持（<code>Clickjacking</code>）是一种通过视觉欺骗的手段来达到攻击目的手段。往往是攻击者将目标网站通过 <code>iframe</code> 嵌入到自己的网页中，通过 <code>opacity</code> 等手段设置 <code>iframe</code> 为透明的，使得肉眼不可见，这样一来当用户在攻击者的网站中操作的时候，比如点击某个按钮（这个按钮的顶层其实是 <code>iframe</code>），从而实现目标网站被点击劫持。</p><p><strong>防护手段</strong>即不希望自己网站的页面被嵌入到别人的网站中。</p><h3 id="frame-busting"><a href="#frame-busting" class="headerlink" title="frame busting"></a>frame busting</h3><p>如果 A 页面通过 <code>iframe</code> 被嵌入到 B 页面，那么在 A 页面内部<code>window</code> 对象将指向 <code>iframe</code>，而 <code>top</code> 将指向最顶层的网页这里是 B。所以可以依据这个原理来判断自己的页面是被 <code>iframe</code> 引入而嵌入到别人页面，如果是的话，则通过如下的判断会使得 B 页面将直接替换 A 的内容而显示，从而让用户发觉自己被骗。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (top.location != <span class="built_in">window</span>.location) &#123;</span><br><span class="line">    top.location = <span class="built_in">window</span>.location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h3><p>通过给页面响应头里设置 <code>X-Frame-Options</code> 为某个属性值，就能达到控制该页面是否可以通过 <code>iframe</code> 的方式被嵌入到别人的网站中。 它有 3 个属性值：</p><ul><li><code>deny</code> 表示该页面不允许嵌入到任何页面，包括同一域名页面也不允许；</li><li><code>sameorigin</code> 表示只允许嵌入到同一域名的页面；</li><li><code>allow-from uri</code> 表示可以嵌入到指定来源的页面中。</li></ul><p>点击劫持中的本质就是通过视觉来欺骗用户，顺着这个思路，还有一个攻击方法也和这个类似，那就是<strong>图片覆盖攻击</strong>大概的原理就是通过样式把图片覆盖在攻击者所希望的任意位置，比如盖在一个网站的 <code>logo</code> 上，当用户点击图片的时候就会被链接到攻击者的站点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">src</span>=<span class="string">&quot;https://hacker.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; left: 100; top: 100; z-index: 100;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这种攻击方式，预防的手段就是需要用户在提交的 <code>HTML</code> 中检查，<code>&lt;img&gt;</code> 标签是否有可能导致浮出。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://time.geekbang.org/column/article/117637">浏览器的工作原理与实践</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">Same-origin_policy</a></li><li><a href="https://developers.google.com/web/fundamentals/security/csp">CSP</a></li><li><a href="https://book.douban.com/subject/10546925/">白帽子讲Web安全</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/browser_safe.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;同源策略（Same-Origin-Policy）&quot;&gt;&lt;a href=&quot;#同源策略（Same-Origin-Policy）&quot; class=&quot;headerlink&quot; title=&quot;同源策略（Same Origin Policy）&quot;&gt;&lt;/a&gt;同源策略（Same Origin Policy）&lt;/h2&gt;&lt;p&gt;如果两个 &lt;code&gt;URL&lt;/code&gt; 的协议、域名和端口都相同，我们就称这两个 &lt;code&gt;URL&lt;/code&gt; 同源。&lt;/p&gt;
&lt;p&gt;比如，这个 &lt;code&gt;http://store.company.com/dir/page.html&lt;/code&gt; 和下面这些 &lt;code&gt;URL&lt;/code&gt; 相比源的结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;store.company.com&amp;#x2F;dir2&amp;#x2F;other.html         &amp;#x2F;&amp;#x2F; 同源，只有路径不同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;store.company.com&amp;#x2F;dir&amp;#x2F;inner&amp;#x2F;another.html  &amp;#x2F;&amp;#x2F; 同源，只有路径不同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https:&amp;#x2F;&amp;#x2F;store.company.com&amp;#x2F;secure.html            &amp;#x2F;&amp;#x2F; 失败，协议不同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;news.company.com&amp;#x2F;dir&amp;#x2F;other.html           &amp;#x2F;&amp;#x2F; 失败，域名不同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;store.company.com:81&amp;#x2F;dir&amp;#x2F;etc.html         &amp;#x2F;&amp;#x2F; 失败，端口不同 ( http:&amp;#x2F;&amp;#x2F; 默认端口是80)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="https://bubuzou.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="安全" scheme="https://bubuzou.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>「建议收藏」送你一份精心总结的3万字ES6实用指南（全）</title>
    <link href="https://bubuzou.com/2020/11/17/es6/"/>
    <id>https://bubuzou.com/2020/11/17/es6/</id>
    <published>2020-11-17T07:53:04.000Z</published>
    <updated>2024-06-12T09:26:57.393Z</updated>
    
    <content type="html"><![CDATA[<p>写本篇文章目的是为了夯实基础，基于阮一峰老师的著作 <a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a> 以及 <a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">tc39-finished-proposals</a> 这两个知识线路总结提炼出来的重点和要点，涉及到从 <code>ES2015</code> 到 <code>ES2021</code> 的几乎所有知识，基本上都是按照一个知识点配上一段代码的形式来展示，所以篇幅较长，也正是因为篇幅过长，所以就没把 <code>Stage 2</code> 和 <code>Stage 3</code> 阶段的提案写到这里，后续 <code>ES2021</code> 更新了我再同步更新。</p><blockquote><p>有 5 个提案已经列入 Expected Publication Year in 2021 所以本篇中暂且把他们归为 ES2021。</p></blockquote><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es6.png"></p><a id="more"></a><h2 id="ES6-前言"><a href="#ES6-前言" class="headerlink" title="ES6 前言"></a>ES6 前言</h2><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><p>能写好 <code>JS</code> 固然是重要的，但是作为一个前端，我们也要了解自己所使用语言的发展历程，这里强烈推荐看 <a href="https://cn.history.js.org/index.html">《JavaScript 20 年》</a>，本书详细记载和解读了自 1995 年语言诞生到 2015 年 <code>ES6</code> 规范制定为止，共计 20 年的 <code>JavaScript</code> 语言演化历程。</p><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><p>2011 年，发布了 <code>ECMAScript 5.1</code> 版，而 2015 年 6 月发布了 <code>ES6</code> 的第一个版本又叫 <code>ES2015</code>。<code>ES6</code> 其实是一个泛指，指代 5.1 版本以后的下一代标准。<code>TC39</code> 规定将于每年的 6 月发布一次正式版本，版本号以当年的年份为准，比如当前已经发布了 <code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>、<code>ES2019</code>、<code>ES2020</code> 等版本。</p><h3 id="提案发布流程"><a href="#提案发布流程" class="headerlink" title="提案发布流程"></a>提案发布流程</h3><p>任何人都可以向 <code>TC39</code> 提案，要求修改语言标准。一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 <code>TC39</code> 委员会批准。</p><ul><li><code>Stage 0</code> - <code>Strawperson</code>（展示阶段）</li><li><code>Stage 1</code> - <code>Proposal</code>（征求意见阶段）</li><li><code>Stage 2</code> - <code>Draft</code>（草案阶段）</li><li><code>Stage 3</code> - <code>Candidate</code>（候选人阶段）</li><li><code>Stage 4</code> - <code>Finished</code>（定案阶段）</li></ul><p>一个提案只要能进入 <code>Stage 2</code>，就差不多肯定会包括在以后的正式标准里面。<code>ECMAScript</code> 当前的所有提案，可以在这里查看 <a href="https://github.com/tc39/ecma262">ecma262</a>。关于提案流程可以在这里 <a href="https://tc39.es/process-document/">TC39_Process</a> 看到更加详细的信息。</p><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2015.png"></p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><code>const</code>：声明一个常量，<code>let</code>：声明一个变量；<code>const/let</code> 声明的常量/变量都只能作用于代码块（块级作用域或函数作用域）里；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><code>const/let</code> 不存在变量提升，所以在代码块里必须先声明然后才可以使用，这叫暂时性死区；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br></pre></td></tr></table></figure><p><code>const/let</code> 不允许在同一个作用域内，重复声明；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span> <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const</code> 声明时必须初始化，且后期不能被修改，但如果初始化的是一个对象，那么不能修改的是该对象的内存地址；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person.name = <span class="string">&#x27;bubuzou&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// &#x27;bubuzou&#x27;</span></span><br><span class="line">person = <span class="string">&#x27;&#x27;</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p><code>const/let</code> 在全局作用域中声明的常量/变量不会挂到顶层对象（浏览器中是 window ）的属性中；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name) <span class="comment">// &#x27;布兰&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p><strong>解构类型</strong>：</p><ul><li><p>字符串解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c = <span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;12&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// &#x27;1&#x27; &#x27;2&#x27; &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数值解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toFixed</span>: tf &#125; = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(tf.call(<span class="built_in">Math</span>.PI, <span class="number">2</span>)) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure></li><li><p>布尔值解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: ts &#125; = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(ts.call(<span class="literal">false</span>)) <span class="comment">// &#x27;false&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数组解构：等号右侧的数据具有 <code>Iterator</code> 接口可以进行数组形式的解构赋值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构不成功的变量值为 undefined</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1, 2, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以设置默认值</span></span><br><span class="line"><span class="keyword">let</span> [x, y, z = <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z) <span class="comment">// 1, 2, null</span></span><br></pre></td></tr></table></figure><blockquote><p>什么样的数据具有 <code>Iterator</code> 接口呢？如果一个对象能够通过 [Symbol.iterator] 访问，且能够返回一个符合迭代器协议的对象，那么该对象就是可迭代的。目前内置的可迭代对象有：String、Array、TypeArray、Map、Set、arguments 和 NodeList 等。</p></blockquote></li><li><p>对象解构：与数组按照索引位置进行解构不同，对象解构是按照属性名进行解构赋值，如果在当前对象属性匹配不成功则会去对象的原型属性上查找：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认写法</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name, <span class="attr">age</span>: age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改名且设置默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name1, <span class="attr">age</span>: age1 = <span class="number">12</span> &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name1, age1) <span class="comment">// &#x27;布兰&#x27; 12</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数解构：其实就是运用上面的对象解构和数组解构规则；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123; x = <span class="number">0</span>, y = <span class="number">0</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([x, y])</span><br><span class="line">  <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">move() <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>解构要点</strong>：</p><ul><li>只要等号两边的模式相同（同是对象或同是数组），则左边的变量会被赋予对应的值；</li><li>解构不成功的变量值为 <code>undefined</code>；</li><li>默认值生效的前提是当等号右边对应的值全等于 undefined 的时候；</li><li>只要等号右边的值不是对象或者数组，则会进行自动装箱将其转成对象；</li><li><code>null</code> 和 <code>undefined</code> 都无法转成对象，所以无法解构。</li></ul><p><strong>解构应用</strong>：</p><ul><li><p>交换变量的值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span></span><br><span class="line">;[x, y] = [y, x]</span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure></li><li><p>通过函数返回对象属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = getParams()</span><br></pre></td></tr></table></figure></li><li><p>通过定义函数参数来声明变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line">init(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; name, age &#125; = person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简洁用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">&#123; name, age &#125;</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定函数参数默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPerson</span>(<span class="params">&#123; name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age)</span><br><span class="line">&#125;</span><br><span class="line">initPerson() <span class="comment">// &#x27;布兰&#x27; 12</span></span><br><span class="line">initPerson(&#123; <span class="attr">age</span>: <span class="number">20</span> &#125;) <span class="comment">// &#x27;布兰&#x27; 20</span></span><br></pre></td></tr></table></figure></li><li><p>提取 <code>JSON</code> 数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> responseData = &#123;</span><br><span class="line">  code: <span class="number">1000</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  message: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; code, data = &#123;&#125; &#125; = responseData</span><br></pre></td></tr></table></figure></li><li><p>遍历 Map 结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">map.set(<span class="string">&#x27;xiamen&#x27;</span>, <span class="string">&#x27;厦门&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输入模块的指定方法和属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile, writeFile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li><p>可以使用 <code>Unicode</code> 编码来表示一个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下写法都可以用来表示字符 z</span></span><br><span class="line"><span class="string">&#x27;\z&#x27;</span> <span class="comment">// 转义</span></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> <span class="comment">// 十进制表示法</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> <span class="comment">// 十六进制表示法</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> <span class="comment">// Unicode 普通表示法</span></span><br><span class="line"><span class="string">&#x27;\u&#123;7A&#125;&#x27;</span> <span class="comment">// Unicode 大括号表示法</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.52unicode.com/">www.52unicode.com</a> 这个网站可以查询到常见符号的 Unicode 编码。</p></blockquote></li><li><p>可以使用 <code>for...of</code> <strong>正确遍历</strong>字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;😀🤣😜😍🤗🤔&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> emoji <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(emoji) <span class="comment">// 😀🤣😜😍🤗🤔</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = str.length; i &lt; l; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str[i]) <span class="comment">// 不能正确输出表情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模板字符串使用两个反引号标识（``），可以用来定义多行字符串，或者使用它在字符串中插入变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;hero&#x27;</span></span><br><span class="line"><span class="keyword">let</span> tips = <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, </span></span><br><span class="line"><span class="string">    welcome to my world.`</span></span><br><span class="line">alert(tips)</span><br></pre></td></tr></table></figure></li><li><p>标签模板：在函数名后面接一个模板字符串相当于给函数传入了参数进行调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  age = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> tips = parse<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, are you <span class="subst">$&#123;age&#125;</span> years old this year?`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">stringArr, ...variable</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于传递如下参数进行调用 parse 函数</span></span><br><span class="line">parse([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27;, are you &#x27;</span>, <span class="string">&#x27; years old this year?&#x27;</span>], name, age)</span><br></pre></td></tr></table></figure></li><li><p><code>String.fromCodePoint()</code> 用于从 <code>Unicode</code> 码点返回对应字符，可以支持 <code>0xFFFF</code> 的码点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x1f600</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f600</span>) <span class="comment">// &quot;😀&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>String.raw()</code> 返回把字符串所有变量替换且对斜杠进行转义的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span> + <span class="number">3</span>&#125;</span>!`</span> <span class="comment">// &quot;Hi\n5!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>codePointAt()</code> 返回字符的十进制码点，对于 <code>Unicode</code> 大于 <code>0xFFFF</code> 的字符，会被认为是 2 个字符，十进制码点转成十六进制可以使用 <code>toString(16)</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emoji = <span class="string">&#x27;🤣&#x27;</span></span><br><span class="line">emoji.length <span class="comment">// 2</span></span><br><span class="line">emoji.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// &#x27;d83d&#x27;</span></span><br><span class="line">emoji.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>) <span class="comment">// &#x27;de00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0xd83d</span>, <span class="number">0xde00</span>) === <span class="string">&#x27;🤣&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>normalize()</code> 方法会按照指定的一种 <code>Unicode</code> 正规形式将当前字符串正规化。（如果该值不是字符串，则首先将其转换为一个字符串）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;\u00F1&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;\u006E\u0303&#x27;</span></span><br><span class="line"></span><br><span class="line">str1 <span class="comment">//  ñ</span></span><br><span class="line">str2 <span class="comment">//  ñ</span></span><br><span class="line">str1 === str2 <span class="comment">// false</span></span><br><span class="line">str1.length === str2.length <span class="comment">// false</span></span><br><span class="line">str1.normalize() === str2.normalize() <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>字符串是否包含子串：</p><ul><li>includes()：返回布尔值，表示是否找到了参数字符串。</li><li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line"></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line"></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，使用第二个参数 <code>n</code> 时，<code>endsWith</code> 的行为与其他两个方法有所不同。它针对前 <code>n</code> 个字符，而其他两个方法针对从第 <code>n</code> 个位置直到字符串结束。</p></li><li><p><code>repeat(n)</code> 将当前字符串重复 <code>n</code> 次后，返回一个新字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">2</span>) <span class="comment">// &#x27;xx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">1.9</span>) <span class="comment">// &#x27;x&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="literal">undefined</span>) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="string">&#x27;2a&#x27;</span>) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">-0.6</span>) <span class="comment">// &#x27;&#x27;，解释：0 ~ 1 之间的小数相当于 0</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">-2</span>) <span class="comment">// RangeError</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="literal">Infinity</span>) <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li><p>二进制（0b）和八进制（0o）表示法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> b = num.toString(<span class="number">2</span>) <span class="comment">// 二进制的100：1100100</span></span><br><span class="line"><span class="keyword">let</span> o = num.toString(<span class="number">8</span>) <span class="comment">// 八进制的100：144</span></span><br><span class="line"><span class="number">0b1100100</span> === <span class="number">100</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o144</span> === <span class="number">100</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isFinite()</code> 判断一个数是否是有限的数，入参如果不是数值一律返回 <code>false</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">-2.9</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">false</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isNaN()</code> 判断一个数值是否为 <code>NaN</code>，如果入参不是 <code>NaN</code> 那结果都是 <code>false</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;a&#x27;</span> / <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;NaN&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>数值转化：<code>Number.parseInt()</code> 和 <code>Number.parseFloat()</code>，非严格转化，从左到右解析字符串，遇到非数字就停止解析，并且把解析的数字返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12a&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;a12&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xA&#x27;</span>) <span class="comment">// 10，0x开头的将会被当成十六进制数</span></span><br></pre></td></tr></table></figure><p><code>parseInt()</code> 默认是用十进制去解析字符串的，其实他是支持传入第二个参数的，表示要以多少进制的 基数去解析第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1010&#x27;</span>, <span class="number">2</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>) <span class="comment">// 255</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.im/post/6855129005121765390#heading-13">parseInt</a></p></li><li><p><code>Number.isInteger()</code> 判断一个数值是否为整数，入参为非数值则一定返回 <code>false</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger() <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">&#x27;15&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">3.0000000000000002</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>如果对数据精度的要求较高，不建议使用 Number.isInteger() 判断一个数值是否为整数。</p></blockquote></li><li><p><code>Number.EPSILON</code> 表示一个可接受的最小误差范围，通常用于浮点数运算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>) &lt; <span class="built_in">Number</span>.EPSILON <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isSafeInteger()</code> 用来判断一个数是否在最大安全整数（<code>Number.MAX_SAFE_INTEGER</code>）和最小安全整数（<code>Number.MIN_SAFE_INTEGER</code>）之间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">2</span> ** <span class="number">53</span> - <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">&#x27;2&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>Math.trunc()</code>：返回数值整数部分</p></li><li><p><code>Math.sign()</code>：返回数值类型(正数 1、负数 -1、零 0)</p></li><li><p><code>Math.cbrt()</code>：返回数值立方根</p></li><li><p><code>Math.clz32()</code>：返回数值的 32 位无符号整数形式</p></li><li><p><code>Math.imul()</code>：返回两个数值相乘</p></li><li><p><code>Math.fround()</code>：返回数值的 32 位单精度浮点数形式</p></li><li><p><code>Math.hypot()</code>：返回所有数值平方和的平方根</p></li><li><p><code>Math.expm1()</code>：返回 <code>e^n - 1</code></p></li><li><p><code>Math.log1p()</code>：返回 1 + n 的自然对数(<code>Math.log(1 + n)</code>)</p></li><li><p><code>Math.log10()</code>：返回以 10 为底的 n 的对数</p></li><li><p><code>Math.log2()</code>：返回以 2 为底的 n 的对数</p></li><li><p><code>Math.sinh()</code>：返回 n 的双曲正弦</p></li><li><p><code>Math.cosh()</code>：返回 n 的双曲余弦</p></li><li><p><code>Math.tanh()</code>：返回 n 的双曲正切</p></li><li><p><code>Math.asinh()</code>：返回 n 的反双曲正弦</p></li><li><p><code>Math.acosh()</code>：返回 n 的反双曲余弦</p></li><li><p><code>Math.atanh()</code>：返回 n 的反双曲正切</p></li></ul><h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li><p>数组扩展运算符（…）将数组展开成用逗号分隔的参数序列，只能展开一层数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：函数传参</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>] <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：浅克隆</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> clone = [...a]</span><br><span class="line">a === clone <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用四：数组解构</span></span><br><span class="line"><span class="keyword">const</span> [x, ...y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.from()</code> 可以将类数组对象（ <code>NodeList</code>，<code>arguments</code>）和可迭代对象转成数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：字符串转数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并去重</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(merge)) <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：arguments 转数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果 <code>Array.from()</code> 带第二个参数 <code>mapFn</code>，将对生成的新数组执行一次 <code>map</code> 操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x) <span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> ++i) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.of()</code> 将一组参数转成数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayOf</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(params)</span><br><span class="line">&#125;</span><br><span class="line">arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.copyWithin()</code> 在当前数组内部，将制定位置的成员复制到其他位置（会覆盖原来位置的成员），最后返回一个新数组。接收 3 个参数，参数为负数表示右边开始计算：</p><ul><li><code>target</code>（必选）：替换位置的索引；</li><li><code>start</code>（可选）：从该位置开始读取数据，默认为 0；</li><li><code>end</code>（可选）：从该位置结束读取数据（不包括该位置的数据），默认为原数组长度；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  .copyWithin(<span class="number">-1</span>) <span class="comment">// [1, 2, 3, 4, 1]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)].copyWithin(<span class="number">1</span>) <span class="comment">// [1, 1, 2, 3, 4]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)].copyWithin(<span class="number">0</span>, <span class="number">-3</span>, <span class="number">-1</span>) <span class="comment">// [3, 4, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>查找第一个出现的子成员：<code>find()</code> 和 <code>findIndex()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出第一个偶数</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line">  .find(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// 找出第一个偶数的索引位置</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>)</span><br><span class="line">  ].findIndex(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>fill()</code> 使用给定的值来填充数组，有 3 个参数：</p><ul><li><code>value</code>：填充值；</li><li><code>start</code>（可选），开始索引，默认为 0；</li><li><code>end</code>（可选）：结束索引，默认为数组长度，不包括该索引位置的值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化空数组</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">  .fill(<span class="number">1</span>) <span class="comment">// [1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)].fill(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>) <span class="comment">// [1, 2, &#x27;a&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <code>keys()</code>（键名）、<code>entries()</code>（键值）和 <code>values()</code>（键值对） 获取数组迭代器对象，可以被 <code>for...of</code> 迭代，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v) <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e) <span class="comment">// [0, &#x27;a&#x27;] [0, &#x27;b&#x27;] [0, &#x27;c&#x27;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组空位，是指数组没有值，比如：<code>[,,]</code>，而像这种 <code>[undefined]</code> 是不包含空位的。由于 <code>ES6</code> 之前的一些 <code>API</code> 对空位的处理规则很不一致，所以实际操作的时候应该尽量避免空位的出现，而为了改变这个现状，<code>ES6</code> 的 <code>API</code> 会默认将空位处理成 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="number">1</span>, , <span class="number">3</span>].values()]  <span class="comment">// [1, undefined, 3]</span></span><br><span class="line">[<span class="number">1</span>, , <span class="number">3</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x === <span class="literal">undefined</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li><p>对象属性简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性名表达式：在用对象字面量定义对象的时候，允许通过属性名表达式来定义对象属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [name]: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    [<span class="string">&#x27;get&#x27;</span>+ name]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法的 <code>name</code> 属性，存在好几种情况，这里仅列出常见的几种：</p><p>情况一：普通对象方法的 <code>name</code> 属性直接返回方法名，函数声明亦是如此，函数表达式返回变量名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  hi() &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">person.hi.name <span class="comment">// &#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure><p>情况二：构造函数的 <code>name</code> 为 <code>anonymous</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>().name <span class="comment">// &#x27;anonymous&#x27;</span></span><br></pre></td></tr></table></figure><p>情况三：绑定函数的 <code>name</code> 将会在函数名前加上 <code>bound</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// &#x27;bound foo&#x27;</span></span><br></pre></td></tr></table></figure><p>情况四：如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则 <code>name</code> 属性不是在该方法上面，而是该方法的属性的描述对象的 <code>get</code> 和 <code>set</code> 属性上面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>() &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">x</span>) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">o.foo.name <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">descriptor.get.name <span class="comment">// &quot;get foo&quot;</span></span><br><span class="line">descriptor.set.name <span class="comment">// &quot;set foo&quot;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name">function_name</a></p></li><li><p>属性的可枚举性</p><p>对象的每个属性都有一个描述对象（<code>Descriptor</code>），用来控制该属性的行为。可以通过 <code>Object.getOwnPropertyDescriptor()</code> 来获取对象某个属性的描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     value: &quot;布兰&quot;,</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>enumerable</code> 就是对象某个属性的可枚举属性，如果某个属性的 <code>enumerable</code> 值为 <code>false</code> 则表示该属性不能被枚举，所以该属性会被如下 4 种操作忽略：</p><ul><li><code>for...in</code> ：只遍历对象自身的和继承的可枚举的属性；</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名；</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性；</li><li><code>Object.assign()</code>： 只拷贝对象自身的可枚举的属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="number">12</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line">person <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作都将忽略 person 对象的 age 属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(person) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(person) <span class="comment">// &#x27;&#123;&quot;name&quot;: &quot;布兰&quot;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, person) <span class="comment">// &#123; name: &#x27;布兰&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p><code>Reflect.ownKeys(obj)</code>： 返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 <code>Symbol</code> 或字符串，也不管是否可枚举：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(person) <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>super</code> 关键字，指向对象的原型对象，只能用于对象的方法中，其他地方将报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.name</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, &#123; <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span> &#125;)</span><br><span class="line">person.getName() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下几种 super 的使用将报错</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  foo: <span class="built_in">super</span>.foo,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  foo: <span class="function">() =&gt;</span> <span class="built_in">super</span>.foo,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.foo</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.is()</code> 用来判断两个值是否相等，表现基本和 <code>===</code> 一样，除了以下两种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.assign()</code> 用于对象的合并，将源对象（<code>source</code>）的所有可枚举属性，复制到目标对象（<code>target</code>），如果有同名属性，则后面的会直接替换前面的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> source1 = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="number">1</span>, <span class="attr">f</span>: <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: &#123; <span class="attr">g</span>: <span class="number">3</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2)</span><br><span class="line">target <span class="comment">// &#123; a: 3, b: 3, c: 4, d: &#123;g: 3&#125; &#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code> 实行的是浅拷贝，如果源对象某个属性是对象，那么拷贝的是这个对象的引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;</span><br><span class="line"><span class="keyword">let</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line">target.a.b = <span class="number">3</span></span><br><span class="line">source.a.b <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>__proto__</code> 属性是用来读取和设置当前对象的原型，而由于其下划线更多的是表面其是一个内部属性，所以建议不在正式场合使用它，而是用下面的 <code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p></li><li><p><code>Object.setPrototypeOf()</code> 用于设置对象原型，<code>Object.getPrototypeOf()</code> 用于读取对象原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, &#123; <span class="attr">name</span>: <span class="string">&#x27;动物&#x27;</span> &#125;)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) <span class="comment">// &#123;name: &#x27;动物&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li><p><code>RegExp</code> 构造函数，允许首参为正则表达式，第二个参数为修饰符，如果有第二个参数，则修饰符以第二个为准：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xYz\d+/gi</span>, i)</span><br><span class="line">reg.flags <span class="comment">// &#x27;i&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>正则方法调用变更：字符串对象的 <code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code> 内部调用转为调用 <code>RegExp</code> 实例对应的 <code>RegExp.prototype[Symbol.方法]</code>；</p></li><li><p><code>u</code> 修饰符：含义为 <code>Unicode</code> 模式，用来正确处理大于 <code>\uFFFF</code> 的 <code>Unicode</code> 字符。也就是说，如果待匹配的字符串中可能包含有大于 <code>\uFFFF</code> 的字符，就必须加上 <code>u</code> 修饰符，才能正确处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上 u 修饰符才能让 . 字符正确识别大于 \uFFFF 的字符</span></span><br><span class="line">/^.$/.test(<span class="string">&#x27;🤣&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(<span class="string">&#x27;🤣&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大括号 Unicode 字符表示法必须加上 u 修饰符</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">&#x27;a&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有 u 修饰符，量词才能正确匹配大于 \uFFFF 的字符</span></span><br><span class="line">/🤣&#123;<span class="number">2</span>&#125;/.test(<span class="string">&#x27;🤣🤣&#x27;</span>)  <span class="comment">// false</span></span><br><span class="line">/🤣&#123;<span class="number">2</span>&#125;/u.test(<span class="string">&#x27;🤣🤣&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>RegExp.prototype.unicode</code> 属性表示正则是否设置了 <code>u</code> 修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/🤣/.unicode   <span class="comment">// false</span></span><br><span class="line">/🤣/u.unicode  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>y</code> 修饰符，与 <code>g</code> 修饰符类似也是全局匹配；不同的是 <code>g</code> 是剩余字符中匹配即可，而 <code>y</code> 则是必须在剩余的第一个字符开始匹配才行，所以 <code>y</code> 修饰符也叫黏连修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span></span><br><span class="line"><span class="keyword">let</span> r1 = <span class="regexp">/a+/g</span></span><br><span class="line"><span class="keyword">let</span> r2 = <span class="regexp">/a+/y</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><code>RegExp.prototype.sticky</code> 属性表示是否设置了 <code>y</code> 修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/abc/y</span>.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>RegExp.prototype.flags</code> 属性会返回当前正则的所有修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/abc🤣/iuy</span>.flags <span class="comment">// &#x27;iuy&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li><p>函数参数默认值。参数不能有同名的，函数体内不能用 <code>let</code> 和 <code>const</code> 声明同参数名的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params">name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>使用参数默认值的时候，参数不能有同名的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, x, y</span>) </span>&#123;&#125; <span class="comment">// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, x, y = <span class="number">1</span></span>) </span>&#123;&#125; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>函数体内不能用 <code>let</code> 和 <code>const</code> 声明同参数名的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的 <code>length</code> 属性会返回没有指定默认值的参数个数，且如果设置默认值的参数不是尾参数，则 <code>length</code> 不再计入后面的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;&#125;</span><br><span class="line">  .length(</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">1</span></span>) </span>&#123;&#125;</span><br><span class="line">  )</span><br><span class="line">  .length(</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;&#125;</span><br><span class="line">  ).length) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p>剩余（<code>rest</code>） 参数（…变量名）的形式，用于获取函数的剩余参数，注意 <code>rest</code> 参数必须放在最后一个位置，可以很好的代替 <code>arguments</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> y) &#123;</span><br><span class="line">    coonsole.log(val) <span class="comment">// 2 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>严格模式：只要函数参数使用了默认值、解构赋值或者扩展运算符，那么函数体内就不能显示的设定为严格模式，因为严格模式的作用范围包含了函数参数，而函数执行的顺序是先执行参数，然后再执行函数体，执行到函数体里的 <code>use strict</code> 的时候，那么此时因为函数参数已经执行完成了，那函数参数还要不要受到严格模式的限制呢？这就出现矛盾了。规避限制的办法有两个：设置全局的严格模式或者在函数体外在包一个立即执行函数并且声明严格模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二</span></span><br><span class="line"><span class="keyword">let</span> f = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li><p>箭头函数语法比函数表达式更简洁，并且没有自己的 <code>this</code>、<code>arguments</code>，不能用作构造函数和用作生成器。<br>几种箭头函数写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f1 = <span class="function">() =&gt;</span> &#123;&#125; <span class="comment">// 没有参数</span></span><br><span class="line"><span class="keyword">let</span> f2 = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;&#125; <span class="comment">// 1个参数</span></span><br><span class="line"><span class="keyword">let</span> f3 = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;&#125; <span class="comment">// 1个参数可以省略圆括号</span></span><br><span class="line"><span class="keyword">let</span> f4 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;&#125; <span class="comment">// 2个参数以上必须加上圆括号</span></span><br><span class="line"><span class="keyword">let</span> f5 = <span class="function">(<span class="params">x = <span class="number">1</span>, y = <span class="number">2</span></span>) =&gt;</span> &#123;&#125; <span class="comment">// 支持参数默认值</span></span><br><span class="line"><span class="keyword">let</span> f6 = <span class="function">(<span class="params">x, ...y</span>) =&gt;</span> &#123;&#125; <span class="comment">// 支持 rest 参数</span></span><br><span class="line"><span class="keyword">let</span> f7 = (&#123; x = <span class="number">1</span>, y = <span class="number">2</span> &#125; = &#123;&#125;) <span class="comment">// 支持参数解构</span></span><br></pre></td></tr></table></figure><p>箭头函数没有自己的 <code>this</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age++</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person() <span class="comment">// 1 秒后 Person &#123;age: 1&#125;</span></span><br></pre></td></tr></table></figure><p>通过 <code>call/apply</code> 调用箭头函数的时候将不会绑定第一个参数的作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> adder = &#123;</span><br><span class="line">  base: <span class="number">1</span>,</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="function">(<span class="params">v</span>) =&gt;</span> v + <span class="built_in">this</span>.base</span><br><span class="line">    <span class="keyword">return</span> f(a)</span><br><span class="line">  &#125;,</span><br><span class="line">  addThruCall: <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="function">(<span class="params">v</span>) =&gt;</span> v + <span class="built_in">this</span>.base</span><br><span class="line">    <span class="keyword">let</span> b = &#123;</span><br><span class="line">      base: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f.call(b, a)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">adder.add(<span class="number">1</span>) <span class="comment">// 输出 2</span></span><br><span class="line">adder.addThruCall(<span class="number">1</span>) <span class="comment">// 仍然输出 2</span></span><br></pre></td></tr></table></figure><p>箭头函数没有自己的 <code>arguments</code> 对象，不过可以使用 <code>rest</code> 参数代替：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> log = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数代替写法</span></span><br><span class="line"><span class="keyword">let</span> restLog = <span class="function">(<span class="params">...arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr) <span class="comment">// [2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line">restLog(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>箭头函数不能用作构造器，和 <code>new</code> 一起用会抛出错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure><p>箭头函数返回对象字面量，需要用圆括号包起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func2 = <span class="function">() =&gt;</span> (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow_functions</a></p></li><li><p>尾调用和尾递归</p><p>首先得知道什么是尾调用：函数的最后一步调用另外一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都不是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x)</span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x)</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  g(x)</span><br><span class="line">  <span class="comment">// 因为最后一步是 return: undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾调用有啥用？我们知道函数的相互调用是会生成“调用帧”的，而“调用帧”里存了各种信息比如函数的内部变量和调用函数的位置等，所有的“调用帧”组成了一个“调用栈”。如果在函数的最后一步操作调用了另外一个函数，因为外层函数里调用位置、内部变量等信息都不会再用到了，所有就无需保留外层函数的“调用帧”了，只要直接用内层函数的“调用帧”取代外层函数的“调用帧”即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> g(m + n)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这样一来就很明显的减少了调用栈中的帧数，内存占用就少了，所以这就是尾调用的优化作用。尾递归也是如此，递归如果次数多那就需要保留非常多的“调用帧”，所以经常会出现栈溢出错误，而使用了尾递归优化后就不会发生栈溢出的错误了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规递归的斐波那契函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fibonacci(<span class="number">100</span>) <span class="comment">// 超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归优化后的斐波那契函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span>(<span class="params">n, ac1 = <span class="number">1</span>, ac2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ac2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci2(n - <span class="number">1</span>, ac2, ac1 + ac2)</span><br><span class="line">&#125;</span><br><span class="line">s</span><br><span class="line">Fibonacci2(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul><li><p><code>Symbol</code> 是一个新的原始类型，用来表示一个独一无二的值，可以通过 <code>Symbol()</code> 函数来创建一个 <code>Symbol</code> 类型的值，为了加以区分，可以传入一个字符串作为其描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol</code> 类型无法通过数学运算符进行隐式类型转换，但是可以通过 <code>String()</code> 显示转成字符串或者通过 <code>Boolean()</code> 显示转成布尔值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">String</span>(s) <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line">s.toString() <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line"><span class="built_in">Boolean</span>(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>引入 <code>Symbol</code> 最大的初衷其实就是为了让它作为对象的属性名而使用，这样就可以有效避免属性名的冲突了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [foo]: <span class="string">&#x27;foo1&#x27;</span>,</span><br><span class="line">  foo: <span class="string">&#x27;foo2&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj[foo] <span class="comment">// &#x27;foo1&#x27;</span></span><br><span class="line">obj.foo <span class="comment">// &#x27;foo2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol</code> 属性的不可枚举性，不会被 <code>for...in</code>、<code>for...of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 等枚举：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(person) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(person) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(person) <span class="comment">// &#x27;&#123;&quot;name&quot;:&quot;布兰&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>但是可以通过 <code>Object.getOwnPropertySymbols()</code> 获取到对象的所有 <code>Symbol</code> 属性名，返回一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(person) <span class="comment">// [Symbol(age)]</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>静态方法</strong>：</p><ul><li><p><code>Symbol.for()</code> 按照描述去全局查找 <code>Symbol</code>，找不到则在全局登记一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Symbol.for()</code> 的这个全局登记特性，可以用在不同的 <code>iframe</code> 或 <code>service worker</code> 中取到同一个值。</p></li><li><p><code>Symbol.keyFor()</code> 根据已经在全局登记的 <code>Symbol</code> 查找其描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s) <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong><code>Symbol</code> 的内置值</strong>：</p><ul><li><code>Symbol.hasInstance</code>：指向一个内部方法，当其他对象使用 <code>instanceof</code> 运算符判断是否为此对象的实例时会调用此方法；</li><li><code>Symbol.isConcatSpreadable</code>：指向一个布尔，定义对象用于 <code>Array.prototype.concat()</code> 时是否可展开；</li><li><code>Symbol.species</code>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数；</li><li><code>Symbol.match</code>：指向一个函数，当实例对象被 <code>String.prototype.match()</code> 调用时会重新定义 match()的行为；</li><li><code>Symbol.replace</code>：指向一个函数，当实例对象被 <code>String.prototype.replace()</code> 调用时会重新定义 <code>replace()</code> 的行为；</li><li><code>Symbol.search</code>：指向一个函数，当实例对象被 <code>String.prototype.search()</code> 调用时会重新定义 <code>search()</code> 的行为；s</li><li><code>Symbol.split</code>：指向一个函数，当实例对象被 <code>String.prototype.split()</code> 调用时会重新定义 <code>split()</code> 的行为；</li><li><code>Symbol.iterator</code>：指向一个默认遍历器方法，当实例对象执行<code> for...of</code> 时会调用指定的默认遍历器；</li><li><code>Symbol.toPrimitive</code>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值；</li><li><code>Symbol.toStringTag</code>：指向一个函数，当实例对象被 <code>Object.prototype.toString()</code> 调用时其返回值会出现在 <code>toString()</code> 返回的字符串之中表示对象的类型；</li><li><code>Symbol.unscopables</code>：指向一个对象，指定使用 <code>with</code> 时哪些属性会被 <code>with</code> 环境排除；</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><p><code>Set</code> 是一种新的数据结构，类似数组，但是它没有键只有值，且值都是唯一的。可以通过构造函数生成一个新实例，接收一个数组或者可迭代数据结构作为参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// Set &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Set</code> 判断两个值是不是相等用的是 <a href="https://tc39.es/ecma262/#sec-samevaluezero">sameValueZero</a> 算法，类似于 <code>===</code>，唯一的区别是，在 <code>Set</code> 里 <code>NaN</code> 之间被认为是相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>相同对象的不同实例也被 <code>Set</code> 认为是不相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>Set</code> 是有顺序的，将按照插入的顺序进行迭代，可以使用 <code>for...of</code> 迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>)</span><br><span class="line">set.add(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>Set</code> 实例属性和方法</strong>：</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是 <code>Set</code> 函数；</li><li><code>Set.prototype.size</code>：返回 <code>Set</code> 实例的成员总数；</li><li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身；</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功；</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为 Set 的成员；</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值；</li><li><code>Set.prototype.keys()</code>：返回键名的遍历器；</li><li><code>Set.prototype.values()</code>：返回键值的遍历器；</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器；</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>) <span class="comment">// Set &#123;1, 3, 5&#125;</span></span><br><span class="line">set.size <span class="comment">// 3</span></span><br><span class="line">set.delete(<span class="number">1</span>) <span class="comment">// true，1 已被删除</span></span><br><span class="line">set.has(<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line">set.keys() <span class="comment">// SetIterator &#123;3, 5&#125;</span></span><br><span class="line">set.clear()</span><br><span class="line">set.size <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><strong><code>Set</code> 应用场景</strong>：</p><ul><li><p>数组去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;[...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>])] <span class="comment">// [1, 3, 6]</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// [1, 3, 6]</span></span><br></pre></td></tr></table></figure></li><li><p>字符串去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[...new <span class="built_in">Set</span>(<span class="string">&#x27;abcbacd&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &#x27;abcd&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>求两个集合的交集/并集/差集：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]) <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> b.has(x))) <span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.has(x))) <span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>遍历修改集合成员的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function">(<span class="params">val</span>) =&gt;</span> val * <span class="number">2</span>)) <span class="comment">// Set &#123;2, 3, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, <span class="function">(<span class="params">val</span>) =&gt;</span> val * <span class="number">2</span>)) <span class="comment">// Set &#123;2, 4, 6&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><ul><li><p><code>WeakSet</code> 对象允许将弱保持对象存储在一个集合中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">ws.add(foo) <span class="comment">// WeakSet &#123;&#123;&#125;&#125;</span></span><br><span class="line">ws.has(foo) <span class="comment">// true</span></span><br><span class="line">ws.delete(foo) <span class="comment">// WeakSet &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>和 <code>Set</code> 的区别</strong>：</p><ul><li><code>WeakSet</code> 只能是对象的集合，而不能是任何类型的任意值；</li><li><code>WeakSet</code> 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 <code>WeakSet</code> 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 <code>WeakSet</code> 中没有存储当前对象的列表。正因为这样，<code>WeakSet</code> 是不可枚举的，也就没有 <code>size</code> 属性，没有 <code>clear</code> 和遍历的方法。</li></ul><p><strong>实例方法</strong>：</p><ul><li><code>WeakSet.prototype.add(value)</code>：添加一个新元素 <code>value</code>；</li><li><code>WeakSet.prototype.delete(value)</code>：从该 <code>WeakSet</code> 对象中删除 <code>value</code> 这个元素；</li><li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值, 表示给定的值 <code>value</code> 是否存在于这个 <code>WeakSet</code> 中；</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><p><code>Map</code> 是一种类似于 <code>Object</code> 的这种键值对的数据结构，区别是对象的键只能是字符串或者 <code>Symbol</code>，而 <code>Map</code> 的键可以是任何类型（原始类型、对象或者函数），可以通过 <code>Map</code> 构造函数创建一个实例，入参是具有 <code>Iterator</code> 接口且每个成员都是一个双元素数组 <code>[key, value]</code> 的数据结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map1.set(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;布兰&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;age&#x27;</span>, <span class="number">12</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(arr)</span><br></pre></td></tr></table></figure></li><li><p><code>Map</code> 中的键和 <code>Set</code> 里的值一样也必须是唯一的，遵循 <a href="https://tc39.es/ecma262/#sec-samevaluezero">sameValueZero</a> 算法，对于同一个键后面插入的会覆盖前面的，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span> &#125;</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo1&#x27;</span>)</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo2&#x27;</span>)</span><br><span class="line">map.get(foo) <span class="comment">// &#x27;foo2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>对于键名同为 <code>NaN</code> 以及相同对象而不同实例的处理同 <code>Set</code> 的值一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(a, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(b, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">map.size <span class="comment">// 1</span></span><br><span class="line">map.get(a) <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> d = &#123; <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span> &#125;</span><br><span class="line">map.set(c, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">map.set(d, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">map.size <span class="comment">// 3</span></span><br><span class="line">map.get(c) <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>实例属性和方法</strong>：</p><ul><li><code>Map.prototype.size</code>：返回 <code>Map</code> 对象的键值对数量；</li><li><code>Map.prototype.set(key, value)</code>：设置 <code>Map</code> 对象中键的值。返回该 <code>Map</code> 对象；</li><li><code>Map.prototype.get(key)</code>： 返回键对应的值，如果不存在，则返回 <code>undefined</code>；</li><li><code>Map.prototype.has(key)</code>：返回一个布尔值，表示 <code>Map</code> 实例是否包含键对应的值；</li><li><code>Map.prototype.delete(key)</code>： 如果 <code>Map</code> 对象中存在该元素，则移除它并返回 <code>true</code>；</li><li><code>Map.prototype.clear()</code>： 移除 <code>Map</code> 对象的所有键/值对；</li><li><code>Map.prototype.keys()</code>：返回一个新的 <code>Iterator</code> 对象， 它按插入顺序包含了 <code>Map</code> 对象中每个元素的键；</li><li><code>Map.prototype.values()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map</code> 对象中每个元素的值；</li><li><code>Map.prototype.entries()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map</code> 对象中每个元素的 <code>[key, value]</code> 数组；</li><li><code>Map.prototype.forEach(callbackFn[, thisArg])</code>：按插入顺序遍历 <code>Map</code>；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125; &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125; &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><ul><li><p>类似于 <code>Map</code> 的结构，但是键必须是对象的弱引用，注意弱引用的是键名而不是键值，因而 <code>WeakMap</code> 是不能被迭代的；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;</span><br><span class="line">wm.set(foo, <span class="string">&#x27;a&#x27;</span>) <span class="comment">// Weak</span></span><br><span class="line">wm.get(foo) <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">wm.has(foo) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>虽然 <code>wm</code> 的键对 <code>foo</code> 对象有引用，但是丝毫不会阻止 <code>foo</code> 对象被 <code>GC</code> 回收。当引用对象 <code>foo</code> 被垃圾回收之后，<code>wm</code> 的 <code>foo</code> 键值对也会自动移除，所以不用手动删除引用。</p></li></ul><p><strong>实例方法</strong>：</p><ul><li><code>WeakMap.prototype.delete(key)</code>：移除 <code>key</code> 的关联对象；</li><li><code>WeakMap.prototype.get(key)</code>：返回 key 关联对象, 或者 undefined(没有 key 关联对象时)；</li><li><code>WeakMap.prototype.has(key)</code>：根据是否有 <code>key</code> 关联对象返回一个 <code>Boolean</code> 值；</li><li><code>WeakMap.prototype.set(key, value)</code>：在 <code>WeakMap</code> 中设置一组 <code>key</code> 关联对象，返回这个 <code>WeakMap</code> 对象；</li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul><li><p><code>Proxy</code> 用来定义基本操作的的自定义行为，可以理解为当对目标对象 <code>target</code> 进行某个操作之前会先进行拦截（执行 <code>handler</code> 里定义的方法），必须要对 <code>Proxy</code> 实例进行操作才能触发拦截，对目标对象操作是不会拦截的，可以通过如下方式定义一个代理实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;target.name&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">instance.name <span class="comment">// &#x27;hello, 布兰&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>如果 <code>handle</code> 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;)</span><br><span class="line">proxy.name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">target.name <span class="comment">// &#x27;布兰&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>目标对象被 <code>Proxy</code> 代理的时候，内部的 <code>this</code> 会指向代理的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === proxy)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">target.m() <span class="comment">// false</span></span><br><span class="line">proxy.m() <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>静态方法</strong>：</p><ul><li><p><code>Proxy.revocable()</code> 用以定义一个可撤销的 <code>Proxy</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler)</span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">123</span></span><br><span class="line">proxy.foo <span class="comment">// 123</span></span><br><span class="line">revoke()</span><br><span class="line">proxy.foo <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></li></ul><p><strong><code>handle</code> 对象的方法</strong>：</p><ul><li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。</li><li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如 <code>proxy.foo = v或proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li><code>has(target, propKey)</code>：拦截 <code>propKey in proxy</code> 的操作，返回一个布尔值。<br><code>deleteProperty(target, propKey)</code>：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li><li><code>ownKeys(target)</code>：拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code> 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys()</code> 的返回结果仅包括目标对象自身的可遍历属性。</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li><code>defineProperty(target, propKey, propDesc)</code>：拦截 <code>Object.defineProperty(proxy, propKey, propDesc)</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li><code>preventExtensions(target)</code>：拦截 <code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li><code>getPrototypeOf(target)</code>：拦截 <code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li><code>isExtensible(target)</code>：拦截 <code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li><code>setPrototypeOf(target, proto)</code>：拦截 <code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li><code>apply(target, object, args)</code>：拦截 <code>Proxy</code> 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li><code>construct(target, args)</code>：拦截 <code>Proxy</code> 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code>。</li></ul><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul><li><code>Reflect</code> 是一个内置的对象，它提供拦截 <code>JavaScript</code> 操作的方法。这些方法与 <code>proxy handlers</code> 的方法相同。<code>Reflect</code> 不是一个函数对象，因此它是不可构造的。</li><li>设计的目的：<ul><li>将 <code>Object</code> 属于语言内部的方法放到 <code>Reflect</code> 上；</li><li>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理；</li><li>让 <code>Object</code> 操作变成函数行为；</li><li><code>Proxy handles</code> 与 <code>Reflect</code> 方法一一对应，前者用于定义自定义行为，而后者用于恢复默认行为；</li></ul></li></ul><p><strong>静态方法</strong>：</p><ul><li><code>Reflect.apply(target, thisArgument, argumentsList)</code> 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 <code>Function.prototype.apply()</code> 功能类似；</li><li><code>Reflect.construct(target, argumentsList[, newTarget])</code> 对构造函数进行 <code>new</code> 操作，相当于执行 <code>new target(...args)</code>；</li><li><code>Reflect.defineProperty(target, propertyKey, attributes)</code> 和 <code>Object.defineProperty()</code> 类似。如果设置成功就会返回 <code>true</code>；</li><li><code>Reflect.deleteProperty(target, propertyKey)</code> 作为函数的 <code>delete</code> 操作符，相当于执行 <code>delete target[name]</code>；</li><li><code>Reflect.get(target, propertyKey[, receiver])</code> 获取对象身上某个属性的值，类似于 <code>target[name]</code>；</li><li><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code> 类似于 <code>Object.getOwnPropertyDescriptor()</code>。如果对象中存在该属性，则返回对应的属性描述符, 否则返回 <code>undefined</code>；</li><li><code>Reflect.getPrototypeOf(target)</code> 类似于 <code>Object.getPrototypeOf()</code>；</li><li><code>Reflect.has(target, propertyKey)</code> 判断一个对象是否存在某个属性，和 <code>in</code> 运算符 的功能完全相同；</li><li><code>Reflect.isExtensible(target)</code> 类似于 <code>Object.isExtensible()</code>；</li><li><code>Reflect.ownKeys(target)</code> 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <code>Object.keys()</code>, 但不会受 <code>enumerable</code> 影响)；</li><li><code>Reflect.preventExtensions(target)</code> 类似于 <code>Object.preventExtensions()</code>。返回一个 <code>Boolean</code>；</li><li><code>Reflect.set(target, propertyKey, value[, receiver])</code> 将值分配给属性的函数。返回一个 <code>Boolean</code>，如果更新成功，则返回 <code>true</code>；</li><li><code>Reflect.setPrototypeOf(target, prototype)</code> 设置对象原型的函数. 返回一个 <code>Boolean</code>， 如果更新成功，则返回 <code>true</code>；</li></ul><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul><li><p>可以用 <code>class</code> 关键字来定义一个类，类是对一类具有共同特征的事物的抽象，就比如可以把小狗定义为一个类，小狗有名字会叫也会跳；类是特殊的函数，就像函数定义的时候有函数声明和函数表达式一样，类的定义也有类声明和类表达式，不过类声明不同于函数声明，它是无法提升的；类也有 <code>name</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  bark() &#123;&#125;</span><br><span class="line">  jump() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.name <span class="comment">// &#x27;Dog&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类表达式：可以命名（类的 name 属性取类名），也可以不命名（类的 name 属性取变量名）</span></span><br><span class="line"><span class="keyword">let</span> Animal2 = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">&#125;</span><br><span class="line">Animal2.name <span class="comment">// &#x27;Animal2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>JS</code> 中的类建立在原型的基础上（通过函数来模拟类，其实类就是构造函数的语法糖），和 <code>ES5</code> 中构造函数类似，但是也有区别，比如类的内部方法是不可被迭代的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  bark() &#123;&#125;</span><br><span class="line">  jump() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(Dog.prototype) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog2</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Dog2.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  bark() &#123;&#125;,</span><br><span class="line">  jump() &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(Dog2.prototype) <span class="comment">// [&#x27;constructor&#x27;, &#x27;bark&#x27;, &#x27;jump&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>基于原型给类添加新方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(Dog.prototype, &#123;</span><br><span class="line">  wag() &#123;&#125;, <span class="comment">// 摇尾巴</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，<code>getter</code>和 <code>setter</code> 都在严格模式下执行。</p></li><li><p>类内部的 <code>this</code> 默认指向类实例，所以如果直接调用原型方法或者静态方法会导致 <code>this</code> 指向运行时的环境，而类内部是严格模式，所以此时的 <code>this</code> 会是 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  bark() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is bark.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> jump() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is jump.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;大黄&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> &#123; bark &#125; = dog</span><br><span class="line"><span class="keyword">let</span> &#123; jump &#125; = Dog</span><br><span class="line">bark() <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line">jump() <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>方法和关键字</strong>：</p><ul><li><code>constructor</code> 方法是类的默认方法，通过 <code>new</code> 关键字生成实例的时候，会自动调用；一个类必须有<code>constructor</code> 方法，如果没有显示定义，则会自动添加一个空的；<code>constructor</code> 默认会返回实例对象：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>get</code> 和 <code>set</code> 关键字拦截某个属性的读写操作：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>用 <code>static</code> 关键字给类定义静态方法，静态方法不会存在类的原型上，所以不能通过类实例调用，只能通过类名来调用，静态方法和原型方法可以同名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  bark() &#123;&#125;</span><br><span class="line">  jump() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;原型方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> jump() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;静态方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Dog.prototype) <span class="comment">// [&#x27;constructor&#x27;, &#x27;bark&#x27;, &#x27;jump&#x27;]</span></span><br><span class="line">Dog.jump() <span class="comment">// &#x27;静态方法&#x27;</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.jump() <span class="comment">// &#x27;原型方法&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>公有字段和私有字段：</p><p>静态公有字段和静态方法一样只能通过类名调用；私有属性和私有方法只能在类的内部调用，外部调用将报错：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  age = <span class="number">12</span> <span class="comment">// 公有字段</span></span><br><span class="line">  <span class="keyword">static</span> sex = <span class="string">&#x27;male&#x27;</span> <span class="comment">// 静态公有字段</span></span><br><span class="line">  #secret = &#x27;我是人类的好朋友&#x27; // 私有字段</span><br><span class="line">  #getSecret() &#123;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    return this.#secret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.sex <span class="comment">// &#x27;male&#x27;</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.#getSecret() // SyntaxError</span><br></pre></td></tr></table></figure><blockquote><p>公共和私有字段声明是 JavaScript 标准委员会 TC39 提出的实验性功能（第 3 阶段）。浏览器中的支持是有限的，但是可以通过 Babel 等系统构建后使用此功能。</p></blockquote></li><li><p><code>new.target</code> 属性允许你检测函数、构造方法或者类是否是通过 <code>new</code> 运算符被调用的。在通过 <code>new</code> 运算符被初始化的函数或构造方法中，<code>new.target</code> 返回一个指向构造方法或函数的引用。在普通的函数调用中，<code>new.target</code> 的值是 <code>undefined</code>，子类继承父类的时候会返回子类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) <span class="keyword">return</span> <span class="string">&#x27;new target is undefined&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn is called by new&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog() <span class="comment">// &#x27;Dog&#x27;</span></span><br><span class="line">fn() <span class="comment">// &#x27;new target is undefined&#x27;</span></span><br><span class="line"><span class="keyword">new</span> fn() <span class="comment">// &#x27;fn is called by new&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>类的继承</strong>：</p><ul><li><p>类可以通过 <code>extends</code> 关键字实现继承，如果子类显示的定义了 <code>constructor</code> 则必须在内部调用 <code>super()</code> 方法，内部的 <code>this</code> 指向当前子类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is running.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name) <span class="comment">// 必须调用</span></span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  bark() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is barking.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;大黄&#x27;</span>)</span><br><span class="line">dog.run() <span class="comment">// &#x27;大黄 is running.&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <code>super()</code> 调用父类的构造函数或者通过 <code>super</code> 调用父类的原型方法；另外也可以在子类的静态方法里通过 <code>super</code> 调用父类的静态方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码改造</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="built_in">super</span>(name)  <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    bark() &#123;</span><br><span class="line">        <span class="built_in">super</span>.run()  <span class="comment">// 调用父类原型方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is barking.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.bark()s</span><br><span class="line"><span class="comment">// &#x27;大黄 is running.&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;大黄 is barking.&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>子类的 <code>__proto__</code> 属性，表示构造函数的继承，总是指向父类；子类 <code>prototype</code> 属性的 <code>__proto__</code> 属性，表示方法的继承，总是指向父类的 prototype 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dog.__proto__ === Animal <span class="comment">// true</span></span><br><span class="line">Dog.prototype.__proto__ === Animal.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>子类原型的原型指向父类的原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.__proto__.__proto__ === animal.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>extends</code> 还可以实现继承原生的构造函数，如下这些构造函数都可以被继承：</p><ul><li><code>String()</code></li><li><code>Number()</code></li><li><code>Boolean()</code></li><li><code>Array()</code></li><li><code>Object()</code></li><li><code>Function()</code></li><li><code>Date()</code></li><li><code>RegExp()</code></li><li><code>Error()</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> <span class="keyword">extends</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name)</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  welcome() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`hello <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ms = <span class="keyword">new</span> MyString(<span class="string">&#x27;布兰&#x27;</span>)</span><br><span class="line">ms.welcome() <span class="comment">// &#x27;hello 布兰&#x27;</span></span><br><span class="line">ms.length <span class="comment">// 2</span></span><br><span class="line">ms.indexOf(<span class="string">&#x27;兰&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul><li><p>浏览器传统加载模块方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步加载</span></span><br><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defer异步加载：顺序执行，文档解析完成后执行；</span></span><br><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span> defer&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async异步加载：乱序加载，下载完就执行。</span></span><br><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>浏览器现在可以按照模块（加上 <code>type=&quot;module&quot;</code>）来加载脚本，默认将按照 <code>defer</code> 的方式异步加载；<code>ES6</code> 的模块加载依赖于 <code>import</code> 和 <code>export</code> 这 2 个命令；模块内部自动采用严格模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块加载</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;test.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>export</code> 用于输出模块的对外接口，一个模块内只能允许一个 <code>export default</code> 存在，以下是几种输出模块接口的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="comment">// 写法一：单独导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：按需导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三：重命名后导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> name1, age <span class="keyword">as</span> age1 &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法四：默认导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name</span><br></pre></td></tr></table></figure></li><li><p><code>import</code> 用于输入其他模块的接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按需导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入后重命名</span></span><br><span class="line"><span class="keyword">import</span> &#123; name1 <span class="keyword">as</span> name, age1 <span class="keyword">as</span> age &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导入</span></span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> person <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合导入</span></span><br><span class="line"><span class="keyword">import</span> _, &#123; each &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br></pre></td></tr></table></figure><p><code>import</code> 导入的细节：</p><ul><li>导入的变量名必须与导出模块的名字一致，可以使用 <code>as</code> 进行重命名；</li><li>导入的变量都是只读的，不能改写；</li><li><code>import</code> 命令具有提升效果，会提升到整个模块的头部，首先执行；</li><li><code>import</code> 是编译时导入，所以不能将其写到代码块（比如 <code>if</code> 判断块里）或者函数内部；</li><li><code>import</code> 会执行所加载的模块的代码，如果重复导入同一个模块则只会执行一次模块；</li></ul></li><li><p><code>import</code> 和 <code>export</code> 的复合写法：<code>export</code> 和 <code>import</code> 语句可以结合在一起写成一行，相当于是在当前模块直接转发外部模块的接口，复合写法也支持用 <code>as</code> 重命名。以下例子中需要在 <code>hub.js</code> 模块中转发 <code>person.js</code> 的接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"><span class="comment">// 按需转发接口（中转模块：hub.js）</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; name, age &#125;</span><br><span class="line"><span class="comment">// 转发默认接口（中转模块：hub.js）</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">&#x27;./person.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> person</span><br></pre></td></tr></table></figure></li><li><p><code>ES6</code> 模块和 <code>CommonJS</code> 模块的差异：</p><ul><li><code>CommonJS</code> 模块输出的是一个值的拷贝（一旦输出一个值，模块内部的变化就影响不到这个值），<code>ES6</code> 模块输出的是值的引用（是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值）；</li><li><code>CommonJS</code> 模块是运行时加载，<code>ES6</code> 模块是编译时输出接口；</li><li><code>CommonJS</code> 模块的 <code>require()</code> 是同步加载模块，<code>ES6</code> 模块的 <code>import</code> 命令是异步加载，有一个独立的模块依赖的解析阶段；</li></ul></li></ul><h3 id="Iterator-和-for…of"><a href="#Iterator-和-for…of" class="headerlink" title="Iterator 和 for…of"></a>Iterator 和 for…of</h3><ul><li><p><code>Iterator</code> 迭代器协议，为各种数据结构提供了一种统一按照某种顺序进行访问的机制。通常部署在一个可迭代数据结构内部或其原型上。一个对象要能够成为迭代器，它必须有一个 <code>next()</code> 方法，每次执行 <code>next()</code> 方法会返回一个对象，这个对象包含了一个 <code>done</code> 属性（是个布尔值，<code>true</code> 表示可以继续下次迭代）和一个 <code>value</code> 属性（每次迭代的值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> makeIterator = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">return</span> index &lt; arr.length</span><br><span class="line">        ? &#123;</span><br><span class="line">            value: arr[index++],</span><br><span class="line">            done: <span class="literal">false</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        : &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>iterable</code> 可迭代数据结构：内部或者原型上必须有一个 <code>Symbol.iterator</code> 属性（如果是异步的则是 <code>Symbol.asyncIterator</code>），这个属性是一个函数，执行后会生成一个迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      index: <span class="number">0</span>,</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.index &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="built_in">this</span>.index++, done: <span class="literal">false</span> &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的一些可迭代数据结构有：<code>String</code>、<code>Array</code>、<code>TypedArray</code>、<code>Map</code> 和 <code>Set</code>、<code>arguments</code>、<code>NodeList</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> si = <span class="string">&#x27;hi&#x27;</span>[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">si <span class="comment">// StringIterator</span></span><br><span class="line">si.next() <span class="comment">// &#123;value: &#x27;h&#x27;, done: false&#125;</span></span><br><span class="line">si.next() <span class="comment">// &#123;value: &#x27;i&#x27;, done: false&#125;</span></span><br><span class="line">si.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>for...of</code>：用于遍历可迭代数据结构：</p><ul><li>遍历字符串：<code>for...in</code> 获取索引，<code>for...of</code> 获取值；</li><li>遍历数组：<code>for...in</code> 获取索引，<code>for...of</code> 获取值；</li><li>遍历对象：<code>for...in</code> 获取键，<code>for...of</code> 需自行部署 <code>[Symbol.iterator]</code> 接口；</li><li>遍历 <code>Set</code>：<code>for...of</code> 获取值， <code>for (const v of set)</code>；</li><li>遍历 <code>Map</code>：<code>for...of</code> 获取键值对，<code>for (const [k, v] of map)</code>；</li><li>遍历类数组：包含 <code>length</code> 的对象、<code>arguments</code> 对象、<code>NodeList</code>对象(无 <code>Iterator</code> 接口的类数组可用 <code>Array.from()</code> 转换)；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">&#x27;abc&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">//  &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 Set</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;布兰&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;age&#x27;</span>, <span class="number">12</span>],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27;: &#x27;</span> + value) <span class="comment">// &#x27;name: 布兰&#x27; &#x27;age: 12&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>for...of</code> 和 <code>for...in</code> 对比</p><p>共同点：能够通过 <code>break</code>、<code>continue</code> 和 <code>return</code> 跳出循环；<br>不同点：</p><ul><li><code>for...in</code> 的特点：只能遍历键，会遍历原型上属性，遍历无顺序，适合于对象的遍历；</li><li><code>for...of</code> 的特点：能够遍历值（某些数据结构能遍历键和值，比如 <code>Map</code>），不会遍历原型上的键值，遍历顺序为数据的添加顺序，适用于遍历可迭代数据结构；</li></ul></li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><code>Promise</code> 这块知识可以直接看我之前写的一篇文章：<a href="https://juejin.im/post/6886247841686093837">深入理解 Promise</a> 非常完整。</p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul><li><p><code>function*</code> 会定义一个生成器函数，调用生成器函数不会立即执行，而是会返回一个 <code>Generator</code> 对象，这个对象是符合可迭代协议和迭代器协议的，换句话说这个 <code>Generator</code> 是可以被迭代的。</p></li><li><p>生成器函数内部通过 <code>yield</code> 来控制暂停，而 <code>next()</code> 将把它恢复执行，它的运行逻辑是如下这样的：</p><ul><li>遇到 <code>yield</code> 表达式，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值作为返回的对象的 <code>value</code> 属性值；</li><li>下一次调用 <code>next</code> 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 表达式；</li><li>如果没有再遇到新的 <code>yield</code> 表达式，就一直运行到函数结束，直到 <code>return</code> 语句为止，并将 <code>return</code> 语句后面的表达式的值，作为返回的对象的 <code>value</code> 属性值；</li><li>如果该函数没有 <code>return</code> 语句，则返回的对象的 <code>value</code> 属性值为 <code>undefined</code>；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next() <span class="comment">// &#123;value: &#x27;hello&#x27;, done: false&#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123;value: &#x27;world&#x27;, done: false&#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123;value: &#x27;end&#x27;, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在生成器函数内部可以使用 <code>yield*</code> 表达式委托给另一个 <code>Generator</code> 或可迭代对象，比如数组、字符串等；<code>yield*</code> 表达式本身的值是当迭代器关闭时返回的值（即 <code>done</code> 为 <code>true</code> 时）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* inner()</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line">g.next()</span><br><span class="line">g.next()</span><br></pre></td></tr></table></figure></li></ul><p><strong>实例方法</strong>：</p><ul><li><p><code>Generator.prototype.next()</code>：返回一个包含属性 <code>done</code> 和 <code>value</code> 的对象。该方法也可以通过接受一个参数用以向生成器传值。如果传入了参数，那么这个参数会传给上一条执行的 <code>yield</code> 语句左边的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">12</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> a</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = f()</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">&#x27;c&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123;value: 12, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: &#x27;b&#x27;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Generator.prototype.throw()</code>：用来向生成器抛出异常，如果内部捕获了则会恢复生成器的执行（即执行下一条 <code>yield</code> 表达式），并且返回带有 <code>done</code> 及 <code>value</code> 两个属性的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">    yiele <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line">g.throw(<span class="string">&#x27;error a&#x27;</span>)</span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;error a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;b&quot;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;c&quot;, done: false&#125;</span></span><br></pre></td></tr></table></figure><p>如果内部没有捕获异常，将中断内部代码的继续执行（类似 <code>throw</code> 抛出的异常，如果没有捕获，则后面的代码将不会执行），此时异常会抛到外部，可以被外部的 <code>try...catch</code> 块捕获，此时如果再执行一次 <code>next()</code>，会返回一个值为 <code>done</code> 属性为 <code>true</code> 的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  g.throw(<span class="string">&#x27;error a&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#x27;error a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Generator.prototype.return()</code>：返回给定的值并结束生成器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>应用</strong>：</p><ul><li><p>将异步操作同步化，比如同时有多个请求，多个请求之间是有顺序的，只能等前面的请求完成了才请求后面的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res1 = <span class="keyword">yield</span> request(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res1)</span><br><span class="line">  <span class="keyword">let</span> res2 = <span class="keyword">yield</span> request(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line">  <span class="keyword">let</span> res3 = <span class="keyword">yield</span> request(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟异步请求</span></span><br><span class="line">    it.next(url)</span><br><span class="line">  &#125;, <span class="number">300</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = main()</span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>给对象部署 <code>Iterator</code> 接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i]</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;foo&#x27; 3</span></span><br><span class="line"><span class="comment">// &#x27;bar&#x27; 7</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2016.png"></p><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><p>判断一个数组是否包含某个元素，之前一般是这么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (~arr.indexOf(el)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而现在你可以这么做了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.includes(el)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>indexOf</code> 会返回找到元素在数组中的索引位置，判断的逻辑是是否严格相等，所以他在遇到 <code>NaN</code> 的时候不能正确返回索引，但是 <code>includes</code> 解决了这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>]</span><br><span class="line">  .indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>)].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="求幂运算符（-）"><a href="#求幂运算符（-）" class="headerlink" title="求幂运算符（**）"></a>求幂运算符（**）</h3><p><code>x ** y</code> 是求 <code>x</code> 的 <code>y</code> 次幂，和 <code>Math.pow(x, y)</code> 功能一致：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x ** y</span></span><br><span class="line"><span class="keyword">let</span> squared = <span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 2 * 2 = 4</span></span><br><span class="line"><span class="keyword">let</span> cubed = <span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 2 * 2 * 2 = 8</span></span><br></pre></td></tr></table></figure><p><code>x **= y</code> 表示求 <code>x</code> 的 <code>y</code> 次幂，并且把结果赋值给 <code>x</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x **= y</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line">x **= <span class="number">3</span> <span class="comment">// x 最后等于 8</span></span><br></pre></td></tr></table></figure><h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2017.png"></p><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p>返回一个由对象自身所有可遍历属性的属性值组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">12</span>,</span><br><span class="line">  enumrable: <span class="literal">false</span>, <span class="comment">// age 属性将不可遍历</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(person)) <span class="comment">// [&#x27;布兰&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似 str.split(&#x27;&#x27;) 效果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(<span class="string">&#x27;abc&#x27;</span>)) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>返回一个由对象自身所有可遍历属性的键值对组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(person)) <span class="comment">// [[&quot;name&quot;, &quot;布兰&quot;], [&quot;age&quot;, 12]]</span></span><br></pre></td></tr></table></figure><p>利用这个方法可以很好的将对象转成正在的 <code>Map</code> 结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(person))</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptor()</code> 会返回指定对象某个自身属性的的描述对象，而 <code>Object.getOwnPropertyDescriptors()</code> 则是返回指定对象自身所有属性的描述对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person))</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  name: &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;,</span></span><br><span class="line"><span class="comment">//  age: &#123;configurable: false, enumerable: false, value: 12, writable: false&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>配合 <code>Object.create()</code> 可以实现浅克隆：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Object</span>.create(</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="String-prototype-padStart"><a href="#String-prototype-padStart" class="headerlink" title="String.prototype.padStart()"></a>String.prototype.padStart()</h3><p><code>str.padStart(length [, padStr])</code> 会返回一个新字符串，该字符串将从 <code>str</code> 字符串的左侧开始填充某个字符串 <code>padStr</code>（非必填，如果不是字符串则会转成字符串, 传入 <code>undefined</code> 和不传这个参数效果一致）直到达到指定位数 <code>length</code> 为止：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>, <span class="number">2</span>) <span class="comment">// &#x27;22abc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>, <span class="literal">undefined</span>) <span class="comment">// &#x27;  abc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>, &#123;&#125;) <span class="comment">// &#x27;[oabc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">5</span>) <span class="comment">// &#x27;  abc&#x27;</span></span><br><span class="line"><span class="string">&#x27;abcde&#x27;</span>.padStart(<span class="number">2</span>, <span class="string">&#x27;f&#x27;</span>) <span class="comment">// &#x27;abcde&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-padEnd"><a href="#String-prototype-padEnd" class="headerlink" title="String.prototype.padEnd()"></a>String.prototype.padEnd()</h3><p>规则和 <code>padStart</code> 类似，但是是从字符串右侧开始填充：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padEnd(<span class="number">5</span>, <span class="number">2</span>) <span class="comment">// &#x27;abc22&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="函数参数尾逗号"><a href="#函数参数尾逗号" class="headerlink" title="函数参数尾逗号"></a>函数参数尾逗号</h3><p>允许函数在定义和调用的时候时候最后一个参数后加上逗号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">param1, param2</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">init(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Async-函数"><a href="#Async-函数" class="headerlink" title="Async 函数"></a>Async 函数</h3><ul><li><p>使用 <code>async</code> 可以声明一个 <code>async</code> 函数，结合 <code>await</code> 可以用一种很简介的方法写成基于 <code>Promise</code> 的异步行为，而不需要刻意的链式调用。<code>await</code> 表达式会暂停整个 <code>async</code> 函数的执行进程并出让其控制权，只有当其等待的基于 <code>Promise</code> 的异步操作被兑现或被拒绝之后才会恢复进程。<code>async</code> 函数有如下几种定义形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法</span></span><br><span class="line">lef obj = &#123;</span><br><span class="line">    <span class="keyword">async</span> foo() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">async</span> bark() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>async</code> 函数一定会返回一个 <code>Promise</code> 对象，所以它可以使用 <code>then</code> 添加处理函数。如果一个 <code>async</code> 函数的返回值看起来不是<code>Promise</code>，那么它将会被隐式地包装在一个 <code>Promise</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>内部如果发生错误，或者显示抛出错误，那么 <code>async</code> 函数会返回一个 <code>rejected</code> 状态的 <code>Promsie</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo().catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err) <span class="comment">// Error: error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>返回的 <code>Promise</code> 对象必须等到内部所有 <code>await</code> 命令 <code>Promise</code> 对象执行完才会发生状态改变，除非遇到 <code>return</code> 语句或抛出错误；任何一个 <code>await</code> 命令返回的 <code>Promise</code> 对象变 <code>为rejected</code> 状态，整个 <code>Async</code> 函数都会中断后续执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a_&#x27;</span> + a)</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b_&#x27;</span> + b) <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 不会执行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#x27;a_success&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;fail&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>所以为了保证 <code>async</code> 里的异步操作都能完成，我们需要将他们放到 <code>try...catch()</code> 块里或者在 <code>await</code> 返回的 <code>Promise</code> 后跟一个 <code>catch</code> 处理函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;a fail&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a_&#x27;</span> + a) <span class="comment">// 不会执行</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e) <span class="comment">// &#x27;a fail&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;b fail&#x27;</span>).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e) <span class="comment">// &#x27;b fail&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b_&#x27;</span> + b) <span class="comment">// &#x27;bundefined&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 不会执行</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>async</code> 函数里的多个异步操作之间没有依赖关系，建议将他们写到一起减少执行时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo()</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar()</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise</span><br></pre></td></tr></table></figure></li><li><p><code>await</code> 命令只能用在 <code>async</code> 函数之中，如果用在普通函数，就会报错。</p></li></ul><h3 id="共享内存和-Atomics-对象"><a href="#共享内存和-Atomics-对象" class="headerlink" title="共享内存和 Atomics 对象"></a>共享内存和 Atomics 对象</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/arraybuffer#SharedArrayBuffer">SharedArrayBuffer</a></li><li><a href="https://es6.ruanyifeng.com/#docs/arraybuffer#Atomics-%E5%AF%B9%E8%B1%A1">Atomics</a></li></ul><h2 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2018.png"></p><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>Promise.prototype.finally()</code> 用于给 <code>Promise</code> 对象添加 <code>onFinally</code> 函数，这个函数主要是做一些清理的工作，<strong>只有状态变化</strong>的时候才会执行该 <code>onFinally</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">888</span>) <span class="comment">// 并不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;).finally(onFinally)</span><br></pre></td></tr></table></figure><p><code>finally()</code> 会生成一个 <code>Promise</code> 新实例，finally 一般会原样后传父 Promise，无论父级实例是什么状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = p3.finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3) <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure><p>上面说的是一般，但是也有特殊情况，比如 <code>finally</code> 里返回了一个非 <code>fulfilled</code> 的 <code>Promise</code> 或者抛出了异常的时候，则会返回对应状态的新实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3) <span class="comment">// Promise &#123;&lt;rejected&gt;: 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = p1.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4) <span class="comment">// Promise &#123;&lt;rejected&gt;: Error: error&#125;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.im/post/6886247841686093837#heading-9">深入理解 Promise</a></p><h3 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h3><p>想要了解异步迭代器最好的方式就是和同步迭代器进行对比。我们知道可迭代数据的内部都是有一个 <code>Symbol.iterator</code> 属性，它是一个函数，执行后会返回一个迭代器对象，这个迭代器对象有一个 <code>next()</code> 方法可以对数据进行迭代，<code>next()</code> 执行后会返回一个对象，包含了当前迭代值 <code>value</code> 和 标识是否完成迭代的 <code>done</code> 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = [<span class="number">1</span>, <span class="number">2</span>][<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefinde, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面这里的 <code>next()</code> 执行的是同步操作，所以这个是同步迭代器，但是如果 <code>next()</code> 里需要执行异步操作，那就需要异步迭代了，可异步迭代数据的内部有一个 <code>Symbol.asyncIterator</code> 属性，基于此我们来实现一个异步迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(iterable) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = iterable</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">this</span>.data.length,</span><br><span class="line">      index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> done = index &gt;= length</span><br><span class="line">        <span class="keyword">const</span> value = !done ? <span class="built_in">this</span>.data[index++] : <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(&#123; value, done &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步迭代器的 <code>next()</code> 会进行异步的操作，通常是返回一个 <code>Promise</code>，所以需要对应的处理函数去处理结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> asyncIterator = emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">asyncIterator.next().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line">asyncIterator.next().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line">asyncIterator.next().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>另外也可以使用 <code>for await...of</code> 来迭代异步可迭代数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> asyncIterable = <span class="keyword">new</span> Emitter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> asyncIterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount()</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>另外还可以通过异步生成器来创建异步迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(iterable) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = iterable</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">this</span>.data.length,</span><br><span class="line">      index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; length) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">this</span>.data[index++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">  <span class="keyword">const</span> asyncIterable = emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> asyncIterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount()</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration_protocols</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for-await...of">for-await…of</a></li></ul><h3 id="s-修饰符-dotAll-模式"><a href="#s-修饰符-dotAll-模式" class="headerlink" title="s 修饰符(dotAll 模式)"></a>s 修饰符(dotAll 模式)</h3><p>正则表达式新增了一个 <code>s</code> 修饰符，使得 <code>.</code> 可以匹配任意单个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/foo.bar/</span>.test(<span class="string">&#x27;foo\nbar&#x27;</span>) / <span class="comment">// false</span></span><br><span class="line">  foo.bar /</span><br><span class="line">  s.test(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面这又被称为 <code>dotAll</code> 模式，表示点（<code>dot</code>）代表一切字符。所以，正则表达式还引入了一个 dotAll 属性，返回一个布尔值，表示该正则表达式是否处在 dotAll 模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/foo.bar/</span>s.dotAll <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="具名组匹配"><a href="#具名组匹配" class="headerlink" title="具名组匹配"></a>具名组匹配</h3><p>正则表达式可以使用捕获组来匹配字符串，但是想要获取某个组的结果只能通过对应的索引来获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> result = re.exec(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="comment">// result[0] === &#x27;2015-01-02&#x27;</span></span><br><span class="line"><span class="comment">// result[1] === &#x27;2015&#x27;</span></span><br><span class="line"><span class="comment">// result[2] === &#x27;01&#x27;</span></span><br><span class="line"><span class="comment">// result[3] === &#x27;02&#x27;</span></span><br></pre></td></tr></table></figure><p>而现在我们可以通过给捕获组 <code>(?&lt;name&gt;...)</code> 加上名字 <code>name</code> ，通过名字来获取对应组的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> result = re.exec(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="comment">// result.groups.year === &#x27;2015&#x27;</span></span><br><span class="line"><span class="comment">// result.groups.month === &#x27;01&#x27;</span></span><br><span class="line"><span class="comment">// result.groups.day === &#x27;02&#x27;</span></span><br></pre></td></tr></table></figure><p>配合解构赋值可以写出非常精简的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  groups: &#123; year, month, day &#125;,</span><br><span class="line">&#125; = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>.exec(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(year, month, day) <span class="comment">// 2015 01 02</span></span><br></pre></td></tr></table></figure><p>具名组也可以通过传递给 <code>String.prototype.replace</code> 的替换值中进行引用。如果该值为字符串，则可以使用 <code>$&lt;name&gt;</code> 获取到对应组的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">&#x27;2015-01-02&#x27;</span>.replace(re, <span class="string">&#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// result === &#x27;02/01/2015&#x27;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/tc39/proposal-regexp-named-groups">proposal-regexp-named-groups</a></p><h3 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h3><p>后行断言： <code>(?&lt;=y)x</code>，<code>x</code> 只有在 <code>y</code> 后面才能匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/(?&lt;=\$)\d+/</span>.exec(<span class="string">&#x27;I have $100.&#x27;</span>) <span class="comment">// [&#x27;100&#x27;]</span></span><br></pre></td></tr></table></figure><p>后行否定断言： <code>(?&lt;!y)x</code>，<code>x</code> 只有不在 <code>y</code> 后面才能匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="regexp">/(?&lt;!\$)\d+/</span>.exec(<span class="string">&#x27;I have $100.&#x27;</span>) <span class="comment">// [&#x27;00&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="Unicode-属性转义"><a href="#Unicode-属性转义" class="headerlink" title="Unicode 属性转义"></a>Unicode 属性转义</h3><p>允许正则表达式匹配符合 <code>Unicode</code> 某种属性的所有字符，<code>\p&#123;...&#125;</code> 是匹配包含，<code>\P&#123;...&#125;</code> 是匹配不包含的字符，且必须搭配 <code>/u</code> 修饰符才会生效：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\p&#123;Emoji&#125;+<span class="regexp">/u.exec(&#x27;😁😭笑死我了🤣😂不行了&#x27;)  /</span><span class="regexp">/ [&#x27;😁😭&#x27;]</span></span><br><span class="line"><span class="regexp">/</span>\P&#123;Emoji&#125;+<span class="regexp">/u.exec(&#x27;😁😭笑死我了🤣😂不行了&#x27;)  /</span><span class="regexp">/ [&#x27;笑死我了&#x27;]</span></span><br></pre></td></tr></table></figure><p>这里可以查询到更多的 <code>Unicode</code> 的属性 <a href="http://unicode.org/reports/tr18/#Full_Properties">Full_Properties</a></p><h3 id="对象扩展运算符"><a href="#对象扩展运算符" class="headerlink" title="对象扩展运算符"></a>对象扩展运算符</h3><p>对象的扩展运算符可以用到解构赋值上，且只能应用到最后一个变量上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, ...y &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">// &#123;a: 2, b: 3&#125;</span></span><br></pre></td></tr></table></figure><p>对象扩展运算符不能解构原型上的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">obj.__proto__ = &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123; ...a &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(a.y) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>应用一：可以实现浅拷贝，但是不会拷贝原始属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(&#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;)</span><br><span class="line">person.age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝写法一</span></span><br><span class="line"><span class="keyword">let</span> &#123; ...pClone1 &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(pClone1) <span class="comment">// &#123; age: 12 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(pClone1.name) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝写法二</span></span><br><span class="line"><span class="keyword">let</span> pClone2 = &#123; ...person &#125;</span><br><span class="line"><span class="built_in">console</span>.log(pClone2) <span class="comment">// &#123; age: 12 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(pClone2.name) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>应用二：合并两个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b)</span><br></pre></td></tr></table></figure><p>应用三：重写对象属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure><p>应用四：给新对象设置默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;</span><br></pre></td></tr></table></figure><p>应用五：利用扩展运算符的解构赋值可以扩展函数参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> baseFunction(restConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md">Object Spread Initializer</a></li><li><a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Rest.md">Object Rest Destructuring</a></li></ul><h3 id="放松对标签模板里字符串转义的限制"><a href="#放松对标签模板里字符串转义的限制" class="headerlink" title="放松对标签模板里字符串转义的限制"></a>放松对标签模板里字符串转义的限制</h3><p><a href="https://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%99%90%E5%88%B6">ECMAScript 6 入门</a></p><h2 id="ES2019"><a href="#ES2019" class="headerlink" title="ES2019"></a>ES2019</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2019.png"></p><h3 id="允许省略-catch-里的参数"><a href="#允许省略-catch-里的参数" class="headerlink" title="允许省略 catch 里的参数"></a>允许省略 catch 里的参数</h3><p>异常被捕获的时候如果不需要做操作，甚至可以省略 <code>catch(err)</code> 里的参数和圆括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON-stringify-变动"><a href="#JSON-stringify-变动" class="headerlink" title="JSON.stringify()变动"></a>JSON.stringify()变动</h3><p><code>UTF-8</code> 标准规定，<code>0xD800</code> 到 <code>0xDFFF</code> 之间的码点，不能单独使用，必须配对使用。<br>所以 <code>JSON.stringify()</code> 对单个码点进行操作，如果码点符合 <code>UTF-8</code> 标准，则会返回对应的字符，否则会返回对应的码点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;1f600&#125;&#x27;</span>) <span class="comment">// &quot;&quot;😀&quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="comment">// &quot;&quot;\ud834&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h3><p><code>Symbol</code> 实例新增了一个描述属性 <code>description</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">symbol.description <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h3><p>函数的 <code>toString()</code> 会原样输出函数定义时候的样子，不会省略注释和空格。</p><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.fromEntries()</code> 方法是 <code>Object.entries()</code> 的逆操作，用于将一个键值对数组转为对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> keyValueArr = <span class="built_in">Object</span>.entries(person) <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(arr) <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>常用可迭代数据结构之间的装换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 -&gt; 键值对数组</span></span><br><span class="line"><span class="keyword">let</span> keyValueArr = <span class="built_in">Object</span>.entries(person) <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对数组 -&gt; Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(keyValueArr) <span class="comment">// Map &#123;&quot;name&quot;: &quot;布兰&quot;, &quot;age&quot;: 12&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map -&gt; 键值对数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(map) <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对数组 -&gt; 对象</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Array</span>.from(arr).reduce(</span><br><span class="line">  (acc, [key, val]) =&gt; <span class="built_in">Object</span>.assign(acc, &#123; [key]: val &#125;),</span><br><span class="line">  &#123;&#125;</span><br><span class="line">) <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/tc39/proposal-object-from-entries">Object.fromEntries</a></p><h3 id="字符串可直接输入行分隔符和段分隔符"><a href="#字符串可直接输入行分隔符和段分隔符" class="headerlink" title="字符串可直接输入行分隔符和段分隔符"></a>字符串可直接输入行分隔符和段分隔符</h3><p><code>JavaScript</code> 规定有 5 个字符，不能在字符串里面直接使用，只能使用转义形式。</p><ul><li><code>U+005C</code>：反斜杠（reverse solidus)</li><li><code>U+000D</code>：回车（carriage return）</li><li><code>U+2028</code>：行分隔符（line separator）</li><li><code>U+2029</code>：段分隔符（paragraph separator）</li><li><code>U+000A</code>：换行符（line feed）</li></ul><p>但是由于 <code>JSON</code> 允许字符串里可以使用 <code>U+2028</code> 和 <code>U+2029</code>，所以使得 <code>JSON.parse()</code> 去解析字符串的时候可能会报错，所以 <code>ES2019</code> 允许模板字符串里可以直接这两个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;\u2028&quot;&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;\u2029&quot;&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;\u005C&quot;&#x27;</span>) <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-trimStart"><a href="#String-prototype-trimStart" class="headerlink" title="String.prototype.trimStart"></a>String.prototype.trimStart</h3><p>消除字符串头部空格，返回一个新字符串；浏览器还额外增加了它的别名函数 <code>trimLeft()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;  hello world &#x27;</span></span><br><span class="line"><span class="keyword">let</span> newStr = str.trimStart()</span><br><span class="line"><span class="built_in">console</span>.log(newStr, newStr === str)</span><br><span class="line"><span class="comment">// &#x27;hello world &#x27;  false</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-trimEnd"><a href="#String-prototype-trimEnd" class="headerlink" title="String.prototype.trimEnd"></a>String.prototype.trimEnd</h3><p>消除字符串尾部空格，返回一个新字符串；浏览器还额外增加了它的别名函数 <code>trimRight()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;  hello world &#x27;</span></span><br><span class="line"><span class="keyword">let</span> newStr = str.trimEnd()</span><br><span class="line"><span class="built_in">console</span>.log(newStr, newStr === str)</span><br><span class="line"><span class="comment">// &#x27;  hello world&#x27;  false</span></span><br></pre></td></tr></table></figure><h3 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h3><p><code>arr.flat(depth)</code> 按照 <code>depth</code> （不传值的话默认是 1）深度拍平一个数组，并且将结果以新数组形式返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// depth 默认是 1</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.flat()) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Infinity，可展开任意深度的嵌套数组；自动跳过空数组；</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, , [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr2.flat(<span class="literal">Infinity</span>))</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>用 <code>reduce</code> 实现拍平一层数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> newStr = arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.concat(cur), [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> flattened = <span class="function">(<span class="params">arr</span>) =&gt;</span> [].concat(...arr)</span><br><span class="line">flattened(arr)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">flat</a></p><h3 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h3><p><code>flatMap(callback)</code> 使用映射函数 <code>callback</code> 映射每个元素，<code>callback</code> 每次的返回值组成一个数组，并且将这个数组执行类似 <code>arr.flat(1)</code> 的操作进行拍平一层后最后返回结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// 将 [[2], [4], [6], [8]] 数组拍平一层得到最终结果：[2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap">flatMap</a></p><h2 id="ES2020"><a href="#ES2020" class="headerlink" title="ES2020"></a>ES2020</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2020.png"></p><h3 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll()"></a>String.prototype.matchAll()</h3><p><code>String.prototype.matchAll()</code> 方法，可以一次性取出所有匹配。不过，它返回的是一个 <code>RegExpStringIterator</code> 迭代器同是也是一个可迭代的数据结构，所以可以通过 <code>for...of</code> 进行迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;test1test2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span></span><br><span class="line"><span class="keyword">let</span> iterable = str.matchAll(regexp)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;test1&#x27;, &#x27;e&#x27;, &#x27;st1&#x27;, &#x27;1&#x27;, index: 0, input: &#x27;test1test1&#x27;, groups: undefined]</span></span><br><span class="line"><span class="comment">// [&#x27;test2&#x27;, &#x27;e&#x27;, &#x27;st2&#x27;, &#x27;2&#x27;, index: 5, input: &#x27;test1test2&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意当使用 matchAll(regexp) 的时候，正则表达式必须加上 /g 修饰符。</p></blockquote><p>也可以将这个可迭代数据转成数组形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">;[...str.matchAll(regexp)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="built_in">Array</span>.from(str.matchAll(regexp))</span><br></pre></td></tr></table></figure><h3 id="动态-import"><a href="#动态-import" class="headerlink" title="动态 import()"></a>动态 import()</h3><p>标准用法的 <code>import</code> 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。</p><p>比如按需加载一个模块可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xxx) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module.js&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>import()</code> 是异步导入的，结果会返回一个 <code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;/module.js&#x27;</span>).then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something with the module.</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>动态 <code>import()</code> 的应用场景挺多的，比如 <code>Vue</code> 中的路由懒加载就是使用的动态导入组件。另外由于动态性不便于静态分析工具和 <code>tree-shaking</code> 工作，所以不能滥用。</p><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p><code>BigInt</code> 是一种内置对象，它提供了一种方法来表示大于 $2^{53}$ - 1 的整数。这原本是 <code>Javascript</code> 中可以用 <code>Number</code> 表示的最大数字。<code>BigInt</code> 可以表示任意大的整数。</p><p>为了区分 <code>Number</code>，定义一个 <code>BigInt</code> 需要在整数后面加上一个 <code>n</code>，或者用函数直接定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = <span class="number">10n</span></span><br><span class="line"><span class="keyword">const</span> num2 = BigInt(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><code>Number</code> 和 <code>BigInt</code> 之间能进行比较，但他们之间是宽松相等；且由于他们表示的是不同类型的数字，所以不能直接进行四则运算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10n</span> == <span class="number">10</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">10n</span> === <span class="number">10</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">10n</span> &gt; <span class="number">8</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">10</span> + <span class="built_in">Number</span>(<span class="number">10n</span>) <span class="comment">// 20</span></span><br><span class="line"><span class="number">10</span> + <span class="number">10n</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p><code>Promise.allSettled(iterable)</code> 当所有的实例都已经 <code>settled</code>，即状态变化过了，那么将返回一个新实例，该新实例的内部值是由所有实例的值和状态组合成的数组，数组的每项是由每个实例的状态和内部值组成的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.allSettled([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">9</span>)</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">6</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  init(),</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: undefined&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, reason: 6&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 3&#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>只要所有实例中包含一个 <code>pending</code> 状态的实例，那么 <code>Promise.allSettled()</code> 的结果为返回一个这样 <code>Promise &#123;&lt;pending&gt;&#125;</code> 的实例。</p><h3 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h3><p>在以前，从不同的 <code>JavaScript</code> 环境中获取全局对象需要不同的语句。在 <code>Web</code> 中，可以通过 <code>window</code>、<code>self</code> 或者 <code>frames</code> 取到全局对象，但是在 <code>Web Workers</code> 中，只有 <code>self</code> 可以。在 <code>Node.js</code> 中，它们都无法获取，必须使用 <code>global</code>。</p><p>而现在只需要使用 <code>globalThis</code> 即可获取到顶层对象，而不用担心环境问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line">globalThis === <span class="built_in">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="import-meta"><a href="#import-meta" class="headerlink" title="import.meta"></a>import.meta</h3><p><code>import.meta</code> 是一个给 <code>JavaScript</code> 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 <code>URL</code>，<code>import.meta</code> 必须在一个模块里使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有声明 type=&quot;module&quot;，就使用 import.meta 会报错</span></span><br><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在module.js里</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">import</span>.meta)</span><br><span class="line"><span class="comment">// &#123;url: &quot;http://localhost/3ag/js/module.js&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>如果需要在配置了 <code>Webpack</code> 的项目，比如 <code>Vue</code> 里使用 <code>import.meta</code> 需要加一个包且配置一下参数，否则项目编译阶段会报错。</p><p>包配置详情参考：<a href="https://www.npmjs.com/package/@open-wc/webpack-import-meta-loader">@open-wc/webpack-import-meta-loader</a></p><p>比如我用的是 <code>4.x</code> 版本的 <code>vue-cli</code>，那我需要在 <code>vue.config.js</code> 里配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">      .test(<span class="regexp">/\.js$/</span>)</span><br><span class="line">      .use(<span class="string">&#x27;@open-wc/webpack-import-meta-loader&#x27;</span>)</span><br><span class="line">      .loader(<span class="string">&#x27;@open-wc/webpack-import-meta-loader&#x27;</span>)</span><br><span class="line">      .end()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选链操作符（-）"><a href="#可选链操作符（-）" class="headerlink" title="可选链操作符（?.）"></a>可选链操作符（?.）</h3><p>通常我们获取一个深层对象的属性会需要写很多判断或者使用逻辑与 <code>&amp;&amp;</code> 操作符，因为对象的某个属性如果为 <code>null</code> 或者 <code>undefined</code> 就有可能报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  first: &#123;</span><br><span class="line">    second: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> name1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.first) &#123;</span><br><span class="line">    name1 = obj.first.second</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> name2 = obj &amp;&amp; obj.first &amp;&amp; obj.first.second</span><br></pre></td></tr></table></figure><p><code>?.</code> 操作符允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。如果某个属性为 <code>null</code> 或者 <code>undefined</code> 则结果直接为 <code>undefined</code>。有了可选链操作符就可以使得表达式更加简明了，对于上面例子用可选链操作符可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name3 = obj?.first?.second</span><br></pre></td></tr></table></figure><h3 id="空值合并操作符（-）"><a href="#空值合并操作符（-）" class="headerlink" title="空值合并操作符（??）"></a>空值合并操作符（??）</h3><p>对于逻辑或 <code>||</code> 运算符，当对运算符左侧的操作数进行装换为 <code>Boolean</code> 值的时候，如果为 <code>true</code>，则取左边的操作数为结果，否则取右边的操作数为结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// &#x27;布兰&#x27;</span></span><br></pre></td></tr></table></figure><p>我们都知道 <code>&#39;&#39;</code>、<code>0</code>、<code>null</code>、<code>undefined</code>、<code>false</code>、<code>NaN</code> 等转成 <code>Boolean</code> 值的时候都是 <code>false</code>，所以都会取右边的操作数。这个时候如果要给变量设置默认值，如果遇到本身值就可能是 <code>&#39;&#39;</code> 或 <code>0</code> 的情况那就会出错了，会被错误的设置为默认值了。</p><p>而 <code>??</code> 操作符就是为了解决这个问题而出现的，<code>x ?? y</code> 只有左侧的操作数为 <code>null</code> 或 <code>undefined</code> 的时候才取右侧操作数，否则取左侧操作数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span> ?? <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="ES2021"><a href="#ES2021" class="headerlink" title="ES2021"></a>ES2021</h2><p><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es2021.png"></p><p>如下这几个提案已经确定了会在 2021 年发布，所以把他们归到 <code>ES2021</code> 中。</p><h3 id="String-prototype-replaceAll"><a href="#String-prototype-replaceAll" class="headerlink" title="String.prototype.replaceAll"></a>String.prototype.replaceAll</h3><p>之前需要替换一个字符串里的全部匹配字符可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = <span class="string">&#x27;q=query+string+parameters&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">const</span> withSpaces1 = queryString.replace(<span class="regexp">/\+/g</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> withSpaces2 = queryString.split(<span class="string">&#x27;+&#x27;</span>).join(<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>而现在只需要这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withSpace3 = queryString.replaceAll(<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>replaceAll 的第一个参数可以是字符串也可以是正则表达式，当是正则表达式的时候，必须加上全局修饰符 /g，否则报错。</p></blockquote><p>参考：<a href="https://github.com/tc39/proposal-string-replaceall">string-replaceall</a></p><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h3><p><code>Promsie.any()</code> 和 <code>Promise.all()</code> 一样接受一个可迭代的对象，然后依据不同的入参会返回不同的新实例：</p><ul><li><p>传一个空的可迭代对象或者可迭代对象所有 <code>Promise</code> 都是 <code>rejected</code> 状态的，则会抛出一个 <code>AggregateError</code> 类型的错误，同时返回一个 <code>rejected</code> 状态的新实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.any([])</span><br><span class="line"><span class="keyword">let</span> p2.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;rejected&gt;: AggregateError: All promises were rejected&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>只要可迭代对象里包含任何一个 <code>fulfilled</code> 状态的 <code>Promise</code>，则会返回第一个 <code>fulfilled</code> 的实例，并且以它的值作为新实例的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.any([</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">2</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line">])</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>其他情况下，都会返回一个 <code>pending</code> 状态的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.any([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">2</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;),</span><br><span class="line">])</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;pending&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="WeakRef"><a href="#WeakRef" class="headerlink" title="WeakRef"></a>WeakRef</h3><p>我们知道一个普通的引用（默认是强引用）会将与之对应的对象保存在内存中。只有当该对象没有任何的强引用时，<code>JavaScript</code> 引擎 <code>GC</code> 才会销毁该对象并且回收该对象所占的内存空间。</p><p><code>WeakRef</code> 对象允许你保留对另一个对象的弱引用，而不会阻止被弱引用的对象被 <code>GC</code> 回收。<code>WeakRef</code> 的实例方法 <code>deref()</code> 可以返回当前实例的 <code>WeakRef</code> 对象所绑定的 <code>target</code> 对象，如果该 <code>target</code> 对象已被 <code>GC</code> 回收则返回 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> wr = <span class="keyword">new</span> WeakRef(person)</span><br><span class="line"><span class="built_in">console</span>.log(wr.deref())</span><br><span class="line"><span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>正确使用 WeakRef 对象需要仔细的考虑，最好尽量避免使用。这里面有诸多原因，比如：GC 在一个 JavaScript 引擎中的行为有可能在另一个 JavaScript 引擎中的行为大相径庭，或者甚至在同一类引擎，不同版本中 GC 的行为都有可能有较大的差距。GC 目前还是 JavaScript 引擎实现者不断改进和改进解决方案的一个难题。</p></blockquote><p>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef">WeakRef</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">内存管理</a></li></ul><h3 id="逻辑赋值符"><a href="#逻辑赋值符" class="headerlink" title="逻辑赋值符"></a>逻辑赋值符</h3><p>逻辑赋值符包含 3 个：</p><ul><li><code>x &amp;&amp;= y</code>：逻辑与赋值符，相当于 <code>x &amp;&amp; (x = y)</code></li><li><code>x ||= y</code>：逻辑或赋值符，相当于 <code>x || (x = y)</code></li><li><code>x ??= y</code>：逻辑空赋值符，相当于 <code>x ?? (x = y)</code></li></ul><p>看如下示例，加深理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line">x &amp;&amp;= <span class="number">1</span> <span class="comment">// x: 0</span></span><br><span class="line">x ||= <span class="number">1</span> <span class="comment">// x: 1</span></span><br><span class="line">x ??= <span class="number">2</span> <span class="comment">// x: 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">1</span></span><br><span class="line">y &amp;&amp;= <span class="number">0</span> <span class="comment">// y: 0</span></span><br><span class="line">y ||= <span class="literal">null</span> <span class="comment">// y: null</span></span><br><span class="line">y ??= <span class="number">2</span> <span class="comment">// y: 2</span></span><br></pre></td></tr></table></figure><h3 id="数值分隔符（-）"><a href="#数值分隔符（-）" class="headerlink" title="数值分隔符（_）"></a>数值分隔符（_）</h3><p>对于下面一串数字，你一眼看上去不确定它到底是多少吧？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1000000000</span></span><br></pre></td></tr></table></figure><p>那现在呢？是不是可以很清楚的看出来它是 10 亿：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1</span>_000_000_000</span><br></pre></td></tr></table></figure><p>数值分隔符（<code>_</code>）的作用就是为了让数值的可读性更强。除了能用于十进制，还可以用于二级制，十六进制甚至是 <code>BigInt</code> 类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> binarary = <span class="number">0b1010</span>_0001_1000_0101</span><br><span class="line"><span class="keyword">let</span> hex = <span class="number">0xa0</span>_b0_c0</span><br><span class="line"><span class="keyword">let</span> budget = <span class="number">1</span>_000_000_000_000n</span><br></pre></td></tr></table></figure><p>使用时必须注意 <code>_</code> 的两边必须要有类型的数值，否则会报错，以下这些都是无效的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>_</span><br><span class="line"><span class="keyword">let</span> binarary = <span class="number">0b1011</span>_</span><br><span class="line"><span class="keyword">let</span> hex = <span class="number">0</span>x_0A0B</span><br><span class="line"><span class="keyword">let</span> budget = <span class="number">1</span>_n</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://es6.ruanyifeng.com/">ECMAScript6 入门</a></li><li><a href="https://juejin.im/post/6844903959283367950">1.5 万字概括 ES6 全部特性(已更新 ES2020)</a></li><li><a href="https://juejin.im/post/6844903775329583112">近一万字的 ES6 语法知识点补充</a></li><li><a href="https://juejin.im/post/6886247841686093837#heading-9">深入理解 Promise</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for-await...of">for-await…of</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration_protocols</a></li><li><a href="https://github.com/tc39/proposal-object-from-entries">Object.fromEntries</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef">WeakRef</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">内存管理</a></li><li><a href="https://github.com/doodlewind/jshistory-cn">jshistory-cn</a></li><li><a href="https://tc39.es/ecma262/#sec-samevaluezero">sameValueZero</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写本篇文章目的是为了夯实基础，基于阮一峰老师的著作 &lt;a href=&quot;https://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6 入门&lt;/a&gt; 以及 &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;tc39-finished-proposals&lt;/a&gt; 这两个知识线路总结提炼出来的重点和要点，涉及到从 &lt;code&gt;ES2015&lt;/code&gt; 到 &lt;code&gt;ES2021&lt;/code&gt; 的几乎所有知识，基本上都是按照一个知识点配上一段代码的形式来展示，所以篇幅较长，也正是因为篇幅过长，所以就没把 &lt;code&gt;Stage 2&lt;/code&gt; 和 &lt;code&gt;Stage 3&lt;/code&gt; 阶段的提案写到这里，后续 &lt;code&gt;ES2021&lt;/code&gt; 更新了我再同步更新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有 5 个提案已经列入 Expected Publication Year in 2021 所以本篇中暂且把他们归为 ES2021。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202011/es6.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://bubuzou.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
